
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ada_pots
 * 
 */
export type ada_pots = $Result.DefaultSelection<Prisma.$ada_potsPayload>
/**
 * Model block
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type block = $Result.DefaultSelection<Prisma.$blockPayload>
/**
 * Model collateral_tx_in
 * 
 */
export type collateral_tx_in = $Result.DefaultSelection<Prisma.$collateral_tx_inPayload>
/**
 * Model collateral_tx_out
 * 
 */
export type collateral_tx_out = $Result.DefaultSelection<Prisma.$collateral_tx_outPayload>
/**
 * Model committee
 * 
 */
export type committee = $Result.DefaultSelection<Prisma.$committeePayload>
/**
 * Model committee_de_registration
 * 
 */
export type committee_de_registration = $Result.DefaultSelection<Prisma.$committee_de_registrationPayload>
/**
 * Model committee_hash
 * 
 */
export type committee_hash = $Result.DefaultSelection<Prisma.$committee_hashPayload>
/**
 * Model committee_member
 * 
 */
export type committee_member = $Result.DefaultSelection<Prisma.$committee_memberPayload>
/**
 * Model committee_registration
 * 
 */
export type committee_registration = $Result.DefaultSelection<Prisma.$committee_registrationPayload>
/**
 * Model constitution
 * 
 */
export type constitution = $Result.DefaultSelection<Prisma.$constitutionPayload>
/**
 * Model cost_model
 * 
 */
export type cost_model = $Result.DefaultSelection<Prisma.$cost_modelPayload>
/**
 * Model datum
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type datum = $Result.DefaultSelection<Prisma.$datumPayload>
/**
 * Model delegation
 * 
 */
export type delegation = $Result.DefaultSelection<Prisma.$delegationPayload>
/**
 * Model delegation_vote
 * 
 */
export type delegation_vote = $Result.DefaultSelection<Prisma.$delegation_votePayload>
/**
 * Model delisted_pool
 * 
 */
export type delisted_pool = $Result.DefaultSelection<Prisma.$delisted_poolPayload>
/**
 * Model drep_distr
 * 
 */
export type drep_distr = $Result.DefaultSelection<Prisma.$drep_distrPayload>
/**
 * Model drep_hash
 * 
 */
export type drep_hash = $Result.DefaultSelection<Prisma.$drep_hashPayload>
/**
 * Model drep_registration
 * 
 */
export type drep_registration = $Result.DefaultSelection<Prisma.$drep_registrationPayload>
/**
 * Model epoch
 * 
 */
export type epoch = $Result.DefaultSelection<Prisma.$epochPayload>
/**
 * Model epoch_param
 * 
 */
export type epoch_param = $Result.DefaultSelection<Prisma.$epoch_paramPayload>
/**
 * Model epoch_stake
 * 
 */
export type epoch_stake = $Result.DefaultSelection<Prisma.$epoch_stakePayload>
/**
 * Model epoch_stake_progress
 * 
 */
export type epoch_stake_progress = $Result.DefaultSelection<Prisma.$epoch_stake_progressPayload>
/**
 * Model epoch_state
 * 
 */
export type epoch_state = $Result.DefaultSelection<Prisma.$epoch_statePayload>
/**
 * Model epoch_sync_time
 * 
 */
export type epoch_sync_time = $Result.DefaultSelection<Prisma.$epoch_sync_timePayload>
/**
 * Model event_info
 * 
 */
export type event_info = $Result.DefaultSelection<Prisma.$event_infoPayload>
/**
 * Model extra_key_witness
 * 
 */
export type extra_key_witness = $Result.DefaultSelection<Prisma.$extra_key_witnessPayload>
/**
 * Model extra_migrations
 * 
 */
export type extra_migrations = $Result.DefaultSelection<Prisma.$extra_migrationsPayload>
/**
 * Model gov_action_proposal
 * 
 */
export type gov_action_proposal = $Result.DefaultSelection<Prisma.$gov_action_proposalPayload>
/**
 * Model ma_tx_mint
 * 
 */
export type ma_tx_mint = $Result.DefaultSelection<Prisma.$ma_tx_mintPayload>
/**
 * Model ma_tx_out
 * 
 */
export type ma_tx_out = $Result.DefaultSelection<Prisma.$ma_tx_outPayload>
/**
 * Model meta
 * 
 */
export type meta = $Result.DefaultSelection<Prisma.$metaPayload>
/**
 * Model multi_asset
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type multi_asset = $Result.DefaultSelection<Prisma.$multi_assetPayload>
/**
 * Model new_committee
 * 
 */
export type new_committee = $Result.DefaultSelection<Prisma.$new_committeePayload>
/**
 * Model off_chain_pool_data
 * 
 */
export type off_chain_pool_data = $Result.DefaultSelection<Prisma.$off_chain_pool_dataPayload>
/**
 * Model off_chain_pool_fetch_error
 * 
 */
export type off_chain_pool_fetch_error = $Result.DefaultSelection<Prisma.$off_chain_pool_fetch_errorPayload>
/**
 * Model off_chain_vote_author
 * 
 */
export type off_chain_vote_author = $Result.DefaultSelection<Prisma.$off_chain_vote_authorPayload>
/**
 * Model off_chain_vote_data
 * 
 */
export type off_chain_vote_data = $Result.DefaultSelection<Prisma.$off_chain_vote_dataPayload>
/**
 * Model off_chain_vote_drep_data
 * 
 */
export type off_chain_vote_drep_data = $Result.DefaultSelection<Prisma.$off_chain_vote_drep_dataPayload>
/**
 * Model off_chain_vote_external_update
 * 
 */
export type off_chain_vote_external_update = $Result.DefaultSelection<Prisma.$off_chain_vote_external_updatePayload>
/**
 * Model off_chain_vote_fetch_error
 * 
 */
export type off_chain_vote_fetch_error = $Result.DefaultSelection<Prisma.$off_chain_vote_fetch_errorPayload>
/**
 * Model off_chain_vote_gov_action_data
 * 
 */
export type off_chain_vote_gov_action_data = $Result.DefaultSelection<Prisma.$off_chain_vote_gov_action_dataPayload>
/**
 * Model off_chain_vote_reference
 * 
 */
export type off_chain_vote_reference = $Result.DefaultSelection<Prisma.$off_chain_vote_referencePayload>
/**
 * Model param_proposal
 * 
 */
export type param_proposal = $Result.DefaultSelection<Prisma.$param_proposalPayload>
/**
 * Model pool_hash
 * 
 */
export type pool_hash = $Result.DefaultSelection<Prisma.$pool_hashPayload>
/**
 * Model pool_metadata_ref
 * 
 */
export type pool_metadata_ref = $Result.DefaultSelection<Prisma.$pool_metadata_refPayload>
/**
 * Model pool_owner
 * 
 */
export type pool_owner = $Result.DefaultSelection<Prisma.$pool_ownerPayload>
/**
 * Model pool_relay
 * 
 */
export type pool_relay = $Result.DefaultSelection<Prisma.$pool_relayPayload>
/**
 * Model pool_retire
 * 
 */
export type pool_retire = $Result.DefaultSelection<Prisma.$pool_retirePayload>
/**
 * Model pool_stat
 * 
 */
export type pool_stat = $Result.DefaultSelection<Prisma.$pool_statPayload>
/**
 * Model pool_update
 * 
 */
export type pool_update = $Result.DefaultSelection<Prisma.$pool_updatePayload>
/**
 * Model pot_transfer
 * 
 */
export type pot_transfer = $Result.DefaultSelection<Prisma.$pot_transferPayload>
/**
 * Model redeemer
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type redeemer = $Result.DefaultSelection<Prisma.$redeemerPayload>
/**
 * Model redeemer_data
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type redeemer_data = $Result.DefaultSelection<Prisma.$redeemer_dataPayload>
/**
 * Model reference_tx_in
 * 
 */
export type reference_tx_in = $Result.DefaultSelection<Prisma.$reference_tx_inPayload>
/**
 * Model reserve
 * 
 */
export type reserve = $Result.DefaultSelection<Prisma.$reservePayload>
/**
 * Model reserved_pool_ticker
 * 
 */
export type reserved_pool_ticker = $Result.DefaultSelection<Prisma.$reserved_pool_tickerPayload>
/**
 * Model reverse_index
 * 
 */
export type reverse_index = $Result.DefaultSelection<Prisma.$reverse_indexPayload>
/**
 * Model reward
 * 
 */
export type reward = $Result.DefaultSelection<Prisma.$rewardPayload>
/**
 * Model schema_version
 * 
 */
export type schema_version = $Result.DefaultSelection<Prisma.$schema_versionPayload>
/**
 * Model script
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type script = $Result.DefaultSelection<Prisma.$scriptPayload>
/**
 * Model slot_leader
 * 
 */
export type slot_leader = $Result.DefaultSelection<Prisma.$slot_leaderPayload>
/**
 * Model stake_address
 * 
 */
export type stake_address = $Result.DefaultSelection<Prisma.$stake_addressPayload>
/**
 * Model stake_deregistration
 * 
 */
export type stake_deregistration = $Result.DefaultSelection<Prisma.$stake_deregistrationPayload>
/**
 * Model stake_registration
 * 
 */
export type stake_registration = $Result.DefaultSelection<Prisma.$stake_registrationPayload>
/**
 * Model treasury
 * 
 */
export type treasury = $Result.DefaultSelection<Prisma.$treasuryPayload>
/**
 * Model treasury_withdrawal
 * 
 */
export type treasury_withdrawal = $Result.DefaultSelection<Prisma.$treasury_withdrawalPayload>
/**
 * Model tx
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type tx = $Result.DefaultSelection<Prisma.$txPayload>
/**
 * Model tx_cbor
 * 
 */
export type tx_cbor = $Result.DefaultSelection<Prisma.$tx_cborPayload>
/**
 * Model tx_in
 * 
 */
export type tx_in = $Result.DefaultSelection<Prisma.$tx_inPayload>
/**
 * Model tx_metadata
 * 
 */
export type tx_metadata = $Result.DefaultSelection<Prisma.$tx_metadataPayload>
/**
 * Model tx_out
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type tx_out = $Result.DefaultSelection<Prisma.$tx_outPayload>
/**
 * Model voting_anchor
 * 
 */
export type voting_anchor = $Result.DefaultSelection<Prisma.$voting_anchorPayload>
/**
 * Model voting_procedure
 * 
 */
export type voting_procedure = $Result.DefaultSelection<Prisma.$voting_procedurePayload>
/**
 * Model withdrawal
 * 
 */
export type withdrawal = $Result.DefaultSelection<Prisma.$withdrawalPayload>
/**
 * Model sqlx_migrations
 * 
 */
export type sqlx_migrations = $Result.DefaultSelection<Prisma.$sqlx_migrationsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const anchortype: {
  gov_action: 'gov_action',
  drep: 'drep',
  other: 'other',
  vote: 'vote',
  committee_dereg: 'committee_dereg',
  constitution: 'constitution'
};

export type anchortype = (typeof anchortype)[keyof typeof anchortype]


export const govactiontype: {
  ParameterChange: 'ParameterChange',
  HardForkInitiation: 'HardForkInitiation',
  TreasuryWithdrawals: 'TreasuryWithdrawals',
  NoConfidence: 'NoConfidence',
  NewCommittee: 'NewCommittee',
  NewConstitution: 'NewConstitution',
  InfoAction: 'InfoAction'
};

export type govactiontype = (typeof govactiontype)[keyof typeof govactiontype]


export const rewardtype: {
  leader: 'leader',
  member: 'member',
  reserves: 'reserves',
  treasury: 'treasury',
  refund: 'refund',
  proposal_refund: 'proposal_refund'
};

export type rewardtype = (typeof rewardtype)[keyof typeof rewardtype]


export const scriptpurposetype: {
  spend: 'spend',
  mint: 'mint',
  cert: 'cert',
  reward: 'reward',
  vote: 'vote',
  propose: 'propose'
};

export type scriptpurposetype = (typeof scriptpurposetype)[keyof typeof scriptpurposetype]


export const scripttype: {
  multisig: 'multisig',
  timelock: 'timelock',
  plutusV1: 'plutusV1',
  plutusV2: 'plutusV2',
  plutusV3: 'plutusV3'
};

export type scripttype = (typeof scripttype)[keyof typeof scripttype]


export const syncstatetype: {
  lagging: 'lagging',
  following: 'following'
};

export type syncstatetype = (typeof syncstatetype)[keyof typeof syncstatetype]


export const vote: {
  Yes: 'Yes',
  No: 'No',
  Abstain: 'Abstain'
};

export type vote = (typeof vote)[keyof typeof vote]


export const voterrole: {
  ConstitutionalCommittee: 'ConstitutionalCommittee',
  DRep: 'DRep',
  SPO: 'SPO'
};

export type voterrole = (typeof voterrole)[keyof typeof voterrole]

}

export type anchortype = $Enums.anchortype

export const anchortype: typeof $Enums.anchortype

export type govactiontype = $Enums.govactiontype

export const govactiontype: typeof $Enums.govactiontype

export type rewardtype = $Enums.rewardtype

export const rewardtype: typeof $Enums.rewardtype

export type scriptpurposetype = $Enums.scriptpurposetype

export const scriptpurposetype: typeof $Enums.scriptpurposetype

export type scripttype = $Enums.scripttype

export const scripttype: typeof $Enums.scripttype

export type syncstatetype = $Enums.syncstatetype

export const syncstatetype: typeof $Enums.syncstatetype

export type vote = $Enums.vote

export const vote: typeof $Enums.vote

export type voterrole = $Enums.voterrole

export const voterrole: typeof $Enums.voterrole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Ada_pots
 * const ada_pots = await prisma.ada_pots.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Ada_pots
   * const ada_pots = await prisma.ada_pots.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Executes a typed SQL query and returns a typed result
   * @example
   * ```
   * import { myQuery } from '@prisma/client/sql'
   * 
   * const result = await prisma.$queryRawTyped(myQuery())
   * ```
   */
  $queryRawTyped<T>(typedSql: runtime.TypedSql<unknown[], T>): Prisma.PrismaPromise<T[]>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.ada_pots`: Exposes CRUD operations for the **ada_pots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ada_pots
    * const ada_pots = await prisma.ada_pots.findMany()
    * ```
    */
  get ada_pots(): Prisma.ada_potsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.blockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collateral_tx_in`: Exposes CRUD operations for the **collateral_tx_in** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collateral_tx_ins
    * const collateral_tx_ins = await prisma.collateral_tx_in.findMany()
    * ```
    */
  get collateral_tx_in(): Prisma.collateral_tx_inDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collateral_tx_out`: Exposes CRUD operations for the **collateral_tx_out** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collateral_tx_outs
    * const collateral_tx_outs = await prisma.collateral_tx_out.findMany()
    * ```
    */
  get collateral_tx_out(): Prisma.collateral_tx_outDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.committee`: Exposes CRUD operations for the **committee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Committees
    * const committees = await prisma.committee.findMany()
    * ```
    */
  get committee(): Prisma.committeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.committee_de_registration`: Exposes CRUD operations for the **committee_de_registration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Committee_de_registrations
    * const committee_de_registrations = await prisma.committee_de_registration.findMany()
    * ```
    */
  get committee_de_registration(): Prisma.committee_de_registrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.committee_hash`: Exposes CRUD operations for the **committee_hash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Committee_hashes
    * const committee_hashes = await prisma.committee_hash.findMany()
    * ```
    */
  get committee_hash(): Prisma.committee_hashDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.committee_member`: Exposes CRUD operations for the **committee_member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Committee_members
    * const committee_members = await prisma.committee_member.findMany()
    * ```
    */
  get committee_member(): Prisma.committee_memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.committee_registration`: Exposes CRUD operations for the **committee_registration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Committee_registrations
    * const committee_registrations = await prisma.committee_registration.findMany()
    * ```
    */
  get committee_registration(): Prisma.committee_registrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constitution`: Exposes CRUD operations for the **constitution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Constitutions
    * const constitutions = await prisma.constitution.findMany()
    * ```
    */
  get constitution(): Prisma.constitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cost_model`: Exposes CRUD operations for the **cost_model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cost_models
    * const cost_models = await prisma.cost_model.findMany()
    * ```
    */
  get cost_model(): Prisma.cost_modelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.datum`: Exposes CRUD operations for the **datum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Data
    * const data = await prisma.datum.findMany()
    * ```
    */
  get datum(): Prisma.datumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delegation`: Exposes CRUD operations for the **delegation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delegations
    * const delegations = await prisma.delegation.findMany()
    * ```
    */
  get delegation(): Prisma.delegationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delegation_vote`: Exposes CRUD operations for the **delegation_vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delegation_votes
    * const delegation_votes = await prisma.delegation_vote.findMany()
    * ```
    */
  get delegation_vote(): Prisma.delegation_voteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delisted_pool`: Exposes CRUD operations for the **delisted_pool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delisted_pools
    * const delisted_pools = await prisma.delisted_pool.findMany()
    * ```
    */
  get delisted_pool(): Prisma.delisted_poolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drep_distr`: Exposes CRUD operations for the **drep_distr** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drep_distrs
    * const drep_distrs = await prisma.drep_distr.findMany()
    * ```
    */
  get drep_distr(): Prisma.drep_distrDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drep_hash`: Exposes CRUD operations for the **drep_hash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drep_hashes
    * const drep_hashes = await prisma.drep_hash.findMany()
    * ```
    */
  get drep_hash(): Prisma.drep_hashDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.drep_registration`: Exposes CRUD operations for the **drep_registration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drep_registrations
    * const drep_registrations = await prisma.drep_registration.findMany()
    * ```
    */
  get drep_registration(): Prisma.drep_registrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch`: Exposes CRUD operations for the **epoch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoches
    * const epoches = await prisma.epoch.findMany()
    * ```
    */
  get epoch(): Prisma.epochDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch_param`: Exposes CRUD operations for the **epoch_param** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoch_params
    * const epoch_params = await prisma.epoch_param.findMany()
    * ```
    */
  get epoch_param(): Prisma.epoch_paramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch_stake`: Exposes CRUD operations for the **epoch_stake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoch_stakes
    * const epoch_stakes = await prisma.epoch_stake.findMany()
    * ```
    */
  get epoch_stake(): Prisma.epoch_stakeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch_stake_progress`: Exposes CRUD operations for the **epoch_stake_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoch_stake_progresses
    * const epoch_stake_progresses = await prisma.epoch_stake_progress.findMany()
    * ```
    */
  get epoch_stake_progress(): Prisma.epoch_stake_progressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch_state`: Exposes CRUD operations for the **epoch_state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoch_states
    * const epoch_states = await prisma.epoch_state.findMany()
    * ```
    */
  get epoch_state(): Prisma.epoch_stateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.epoch_sync_time`: Exposes CRUD operations for the **epoch_sync_time** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Epoch_sync_times
    * const epoch_sync_times = await prisma.epoch_sync_time.findMany()
    * ```
    */
  get epoch_sync_time(): Prisma.epoch_sync_timeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event_info`: Exposes CRUD operations for the **event_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_infos
    * const event_infos = await prisma.event_info.findMany()
    * ```
    */
  get event_info(): Prisma.event_infoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extra_key_witness`: Exposes CRUD operations for the **extra_key_witness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extra_key_witnesses
    * const extra_key_witnesses = await prisma.extra_key_witness.findMany()
    * ```
    */
  get extra_key_witness(): Prisma.extra_key_witnessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extra_migrations`: Exposes CRUD operations for the **extra_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Extra_migrations
    * const extra_migrations = await prisma.extra_migrations.findMany()
    * ```
    */
  get extra_migrations(): Prisma.extra_migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gov_action_proposal`: Exposes CRUD operations for the **gov_action_proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gov_action_proposals
    * const gov_action_proposals = await prisma.gov_action_proposal.findMany()
    * ```
    */
  get gov_action_proposal(): Prisma.gov_action_proposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ma_tx_mint`: Exposes CRUD operations for the **ma_tx_mint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ma_tx_mints
    * const ma_tx_mints = await prisma.ma_tx_mint.findMany()
    * ```
    */
  get ma_tx_mint(): Prisma.ma_tx_mintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ma_tx_out`: Exposes CRUD operations for the **ma_tx_out** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ma_tx_outs
    * const ma_tx_outs = await prisma.ma_tx_out.findMany()
    * ```
    */
  get ma_tx_out(): Prisma.ma_tx_outDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meta`: Exposes CRUD operations for the **meta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metas
    * const metas = await prisma.meta.findMany()
    * ```
    */
  get meta(): Prisma.metaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multi_asset`: Exposes CRUD operations for the **multi_asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Multi_assets
    * const multi_assets = await prisma.multi_asset.findMany()
    * ```
    */
  get multi_asset(): Prisma.multi_assetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.new_committee`: Exposes CRUD operations for the **new_committee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more New_committees
    * const new_committees = await prisma.new_committee.findMany()
    * ```
    */
  get new_committee(): Prisma.new_committeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_pool_data`: Exposes CRUD operations for the **off_chain_pool_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_pool_data
    * const off_chain_pool_data = await prisma.off_chain_pool_data.findMany()
    * ```
    */
  get off_chain_pool_data(): Prisma.off_chain_pool_dataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_pool_fetch_error`: Exposes CRUD operations for the **off_chain_pool_fetch_error** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_pool_fetch_errors
    * const off_chain_pool_fetch_errors = await prisma.off_chain_pool_fetch_error.findMany()
    * ```
    */
  get off_chain_pool_fetch_error(): Prisma.off_chain_pool_fetch_errorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_author`: Exposes CRUD operations for the **off_chain_vote_author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_authors
    * const off_chain_vote_authors = await prisma.off_chain_vote_author.findMany()
    * ```
    */
  get off_chain_vote_author(): Prisma.off_chain_vote_authorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_data`: Exposes CRUD operations for the **off_chain_vote_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_data
    * const off_chain_vote_data = await prisma.off_chain_vote_data.findMany()
    * ```
    */
  get off_chain_vote_data(): Prisma.off_chain_vote_dataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_drep_data`: Exposes CRUD operations for the **off_chain_vote_drep_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_drep_data
    * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findMany()
    * ```
    */
  get off_chain_vote_drep_data(): Prisma.off_chain_vote_drep_dataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_external_update`: Exposes CRUD operations for the **off_chain_vote_external_update** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_external_updates
    * const off_chain_vote_external_updates = await prisma.off_chain_vote_external_update.findMany()
    * ```
    */
  get off_chain_vote_external_update(): Prisma.off_chain_vote_external_updateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_fetch_error`: Exposes CRUD operations for the **off_chain_vote_fetch_error** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_fetch_errors
    * const off_chain_vote_fetch_errors = await prisma.off_chain_vote_fetch_error.findMany()
    * ```
    */
  get off_chain_vote_fetch_error(): Prisma.off_chain_vote_fetch_errorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_gov_action_data`: Exposes CRUD operations for the **off_chain_vote_gov_action_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_gov_action_data
    * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findMany()
    * ```
    */
  get off_chain_vote_gov_action_data(): Prisma.off_chain_vote_gov_action_dataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.off_chain_vote_reference`: Exposes CRUD operations for the **off_chain_vote_reference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Off_chain_vote_references
    * const off_chain_vote_references = await prisma.off_chain_vote_reference.findMany()
    * ```
    */
  get off_chain_vote_reference(): Prisma.off_chain_vote_referenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.param_proposal`: Exposes CRUD operations for the **param_proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Param_proposals
    * const param_proposals = await prisma.param_proposal.findMany()
    * ```
    */
  get param_proposal(): Prisma.param_proposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_hash`: Exposes CRUD operations for the **pool_hash** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_hashes
    * const pool_hashes = await prisma.pool_hash.findMany()
    * ```
    */
  get pool_hash(): Prisma.pool_hashDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_metadata_ref`: Exposes CRUD operations for the **pool_metadata_ref** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_metadata_refs
    * const pool_metadata_refs = await prisma.pool_metadata_ref.findMany()
    * ```
    */
  get pool_metadata_ref(): Prisma.pool_metadata_refDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_owner`: Exposes CRUD operations for the **pool_owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_owners
    * const pool_owners = await prisma.pool_owner.findMany()
    * ```
    */
  get pool_owner(): Prisma.pool_ownerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_relay`: Exposes CRUD operations for the **pool_relay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_relays
    * const pool_relays = await prisma.pool_relay.findMany()
    * ```
    */
  get pool_relay(): Prisma.pool_relayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_retire`: Exposes CRUD operations for the **pool_retire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_retires
    * const pool_retires = await prisma.pool_retire.findMany()
    * ```
    */
  get pool_retire(): Prisma.pool_retireDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_stat`: Exposes CRUD operations for the **pool_stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_stats
    * const pool_stats = await prisma.pool_stat.findMany()
    * ```
    */
  get pool_stat(): Prisma.pool_statDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pool_update`: Exposes CRUD operations for the **pool_update** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pool_updates
    * const pool_updates = await prisma.pool_update.findMany()
    * ```
    */
  get pool_update(): Prisma.pool_updateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pot_transfer`: Exposes CRUD operations for the **pot_transfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pot_transfers
    * const pot_transfers = await prisma.pot_transfer.findMany()
    * ```
    */
  get pot_transfer(): Prisma.pot_transferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemer`: Exposes CRUD operations for the **redeemer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redeemers
    * const redeemers = await prisma.redeemer.findMany()
    * ```
    */
  get redeemer(): Prisma.redeemerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redeemer_data`: Exposes CRUD operations for the **redeemer_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redeemer_data
    * const redeemer_data = await prisma.redeemer_data.findMany()
    * ```
    */
  get redeemer_data(): Prisma.redeemer_dataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reference_tx_in`: Exposes CRUD operations for the **reference_tx_in** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reference_tx_ins
    * const reference_tx_ins = await prisma.reference_tx_in.findMany()
    * ```
    */
  get reference_tx_in(): Prisma.reference_tx_inDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reserve`: Exposes CRUD operations for the **reserve** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reserves
    * const reserves = await prisma.reserve.findMany()
    * ```
    */
  get reserve(): Prisma.reserveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reserved_pool_ticker`: Exposes CRUD operations for the **reserved_pool_ticker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reserved_pool_tickers
    * const reserved_pool_tickers = await prisma.reserved_pool_ticker.findMany()
    * ```
    */
  get reserved_pool_ticker(): Prisma.reserved_pool_tickerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reverse_index`: Exposes CRUD operations for the **reverse_index** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reverse_indices
    * const reverse_indices = await prisma.reverse_index.findMany()
    * ```
    */
  get reverse_index(): Prisma.reverse_indexDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.rewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schema_version`: Exposes CRUD operations for the **schema_version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schema_versions
    * const schema_versions = await prisma.schema_version.findMany()
    * ```
    */
  get schema_version(): Prisma.schema_versionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.script`: Exposes CRUD operations for the **script** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scripts
    * const scripts = await prisma.script.findMany()
    * ```
    */
  get script(): Prisma.scriptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slot_leader`: Exposes CRUD operations for the **slot_leader** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Slot_leaders
    * const slot_leaders = await prisma.slot_leader.findMany()
    * ```
    */
  get slot_leader(): Prisma.slot_leaderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stake_address`: Exposes CRUD operations for the **stake_address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stake_addresses
    * const stake_addresses = await prisma.stake_address.findMany()
    * ```
    */
  get stake_address(): Prisma.stake_addressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stake_deregistration`: Exposes CRUD operations for the **stake_deregistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stake_deregistrations
    * const stake_deregistrations = await prisma.stake_deregistration.findMany()
    * ```
    */
  get stake_deregistration(): Prisma.stake_deregistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stake_registration`: Exposes CRUD operations for the **stake_registration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stake_registrations
    * const stake_registrations = await prisma.stake_registration.findMany()
    * ```
    */
  get stake_registration(): Prisma.stake_registrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasury`: Exposes CRUD operations for the **treasury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treasuries
    * const treasuries = await prisma.treasury.findMany()
    * ```
    */
  get treasury(): Prisma.treasuryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasury_withdrawal`: Exposes CRUD operations for the **treasury_withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treasury_withdrawals
    * const treasury_withdrawals = await prisma.treasury_withdrawal.findMany()
    * ```
    */
  get treasury_withdrawal(): Prisma.treasury_withdrawalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tx`: Exposes CRUD operations for the **tx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Txes
    * const txes = await prisma.tx.findMany()
    * ```
    */
  get tx(): Prisma.txDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tx_cbor`: Exposes CRUD operations for the **tx_cbor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tx_cbors
    * const tx_cbors = await prisma.tx_cbor.findMany()
    * ```
    */
  get tx_cbor(): Prisma.tx_cborDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tx_in`: Exposes CRUD operations for the **tx_in** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tx_ins
    * const tx_ins = await prisma.tx_in.findMany()
    * ```
    */
  get tx_in(): Prisma.tx_inDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tx_metadata`: Exposes CRUD operations for the **tx_metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tx_metadata
    * const tx_metadata = await prisma.tx_metadata.findMany()
    * ```
    */
  get tx_metadata(): Prisma.tx_metadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tx_out`: Exposes CRUD operations for the **tx_out** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tx_outs
    * const tx_outs = await prisma.tx_out.findMany()
    * ```
    */
  get tx_out(): Prisma.tx_outDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voting_anchor`: Exposes CRUD operations for the **voting_anchor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Voting_anchors
    * const voting_anchors = await prisma.voting_anchor.findMany()
    * ```
    */
  get voting_anchor(): Prisma.voting_anchorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voting_procedure`: Exposes CRUD operations for the **voting_procedure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Voting_procedures
    * const voting_procedures = await prisma.voting_procedure.findMany()
    * ```
    */
  get voting_procedure(): Prisma.voting_procedureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.withdrawal`: Exposes CRUD operations for the **withdrawal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Withdrawals
    * const withdrawals = await prisma.withdrawal.findMany()
    * ```
    */
  get withdrawal(): Prisma.withdrawalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sqlx_migrations`: Exposes CRUD operations for the **sqlx_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sqlx_migrations
    * const sqlx_migrations = await prisma.sqlx_migrations.findMany()
    * ```
    */
  get sqlx_migrations(): Prisma.sqlx_migrationsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ada_pots: 'ada_pots',
    block: 'block',
    collateral_tx_in: 'collateral_tx_in',
    collateral_tx_out: 'collateral_tx_out',
    committee: 'committee',
    committee_de_registration: 'committee_de_registration',
    committee_hash: 'committee_hash',
    committee_member: 'committee_member',
    committee_registration: 'committee_registration',
    constitution: 'constitution',
    cost_model: 'cost_model',
    datum: 'datum',
    delegation: 'delegation',
    delegation_vote: 'delegation_vote',
    delisted_pool: 'delisted_pool',
    drep_distr: 'drep_distr',
    drep_hash: 'drep_hash',
    drep_registration: 'drep_registration',
    epoch: 'epoch',
    epoch_param: 'epoch_param',
    epoch_stake: 'epoch_stake',
    epoch_stake_progress: 'epoch_stake_progress',
    epoch_state: 'epoch_state',
    epoch_sync_time: 'epoch_sync_time',
    event_info: 'event_info',
    extra_key_witness: 'extra_key_witness',
    extra_migrations: 'extra_migrations',
    gov_action_proposal: 'gov_action_proposal',
    ma_tx_mint: 'ma_tx_mint',
    ma_tx_out: 'ma_tx_out',
    meta: 'meta',
    multi_asset: 'multi_asset',
    new_committee: 'new_committee',
    off_chain_pool_data: 'off_chain_pool_data',
    off_chain_pool_fetch_error: 'off_chain_pool_fetch_error',
    off_chain_vote_author: 'off_chain_vote_author',
    off_chain_vote_data: 'off_chain_vote_data',
    off_chain_vote_drep_data: 'off_chain_vote_drep_data',
    off_chain_vote_external_update: 'off_chain_vote_external_update',
    off_chain_vote_fetch_error: 'off_chain_vote_fetch_error',
    off_chain_vote_gov_action_data: 'off_chain_vote_gov_action_data',
    off_chain_vote_reference: 'off_chain_vote_reference',
    param_proposal: 'param_proposal',
    pool_hash: 'pool_hash',
    pool_metadata_ref: 'pool_metadata_ref',
    pool_owner: 'pool_owner',
    pool_relay: 'pool_relay',
    pool_retire: 'pool_retire',
    pool_stat: 'pool_stat',
    pool_update: 'pool_update',
    pot_transfer: 'pot_transfer',
    redeemer: 'redeemer',
    redeemer_data: 'redeemer_data',
    reference_tx_in: 'reference_tx_in',
    reserve: 'reserve',
    reserved_pool_ticker: 'reserved_pool_ticker',
    reverse_index: 'reverse_index',
    reward: 'reward',
    schema_version: 'schema_version',
    script: 'script',
    slot_leader: 'slot_leader',
    stake_address: 'stake_address',
    stake_deregistration: 'stake_deregistration',
    stake_registration: 'stake_registration',
    treasury: 'treasury',
    treasury_withdrawal: 'treasury_withdrawal',
    tx: 'tx',
    tx_cbor: 'tx_cbor',
    tx_in: 'tx_in',
    tx_metadata: 'tx_metadata',
    tx_out: 'tx_out',
    voting_anchor: 'voting_anchor',
    voting_procedure: 'voting_procedure',
    withdrawal: 'withdrawal',
    sqlx_migrations: 'sqlx_migrations'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "ada_pots" | "block" | "collateral_tx_in" | "collateral_tx_out" | "committee" | "committee_de_registration" | "committee_hash" | "committee_member" | "committee_registration" | "constitution" | "cost_model" | "datum" | "delegation" | "delegation_vote" | "delisted_pool" | "drep_distr" | "drep_hash" | "drep_registration" | "epoch" | "epoch_param" | "epoch_stake" | "epoch_stake_progress" | "epoch_state" | "epoch_sync_time" | "event_info" | "extra_key_witness" | "extra_migrations" | "gov_action_proposal" | "ma_tx_mint" | "ma_tx_out" | "meta" | "multi_asset" | "new_committee" | "off_chain_pool_data" | "off_chain_pool_fetch_error" | "off_chain_vote_author" | "off_chain_vote_data" | "off_chain_vote_drep_data" | "off_chain_vote_external_update" | "off_chain_vote_fetch_error" | "off_chain_vote_gov_action_data" | "off_chain_vote_reference" | "param_proposal" | "pool_hash" | "pool_metadata_ref" | "pool_owner" | "pool_relay" | "pool_retire" | "pool_stat" | "pool_update" | "pot_transfer" | "redeemer" | "redeemer_data" | "reference_tx_in" | "reserve" | "reserved_pool_ticker" | "reverse_index" | "reward" | "schema_version" | "script" | "slot_leader" | "stake_address" | "stake_deregistration" | "stake_registration" | "treasury" | "treasury_withdrawal" | "tx" | "tx_cbor" | "tx_in" | "tx_metadata" | "tx_out" | "voting_anchor" | "voting_procedure" | "withdrawal" | "sqlx_migrations"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ada_pots: {
        payload: Prisma.$ada_potsPayload<ExtArgs>
        fields: Prisma.ada_potsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ada_potsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ada_potsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          findFirst: {
            args: Prisma.ada_potsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ada_potsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          findMany: {
            args: Prisma.ada_potsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>[]
          }
          create: {
            args: Prisma.ada_potsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          createMany: {
            args: Prisma.ada_potsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ada_potsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>[]
          }
          delete: {
            args: Prisma.ada_potsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          update: {
            args: Prisma.ada_potsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          deleteMany: {
            args: Prisma.ada_potsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ada_potsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ada_potsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>[]
          }
          upsert: {
            args: Prisma.ada_potsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ada_potsPayload>
          }
          aggregate: {
            args: Prisma.Ada_potsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAda_pots>
          }
          groupBy: {
            args: Prisma.ada_potsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ada_potsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ada_potsCountArgs<ExtArgs>
            result: $Utils.Optional<Ada_potsCountAggregateOutputType> | number
          }
        }
      }
      block: {
        payload: Prisma.$blockPayload<ExtArgs>
        fields: Prisma.blockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          findFirst: {
            args: Prisma.blockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          findMany: {
            args: Prisma.blockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>[]
          }
          create: {
            args: Prisma.blockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          createMany: {
            args: Prisma.blockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>[]
          }
          delete: {
            args: Prisma.blockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          update: {
            args: Prisma.blockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          deleteMany: {
            args: Prisma.blockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>[]
          }
          upsert: {
            args: Prisma.blockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.blockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.blockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      collateral_tx_in: {
        payload: Prisma.$collateral_tx_inPayload<ExtArgs>
        fields: Prisma.collateral_tx_inFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collateral_tx_inFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collateral_tx_inFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          findFirst: {
            args: Prisma.collateral_tx_inFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collateral_tx_inFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          findMany: {
            args: Prisma.collateral_tx_inFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>[]
          }
          create: {
            args: Prisma.collateral_tx_inCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          createMany: {
            args: Prisma.collateral_tx_inCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collateral_tx_inCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>[]
          }
          delete: {
            args: Prisma.collateral_tx_inDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          update: {
            args: Prisma.collateral_tx_inUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          deleteMany: {
            args: Prisma.collateral_tx_inDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collateral_tx_inUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collateral_tx_inUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>[]
          }
          upsert: {
            args: Prisma.collateral_tx_inUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_inPayload>
          }
          aggregate: {
            args: Prisma.Collateral_tx_inAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollateral_tx_in>
          }
          groupBy: {
            args: Prisma.collateral_tx_inGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collateral_tx_inGroupByOutputType>[]
          }
          count: {
            args: Prisma.collateral_tx_inCountArgs<ExtArgs>
            result: $Utils.Optional<Collateral_tx_inCountAggregateOutputType> | number
          }
        }
      }
      collateral_tx_out: {
        payload: Prisma.$collateral_tx_outPayload<ExtArgs>
        fields: Prisma.collateral_tx_outFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collateral_tx_outFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collateral_tx_outFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          findFirst: {
            args: Prisma.collateral_tx_outFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collateral_tx_outFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          findMany: {
            args: Prisma.collateral_tx_outFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>[]
          }
          create: {
            args: Prisma.collateral_tx_outCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          createMany: {
            args: Prisma.collateral_tx_outCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collateral_tx_outCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>[]
          }
          delete: {
            args: Prisma.collateral_tx_outDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          update: {
            args: Prisma.collateral_tx_outUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          deleteMany: {
            args: Prisma.collateral_tx_outDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collateral_tx_outUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collateral_tx_outUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>[]
          }
          upsert: {
            args: Prisma.collateral_tx_outUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collateral_tx_outPayload>
          }
          aggregate: {
            args: Prisma.Collateral_tx_outAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollateral_tx_out>
          }
          groupBy: {
            args: Prisma.collateral_tx_outGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collateral_tx_outGroupByOutputType>[]
          }
          count: {
            args: Prisma.collateral_tx_outCountArgs<ExtArgs>
            result: $Utils.Optional<Collateral_tx_outCountAggregateOutputType> | number
          }
        }
      }
      committee: {
        payload: Prisma.$committeePayload<ExtArgs>
        fields: Prisma.committeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.committeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.committeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          findFirst: {
            args: Prisma.committeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.committeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          findMany: {
            args: Prisma.committeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>[]
          }
          create: {
            args: Prisma.committeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          createMany: {
            args: Prisma.committeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.committeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>[]
          }
          delete: {
            args: Prisma.committeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          update: {
            args: Prisma.committeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          deleteMany: {
            args: Prisma.committeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.committeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.committeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>[]
          }
          upsert: {
            args: Prisma.committeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committeePayload>
          }
          aggregate: {
            args: Prisma.CommitteeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommittee>
          }
          groupBy: {
            args: Prisma.committeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommitteeGroupByOutputType>[]
          }
          count: {
            args: Prisma.committeeCountArgs<ExtArgs>
            result: $Utils.Optional<CommitteeCountAggregateOutputType> | number
          }
        }
      }
      committee_de_registration: {
        payload: Prisma.$committee_de_registrationPayload<ExtArgs>
        fields: Prisma.committee_de_registrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.committee_de_registrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.committee_de_registrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          findFirst: {
            args: Prisma.committee_de_registrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.committee_de_registrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          findMany: {
            args: Prisma.committee_de_registrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>[]
          }
          create: {
            args: Prisma.committee_de_registrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          createMany: {
            args: Prisma.committee_de_registrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.committee_de_registrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>[]
          }
          delete: {
            args: Prisma.committee_de_registrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          update: {
            args: Prisma.committee_de_registrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          deleteMany: {
            args: Prisma.committee_de_registrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.committee_de_registrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.committee_de_registrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>[]
          }
          upsert: {
            args: Prisma.committee_de_registrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_de_registrationPayload>
          }
          aggregate: {
            args: Prisma.Committee_de_registrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommittee_de_registration>
          }
          groupBy: {
            args: Prisma.committee_de_registrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Committee_de_registrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.committee_de_registrationCountArgs<ExtArgs>
            result: $Utils.Optional<Committee_de_registrationCountAggregateOutputType> | number
          }
        }
      }
      committee_hash: {
        payload: Prisma.$committee_hashPayload<ExtArgs>
        fields: Prisma.committee_hashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.committee_hashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.committee_hashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          findFirst: {
            args: Prisma.committee_hashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.committee_hashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          findMany: {
            args: Prisma.committee_hashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>[]
          }
          create: {
            args: Prisma.committee_hashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          createMany: {
            args: Prisma.committee_hashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.committee_hashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>[]
          }
          delete: {
            args: Prisma.committee_hashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          update: {
            args: Prisma.committee_hashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          deleteMany: {
            args: Prisma.committee_hashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.committee_hashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.committee_hashUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>[]
          }
          upsert: {
            args: Prisma.committee_hashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_hashPayload>
          }
          aggregate: {
            args: Prisma.Committee_hashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommittee_hash>
          }
          groupBy: {
            args: Prisma.committee_hashGroupByArgs<ExtArgs>
            result: $Utils.Optional<Committee_hashGroupByOutputType>[]
          }
          count: {
            args: Prisma.committee_hashCountArgs<ExtArgs>
            result: $Utils.Optional<Committee_hashCountAggregateOutputType> | number
          }
        }
      }
      committee_member: {
        payload: Prisma.$committee_memberPayload<ExtArgs>
        fields: Prisma.committee_memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.committee_memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.committee_memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          findFirst: {
            args: Prisma.committee_memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.committee_memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          findMany: {
            args: Prisma.committee_memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>[]
          }
          create: {
            args: Prisma.committee_memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          createMany: {
            args: Prisma.committee_memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.committee_memberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>[]
          }
          delete: {
            args: Prisma.committee_memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          update: {
            args: Prisma.committee_memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          deleteMany: {
            args: Prisma.committee_memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.committee_memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.committee_memberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>[]
          }
          upsert: {
            args: Prisma.committee_memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_memberPayload>
          }
          aggregate: {
            args: Prisma.Committee_memberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommittee_member>
          }
          groupBy: {
            args: Prisma.committee_memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<Committee_memberGroupByOutputType>[]
          }
          count: {
            args: Prisma.committee_memberCountArgs<ExtArgs>
            result: $Utils.Optional<Committee_memberCountAggregateOutputType> | number
          }
        }
      }
      committee_registration: {
        payload: Prisma.$committee_registrationPayload<ExtArgs>
        fields: Prisma.committee_registrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.committee_registrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.committee_registrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          findFirst: {
            args: Prisma.committee_registrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.committee_registrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          findMany: {
            args: Prisma.committee_registrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>[]
          }
          create: {
            args: Prisma.committee_registrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          createMany: {
            args: Prisma.committee_registrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.committee_registrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>[]
          }
          delete: {
            args: Prisma.committee_registrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          update: {
            args: Prisma.committee_registrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          deleteMany: {
            args: Prisma.committee_registrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.committee_registrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.committee_registrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>[]
          }
          upsert: {
            args: Prisma.committee_registrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$committee_registrationPayload>
          }
          aggregate: {
            args: Prisma.Committee_registrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommittee_registration>
          }
          groupBy: {
            args: Prisma.committee_registrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Committee_registrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.committee_registrationCountArgs<ExtArgs>
            result: $Utils.Optional<Committee_registrationCountAggregateOutputType> | number
          }
        }
      }
      constitution: {
        payload: Prisma.$constitutionPayload<ExtArgs>
        fields: Prisma.constitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.constitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.constitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          findFirst: {
            args: Prisma.constitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.constitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          findMany: {
            args: Prisma.constitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>[]
          }
          create: {
            args: Prisma.constitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          createMany: {
            args: Prisma.constitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.constitutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>[]
          }
          delete: {
            args: Prisma.constitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          update: {
            args: Prisma.constitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          deleteMany: {
            args: Prisma.constitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.constitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.constitutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>[]
          }
          upsert: {
            args: Prisma.constitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$constitutionPayload>
          }
          aggregate: {
            args: Prisma.ConstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstitution>
          }
          groupBy: {
            args: Prisma.constitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConstitutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.constitutionCountArgs<ExtArgs>
            result: $Utils.Optional<ConstitutionCountAggregateOutputType> | number
          }
        }
      }
      cost_model: {
        payload: Prisma.$cost_modelPayload<ExtArgs>
        fields: Prisma.cost_modelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cost_modelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cost_modelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          findFirst: {
            args: Prisma.cost_modelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cost_modelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          findMany: {
            args: Prisma.cost_modelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>[]
          }
          create: {
            args: Prisma.cost_modelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          createMany: {
            args: Prisma.cost_modelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cost_modelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>[]
          }
          delete: {
            args: Prisma.cost_modelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          update: {
            args: Prisma.cost_modelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          deleteMany: {
            args: Prisma.cost_modelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cost_modelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cost_modelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>[]
          }
          upsert: {
            args: Prisma.cost_modelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cost_modelPayload>
          }
          aggregate: {
            args: Prisma.Cost_modelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCost_model>
          }
          groupBy: {
            args: Prisma.cost_modelGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cost_modelGroupByOutputType>[]
          }
          count: {
            args: Prisma.cost_modelCountArgs<ExtArgs>
            result: $Utils.Optional<Cost_modelCountAggregateOutputType> | number
          }
        }
      }
      datum: {
        payload: Prisma.$datumPayload<ExtArgs>
        fields: Prisma.datumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.datumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.datumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          findFirst: {
            args: Prisma.datumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.datumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          findMany: {
            args: Prisma.datumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>[]
          }
          create: {
            args: Prisma.datumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          createMany: {
            args: Prisma.datumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.datumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>[]
          }
          delete: {
            args: Prisma.datumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          update: {
            args: Prisma.datumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          deleteMany: {
            args: Prisma.datumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.datumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.datumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>[]
          }
          upsert: {
            args: Prisma.datumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$datumPayload>
          }
          aggregate: {
            args: Prisma.DatumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatum>
          }
          groupBy: {
            args: Prisma.datumGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatumGroupByOutputType>[]
          }
          count: {
            args: Prisma.datumCountArgs<ExtArgs>
            result: $Utils.Optional<DatumCountAggregateOutputType> | number
          }
        }
      }
      delegation: {
        payload: Prisma.$delegationPayload<ExtArgs>
        fields: Prisma.delegationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.delegationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.delegationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          findFirst: {
            args: Prisma.delegationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.delegationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          findMany: {
            args: Prisma.delegationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>[]
          }
          create: {
            args: Prisma.delegationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          createMany: {
            args: Prisma.delegationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.delegationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>[]
          }
          delete: {
            args: Prisma.delegationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          update: {
            args: Prisma.delegationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          deleteMany: {
            args: Prisma.delegationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.delegationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.delegationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>[]
          }
          upsert: {
            args: Prisma.delegationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegationPayload>
          }
          aggregate: {
            args: Prisma.DelegationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelegation>
          }
          groupBy: {
            args: Prisma.delegationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelegationGroupByOutputType>[]
          }
          count: {
            args: Prisma.delegationCountArgs<ExtArgs>
            result: $Utils.Optional<DelegationCountAggregateOutputType> | number
          }
        }
      }
      delegation_vote: {
        payload: Prisma.$delegation_votePayload<ExtArgs>
        fields: Prisma.delegation_voteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.delegation_voteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.delegation_voteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          findFirst: {
            args: Prisma.delegation_voteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.delegation_voteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          findMany: {
            args: Prisma.delegation_voteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>[]
          }
          create: {
            args: Prisma.delegation_voteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          createMany: {
            args: Prisma.delegation_voteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.delegation_voteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>[]
          }
          delete: {
            args: Prisma.delegation_voteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          update: {
            args: Prisma.delegation_voteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          deleteMany: {
            args: Prisma.delegation_voteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.delegation_voteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.delegation_voteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>[]
          }
          upsert: {
            args: Prisma.delegation_voteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delegation_votePayload>
          }
          aggregate: {
            args: Prisma.Delegation_voteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelegation_vote>
          }
          groupBy: {
            args: Prisma.delegation_voteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Delegation_voteGroupByOutputType>[]
          }
          count: {
            args: Prisma.delegation_voteCountArgs<ExtArgs>
            result: $Utils.Optional<Delegation_voteCountAggregateOutputType> | number
          }
        }
      }
      delisted_pool: {
        payload: Prisma.$delisted_poolPayload<ExtArgs>
        fields: Prisma.delisted_poolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.delisted_poolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.delisted_poolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          findFirst: {
            args: Prisma.delisted_poolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.delisted_poolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          findMany: {
            args: Prisma.delisted_poolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>[]
          }
          create: {
            args: Prisma.delisted_poolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          createMany: {
            args: Prisma.delisted_poolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.delisted_poolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>[]
          }
          delete: {
            args: Prisma.delisted_poolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          update: {
            args: Prisma.delisted_poolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          deleteMany: {
            args: Prisma.delisted_poolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.delisted_poolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.delisted_poolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>[]
          }
          upsert: {
            args: Prisma.delisted_poolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$delisted_poolPayload>
          }
          aggregate: {
            args: Prisma.Delisted_poolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelisted_pool>
          }
          groupBy: {
            args: Prisma.delisted_poolGroupByArgs<ExtArgs>
            result: $Utils.Optional<Delisted_poolGroupByOutputType>[]
          }
          count: {
            args: Prisma.delisted_poolCountArgs<ExtArgs>
            result: $Utils.Optional<Delisted_poolCountAggregateOutputType> | number
          }
        }
      }
      drep_distr: {
        payload: Prisma.$drep_distrPayload<ExtArgs>
        fields: Prisma.drep_distrFieldRefs
        operations: {
          findUnique: {
            args: Prisma.drep_distrFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.drep_distrFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          findFirst: {
            args: Prisma.drep_distrFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.drep_distrFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          findMany: {
            args: Prisma.drep_distrFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>[]
          }
          create: {
            args: Prisma.drep_distrCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          createMany: {
            args: Prisma.drep_distrCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.drep_distrCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>[]
          }
          delete: {
            args: Prisma.drep_distrDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          update: {
            args: Prisma.drep_distrUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          deleteMany: {
            args: Prisma.drep_distrDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.drep_distrUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.drep_distrUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>[]
          }
          upsert: {
            args: Prisma.drep_distrUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_distrPayload>
          }
          aggregate: {
            args: Prisma.Drep_distrAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrep_distr>
          }
          groupBy: {
            args: Prisma.drep_distrGroupByArgs<ExtArgs>
            result: $Utils.Optional<Drep_distrGroupByOutputType>[]
          }
          count: {
            args: Prisma.drep_distrCountArgs<ExtArgs>
            result: $Utils.Optional<Drep_distrCountAggregateOutputType> | number
          }
        }
      }
      drep_hash: {
        payload: Prisma.$drep_hashPayload<ExtArgs>
        fields: Prisma.drep_hashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.drep_hashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.drep_hashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          findFirst: {
            args: Prisma.drep_hashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.drep_hashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          findMany: {
            args: Prisma.drep_hashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>[]
          }
          create: {
            args: Prisma.drep_hashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          createMany: {
            args: Prisma.drep_hashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.drep_hashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>[]
          }
          delete: {
            args: Prisma.drep_hashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          update: {
            args: Prisma.drep_hashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          deleteMany: {
            args: Prisma.drep_hashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.drep_hashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.drep_hashUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>[]
          }
          upsert: {
            args: Prisma.drep_hashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_hashPayload>
          }
          aggregate: {
            args: Prisma.Drep_hashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrep_hash>
          }
          groupBy: {
            args: Prisma.drep_hashGroupByArgs<ExtArgs>
            result: $Utils.Optional<Drep_hashGroupByOutputType>[]
          }
          count: {
            args: Prisma.drep_hashCountArgs<ExtArgs>
            result: $Utils.Optional<Drep_hashCountAggregateOutputType> | number
          }
        }
      }
      drep_registration: {
        payload: Prisma.$drep_registrationPayload<ExtArgs>
        fields: Prisma.drep_registrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.drep_registrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.drep_registrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          findFirst: {
            args: Prisma.drep_registrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.drep_registrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          findMany: {
            args: Prisma.drep_registrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>[]
          }
          create: {
            args: Prisma.drep_registrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          createMany: {
            args: Prisma.drep_registrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.drep_registrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>[]
          }
          delete: {
            args: Prisma.drep_registrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          update: {
            args: Prisma.drep_registrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          deleteMany: {
            args: Prisma.drep_registrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.drep_registrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.drep_registrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>[]
          }
          upsert: {
            args: Prisma.drep_registrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$drep_registrationPayload>
          }
          aggregate: {
            args: Prisma.Drep_registrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrep_registration>
          }
          groupBy: {
            args: Prisma.drep_registrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Drep_registrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.drep_registrationCountArgs<ExtArgs>
            result: $Utils.Optional<Drep_registrationCountAggregateOutputType> | number
          }
        }
      }
      epoch: {
        payload: Prisma.$epochPayload<ExtArgs>
        fields: Prisma.epochFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epochFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epochFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          findFirst: {
            args: Prisma.epochFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epochFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          findMany: {
            args: Prisma.epochFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>[]
          }
          create: {
            args: Prisma.epochCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          createMany: {
            args: Prisma.epochCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epochCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>[]
          }
          delete: {
            args: Prisma.epochDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          update: {
            args: Prisma.epochUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          deleteMany: {
            args: Prisma.epochDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epochUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epochUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>[]
          }
          upsert: {
            args: Prisma.epochUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epochPayload>
          }
          aggregate: {
            args: Prisma.EpochAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch>
          }
          groupBy: {
            args: Prisma.epochGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpochGroupByOutputType>[]
          }
          count: {
            args: Prisma.epochCountArgs<ExtArgs>
            result: $Utils.Optional<EpochCountAggregateOutputType> | number
          }
        }
      }
      epoch_param: {
        payload: Prisma.$epoch_paramPayload<ExtArgs>
        fields: Prisma.epoch_paramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epoch_paramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epoch_paramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          findFirst: {
            args: Prisma.epoch_paramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epoch_paramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          findMany: {
            args: Prisma.epoch_paramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>[]
          }
          create: {
            args: Prisma.epoch_paramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          createMany: {
            args: Prisma.epoch_paramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epoch_paramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>[]
          }
          delete: {
            args: Prisma.epoch_paramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          update: {
            args: Prisma.epoch_paramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          deleteMany: {
            args: Prisma.epoch_paramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epoch_paramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epoch_paramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>[]
          }
          upsert: {
            args: Prisma.epoch_paramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_paramPayload>
          }
          aggregate: {
            args: Prisma.Epoch_paramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch_param>
          }
          groupBy: {
            args: Prisma.epoch_paramGroupByArgs<ExtArgs>
            result: $Utils.Optional<Epoch_paramGroupByOutputType>[]
          }
          count: {
            args: Prisma.epoch_paramCountArgs<ExtArgs>
            result: $Utils.Optional<Epoch_paramCountAggregateOutputType> | number
          }
        }
      }
      epoch_stake: {
        payload: Prisma.$epoch_stakePayload<ExtArgs>
        fields: Prisma.epoch_stakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epoch_stakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epoch_stakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          findFirst: {
            args: Prisma.epoch_stakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epoch_stakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          findMany: {
            args: Prisma.epoch_stakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>[]
          }
          create: {
            args: Prisma.epoch_stakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          createMany: {
            args: Prisma.epoch_stakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epoch_stakeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>[]
          }
          delete: {
            args: Prisma.epoch_stakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          update: {
            args: Prisma.epoch_stakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          deleteMany: {
            args: Prisma.epoch_stakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epoch_stakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epoch_stakeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>[]
          }
          upsert: {
            args: Prisma.epoch_stakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stakePayload>
          }
          aggregate: {
            args: Prisma.Epoch_stakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch_stake>
          }
          groupBy: {
            args: Prisma.epoch_stakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.epoch_stakeCountArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stakeCountAggregateOutputType> | number
          }
        }
      }
      epoch_stake_progress: {
        payload: Prisma.$epoch_stake_progressPayload<ExtArgs>
        fields: Prisma.epoch_stake_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epoch_stake_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epoch_stake_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          findFirst: {
            args: Prisma.epoch_stake_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epoch_stake_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          findMany: {
            args: Prisma.epoch_stake_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>[]
          }
          create: {
            args: Prisma.epoch_stake_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          createMany: {
            args: Prisma.epoch_stake_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epoch_stake_progressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>[]
          }
          delete: {
            args: Prisma.epoch_stake_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          update: {
            args: Prisma.epoch_stake_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          deleteMany: {
            args: Prisma.epoch_stake_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epoch_stake_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epoch_stake_progressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>[]
          }
          upsert: {
            args: Prisma.epoch_stake_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_stake_progressPayload>
          }
          aggregate: {
            args: Prisma.Epoch_stake_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch_stake_progress>
          }
          groupBy: {
            args: Prisma.epoch_stake_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stake_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.epoch_stake_progressCountArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stake_progressCountAggregateOutputType> | number
          }
        }
      }
      epoch_state: {
        payload: Prisma.$epoch_statePayload<ExtArgs>
        fields: Prisma.epoch_stateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epoch_stateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epoch_stateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          findFirst: {
            args: Prisma.epoch_stateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epoch_stateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          findMany: {
            args: Prisma.epoch_stateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>[]
          }
          create: {
            args: Prisma.epoch_stateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          createMany: {
            args: Prisma.epoch_stateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epoch_stateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>[]
          }
          delete: {
            args: Prisma.epoch_stateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          update: {
            args: Prisma.epoch_stateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          deleteMany: {
            args: Prisma.epoch_stateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epoch_stateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epoch_stateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>[]
          }
          upsert: {
            args: Prisma.epoch_stateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_statePayload>
          }
          aggregate: {
            args: Prisma.Epoch_stateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch_state>
          }
          groupBy: {
            args: Prisma.epoch_stateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stateGroupByOutputType>[]
          }
          count: {
            args: Prisma.epoch_stateCountArgs<ExtArgs>
            result: $Utils.Optional<Epoch_stateCountAggregateOutputType> | number
          }
        }
      }
      epoch_sync_time: {
        payload: Prisma.$epoch_sync_timePayload<ExtArgs>
        fields: Prisma.epoch_sync_timeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.epoch_sync_timeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.epoch_sync_timeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          findFirst: {
            args: Prisma.epoch_sync_timeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.epoch_sync_timeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          findMany: {
            args: Prisma.epoch_sync_timeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>[]
          }
          create: {
            args: Prisma.epoch_sync_timeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          createMany: {
            args: Prisma.epoch_sync_timeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.epoch_sync_timeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>[]
          }
          delete: {
            args: Prisma.epoch_sync_timeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          update: {
            args: Prisma.epoch_sync_timeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          deleteMany: {
            args: Prisma.epoch_sync_timeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.epoch_sync_timeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.epoch_sync_timeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>[]
          }
          upsert: {
            args: Prisma.epoch_sync_timeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$epoch_sync_timePayload>
          }
          aggregate: {
            args: Prisma.Epoch_sync_timeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpoch_sync_time>
          }
          groupBy: {
            args: Prisma.epoch_sync_timeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Epoch_sync_timeGroupByOutputType>[]
          }
          count: {
            args: Prisma.epoch_sync_timeCountArgs<ExtArgs>
            result: $Utils.Optional<Epoch_sync_timeCountAggregateOutputType> | number
          }
        }
      }
      event_info: {
        payload: Prisma.$event_infoPayload<ExtArgs>
        fields: Prisma.event_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.event_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.event_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          findFirst: {
            args: Prisma.event_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.event_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          findMany: {
            args: Prisma.event_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>[]
          }
          create: {
            args: Prisma.event_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          createMany: {
            args: Prisma.event_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.event_infoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>[]
          }
          delete: {
            args: Prisma.event_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          update: {
            args: Prisma.event_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          deleteMany: {
            args: Prisma.event_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.event_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.event_infoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>[]
          }
          upsert: {
            args: Prisma.event_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$event_infoPayload>
          }
          aggregate: {
            args: Prisma.Event_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent_info>
          }
          groupBy: {
            args: Prisma.event_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Event_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.event_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Event_infoCountAggregateOutputType> | number
          }
        }
      }
      extra_key_witness: {
        payload: Prisma.$extra_key_witnessPayload<ExtArgs>
        fields: Prisma.extra_key_witnessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extra_key_witnessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extra_key_witnessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          findFirst: {
            args: Prisma.extra_key_witnessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extra_key_witnessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          findMany: {
            args: Prisma.extra_key_witnessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>[]
          }
          create: {
            args: Prisma.extra_key_witnessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          createMany: {
            args: Prisma.extra_key_witnessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.extra_key_witnessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>[]
          }
          delete: {
            args: Prisma.extra_key_witnessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          update: {
            args: Prisma.extra_key_witnessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          deleteMany: {
            args: Prisma.extra_key_witnessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.extra_key_witnessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.extra_key_witnessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>[]
          }
          upsert: {
            args: Prisma.extra_key_witnessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_key_witnessPayload>
          }
          aggregate: {
            args: Prisma.Extra_key_witnessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtra_key_witness>
          }
          groupBy: {
            args: Prisma.extra_key_witnessGroupByArgs<ExtArgs>
            result: $Utils.Optional<Extra_key_witnessGroupByOutputType>[]
          }
          count: {
            args: Prisma.extra_key_witnessCountArgs<ExtArgs>
            result: $Utils.Optional<Extra_key_witnessCountAggregateOutputType> | number
          }
        }
      }
      extra_migrations: {
        payload: Prisma.$extra_migrationsPayload<ExtArgs>
        fields: Prisma.extra_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.extra_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.extra_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          findFirst: {
            args: Prisma.extra_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.extra_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          findMany: {
            args: Prisma.extra_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>[]
          }
          create: {
            args: Prisma.extra_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          createMany: {
            args: Prisma.extra_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.extra_migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>[]
          }
          delete: {
            args: Prisma.extra_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          update: {
            args: Prisma.extra_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.extra_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.extra_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.extra_migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>[]
          }
          upsert: {
            args: Prisma.extra_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$extra_migrationsPayload>
          }
          aggregate: {
            args: Prisma.Extra_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtra_migrations>
          }
          groupBy: {
            args: Prisma.extra_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Extra_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.extra_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Extra_migrationsCountAggregateOutputType> | number
          }
        }
      }
      gov_action_proposal: {
        payload: Prisma.$gov_action_proposalPayload<ExtArgs>
        fields: Prisma.gov_action_proposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gov_action_proposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gov_action_proposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          findFirst: {
            args: Prisma.gov_action_proposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gov_action_proposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          findMany: {
            args: Prisma.gov_action_proposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>[]
          }
          create: {
            args: Prisma.gov_action_proposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          createMany: {
            args: Prisma.gov_action_proposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gov_action_proposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>[]
          }
          delete: {
            args: Prisma.gov_action_proposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          update: {
            args: Prisma.gov_action_proposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          deleteMany: {
            args: Prisma.gov_action_proposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gov_action_proposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gov_action_proposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>[]
          }
          upsert: {
            args: Prisma.gov_action_proposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gov_action_proposalPayload>
          }
          aggregate: {
            args: Prisma.Gov_action_proposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGov_action_proposal>
          }
          groupBy: {
            args: Prisma.gov_action_proposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Gov_action_proposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.gov_action_proposalCountArgs<ExtArgs>
            result: $Utils.Optional<Gov_action_proposalCountAggregateOutputType> | number
          }
        }
      }
      ma_tx_mint: {
        payload: Prisma.$ma_tx_mintPayload<ExtArgs>
        fields: Prisma.ma_tx_mintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ma_tx_mintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ma_tx_mintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          findFirst: {
            args: Prisma.ma_tx_mintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ma_tx_mintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          findMany: {
            args: Prisma.ma_tx_mintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>[]
          }
          create: {
            args: Prisma.ma_tx_mintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          createMany: {
            args: Prisma.ma_tx_mintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ma_tx_mintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>[]
          }
          delete: {
            args: Prisma.ma_tx_mintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          update: {
            args: Prisma.ma_tx_mintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          deleteMany: {
            args: Prisma.ma_tx_mintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ma_tx_mintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ma_tx_mintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>[]
          }
          upsert: {
            args: Prisma.ma_tx_mintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_mintPayload>
          }
          aggregate: {
            args: Prisma.Ma_tx_mintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMa_tx_mint>
          }
          groupBy: {
            args: Prisma.ma_tx_mintGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ma_tx_mintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ma_tx_mintCountArgs<ExtArgs>
            result: $Utils.Optional<Ma_tx_mintCountAggregateOutputType> | number
          }
        }
      }
      ma_tx_out: {
        payload: Prisma.$ma_tx_outPayload<ExtArgs>
        fields: Prisma.ma_tx_outFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ma_tx_outFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ma_tx_outFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          findFirst: {
            args: Prisma.ma_tx_outFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ma_tx_outFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          findMany: {
            args: Prisma.ma_tx_outFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>[]
          }
          create: {
            args: Prisma.ma_tx_outCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          createMany: {
            args: Prisma.ma_tx_outCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ma_tx_outCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>[]
          }
          delete: {
            args: Prisma.ma_tx_outDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          update: {
            args: Prisma.ma_tx_outUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          deleteMany: {
            args: Prisma.ma_tx_outDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ma_tx_outUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ma_tx_outUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>[]
          }
          upsert: {
            args: Prisma.ma_tx_outUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ma_tx_outPayload>
          }
          aggregate: {
            args: Prisma.Ma_tx_outAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMa_tx_out>
          }
          groupBy: {
            args: Prisma.ma_tx_outGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ma_tx_outGroupByOutputType>[]
          }
          count: {
            args: Prisma.ma_tx_outCountArgs<ExtArgs>
            result: $Utils.Optional<Ma_tx_outCountAggregateOutputType> | number
          }
        }
      }
      meta: {
        payload: Prisma.$metaPayload<ExtArgs>
        fields: Prisma.metaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.metaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.metaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          findFirst: {
            args: Prisma.metaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.metaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          findMany: {
            args: Prisma.metaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[]
          }
          create: {
            args: Prisma.metaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          createMany: {
            args: Prisma.metaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.metaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[]
          }
          delete: {
            args: Prisma.metaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          update: {
            args: Prisma.metaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          deleteMany: {
            args: Prisma.metaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.metaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.metaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>[]
          }
          upsert: {
            args: Prisma.metaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$metaPayload>
          }
          aggregate: {
            args: Prisma.MetaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeta>
          }
          groupBy: {
            args: Prisma.metaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetaGroupByOutputType>[]
          }
          count: {
            args: Prisma.metaCountArgs<ExtArgs>
            result: $Utils.Optional<MetaCountAggregateOutputType> | number
          }
        }
      }
      multi_asset: {
        payload: Prisma.$multi_assetPayload<ExtArgs>
        fields: Prisma.multi_assetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.multi_assetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.multi_assetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          findFirst: {
            args: Prisma.multi_assetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.multi_assetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          findMany: {
            args: Prisma.multi_assetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>[]
          }
          create: {
            args: Prisma.multi_assetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          createMany: {
            args: Prisma.multi_assetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.multi_assetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>[]
          }
          delete: {
            args: Prisma.multi_assetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          update: {
            args: Prisma.multi_assetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          deleteMany: {
            args: Prisma.multi_assetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.multi_assetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.multi_assetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>[]
          }
          upsert: {
            args: Prisma.multi_assetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multi_assetPayload>
          }
          aggregate: {
            args: Prisma.Multi_assetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMulti_asset>
          }
          groupBy: {
            args: Prisma.multi_assetGroupByArgs<ExtArgs>
            result: $Utils.Optional<Multi_assetGroupByOutputType>[]
          }
          count: {
            args: Prisma.multi_assetCountArgs<ExtArgs>
            result: $Utils.Optional<Multi_assetCountAggregateOutputType> | number
          }
        }
      }
      new_committee: {
        payload: Prisma.$new_committeePayload<ExtArgs>
        fields: Prisma.new_committeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.new_committeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.new_committeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          findFirst: {
            args: Prisma.new_committeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.new_committeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          findMany: {
            args: Prisma.new_committeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>[]
          }
          create: {
            args: Prisma.new_committeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          createMany: {
            args: Prisma.new_committeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.new_committeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>[]
          }
          delete: {
            args: Prisma.new_committeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          update: {
            args: Prisma.new_committeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          deleteMany: {
            args: Prisma.new_committeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.new_committeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.new_committeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>[]
          }
          upsert: {
            args: Prisma.new_committeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_committeePayload>
          }
          aggregate: {
            args: Prisma.New_committeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNew_committee>
          }
          groupBy: {
            args: Prisma.new_committeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<New_committeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.new_committeeCountArgs<ExtArgs>
            result: $Utils.Optional<New_committeeCountAggregateOutputType> | number
          }
        }
      }
      off_chain_pool_data: {
        payload: Prisma.$off_chain_pool_dataPayload<ExtArgs>
        fields: Prisma.off_chain_pool_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_pool_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_pool_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          findFirst: {
            args: Prisma.off_chain_pool_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_pool_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          findMany: {
            args: Prisma.off_chain_pool_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>[]
          }
          create: {
            args: Prisma.off_chain_pool_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          createMany: {
            args: Prisma.off_chain_pool_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_pool_dataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>[]
          }
          delete: {
            args: Prisma.off_chain_pool_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          update: {
            args: Prisma.off_chain_pool_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_pool_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_pool_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_pool_dataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_pool_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_dataPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_pool_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_pool_data>
          }
          groupBy: {
            args: Prisma.off_chain_pool_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_pool_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_pool_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_pool_dataCountAggregateOutputType> | number
          }
        }
      }
      off_chain_pool_fetch_error: {
        payload: Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>
        fields: Prisma.off_chain_pool_fetch_errorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_pool_fetch_errorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_pool_fetch_errorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          findFirst: {
            args: Prisma.off_chain_pool_fetch_errorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_pool_fetch_errorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          findMany: {
            args: Prisma.off_chain_pool_fetch_errorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>[]
          }
          create: {
            args: Prisma.off_chain_pool_fetch_errorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          createMany: {
            args: Prisma.off_chain_pool_fetch_errorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_pool_fetch_errorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>[]
          }
          delete: {
            args: Prisma.off_chain_pool_fetch_errorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          update: {
            args: Prisma.off_chain_pool_fetch_errorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_pool_fetch_errorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_pool_fetch_errorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_pool_fetch_errorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_pool_fetch_errorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_pool_fetch_errorPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_pool_fetch_errorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_pool_fetch_error>
          }
          groupBy: {
            args: Prisma.off_chain_pool_fetch_errorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_pool_fetch_errorGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_pool_fetch_errorCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_pool_fetch_errorCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_author: {
        payload: Prisma.$off_chain_vote_authorPayload<ExtArgs>
        fields: Prisma.off_chain_vote_authorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_authorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_authorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_authorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_authorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_authorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_authorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_authorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_authorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_authorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          update: {
            args: Prisma.off_chain_vote_authorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_authorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_authorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_authorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_authorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_authorPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_authorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_author>
          }
          groupBy: {
            args: Prisma.off_chain_vote_authorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_authorGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_authorCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_authorCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_data: {
        payload: Prisma.$off_chain_vote_dataPayload<ExtArgs>
        fields: Prisma.off_chain_vote_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_dataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          update: {
            args: Prisma.off_chain_vote_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_dataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_dataPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_data>
          }
          groupBy: {
            args: Prisma.off_chain_vote_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_dataCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_drep_data: {
        payload: Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>
        fields: Prisma.off_chain_vote_drep_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_drep_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_drep_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_drep_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_drep_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_drep_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_drep_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_drep_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_drep_dataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_drep_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          update: {
            args: Prisma.off_chain_vote_drep_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_drep_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_drep_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_drep_dataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_drep_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_drep_dataPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_drep_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_drep_data>
          }
          groupBy: {
            args: Prisma.off_chain_vote_drep_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_drep_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_drep_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_drep_dataCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_external_update: {
        payload: Prisma.$off_chain_vote_external_updatePayload<ExtArgs>
        fields: Prisma.off_chain_vote_external_updateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_external_updateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_external_updateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_external_updateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_external_updateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_external_updateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_external_updateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_external_updateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_external_updateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_external_updateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          update: {
            args: Prisma.off_chain_vote_external_updateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_external_updateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_external_updateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_external_updateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_external_updateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_external_updatePayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_external_updateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_external_update>
          }
          groupBy: {
            args: Prisma.off_chain_vote_external_updateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_external_updateGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_external_updateCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_external_updateCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_fetch_error: {
        payload: Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>
        fields: Prisma.off_chain_vote_fetch_errorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_fetch_errorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_fetch_errorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_fetch_errorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_fetch_errorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_fetch_errorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_fetch_errorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_fetch_errorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_fetch_errorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_fetch_errorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          update: {
            args: Prisma.off_chain_vote_fetch_errorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_fetch_errorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_fetch_errorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_fetch_errorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_fetch_errorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_fetch_errorPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_fetch_errorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_fetch_error>
          }
          groupBy: {
            args: Prisma.off_chain_vote_fetch_errorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_fetch_errorGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_fetch_errorCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_fetch_errorCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_gov_action_data: {
        payload: Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>
        fields: Prisma.off_chain_vote_gov_action_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_gov_action_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_gov_action_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_gov_action_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_gov_action_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_gov_action_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_gov_action_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_gov_action_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_gov_action_dataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_gov_action_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          update: {
            args: Prisma.off_chain_vote_gov_action_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_gov_action_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_gov_action_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_gov_action_dataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_gov_action_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_gov_action_dataPayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_gov_action_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_gov_action_data>
          }
          groupBy: {
            args: Prisma.off_chain_vote_gov_action_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_gov_action_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_gov_action_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_gov_action_dataCountAggregateOutputType> | number
          }
        }
      }
      off_chain_vote_reference: {
        payload: Prisma.$off_chain_vote_referencePayload<ExtArgs>
        fields: Prisma.off_chain_vote_referenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.off_chain_vote_referenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.off_chain_vote_referenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          findFirst: {
            args: Prisma.off_chain_vote_referenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.off_chain_vote_referenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          findMany: {
            args: Prisma.off_chain_vote_referenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>[]
          }
          create: {
            args: Prisma.off_chain_vote_referenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          createMany: {
            args: Prisma.off_chain_vote_referenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.off_chain_vote_referenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>[]
          }
          delete: {
            args: Prisma.off_chain_vote_referenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          update: {
            args: Prisma.off_chain_vote_referenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          deleteMany: {
            args: Prisma.off_chain_vote_referenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.off_chain_vote_referenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.off_chain_vote_referenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>[]
          }
          upsert: {
            args: Prisma.off_chain_vote_referenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$off_chain_vote_referencePayload>
          }
          aggregate: {
            args: Prisma.Off_chain_vote_referenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOff_chain_vote_reference>
          }
          groupBy: {
            args: Prisma.off_chain_vote_referenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_referenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.off_chain_vote_referenceCountArgs<ExtArgs>
            result: $Utils.Optional<Off_chain_vote_referenceCountAggregateOutputType> | number
          }
        }
      }
      param_proposal: {
        payload: Prisma.$param_proposalPayload<ExtArgs>
        fields: Prisma.param_proposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.param_proposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.param_proposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          findFirst: {
            args: Prisma.param_proposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.param_proposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          findMany: {
            args: Prisma.param_proposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>[]
          }
          create: {
            args: Prisma.param_proposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          createMany: {
            args: Prisma.param_proposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.param_proposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>[]
          }
          delete: {
            args: Prisma.param_proposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          update: {
            args: Prisma.param_proposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          deleteMany: {
            args: Prisma.param_proposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.param_proposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.param_proposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>[]
          }
          upsert: {
            args: Prisma.param_proposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$param_proposalPayload>
          }
          aggregate: {
            args: Prisma.Param_proposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParam_proposal>
          }
          groupBy: {
            args: Prisma.param_proposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Param_proposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.param_proposalCountArgs<ExtArgs>
            result: $Utils.Optional<Param_proposalCountAggregateOutputType> | number
          }
        }
      }
      pool_hash: {
        payload: Prisma.$pool_hashPayload<ExtArgs>
        fields: Prisma.pool_hashFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_hashFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_hashFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          findFirst: {
            args: Prisma.pool_hashFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_hashFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          findMany: {
            args: Prisma.pool_hashFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>[]
          }
          create: {
            args: Prisma.pool_hashCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          createMany: {
            args: Prisma.pool_hashCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_hashCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>[]
          }
          delete: {
            args: Prisma.pool_hashDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          update: {
            args: Prisma.pool_hashUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          deleteMany: {
            args: Prisma.pool_hashDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_hashUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_hashUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>[]
          }
          upsert: {
            args: Prisma.pool_hashUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_hashPayload>
          }
          aggregate: {
            args: Prisma.Pool_hashAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_hash>
          }
          groupBy: {
            args: Prisma.pool_hashGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_hashGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_hashCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_hashCountAggregateOutputType> | number
          }
        }
      }
      pool_metadata_ref: {
        payload: Prisma.$pool_metadata_refPayload<ExtArgs>
        fields: Prisma.pool_metadata_refFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_metadata_refFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_metadata_refFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          findFirst: {
            args: Prisma.pool_metadata_refFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_metadata_refFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          findMany: {
            args: Prisma.pool_metadata_refFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>[]
          }
          create: {
            args: Prisma.pool_metadata_refCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          createMany: {
            args: Prisma.pool_metadata_refCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_metadata_refCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>[]
          }
          delete: {
            args: Prisma.pool_metadata_refDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          update: {
            args: Prisma.pool_metadata_refUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          deleteMany: {
            args: Prisma.pool_metadata_refDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_metadata_refUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_metadata_refUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>[]
          }
          upsert: {
            args: Prisma.pool_metadata_refUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_metadata_refPayload>
          }
          aggregate: {
            args: Prisma.Pool_metadata_refAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_metadata_ref>
          }
          groupBy: {
            args: Prisma.pool_metadata_refGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_metadata_refGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_metadata_refCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_metadata_refCountAggregateOutputType> | number
          }
        }
      }
      pool_owner: {
        payload: Prisma.$pool_ownerPayload<ExtArgs>
        fields: Prisma.pool_ownerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_ownerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_ownerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          findFirst: {
            args: Prisma.pool_ownerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_ownerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          findMany: {
            args: Prisma.pool_ownerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>[]
          }
          create: {
            args: Prisma.pool_ownerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          createMany: {
            args: Prisma.pool_ownerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_ownerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>[]
          }
          delete: {
            args: Prisma.pool_ownerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          update: {
            args: Prisma.pool_ownerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          deleteMany: {
            args: Prisma.pool_ownerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_ownerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_ownerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>[]
          }
          upsert: {
            args: Prisma.pool_ownerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_ownerPayload>
          }
          aggregate: {
            args: Prisma.Pool_ownerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_owner>
          }
          groupBy: {
            args: Prisma.pool_ownerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_ownerGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_ownerCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_ownerCountAggregateOutputType> | number
          }
        }
      }
      pool_relay: {
        payload: Prisma.$pool_relayPayload<ExtArgs>
        fields: Prisma.pool_relayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_relayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_relayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          findFirst: {
            args: Prisma.pool_relayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_relayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          findMany: {
            args: Prisma.pool_relayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>[]
          }
          create: {
            args: Prisma.pool_relayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          createMany: {
            args: Prisma.pool_relayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_relayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>[]
          }
          delete: {
            args: Prisma.pool_relayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          update: {
            args: Prisma.pool_relayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          deleteMany: {
            args: Prisma.pool_relayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_relayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_relayUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>[]
          }
          upsert: {
            args: Prisma.pool_relayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_relayPayload>
          }
          aggregate: {
            args: Prisma.Pool_relayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_relay>
          }
          groupBy: {
            args: Prisma.pool_relayGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_relayGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_relayCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_relayCountAggregateOutputType> | number
          }
        }
      }
      pool_retire: {
        payload: Prisma.$pool_retirePayload<ExtArgs>
        fields: Prisma.pool_retireFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_retireFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_retireFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          findFirst: {
            args: Prisma.pool_retireFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_retireFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          findMany: {
            args: Prisma.pool_retireFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>[]
          }
          create: {
            args: Prisma.pool_retireCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          createMany: {
            args: Prisma.pool_retireCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_retireCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>[]
          }
          delete: {
            args: Prisma.pool_retireDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          update: {
            args: Prisma.pool_retireUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          deleteMany: {
            args: Prisma.pool_retireDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_retireUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_retireUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>[]
          }
          upsert: {
            args: Prisma.pool_retireUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_retirePayload>
          }
          aggregate: {
            args: Prisma.Pool_retireAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_retire>
          }
          groupBy: {
            args: Prisma.pool_retireGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_retireGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_retireCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_retireCountAggregateOutputType> | number
          }
        }
      }
      pool_stat: {
        payload: Prisma.$pool_statPayload<ExtArgs>
        fields: Prisma.pool_statFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_statFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_statFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          findFirst: {
            args: Prisma.pool_statFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_statFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          findMany: {
            args: Prisma.pool_statFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>[]
          }
          create: {
            args: Prisma.pool_statCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          createMany: {
            args: Prisma.pool_statCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_statCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>[]
          }
          delete: {
            args: Prisma.pool_statDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          update: {
            args: Prisma.pool_statUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          deleteMany: {
            args: Prisma.pool_statDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_statUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_statUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>[]
          }
          upsert: {
            args: Prisma.pool_statUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_statPayload>
          }
          aggregate: {
            args: Prisma.Pool_statAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_stat>
          }
          groupBy: {
            args: Prisma.pool_statGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_statGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_statCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_statCountAggregateOutputType> | number
          }
        }
      }
      pool_update: {
        payload: Prisma.$pool_updatePayload<ExtArgs>
        fields: Prisma.pool_updateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pool_updateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pool_updateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          findFirst: {
            args: Prisma.pool_updateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pool_updateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          findMany: {
            args: Prisma.pool_updateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>[]
          }
          create: {
            args: Prisma.pool_updateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          createMany: {
            args: Prisma.pool_updateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pool_updateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>[]
          }
          delete: {
            args: Prisma.pool_updateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          update: {
            args: Prisma.pool_updateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          deleteMany: {
            args: Prisma.pool_updateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pool_updateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pool_updateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>[]
          }
          upsert: {
            args: Prisma.pool_updateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pool_updatePayload>
          }
          aggregate: {
            args: Prisma.Pool_updateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePool_update>
          }
          groupBy: {
            args: Prisma.pool_updateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pool_updateGroupByOutputType>[]
          }
          count: {
            args: Prisma.pool_updateCountArgs<ExtArgs>
            result: $Utils.Optional<Pool_updateCountAggregateOutputType> | number
          }
        }
      }
      pot_transfer: {
        payload: Prisma.$pot_transferPayload<ExtArgs>
        fields: Prisma.pot_transferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pot_transferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pot_transferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          findFirst: {
            args: Prisma.pot_transferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pot_transferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          findMany: {
            args: Prisma.pot_transferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>[]
          }
          create: {
            args: Prisma.pot_transferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          createMany: {
            args: Prisma.pot_transferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pot_transferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>[]
          }
          delete: {
            args: Prisma.pot_transferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          update: {
            args: Prisma.pot_transferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          deleteMany: {
            args: Prisma.pot_transferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pot_transferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pot_transferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>[]
          }
          upsert: {
            args: Prisma.pot_transferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pot_transferPayload>
          }
          aggregate: {
            args: Prisma.Pot_transferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePot_transfer>
          }
          groupBy: {
            args: Prisma.pot_transferGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pot_transferGroupByOutputType>[]
          }
          count: {
            args: Prisma.pot_transferCountArgs<ExtArgs>
            result: $Utils.Optional<Pot_transferCountAggregateOutputType> | number
          }
        }
      }
      redeemer: {
        payload: Prisma.$redeemerPayload<ExtArgs>
        fields: Prisma.redeemerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.redeemerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.redeemerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          findFirst: {
            args: Prisma.redeemerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.redeemerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          findMany: {
            args: Prisma.redeemerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>[]
          }
          create: {
            args: Prisma.redeemerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          createMany: {
            args: Prisma.redeemerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.redeemerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>[]
          }
          delete: {
            args: Prisma.redeemerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          update: {
            args: Prisma.redeemerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          deleteMany: {
            args: Prisma.redeemerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.redeemerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.redeemerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>[]
          }
          upsert: {
            args: Prisma.redeemerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemerPayload>
          }
          aggregate: {
            args: Prisma.RedeemerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemer>
          }
          groupBy: {
            args: Prisma.redeemerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedeemerGroupByOutputType>[]
          }
          count: {
            args: Prisma.redeemerCountArgs<ExtArgs>
            result: $Utils.Optional<RedeemerCountAggregateOutputType> | number
          }
        }
      }
      redeemer_data: {
        payload: Prisma.$redeemer_dataPayload<ExtArgs>
        fields: Prisma.redeemer_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.redeemer_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.redeemer_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          findFirst: {
            args: Prisma.redeemer_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.redeemer_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          findMany: {
            args: Prisma.redeemer_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>[]
          }
          create: {
            args: Prisma.redeemer_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          createMany: {
            args: Prisma.redeemer_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.redeemer_dataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>[]
          }
          delete: {
            args: Prisma.redeemer_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          update: {
            args: Prisma.redeemer_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          deleteMany: {
            args: Prisma.redeemer_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.redeemer_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.redeemer_dataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>[]
          }
          upsert: {
            args: Prisma.redeemer_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$redeemer_dataPayload>
          }
          aggregate: {
            args: Prisma.Redeemer_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedeemer_data>
          }
          groupBy: {
            args: Prisma.redeemer_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Redeemer_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.redeemer_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Redeemer_dataCountAggregateOutputType> | number
          }
        }
      }
      reference_tx_in: {
        payload: Prisma.$reference_tx_inPayload<ExtArgs>
        fields: Prisma.reference_tx_inFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reference_tx_inFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reference_tx_inFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          findFirst: {
            args: Prisma.reference_tx_inFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reference_tx_inFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          findMany: {
            args: Prisma.reference_tx_inFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>[]
          }
          create: {
            args: Prisma.reference_tx_inCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          createMany: {
            args: Prisma.reference_tx_inCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reference_tx_inCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>[]
          }
          delete: {
            args: Prisma.reference_tx_inDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          update: {
            args: Prisma.reference_tx_inUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          deleteMany: {
            args: Prisma.reference_tx_inDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reference_tx_inUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reference_tx_inUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>[]
          }
          upsert: {
            args: Prisma.reference_tx_inUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reference_tx_inPayload>
          }
          aggregate: {
            args: Prisma.Reference_tx_inAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReference_tx_in>
          }
          groupBy: {
            args: Prisma.reference_tx_inGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reference_tx_inGroupByOutputType>[]
          }
          count: {
            args: Prisma.reference_tx_inCountArgs<ExtArgs>
            result: $Utils.Optional<Reference_tx_inCountAggregateOutputType> | number
          }
        }
      }
      reserve: {
        payload: Prisma.$reservePayload<ExtArgs>
        fields: Prisma.reserveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reserveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reserveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          findFirst: {
            args: Prisma.reserveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reserveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          findMany: {
            args: Prisma.reserveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>[]
          }
          create: {
            args: Prisma.reserveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          createMany: {
            args: Prisma.reserveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reserveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>[]
          }
          delete: {
            args: Prisma.reserveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          update: {
            args: Prisma.reserveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          deleteMany: {
            args: Prisma.reserveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reserveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reserveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>[]
          }
          upsert: {
            args: Prisma.reserveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reservePayload>
          }
          aggregate: {
            args: Prisma.ReserveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReserve>
          }
          groupBy: {
            args: Prisma.reserveGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReserveGroupByOutputType>[]
          }
          count: {
            args: Prisma.reserveCountArgs<ExtArgs>
            result: $Utils.Optional<ReserveCountAggregateOutputType> | number
          }
        }
      }
      reserved_pool_ticker: {
        payload: Prisma.$reserved_pool_tickerPayload<ExtArgs>
        fields: Prisma.reserved_pool_tickerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reserved_pool_tickerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reserved_pool_tickerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          findFirst: {
            args: Prisma.reserved_pool_tickerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reserved_pool_tickerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          findMany: {
            args: Prisma.reserved_pool_tickerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>[]
          }
          create: {
            args: Prisma.reserved_pool_tickerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          createMany: {
            args: Prisma.reserved_pool_tickerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reserved_pool_tickerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>[]
          }
          delete: {
            args: Prisma.reserved_pool_tickerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          update: {
            args: Prisma.reserved_pool_tickerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          deleteMany: {
            args: Prisma.reserved_pool_tickerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reserved_pool_tickerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reserved_pool_tickerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>[]
          }
          upsert: {
            args: Prisma.reserved_pool_tickerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reserved_pool_tickerPayload>
          }
          aggregate: {
            args: Prisma.Reserved_pool_tickerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReserved_pool_ticker>
          }
          groupBy: {
            args: Prisma.reserved_pool_tickerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reserved_pool_tickerGroupByOutputType>[]
          }
          count: {
            args: Prisma.reserved_pool_tickerCountArgs<ExtArgs>
            result: $Utils.Optional<Reserved_pool_tickerCountAggregateOutputType> | number
          }
        }
      }
      reverse_index: {
        payload: Prisma.$reverse_indexPayload<ExtArgs>
        fields: Prisma.reverse_indexFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reverse_indexFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reverse_indexFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          findFirst: {
            args: Prisma.reverse_indexFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reverse_indexFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          findMany: {
            args: Prisma.reverse_indexFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>[]
          }
          create: {
            args: Prisma.reverse_indexCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          createMany: {
            args: Prisma.reverse_indexCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reverse_indexCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>[]
          }
          delete: {
            args: Prisma.reverse_indexDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          update: {
            args: Prisma.reverse_indexUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          deleteMany: {
            args: Prisma.reverse_indexDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reverse_indexUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reverse_indexUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>[]
          }
          upsert: {
            args: Prisma.reverse_indexUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reverse_indexPayload>
          }
          aggregate: {
            args: Prisma.Reverse_indexAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReverse_index>
          }
          groupBy: {
            args: Prisma.reverse_indexGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reverse_indexGroupByOutputType>[]
          }
          count: {
            args: Prisma.reverse_indexCountArgs<ExtArgs>
            result: $Utils.Optional<Reverse_indexCountAggregateOutputType> | number
          }
        }
      }
      reward: {
        payload: Prisma.$rewardPayload<ExtArgs>
        fields: Prisma.rewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          findFirst: {
            args: Prisma.rewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          findMany: {
            args: Prisma.rewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          create: {
            args: Prisma.rewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          createMany: {
            args: Prisma.rewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          delete: {
            args: Prisma.rewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          update: {
            args: Prisma.rewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          deleteMany: {
            args: Prisma.rewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          upsert: {
            args: Prisma.rewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.rewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.rewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      schema_version: {
        payload: Prisma.$schema_versionPayload<ExtArgs>
        fields: Prisma.schema_versionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schema_versionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schema_versionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          findFirst: {
            args: Prisma.schema_versionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schema_versionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          findMany: {
            args: Prisma.schema_versionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>[]
          }
          create: {
            args: Prisma.schema_versionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          createMany: {
            args: Prisma.schema_versionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schema_versionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>[]
          }
          delete: {
            args: Prisma.schema_versionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          update: {
            args: Prisma.schema_versionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          deleteMany: {
            args: Prisma.schema_versionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schema_versionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.schema_versionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>[]
          }
          upsert: {
            args: Prisma.schema_versionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_versionPayload>
          }
          aggregate: {
            args: Prisma.Schema_versionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchema_version>
          }
          groupBy: {
            args: Prisma.schema_versionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Schema_versionGroupByOutputType>[]
          }
          count: {
            args: Prisma.schema_versionCountArgs<ExtArgs>
            result: $Utils.Optional<Schema_versionCountAggregateOutputType> | number
          }
        }
      }
      script: {
        payload: Prisma.$scriptPayload<ExtArgs>
        fields: Prisma.scriptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scriptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scriptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          findFirst: {
            args: Prisma.scriptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scriptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          findMany: {
            args: Prisma.scriptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>[]
          }
          create: {
            args: Prisma.scriptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          createMany: {
            args: Prisma.scriptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.scriptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>[]
          }
          delete: {
            args: Prisma.scriptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          update: {
            args: Prisma.scriptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          deleteMany: {
            args: Prisma.scriptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.scriptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.scriptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>[]
          }
          upsert: {
            args: Prisma.scriptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scriptPayload>
          }
          aggregate: {
            args: Prisma.ScriptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScript>
          }
          groupBy: {
            args: Prisma.scriptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScriptGroupByOutputType>[]
          }
          count: {
            args: Prisma.scriptCountArgs<ExtArgs>
            result: $Utils.Optional<ScriptCountAggregateOutputType> | number
          }
        }
      }
      slot_leader: {
        payload: Prisma.$slot_leaderPayload<ExtArgs>
        fields: Prisma.slot_leaderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.slot_leaderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.slot_leaderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          findFirst: {
            args: Prisma.slot_leaderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.slot_leaderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          findMany: {
            args: Prisma.slot_leaderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>[]
          }
          create: {
            args: Prisma.slot_leaderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          createMany: {
            args: Prisma.slot_leaderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.slot_leaderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>[]
          }
          delete: {
            args: Prisma.slot_leaderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          update: {
            args: Prisma.slot_leaderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          deleteMany: {
            args: Prisma.slot_leaderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.slot_leaderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.slot_leaderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>[]
          }
          upsert: {
            args: Prisma.slot_leaderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$slot_leaderPayload>
          }
          aggregate: {
            args: Prisma.Slot_leaderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlot_leader>
          }
          groupBy: {
            args: Prisma.slot_leaderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Slot_leaderGroupByOutputType>[]
          }
          count: {
            args: Prisma.slot_leaderCountArgs<ExtArgs>
            result: $Utils.Optional<Slot_leaderCountAggregateOutputType> | number
          }
        }
      }
      stake_address: {
        payload: Prisma.$stake_addressPayload<ExtArgs>
        fields: Prisma.stake_addressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stake_addressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stake_addressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          findFirst: {
            args: Prisma.stake_addressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stake_addressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          findMany: {
            args: Prisma.stake_addressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>[]
          }
          create: {
            args: Prisma.stake_addressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          createMany: {
            args: Prisma.stake_addressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stake_addressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>[]
          }
          delete: {
            args: Prisma.stake_addressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          update: {
            args: Prisma.stake_addressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          deleteMany: {
            args: Prisma.stake_addressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stake_addressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stake_addressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>[]
          }
          upsert: {
            args: Prisma.stake_addressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_addressPayload>
          }
          aggregate: {
            args: Prisma.Stake_addressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStake_address>
          }
          groupBy: {
            args: Prisma.stake_addressGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stake_addressGroupByOutputType>[]
          }
          count: {
            args: Prisma.stake_addressCountArgs<ExtArgs>
            result: $Utils.Optional<Stake_addressCountAggregateOutputType> | number
          }
        }
      }
      stake_deregistration: {
        payload: Prisma.$stake_deregistrationPayload<ExtArgs>
        fields: Prisma.stake_deregistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stake_deregistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stake_deregistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          findFirst: {
            args: Prisma.stake_deregistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stake_deregistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          findMany: {
            args: Prisma.stake_deregistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>[]
          }
          create: {
            args: Prisma.stake_deregistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          createMany: {
            args: Prisma.stake_deregistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stake_deregistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>[]
          }
          delete: {
            args: Prisma.stake_deregistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          update: {
            args: Prisma.stake_deregistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          deleteMany: {
            args: Prisma.stake_deregistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stake_deregistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stake_deregistrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>[]
          }
          upsert: {
            args: Prisma.stake_deregistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_deregistrationPayload>
          }
          aggregate: {
            args: Prisma.Stake_deregistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStake_deregistration>
          }
          groupBy: {
            args: Prisma.stake_deregistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stake_deregistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.stake_deregistrationCountArgs<ExtArgs>
            result: $Utils.Optional<Stake_deregistrationCountAggregateOutputType> | number
          }
        }
      }
      stake_registration: {
        payload: Prisma.$stake_registrationPayload<ExtArgs>
        fields: Prisma.stake_registrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stake_registrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stake_registrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          findFirst: {
            args: Prisma.stake_registrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stake_registrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          findMany: {
            args: Prisma.stake_registrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>[]
          }
          create: {
            args: Prisma.stake_registrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          createMany: {
            args: Prisma.stake_registrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stake_registrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>[]
          }
          delete: {
            args: Prisma.stake_registrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          update: {
            args: Prisma.stake_registrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          deleteMany: {
            args: Prisma.stake_registrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stake_registrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stake_registrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>[]
          }
          upsert: {
            args: Prisma.stake_registrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stake_registrationPayload>
          }
          aggregate: {
            args: Prisma.Stake_registrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStake_registration>
          }
          groupBy: {
            args: Prisma.stake_registrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stake_registrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.stake_registrationCountArgs<ExtArgs>
            result: $Utils.Optional<Stake_registrationCountAggregateOutputType> | number
          }
        }
      }
      treasury: {
        payload: Prisma.$treasuryPayload<ExtArgs>
        fields: Prisma.treasuryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.treasuryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.treasuryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          findFirst: {
            args: Prisma.treasuryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.treasuryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          findMany: {
            args: Prisma.treasuryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>[]
          }
          create: {
            args: Prisma.treasuryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          createMany: {
            args: Prisma.treasuryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.treasuryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>[]
          }
          delete: {
            args: Prisma.treasuryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          update: {
            args: Prisma.treasuryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          deleteMany: {
            args: Prisma.treasuryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.treasuryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.treasuryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>[]
          }
          upsert: {
            args: Prisma.treasuryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasuryPayload>
          }
          aggregate: {
            args: Prisma.TreasuryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreasury>
          }
          groupBy: {
            args: Prisma.treasuryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreasuryGroupByOutputType>[]
          }
          count: {
            args: Prisma.treasuryCountArgs<ExtArgs>
            result: $Utils.Optional<TreasuryCountAggregateOutputType> | number
          }
        }
      }
      treasury_withdrawal: {
        payload: Prisma.$treasury_withdrawalPayload<ExtArgs>
        fields: Prisma.treasury_withdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.treasury_withdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.treasury_withdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          findFirst: {
            args: Prisma.treasury_withdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.treasury_withdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          findMany: {
            args: Prisma.treasury_withdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>[]
          }
          create: {
            args: Prisma.treasury_withdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          createMany: {
            args: Prisma.treasury_withdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.treasury_withdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>[]
          }
          delete: {
            args: Prisma.treasury_withdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          update: {
            args: Prisma.treasury_withdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          deleteMany: {
            args: Prisma.treasury_withdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.treasury_withdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.treasury_withdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>[]
          }
          upsert: {
            args: Prisma.treasury_withdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasury_withdrawalPayload>
          }
          aggregate: {
            args: Prisma.Treasury_withdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreasury_withdrawal>
          }
          groupBy: {
            args: Prisma.treasury_withdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<Treasury_withdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.treasury_withdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<Treasury_withdrawalCountAggregateOutputType> | number
          }
        }
      }
      tx: {
        payload: Prisma.$txPayload<ExtArgs>
        fields: Prisma.txFieldRefs
        operations: {
          findUnique: {
            args: Prisma.txFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.txFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          findFirst: {
            args: Prisma.txFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.txFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          findMany: {
            args: Prisma.txFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>[]
          }
          create: {
            args: Prisma.txCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          createMany: {
            args: Prisma.txCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.txCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>[]
          }
          delete: {
            args: Prisma.txDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          update: {
            args: Prisma.txUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          deleteMany: {
            args: Prisma.txDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.txUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.txUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>[]
          }
          upsert: {
            args: Prisma.txUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$txPayload>
          }
          aggregate: {
            args: Prisma.TxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTx>
          }
          groupBy: {
            args: Prisma.txGroupByArgs<ExtArgs>
            result: $Utils.Optional<TxGroupByOutputType>[]
          }
          count: {
            args: Prisma.txCountArgs<ExtArgs>
            result: $Utils.Optional<TxCountAggregateOutputType> | number
          }
        }
      }
      tx_cbor: {
        payload: Prisma.$tx_cborPayload<ExtArgs>
        fields: Prisma.tx_cborFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tx_cborFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tx_cborFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          findFirst: {
            args: Prisma.tx_cborFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tx_cborFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          findMany: {
            args: Prisma.tx_cborFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>[]
          }
          create: {
            args: Prisma.tx_cborCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          createMany: {
            args: Prisma.tx_cborCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tx_cborCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>[]
          }
          delete: {
            args: Prisma.tx_cborDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          update: {
            args: Prisma.tx_cborUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          deleteMany: {
            args: Prisma.tx_cborDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tx_cborUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tx_cborUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>[]
          }
          upsert: {
            args: Prisma.tx_cborUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_cborPayload>
          }
          aggregate: {
            args: Prisma.Tx_cborAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTx_cbor>
          }
          groupBy: {
            args: Prisma.tx_cborGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tx_cborGroupByOutputType>[]
          }
          count: {
            args: Prisma.tx_cborCountArgs<ExtArgs>
            result: $Utils.Optional<Tx_cborCountAggregateOutputType> | number
          }
        }
      }
      tx_in: {
        payload: Prisma.$tx_inPayload<ExtArgs>
        fields: Prisma.tx_inFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tx_inFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tx_inFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          findFirst: {
            args: Prisma.tx_inFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tx_inFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          findMany: {
            args: Prisma.tx_inFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>[]
          }
          create: {
            args: Prisma.tx_inCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          createMany: {
            args: Prisma.tx_inCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tx_inCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>[]
          }
          delete: {
            args: Prisma.tx_inDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          update: {
            args: Prisma.tx_inUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          deleteMany: {
            args: Prisma.tx_inDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tx_inUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tx_inUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>[]
          }
          upsert: {
            args: Prisma.tx_inUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_inPayload>
          }
          aggregate: {
            args: Prisma.Tx_inAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTx_in>
          }
          groupBy: {
            args: Prisma.tx_inGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tx_inGroupByOutputType>[]
          }
          count: {
            args: Prisma.tx_inCountArgs<ExtArgs>
            result: $Utils.Optional<Tx_inCountAggregateOutputType> | number
          }
        }
      }
      tx_metadata: {
        payload: Prisma.$tx_metadataPayload<ExtArgs>
        fields: Prisma.tx_metadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tx_metadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tx_metadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          findFirst: {
            args: Prisma.tx_metadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tx_metadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          findMany: {
            args: Prisma.tx_metadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>[]
          }
          create: {
            args: Prisma.tx_metadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          createMany: {
            args: Prisma.tx_metadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tx_metadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>[]
          }
          delete: {
            args: Prisma.tx_metadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          update: {
            args: Prisma.tx_metadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          deleteMany: {
            args: Prisma.tx_metadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tx_metadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tx_metadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>[]
          }
          upsert: {
            args: Prisma.tx_metadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_metadataPayload>
          }
          aggregate: {
            args: Prisma.Tx_metadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTx_metadata>
          }
          groupBy: {
            args: Prisma.tx_metadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tx_metadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.tx_metadataCountArgs<ExtArgs>
            result: $Utils.Optional<Tx_metadataCountAggregateOutputType> | number
          }
        }
      }
      tx_out: {
        payload: Prisma.$tx_outPayload<ExtArgs>
        fields: Prisma.tx_outFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tx_outFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tx_outFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          findFirst: {
            args: Prisma.tx_outFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tx_outFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          findMany: {
            args: Prisma.tx_outFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>[]
          }
          create: {
            args: Prisma.tx_outCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          createMany: {
            args: Prisma.tx_outCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tx_outCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>[]
          }
          delete: {
            args: Prisma.tx_outDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          update: {
            args: Prisma.tx_outUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          deleteMany: {
            args: Prisma.tx_outDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tx_outUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tx_outUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>[]
          }
          upsert: {
            args: Prisma.tx_outUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tx_outPayload>
          }
          aggregate: {
            args: Prisma.Tx_outAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTx_out>
          }
          groupBy: {
            args: Prisma.tx_outGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tx_outGroupByOutputType>[]
          }
          count: {
            args: Prisma.tx_outCountArgs<ExtArgs>
            result: $Utils.Optional<Tx_outCountAggregateOutputType> | number
          }
        }
      }
      voting_anchor: {
        payload: Prisma.$voting_anchorPayload<ExtArgs>
        fields: Prisma.voting_anchorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.voting_anchorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.voting_anchorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          findFirst: {
            args: Prisma.voting_anchorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.voting_anchorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          findMany: {
            args: Prisma.voting_anchorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>[]
          }
          create: {
            args: Prisma.voting_anchorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          createMany: {
            args: Prisma.voting_anchorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.voting_anchorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>[]
          }
          delete: {
            args: Prisma.voting_anchorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          update: {
            args: Prisma.voting_anchorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          deleteMany: {
            args: Prisma.voting_anchorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.voting_anchorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.voting_anchorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>[]
          }
          upsert: {
            args: Prisma.voting_anchorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_anchorPayload>
          }
          aggregate: {
            args: Prisma.Voting_anchorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoting_anchor>
          }
          groupBy: {
            args: Prisma.voting_anchorGroupByArgs<ExtArgs>
            result: $Utils.Optional<Voting_anchorGroupByOutputType>[]
          }
          count: {
            args: Prisma.voting_anchorCountArgs<ExtArgs>
            result: $Utils.Optional<Voting_anchorCountAggregateOutputType> | number
          }
        }
      }
      voting_procedure: {
        payload: Prisma.$voting_procedurePayload<ExtArgs>
        fields: Prisma.voting_procedureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.voting_procedureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.voting_procedureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          findFirst: {
            args: Prisma.voting_procedureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.voting_procedureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          findMany: {
            args: Prisma.voting_procedureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>[]
          }
          create: {
            args: Prisma.voting_procedureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          createMany: {
            args: Prisma.voting_procedureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.voting_procedureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>[]
          }
          delete: {
            args: Prisma.voting_procedureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          update: {
            args: Prisma.voting_procedureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          deleteMany: {
            args: Prisma.voting_procedureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.voting_procedureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.voting_procedureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>[]
          }
          upsert: {
            args: Prisma.voting_procedureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$voting_procedurePayload>
          }
          aggregate: {
            args: Prisma.Voting_procedureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoting_procedure>
          }
          groupBy: {
            args: Prisma.voting_procedureGroupByArgs<ExtArgs>
            result: $Utils.Optional<Voting_procedureGroupByOutputType>[]
          }
          count: {
            args: Prisma.voting_procedureCountArgs<ExtArgs>
            result: $Utils.Optional<Voting_procedureCountAggregateOutputType> | number
          }
        }
      }
      withdrawal: {
        payload: Prisma.$withdrawalPayload<ExtArgs>
        fields: Prisma.withdrawalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.withdrawalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.withdrawalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          findFirst: {
            args: Prisma.withdrawalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.withdrawalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          findMany: {
            args: Prisma.withdrawalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          create: {
            args: Prisma.withdrawalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          createMany: {
            args: Prisma.withdrawalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.withdrawalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          delete: {
            args: Prisma.withdrawalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          update: {
            args: Prisma.withdrawalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          deleteMany: {
            args: Prisma.withdrawalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.withdrawalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.withdrawalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>[]
          }
          upsert: {
            args: Prisma.withdrawalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$withdrawalPayload>
          }
          aggregate: {
            args: Prisma.WithdrawalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWithdrawal>
          }
          groupBy: {
            args: Prisma.withdrawalGroupByArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalGroupByOutputType>[]
          }
          count: {
            args: Prisma.withdrawalCountArgs<ExtArgs>
            result: $Utils.Optional<WithdrawalCountAggregateOutputType> | number
          }
        }
      }
      sqlx_migrations: {
        payload: Prisma.$sqlx_migrationsPayload<ExtArgs>
        fields: Prisma.sqlx_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sqlx_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sqlx_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          findFirst: {
            args: Prisma.sqlx_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sqlx_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          findMany: {
            args: Prisma.sqlx_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>[]
          }
          create: {
            args: Prisma.sqlx_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          createMany: {
            args: Prisma.sqlx_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sqlx_migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>[]
          }
          delete: {
            args: Prisma.sqlx_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          update: {
            args: Prisma.sqlx_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.sqlx_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sqlx_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sqlx_migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>[]
          }
          upsert: {
            args: Prisma.sqlx_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sqlx_migrationsPayload>
          }
          aggregate: {
            args: Prisma.Sqlx_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSqlx_migrations>
          }
          groupBy: {
            args: Prisma.sqlx_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sqlx_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sqlx_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Sqlx_migrationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRawTyped: {
          args: runtime.UnknownTypedSql,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ada_pots?: ada_potsOmit
    block?: blockOmit
    collateral_tx_in?: collateral_tx_inOmit
    collateral_tx_out?: collateral_tx_outOmit
    committee?: committeeOmit
    committee_de_registration?: committee_de_registrationOmit
    committee_hash?: committee_hashOmit
    committee_member?: committee_memberOmit
    committee_registration?: committee_registrationOmit
    constitution?: constitutionOmit
    cost_model?: cost_modelOmit
    datum?: datumOmit
    delegation?: delegationOmit
    delegation_vote?: delegation_voteOmit
    delisted_pool?: delisted_poolOmit
    drep_distr?: drep_distrOmit
    drep_hash?: drep_hashOmit
    drep_registration?: drep_registrationOmit
    epoch?: epochOmit
    epoch_param?: epoch_paramOmit
    epoch_stake?: epoch_stakeOmit
    epoch_stake_progress?: epoch_stake_progressOmit
    epoch_state?: epoch_stateOmit
    epoch_sync_time?: epoch_sync_timeOmit
    event_info?: event_infoOmit
    extra_key_witness?: extra_key_witnessOmit
    extra_migrations?: extra_migrationsOmit
    gov_action_proposal?: gov_action_proposalOmit
    ma_tx_mint?: ma_tx_mintOmit
    ma_tx_out?: ma_tx_outOmit
    meta?: metaOmit
    multi_asset?: multi_assetOmit
    new_committee?: new_committeeOmit
    off_chain_pool_data?: off_chain_pool_dataOmit
    off_chain_pool_fetch_error?: off_chain_pool_fetch_errorOmit
    off_chain_vote_author?: off_chain_vote_authorOmit
    off_chain_vote_data?: off_chain_vote_dataOmit
    off_chain_vote_drep_data?: off_chain_vote_drep_dataOmit
    off_chain_vote_external_update?: off_chain_vote_external_updateOmit
    off_chain_vote_fetch_error?: off_chain_vote_fetch_errorOmit
    off_chain_vote_gov_action_data?: off_chain_vote_gov_action_dataOmit
    off_chain_vote_reference?: off_chain_vote_referenceOmit
    param_proposal?: param_proposalOmit
    pool_hash?: pool_hashOmit
    pool_metadata_ref?: pool_metadata_refOmit
    pool_owner?: pool_ownerOmit
    pool_relay?: pool_relayOmit
    pool_retire?: pool_retireOmit
    pool_stat?: pool_statOmit
    pool_update?: pool_updateOmit
    pot_transfer?: pot_transferOmit
    redeemer?: redeemerOmit
    redeemer_data?: redeemer_dataOmit
    reference_tx_in?: reference_tx_inOmit
    reserve?: reserveOmit
    reserved_pool_ticker?: reserved_pool_tickerOmit
    reverse_index?: reverse_indexOmit
    reward?: rewardOmit
    schema_version?: schema_versionOmit
    script?: scriptOmit
    slot_leader?: slot_leaderOmit
    stake_address?: stake_addressOmit
    stake_deregistration?: stake_deregistrationOmit
    stake_registration?: stake_registrationOmit
    treasury?: treasuryOmit
    treasury_withdrawal?: treasury_withdrawalOmit
    tx?: txOmit
    tx_cbor?: tx_cborOmit
    tx_in?: tx_inOmit
    tx_metadata?: tx_metadataOmit
    tx_out?: tx_outOmit
    voting_anchor?: voting_anchorOmit
    voting_procedure?: voting_procedureOmit
    withdrawal?: withdrawalOmit
    sqlx_migrations?: sqlx_migrationsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CommitteeCountOutputType
   */

  export type CommitteeCountOutputType = {
    committee_member: number
  }

  export type CommitteeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    committee_member?: boolean | CommitteeCountOutputTypeCountCommittee_memberArgs
  }

  // Custom InputTypes
  /**
   * CommitteeCountOutputType without action
   */
  export type CommitteeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommitteeCountOutputType
     */
    select?: CommitteeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommitteeCountOutputType without action
   */
  export type CommitteeCountOutputTypeCountCommittee_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committee_memberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ada_pots
   */

  export type AggregateAda_pots = {
    _count: Ada_potsCountAggregateOutputType | null
    _avg: Ada_potsAvgAggregateOutputType | null
    _sum: Ada_potsSumAggregateOutputType | null
    _min: Ada_potsMinAggregateOutputType | null
    _max: Ada_potsMaxAggregateOutputType | null
  }

  export type Ada_potsAvgAggregateOutputType = {
    id: number | null
    slot_no: number | null
    epoch_no: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    rewards: Decimal | null
    utxo: Decimal | null
    deposits_stake: Decimal | null
    fees: Decimal | null
    block_id: number | null
    deposits_drep: Decimal | null
    deposits_proposal: Decimal | null
  }

  export type Ada_potsSumAggregateOutputType = {
    id: bigint | null
    slot_no: bigint | null
    epoch_no: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    rewards: Decimal | null
    utxo: Decimal | null
    deposits_stake: Decimal | null
    fees: Decimal | null
    block_id: bigint | null
    deposits_drep: Decimal | null
    deposits_proposal: Decimal | null
  }

  export type Ada_potsMinAggregateOutputType = {
    id: bigint | null
    slot_no: bigint | null
    epoch_no: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    rewards: Decimal | null
    utxo: Decimal | null
    deposits_stake: Decimal | null
    fees: Decimal | null
    block_id: bigint | null
    deposits_drep: Decimal | null
    deposits_proposal: Decimal | null
  }

  export type Ada_potsMaxAggregateOutputType = {
    id: bigint | null
    slot_no: bigint | null
    epoch_no: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    rewards: Decimal | null
    utxo: Decimal | null
    deposits_stake: Decimal | null
    fees: Decimal | null
    block_id: bigint | null
    deposits_drep: Decimal | null
    deposits_proposal: Decimal | null
  }

  export type Ada_potsCountAggregateOutputType = {
    id: number
    slot_no: number
    epoch_no: number
    treasury: number
    reserves: number
    rewards: number
    utxo: number
    deposits_stake: number
    fees: number
    block_id: number
    deposits_drep: number
    deposits_proposal: number
    _all: number
  }


  export type Ada_potsAvgAggregateInputType = {
    id?: true
    slot_no?: true
    epoch_no?: true
    treasury?: true
    reserves?: true
    rewards?: true
    utxo?: true
    deposits_stake?: true
    fees?: true
    block_id?: true
    deposits_drep?: true
    deposits_proposal?: true
  }

  export type Ada_potsSumAggregateInputType = {
    id?: true
    slot_no?: true
    epoch_no?: true
    treasury?: true
    reserves?: true
    rewards?: true
    utxo?: true
    deposits_stake?: true
    fees?: true
    block_id?: true
    deposits_drep?: true
    deposits_proposal?: true
  }

  export type Ada_potsMinAggregateInputType = {
    id?: true
    slot_no?: true
    epoch_no?: true
    treasury?: true
    reserves?: true
    rewards?: true
    utxo?: true
    deposits_stake?: true
    fees?: true
    block_id?: true
    deposits_drep?: true
    deposits_proposal?: true
  }

  export type Ada_potsMaxAggregateInputType = {
    id?: true
    slot_no?: true
    epoch_no?: true
    treasury?: true
    reserves?: true
    rewards?: true
    utxo?: true
    deposits_stake?: true
    fees?: true
    block_id?: true
    deposits_drep?: true
    deposits_proposal?: true
  }

  export type Ada_potsCountAggregateInputType = {
    id?: true
    slot_no?: true
    epoch_no?: true
    treasury?: true
    reserves?: true
    rewards?: true
    utxo?: true
    deposits_stake?: true
    fees?: true
    block_id?: true
    deposits_drep?: true
    deposits_proposal?: true
    _all?: true
  }

  export type Ada_potsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ada_pots to aggregate.
     */
    where?: ada_potsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ada_pots to fetch.
     */
    orderBy?: ada_potsOrderByWithRelationInput | ada_potsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ada_potsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ada_pots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ada_pots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ada_pots
    **/
    _count?: true | Ada_potsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ada_potsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ada_potsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ada_potsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ada_potsMaxAggregateInputType
  }

  export type GetAda_potsAggregateType<T extends Ada_potsAggregateArgs> = {
        [P in keyof T & keyof AggregateAda_pots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAda_pots[P]>
      : GetScalarType<T[P], AggregateAda_pots[P]>
  }




  export type ada_potsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ada_potsWhereInput
    orderBy?: ada_potsOrderByWithAggregationInput | ada_potsOrderByWithAggregationInput[]
    by: Ada_potsScalarFieldEnum[] | Ada_potsScalarFieldEnum
    having?: ada_potsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ada_potsCountAggregateInputType | true
    _avg?: Ada_potsAvgAggregateInputType
    _sum?: Ada_potsSumAggregateInputType
    _min?: Ada_potsMinAggregateInputType
    _max?: Ada_potsMaxAggregateInputType
  }

  export type Ada_potsGroupByOutputType = {
    id: bigint
    slot_no: bigint
    epoch_no: number
    treasury: Decimal
    reserves: Decimal
    rewards: Decimal
    utxo: Decimal
    deposits_stake: Decimal
    fees: Decimal
    block_id: bigint
    deposits_drep: Decimal
    deposits_proposal: Decimal
    _count: Ada_potsCountAggregateOutputType | null
    _avg: Ada_potsAvgAggregateOutputType | null
    _sum: Ada_potsSumAggregateOutputType | null
    _min: Ada_potsMinAggregateOutputType | null
    _max: Ada_potsMaxAggregateOutputType | null
  }

  type GetAda_potsGroupByPayload<T extends ada_potsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ada_potsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ada_potsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ada_potsGroupByOutputType[P]>
            : GetScalarType<T[P], Ada_potsGroupByOutputType[P]>
        }
      >
    >


  export type ada_potsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_no?: boolean
    epoch_no?: boolean
    treasury?: boolean
    reserves?: boolean
    rewards?: boolean
    utxo?: boolean
    deposits_stake?: boolean
    fees?: boolean
    block_id?: boolean
    deposits_drep?: boolean
    deposits_proposal?: boolean
  }, ExtArgs["result"]["ada_pots"]>

  export type ada_potsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_no?: boolean
    epoch_no?: boolean
    treasury?: boolean
    reserves?: boolean
    rewards?: boolean
    utxo?: boolean
    deposits_stake?: boolean
    fees?: boolean
    block_id?: boolean
    deposits_drep?: boolean
    deposits_proposal?: boolean
  }, ExtArgs["result"]["ada_pots"]>

  export type ada_potsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slot_no?: boolean
    epoch_no?: boolean
    treasury?: boolean
    reserves?: boolean
    rewards?: boolean
    utxo?: boolean
    deposits_stake?: boolean
    fees?: boolean
    block_id?: boolean
    deposits_drep?: boolean
    deposits_proposal?: boolean
  }, ExtArgs["result"]["ada_pots"]>

  export type ada_potsSelectScalar = {
    id?: boolean
    slot_no?: boolean
    epoch_no?: boolean
    treasury?: boolean
    reserves?: boolean
    rewards?: boolean
    utxo?: boolean
    deposits_stake?: boolean
    fees?: boolean
    block_id?: boolean
    deposits_drep?: boolean
    deposits_proposal?: boolean
  }

  export type ada_potsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slot_no" | "epoch_no" | "treasury" | "reserves" | "rewards" | "utxo" | "deposits_stake" | "fees" | "block_id" | "deposits_drep" | "deposits_proposal", ExtArgs["result"]["ada_pots"]>

  export type $ada_potsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ada_pots"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      slot_no: bigint
      epoch_no: number
      treasury: Prisma.Decimal
      reserves: Prisma.Decimal
      rewards: Prisma.Decimal
      utxo: Prisma.Decimal
      deposits_stake: Prisma.Decimal
      fees: Prisma.Decimal
      block_id: bigint
      deposits_drep: Prisma.Decimal
      deposits_proposal: Prisma.Decimal
    }, ExtArgs["result"]["ada_pots"]>
    composites: {}
  }

  type ada_potsGetPayload<S extends boolean | null | undefined | ada_potsDefaultArgs> = $Result.GetResult<Prisma.$ada_potsPayload, S>

  type ada_potsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ada_potsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ada_potsCountAggregateInputType | true
    }

  export interface ada_potsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ada_pots'], meta: { name: 'ada_pots' } }
    /**
     * Find zero or one Ada_pots that matches the filter.
     * @param {ada_potsFindUniqueArgs} args - Arguments to find a Ada_pots
     * @example
     * // Get one Ada_pots
     * const ada_pots = await prisma.ada_pots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ada_potsFindUniqueArgs>(args: SelectSubset<T, ada_potsFindUniqueArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ada_pots that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ada_potsFindUniqueOrThrowArgs} args - Arguments to find a Ada_pots
     * @example
     * // Get one Ada_pots
     * const ada_pots = await prisma.ada_pots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ada_potsFindUniqueOrThrowArgs>(args: SelectSubset<T, ada_potsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ada_pots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsFindFirstArgs} args - Arguments to find a Ada_pots
     * @example
     * // Get one Ada_pots
     * const ada_pots = await prisma.ada_pots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ada_potsFindFirstArgs>(args?: SelectSubset<T, ada_potsFindFirstArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ada_pots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsFindFirstOrThrowArgs} args - Arguments to find a Ada_pots
     * @example
     * // Get one Ada_pots
     * const ada_pots = await prisma.ada_pots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ada_potsFindFirstOrThrowArgs>(args?: SelectSubset<T, ada_potsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ada_pots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ada_pots
     * const ada_pots = await prisma.ada_pots.findMany()
     * 
     * // Get first 10 Ada_pots
     * const ada_pots = await prisma.ada_pots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ada_potsWithIdOnly = await prisma.ada_pots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ada_potsFindManyArgs>(args?: SelectSubset<T, ada_potsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ada_pots.
     * @param {ada_potsCreateArgs} args - Arguments to create a Ada_pots.
     * @example
     * // Create one Ada_pots
     * const Ada_pots = await prisma.ada_pots.create({
     *   data: {
     *     // ... data to create a Ada_pots
     *   }
     * })
     * 
     */
    create<T extends ada_potsCreateArgs>(args: SelectSubset<T, ada_potsCreateArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ada_pots.
     * @param {ada_potsCreateManyArgs} args - Arguments to create many Ada_pots.
     * @example
     * // Create many Ada_pots
     * const ada_pots = await prisma.ada_pots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ada_potsCreateManyArgs>(args?: SelectSubset<T, ada_potsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ada_pots and returns the data saved in the database.
     * @param {ada_potsCreateManyAndReturnArgs} args - Arguments to create many Ada_pots.
     * @example
     * // Create many Ada_pots
     * const ada_pots = await prisma.ada_pots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ada_pots and only return the `id`
     * const ada_potsWithIdOnly = await prisma.ada_pots.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ada_potsCreateManyAndReturnArgs>(args?: SelectSubset<T, ada_potsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ada_pots.
     * @param {ada_potsDeleteArgs} args - Arguments to delete one Ada_pots.
     * @example
     * // Delete one Ada_pots
     * const Ada_pots = await prisma.ada_pots.delete({
     *   where: {
     *     // ... filter to delete one Ada_pots
     *   }
     * })
     * 
     */
    delete<T extends ada_potsDeleteArgs>(args: SelectSubset<T, ada_potsDeleteArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ada_pots.
     * @param {ada_potsUpdateArgs} args - Arguments to update one Ada_pots.
     * @example
     * // Update one Ada_pots
     * const ada_pots = await prisma.ada_pots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ada_potsUpdateArgs>(args: SelectSubset<T, ada_potsUpdateArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ada_pots.
     * @param {ada_potsDeleteManyArgs} args - Arguments to filter Ada_pots to delete.
     * @example
     * // Delete a few Ada_pots
     * const { count } = await prisma.ada_pots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ada_potsDeleteManyArgs>(args?: SelectSubset<T, ada_potsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ada_pots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ada_pots
     * const ada_pots = await prisma.ada_pots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ada_potsUpdateManyArgs>(args: SelectSubset<T, ada_potsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ada_pots and returns the data updated in the database.
     * @param {ada_potsUpdateManyAndReturnArgs} args - Arguments to update many Ada_pots.
     * @example
     * // Update many Ada_pots
     * const ada_pots = await prisma.ada_pots.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ada_pots and only return the `id`
     * const ada_potsWithIdOnly = await prisma.ada_pots.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ada_potsUpdateManyAndReturnArgs>(args: SelectSubset<T, ada_potsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ada_pots.
     * @param {ada_potsUpsertArgs} args - Arguments to update or create a Ada_pots.
     * @example
     * // Update or create a Ada_pots
     * const ada_pots = await prisma.ada_pots.upsert({
     *   create: {
     *     // ... data to create a Ada_pots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ada_pots we want to update
     *   }
     * })
     */
    upsert<T extends ada_potsUpsertArgs>(args: SelectSubset<T, ada_potsUpsertArgs<ExtArgs>>): Prisma__ada_potsClient<$Result.GetResult<Prisma.$ada_potsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ada_pots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsCountArgs} args - Arguments to filter Ada_pots to count.
     * @example
     * // Count the number of Ada_pots
     * const count = await prisma.ada_pots.count({
     *   where: {
     *     // ... the filter for the Ada_pots we want to count
     *   }
     * })
    **/
    count<T extends ada_potsCountArgs>(
      args?: Subset<T, ada_potsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ada_potsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ada_pots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ada_potsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ada_potsAggregateArgs>(args: Subset<T, Ada_potsAggregateArgs>): Prisma.PrismaPromise<GetAda_potsAggregateType<T>>

    /**
     * Group by Ada_pots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ada_potsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ada_potsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ada_potsGroupByArgs['orderBy'] }
        : { orderBy?: ada_potsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ada_potsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAda_potsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ada_pots model
   */
  readonly fields: ada_potsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ada_pots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ada_potsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ada_pots model
   */ 
  interface ada_potsFieldRefs {
    readonly id: FieldRef<"ada_pots", 'BigInt'>
    readonly slot_no: FieldRef<"ada_pots", 'BigInt'>
    readonly epoch_no: FieldRef<"ada_pots", 'Int'>
    readonly treasury: FieldRef<"ada_pots", 'Decimal'>
    readonly reserves: FieldRef<"ada_pots", 'Decimal'>
    readonly rewards: FieldRef<"ada_pots", 'Decimal'>
    readonly utxo: FieldRef<"ada_pots", 'Decimal'>
    readonly deposits_stake: FieldRef<"ada_pots", 'Decimal'>
    readonly fees: FieldRef<"ada_pots", 'Decimal'>
    readonly block_id: FieldRef<"ada_pots", 'BigInt'>
    readonly deposits_drep: FieldRef<"ada_pots", 'Decimal'>
    readonly deposits_proposal: FieldRef<"ada_pots", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ada_pots findUnique
   */
  export type ada_potsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter, which ada_pots to fetch.
     */
    where: ada_potsWhereUniqueInput
  }

  /**
   * ada_pots findUniqueOrThrow
   */
  export type ada_potsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter, which ada_pots to fetch.
     */
    where: ada_potsWhereUniqueInput
  }

  /**
   * ada_pots findFirst
   */
  export type ada_potsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter, which ada_pots to fetch.
     */
    where?: ada_potsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ada_pots to fetch.
     */
    orderBy?: ada_potsOrderByWithRelationInput | ada_potsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ada_pots.
     */
    cursor?: ada_potsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ada_pots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ada_pots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ada_pots.
     */
    distinct?: Ada_potsScalarFieldEnum | Ada_potsScalarFieldEnum[]
  }

  /**
   * ada_pots findFirstOrThrow
   */
  export type ada_potsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter, which ada_pots to fetch.
     */
    where?: ada_potsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ada_pots to fetch.
     */
    orderBy?: ada_potsOrderByWithRelationInput | ada_potsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ada_pots.
     */
    cursor?: ada_potsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ada_pots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ada_pots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ada_pots.
     */
    distinct?: Ada_potsScalarFieldEnum | Ada_potsScalarFieldEnum[]
  }

  /**
   * ada_pots findMany
   */
  export type ada_potsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter, which ada_pots to fetch.
     */
    where?: ada_potsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ada_pots to fetch.
     */
    orderBy?: ada_potsOrderByWithRelationInput | ada_potsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ada_pots.
     */
    cursor?: ada_potsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ada_pots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ada_pots.
     */
    skip?: number
    distinct?: Ada_potsScalarFieldEnum | Ada_potsScalarFieldEnum[]
  }

  /**
   * ada_pots create
   */
  export type ada_potsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * The data needed to create a ada_pots.
     */
    data: XOR<ada_potsCreateInput, ada_potsUncheckedCreateInput>
  }

  /**
   * ada_pots createMany
   */
  export type ada_potsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ada_pots.
     */
    data: ada_potsCreateManyInput | ada_potsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ada_pots createManyAndReturn
   */
  export type ada_potsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * The data used to create many ada_pots.
     */
    data: ada_potsCreateManyInput | ada_potsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ada_pots update
   */
  export type ada_potsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * The data needed to update a ada_pots.
     */
    data: XOR<ada_potsUpdateInput, ada_potsUncheckedUpdateInput>
    /**
     * Choose, which ada_pots to update.
     */
    where: ada_potsWhereUniqueInput
  }

  /**
   * ada_pots updateMany
   */
  export type ada_potsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ada_pots.
     */
    data: XOR<ada_potsUpdateManyMutationInput, ada_potsUncheckedUpdateManyInput>
    /**
     * Filter which ada_pots to update
     */
    where?: ada_potsWhereInput
    /**
     * Limit how many ada_pots to update.
     */
    limit?: number
  }

  /**
   * ada_pots updateManyAndReturn
   */
  export type ada_potsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * The data used to update ada_pots.
     */
    data: XOR<ada_potsUpdateManyMutationInput, ada_potsUncheckedUpdateManyInput>
    /**
     * Filter which ada_pots to update
     */
    where?: ada_potsWhereInput
    /**
     * Limit how many ada_pots to update.
     */
    limit?: number
  }

  /**
   * ada_pots upsert
   */
  export type ada_potsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * The filter to search for the ada_pots to update in case it exists.
     */
    where: ada_potsWhereUniqueInput
    /**
     * In case the ada_pots found by the `where` argument doesn't exist, create a new ada_pots with this data.
     */
    create: XOR<ada_potsCreateInput, ada_potsUncheckedCreateInput>
    /**
     * In case the ada_pots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ada_potsUpdateInput, ada_potsUncheckedUpdateInput>
  }

  /**
   * ada_pots delete
   */
  export type ada_potsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
    /**
     * Filter which ada_pots to delete.
     */
    where: ada_potsWhereUniqueInput
  }

  /**
   * ada_pots deleteMany
   */
  export type ada_potsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ada_pots to delete
     */
    where?: ada_potsWhereInput
    /**
     * Limit how many ada_pots to delete.
     */
    limit?: number
  }

  /**
   * ada_pots without action
   */
  export type ada_potsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ada_pots
     */
    select?: ada_potsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ada_pots
     */
    omit?: ada_potsOmit<ExtArgs> | null
  }


  /**
   * Model block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockAvgAggregateOutputType = {
    id: number | null
    epoch_no: number | null
    slot_no: number | null
    epoch_slot_no: number | null
    block_no: number | null
    previous_id: number | null
    slot_leader_id: number | null
    size: number | null
    tx_count: number | null
    proto_major: number | null
    proto_minor: number | null
    op_cert_counter: number | null
  }

  export type BlockSumAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    slot_no: bigint | null
    epoch_slot_no: number | null
    block_no: number | null
    previous_id: bigint | null
    slot_leader_id: bigint | null
    size: number | null
    tx_count: bigint | null
    proto_major: number | null
    proto_minor: number | null
    op_cert_counter: bigint | null
  }

  export type BlockMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    epoch_no: number | null
    slot_no: bigint | null
    epoch_slot_no: number | null
    block_no: number | null
    previous_id: bigint | null
    slot_leader_id: bigint | null
    size: number | null
    time: Date | null
    tx_count: bigint | null
    proto_major: number | null
    proto_minor: number | null
    vrf_key: string | null
    op_cert: Uint8Array | null
    op_cert_counter: bigint | null
  }

  export type BlockMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    epoch_no: number | null
    slot_no: bigint | null
    epoch_slot_no: number | null
    block_no: number | null
    previous_id: bigint | null
    slot_leader_id: bigint | null
    size: number | null
    time: Date | null
    tx_count: bigint | null
    proto_major: number | null
    proto_minor: number | null
    vrf_key: string | null
    op_cert: Uint8Array | null
    op_cert_counter: bigint | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    hash: number
    epoch_no: number
    slot_no: number
    epoch_slot_no: number
    block_no: number
    previous_id: number
    slot_leader_id: number
    size: number
    time: number
    tx_count: number
    proto_major: number
    proto_minor: number
    vrf_key: number
    op_cert: number
    op_cert_counter: number
    _all: number
  }


  export type BlockAvgAggregateInputType = {
    id?: true
    epoch_no?: true
    slot_no?: true
    epoch_slot_no?: true
    block_no?: true
    previous_id?: true
    slot_leader_id?: true
    size?: true
    tx_count?: true
    proto_major?: true
    proto_minor?: true
    op_cert_counter?: true
  }

  export type BlockSumAggregateInputType = {
    id?: true
    epoch_no?: true
    slot_no?: true
    epoch_slot_no?: true
    block_no?: true
    previous_id?: true
    slot_leader_id?: true
    size?: true
    tx_count?: true
    proto_major?: true
    proto_minor?: true
    op_cert_counter?: true
  }

  export type BlockMinAggregateInputType = {
    id?: true
    hash?: true
    epoch_no?: true
    slot_no?: true
    epoch_slot_no?: true
    block_no?: true
    previous_id?: true
    slot_leader_id?: true
    size?: true
    time?: true
    tx_count?: true
    proto_major?: true
    proto_minor?: true
    vrf_key?: true
    op_cert?: true
    op_cert_counter?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    hash?: true
    epoch_no?: true
    slot_no?: true
    epoch_slot_no?: true
    block_no?: true
    previous_id?: true
    slot_leader_id?: true
    size?: true
    time?: true
    tx_count?: true
    proto_major?: true
    proto_minor?: true
    vrf_key?: true
    op_cert?: true
    op_cert_counter?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    hash?: true
    epoch_no?: true
    slot_no?: true
    epoch_slot_no?: true
    block_no?: true
    previous_id?: true
    slot_leader_id?: true
    size?: true
    time?: true
    tx_count?: true
    proto_major?: true
    proto_minor?: true
    vrf_key?: true
    op_cert?: true
    op_cert_counter?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which block to aggregate.
     */
    where?: blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blockOrderByWithRelationInput | blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type blockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blockWhereInput
    orderBy?: blockOrderByWithAggregationInput | blockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: blockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _avg?: BlockAvgAggregateInputType
    _sum?: BlockSumAggregateInputType
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    epoch_no: number | null
    slot_no: bigint | null
    epoch_slot_no: number | null
    block_no: number | null
    previous_id: bigint | null
    slot_leader_id: bigint
    size: number
    time: Date
    tx_count: bigint
    proto_major: number
    proto_minor: number
    vrf_key: string | null
    op_cert: Uint8Array | null
    op_cert_counter: bigint | null
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends blockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type blockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    epoch_no?: boolean
    slot_no?: boolean
    epoch_slot_no?: boolean
    block_no?: boolean
    previous_id?: boolean
    slot_leader_id?: boolean
    size?: boolean
    time?: boolean
    tx_count?: boolean
    proto_major?: boolean
    proto_minor?: boolean
    vrf_key?: boolean
    op_cert?: boolean
    op_cert_counter?: boolean
  }, ExtArgs["result"]["block"]>

  export type blockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    epoch_no?: boolean
    slot_no?: boolean
    epoch_slot_no?: boolean
    block_no?: boolean
    previous_id?: boolean
    slot_leader_id?: boolean
    size?: boolean
    time?: boolean
    tx_count?: boolean
    proto_major?: boolean
    proto_minor?: boolean
    vrf_key?: boolean
    op_cert?: boolean
    op_cert_counter?: boolean
  }, ExtArgs["result"]["block"]>

  export type blockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    epoch_no?: boolean
    slot_no?: boolean
    epoch_slot_no?: boolean
    block_no?: boolean
    previous_id?: boolean
    slot_leader_id?: boolean
    size?: boolean
    time?: boolean
    tx_count?: boolean
    proto_major?: boolean
    proto_minor?: boolean
    vrf_key?: boolean
    op_cert?: boolean
    op_cert_counter?: boolean
  }, ExtArgs["result"]["block"]>

  export type blockSelectScalar = {
    id?: boolean
    hash?: boolean
    epoch_no?: boolean
    slot_no?: boolean
    epoch_slot_no?: boolean
    block_no?: boolean
    previous_id?: boolean
    slot_leader_id?: boolean
    size?: boolean
    time?: boolean
    tx_count?: boolean
    proto_major?: boolean
    proto_minor?: boolean
    vrf_key?: boolean
    op_cert?: boolean
    op_cert_counter?: boolean
  }

  export type blockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "epoch_no" | "slot_no" | "epoch_slot_no" | "block_no" | "previous_id" | "slot_leader_id" | "size" | "time" | "tx_count" | "proto_major" | "proto_minor" | "vrf_key" | "op_cert" | "op_cert_counter", ExtArgs["result"]["block"]>

  export type $blockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "block"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      epoch_no: number | null
      slot_no: bigint | null
      epoch_slot_no: number | null
      block_no: number | null
      previous_id: bigint | null
      slot_leader_id: bigint
      size: number
      time: Date
      tx_count: bigint
      proto_major: number
      proto_minor: number
      vrf_key: string | null
      op_cert: Uint8Array | null
      op_cert_counter: bigint | null
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type blockGetPayload<S extends boolean | null | undefined | blockDefaultArgs> = $Result.GetResult<Prisma.$blockPayload, S>

  type blockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface blockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['block'], meta: { name: 'block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {blockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blockFindUniqueArgs>(args: SelectSubset<T, blockFindUniqueArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blockFindUniqueOrThrowArgs>(args: SelectSubset<T, blockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blockFindFirstArgs>(args?: SelectSubset<T, blockFindFirstArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blockFindFirstOrThrowArgs>(args?: SelectSubset<T, blockFindFirstOrThrowArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blockFindManyArgs>(args?: SelectSubset<T, blockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Block.
     * @param {blockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends blockCreateArgs>(args: SelectSubset<T, blockCreateArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Blocks.
     * @param {blockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blockCreateManyArgs>(args?: SelectSubset<T, blockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {blockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blockCreateManyAndReturnArgs>(args?: SelectSubset<T, blockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Block.
     * @param {blockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends blockDeleteArgs>(args: SelectSubset<T, blockDeleteArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Block.
     * @param {blockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blockUpdateArgs>(args: SelectSubset<T, blockUpdateArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Blocks.
     * @param {blockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blockDeleteManyArgs>(args?: SelectSubset<T, blockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blockUpdateManyArgs>(args: SelectSubset<T, blockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {blockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blockUpdateManyAndReturnArgs>(args: SelectSubset<T, blockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Block.
     * @param {blockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends blockUpsertArgs>(args: SelectSubset<T, blockUpsertArgs<ExtArgs>>): Prisma__blockClient<$Result.GetResult<Prisma.$blockPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blockCountArgs>(
      args?: Subset<T, blockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blockGroupByArgs['orderBy'] }
        : { orderBy?: blockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the block model
   */
  readonly fields: blockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the block model
   */ 
  interface blockFieldRefs {
    readonly id: FieldRef<"block", 'BigInt'>
    readonly hash: FieldRef<"block", 'Bytes'>
    readonly epoch_no: FieldRef<"block", 'Int'>
    readonly slot_no: FieldRef<"block", 'BigInt'>
    readonly epoch_slot_no: FieldRef<"block", 'Int'>
    readonly block_no: FieldRef<"block", 'Int'>
    readonly previous_id: FieldRef<"block", 'BigInt'>
    readonly slot_leader_id: FieldRef<"block", 'BigInt'>
    readonly size: FieldRef<"block", 'Int'>
    readonly time: FieldRef<"block", 'DateTime'>
    readonly tx_count: FieldRef<"block", 'BigInt'>
    readonly proto_major: FieldRef<"block", 'Int'>
    readonly proto_minor: FieldRef<"block", 'Int'>
    readonly vrf_key: FieldRef<"block", 'String'>
    readonly op_cert: FieldRef<"block", 'Bytes'>
    readonly op_cert_counter: FieldRef<"block", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * block findUnique
   */
  export type blockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter, which block to fetch.
     */
    where: blockWhereUniqueInput
  }

  /**
   * block findUniqueOrThrow
   */
  export type blockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter, which block to fetch.
     */
    where: blockWhereUniqueInput
  }

  /**
   * block findFirst
   */
  export type blockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter, which block to fetch.
     */
    where?: blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blockOrderByWithRelationInput | blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * block findFirstOrThrow
   */
  export type blockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter, which block to fetch.
     */
    where?: blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blockOrderByWithRelationInput | blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     */
    cursor?: blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * block findMany
   */
  export type blockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter, which blocks to fetch.
     */
    where?: blockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     */
    orderBy?: blockOrderByWithRelationInput | blockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     */
    cursor?: blockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * block create
   */
  export type blockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * The data needed to create a block.
     */
    data: XOR<blockCreateInput, blockUncheckedCreateInput>
  }

  /**
   * block createMany
   */
  export type blockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blocks.
     */
    data: blockCreateManyInput | blockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * block createManyAndReturn
   */
  export type blockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * The data used to create many blocks.
     */
    data: blockCreateManyInput | blockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * block update
   */
  export type blockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * The data needed to update a block.
     */
    data: XOR<blockUpdateInput, blockUncheckedUpdateInput>
    /**
     * Choose, which block to update.
     */
    where: blockWhereUniqueInput
  }

  /**
   * block updateMany
   */
  export type blockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blocks.
     */
    data: XOR<blockUpdateManyMutationInput, blockUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blockWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
  }

  /**
   * block updateManyAndReturn
   */
  export type blockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * The data used to update blocks.
     */
    data: XOR<blockUpdateManyMutationInput, blockUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     */
    where?: blockWhereInput
    /**
     * Limit how many blocks to update.
     */
    limit?: number
  }

  /**
   * block upsert
   */
  export type blockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * The filter to search for the block to update in case it exists.
     */
    where: blockWhereUniqueInput
    /**
     * In case the block found by the `where` argument doesn't exist, create a new block with this data.
     */
    create: XOR<blockCreateInput, blockUncheckedCreateInput>
    /**
     * In case the block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blockUpdateInput, blockUncheckedUpdateInput>
  }

  /**
   * block delete
   */
  export type blockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
    /**
     * Filter which block to delete.
     */
    where: blockWhereUniqueInput
  }

  /**
   * block deleteMany
   */
  export type blockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blocks to delete
     */
    where?: blockWhereInput
    /**
     * Limit how many blocks to delete.
     */
    limit?: number
  }

  /**
   * block without action
   */
  export type blockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block
     */
    select?: blockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block
     */
    omit?: blockOmit<ExtArgs> | null
  }


  /**
   * Model collateral_tx_in
   */

  export type AggregateCollateral_tx_in = {
    _count: Collateral_tx_inCountAggregateOutputType | null
    _avg: Collateral_tx_inAvgAggregateOutputType | null
    _sum: Collateral_tx_inSumAggregateOutputType | null
    _min: Collateral_tx_inMinAggregateOutputType | null
    _max: Collateral_tx_inMaxAggregateOutputType | null
  }

  export type Collateral_tx_inAvgAggregateOutputType = {
    id: number | null
    tx_in_id: number | null
    tx_out_id: number | null
    tx_out_index: number | null
  }

  export type Collateral_tx_inSumAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Collateral_tx_inMinAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Collateral_tx_inMaxAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Collateral_tx_inCountAggregateOutputType = {
    id: number
    tx_in_id: number
    tx_out_id: number
    tx_out_index: number
    _all: number
  }


  export type Collateral_tx_inAvgAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Collateral_tx_inSumAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Collateral_tx_inMinAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Collateral_tx_inMaxAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Collateral_tx_inCountAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    _all?: true
  }

  export type Collateral_tx_inAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_tx_in to aggregate.
     */
    where?: collateral_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_ins to fetch.
     */
    orderBy?: collateral_tx_inOrderByWithRelationInput | collateral_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collateral_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collateral_tx_ins
    **/
    _count?: true | Collateral_tx_inCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collateral_tx_inAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collateral_tx_inSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collateral_tx_inMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collateral_tx_inMaxAggregateInputType
  }

  export type GetCollateral_tx_inAggregateType<T extends Collateral_tx_inAggregateArgs> = {
        [P in keyof T & keyof AggregateCollateral_tx_in]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollateral_tx_in[P]>
      : GetScalarType<T[P], AggregateCollateral_tx_in[P]>
  }




  export type collateral_tx_inGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collateral_tx_inWhereInput
    orderBy?: collateral_tx_inOrderByWithAggregationInput | collateral_tx_inOrderByWithAggregationInput[]
    by: Collateral_tx_inScalarFieldEnum[] | Collateral_tx_inScalarFieldEnum
    having?: collateral_tx_inScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collateral_tx_inCountAggregateInputType | true
    _avg?: Collateral_tx_inAvgAggregateInputType
    _sum?: Collateral_tx_inSumAggregateInputType
    _min?: Collateral_tx_inMinAggregateInputType
    _max?: Collateral_tx_inMaxAggregateInputType
  }

  export type Collateral_tx_inGroupByOutputType = {
    id: bigint
    tx_in_id: bigint
    tx_out_id: bigint
    tx_out_index: number
    _count: Collateral_tx_inCountAggregateOutputType | null
    _avg: Collateral_tx_inAvgAggregateOutputType | null
    _sum: Collateral_tx_inSumAggregateOutputType | null
    _min: Collateral_tx_inMinAggregateOutputType | null
    _max: Collateral_tx_inMaxAggregateOutputType | null
  }

  type GetCollateral_tx_inGroupByPayload<T extends collateral_tx_inGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collateral_tx_inGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collateral_tx_inGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collateral_tx_inGroupByOutputType[P]>
            : GetScalarType<T[P], Collateral_tx_inGroupByOutputType[P]>
        }
      >
    >


  export type collateral_tx_inSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["collateral_tx_in"]>

  export type collateral_tx_inSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["collateral_tx_in"]>

  export type collateral_tx_inSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["collateral_tx_in"]>

  export type collateral_tx_inSelectScalar = {
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }

  export type collateral_tx_inOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_in_id" | "tx_out_id" | "tx_out_index", ExtArgs["result"]["collateral_tx_in"]>

  export type $collateral_tx_inPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collateral_tx_in"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_in_id: bigint
      tx_out_id: bigint
      tx_out_index: number
    }, ExtArgs["result"]["collateral_tx_in"]>
    composites: {}
  }

  type collateral_tx_inGetPayload<S extends boolean | null | undefined | collateral_tx_inDefaultArgs> = $Result.GetResult<Prisma.$collateral_tx_inPayload, S>

  type collateral_tx_inCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collateral_tx_inFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Collateral_tx_inCountAggregateInputType | true
    }

  export interface collateral_tx_inDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collateral_tx_in'], meta: { name: 'collateral_tx_in' } }
    /**
     * Find zero or one Collateral_tx_in that matches the filter.
     * @param {collateral_tx_inFindUniqueArgs} args - Arguments to find a Collateral_tx_in
     * @example
     * // Get one Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collateral_tx_inFindUniqueArgs>(args: SelectSubset<T, collateral_tx_inFindUniqueArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Collateral_tx_in that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collateral_tx_inFindUniqueOrThrowArgs} args - Arguments to find a Collateral_tx_in
     * @example
     * // Get one Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collateral_tx_inFindUniqueOrThrowArgs>(args: SelectSubset<T, collateral_tx_inFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Collateral_tx_in that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inFindFirstArgs} args - Arguments to find a Collateral_tx_in
     * @example
     * // Get one Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collateral_tx_inFindFirstArgs>(args?: SelectSubset<T, collateral_tx_inFindFirstArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Collateral_tx_in that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inFindFirstOrThrowArgs} args - Arguments to find a Collateral_tx_in
     * @example
     * // Get one Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collateral_tx_inFindFirstOrThrowArgs>(args?: SelectSubset<T, collateral_tx_inFindFirstOrThrowArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Collateral_tx_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collateral_tx_ins
     * const collateral_tx_ins = await prisma.collateral_tx_in.findMany()
     * 
     * // Get first 10 Collateral_tx_ins
     * const collateral_tx_ins = await prisma.collateral_tx_in.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collateral_tx_inWithIdOnly = await prisma.collateral_tx_in.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collateral_tx_inFindManyArgs>(args?: SelectSubset<T, collateral_tx_inFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Collateral_tx_in.
     * @param {collateral_tx_inCreateArgs} args - Arguments to create a Collateral_tx_in.
     * @example
     * // Create one Collateral_tx_in
     * const Collateral_tx_in = await prisma.collateral_tx_in.create({
     *   data: {
     *     // ... data to create a Collateral_tx_in
     *   }
     * })
     * 
     */
    create<T extends collateral_tx_inCreateArgs>(args: SelectSubset<T, collateral_tx_inCreateArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Collateral_tx_ins.
     * @param {collateral_tx_inCreateManyArgs} args - Arguments to create many Collateral_tx_ins.
     * @example
     * // Create many Collateral_tx_ins
     * const collateral_tx_in = await prisma.collateral_tx_in.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collateral_tx_inCreateManyArgs>(args?: SelectSubset<T, collateral_tx_inCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collateral_tx_ins and returns the data saved in the database.
     * @param {collateral_tx_inCreateManyAndReturnArgs} args - Arguments to create many Collateral_tx_ins.
     * @example
     * // Create many Collateral_tx_ins
     * const collateral_tx_in = await prisma.collateral_tx_in.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collateral_tx_ins and only return the `id`
     * const collateral_tx_inWithIdOnly = await prisma.collateral_tx_in.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collateral_tx_inCreateManyAndReturnArgs>(args?: SelectSubset<T, collateral_tx_inCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Collateral_tx_in.
     * @param {collateral_tx_inDeleteArgs} args - Arguments to delete one Collateral_tx_in.
     * @example
     * // Delete one Collateral_tx_in
     * const Collateral_tx_in = await prisma.collateral_tx_in.delete({
     *   where: {
     *     // ... filter to delete one Collateral_tx_in
     *   }
     * })
     * 
     */
    delete<T extends collateral_tx_inDeleteArgs>(args: SelectSubset<T, collateral_tx_inDeleteArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Collateral_tx_in.
     * @param {collateral_tx_inUpdateArgs} args - Arguments to update one Collateral_tx_in.
     * @example
     * // Update one Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collateral_tx_inUpdateArgs>(args: SelectSubset<T, collateral_tx_inUpdateArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Collateral_tx_ins.
     * @param {collateral_tx_inDeleteManyArgs} args - Arguments to filter Collateral_tx_ins to delete.
     * @example
     * // Delete a few Collateral_tx_ins
     * const { count } = await prisma.collateral_tx_in.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collateral_tx_inDeleteManyArgs>(args?: SelectSubset<T, collateral_tx_inDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collateral_tx_ins
     * const collateral_tx_in = await prisma.collateral_tx_in.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collateral_tx_inUpdateManyArgs>(args: SelectSubset<T, collateral_tx_inUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_tx_ins and returns the data updated in the database.
     * @param {collateral_tx_inUpdateManyAndReturnArgs} args - Arguments to update many Collateral_tx_ins.
     * @example
     * // Update many Collateral_tx_ins
     * const collateral_tx_in = await prisma.collateral_tx_in.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collateral_tx_ins and only return the `id`
     * const collateral_tx_inWithIdOnly = await prisma.collateral_tx_in.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collateral_tx_inUpdateManyAndReturnArgs>(args: SelectSubset<T, collateral_tx_inUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Collateral_tx_in.
     * @param {collateral_tx_inUpsertArgs} args - Arguments to update or create a Collateral_tx_in.
     * @example
     * // Update or create a Collateral_tx_in
     * const collateral_tx_in = await prisma.collateral_tx_in.upsert({
     *   create: {
     *     // ... data to create a Collateral_tx_in
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collateral_tx_in we want to update
     *   }
     * })
     */
    upsert<T extends collateral_tx_inUpsertArgs>(args: SelectSubset<T, collateral_tx_inUpsertArgs<ExtArgs>>): Prisma__collateral_tx_inClient<$Result.GetResult<Prisma.$collateral_tx_inPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Collateral_tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inCountArgs} args - Arguments to filter Collateral_tx_ins to count.
     * @example
     * // Count the number of Collateral_tx_ins
     * const count = await prisma.collateral_tx_in.count({
     *   where: {
     *     // ... the filter for the Collateral_tx_ins we want to count
     *   }
     * })
    **/
    count<T extends collateral_tx_inCountArgs>(
      args?: Subset<T, collateral_tx_inCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collateral_tx_inCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collateral_tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collateral_tx_inAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collateral_tx_inAggregateArgs>(args: Subset<T, Collateral_tx_inAggregateArgs>): Prisma.PrismaPromise<GetCollateral_tx_inAggregateType<T>>

    /**
     * Group by Collateral_tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_inGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collateral_tx_inGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collateral_tx_inGroupByArgs['orderBy'] }
        : { orderBy?: collateral_tx_inGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collateral_tx_inGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollateral_tx_inGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collateral_tx_in model
   */
  readonly fields: collateral_tx_inFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collateral_tx_in.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collateral_tx_inClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collateral_tx_in model
   */ 
  interface collateral_tx_inFieldRefs {
    readonly id: FieldRef<"collateral_tx_in", 'BigInt'>
    readonly tx_in_id: FieldRef<"collateral_tx_in", 'BigInt'>
    readonly tx_out_id: FieldRef<"collateral_tx_in", 'BigInt'>
    readonly tx_out_index: FieldRef<"collateral_tx_in", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * collateral_tx_in findUnique
   */
  export type collateral_tx_inFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_in to fetch.
     */
    where: collateral_tx_inWhereUniqueInput
  }

  /**
   * collateral_tx_in findUniqueOrThrow
   */
  export type collateral_tx_inFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_in to fetch.
     */
    where: collateral_tx_inWhereUniqueInput
  }

  /**
   * collateral_tx_in findFirst
   */
  export type collateral_tx_inFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_in to fetch.
     */
    where?: collateral_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_ins to fetch.
     */
    orderBy?: collateral_tx_inOrderByWithRelationInput | collateral_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_tx_ins.
     */
    cursor?: collateral_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_tx_ins.
     */
    distinct?: Collateral_tx_inScalarFieldEnum | Collateral_tx_inScalarFieldEnum[]
  }

  /**
   * collateral_tx_in findFirstOrThrow
   */
  export type collateral_tx_inFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_in to fetch.
     */
    where?: collateral_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_ins to fetch.
     */
    orderBy?: collateral_tx_inOrderByWithRelationInput | collateral_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_tx_ins.
     */
    cursor?: collateral_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_tx_ins.
     */
    distinct?: Collateral_tx_inScalarFieldEnum | Collateral_tx_inScalarFieldEnum[]
  }

  /**
   * collateral_tx_in findMany
   */
  export type collateral_tx_inFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_ins to fetch.
     */
    where?: collateral_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_ins to fetch.
     */
    orderBy?: collateral_tx_inOrderByWithRelationInput | collateral_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collateral_tx_ins.
     */
    cursor?: collateral_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_ins.
     */
    skip?: number
    distinct?: Collateral_tx_inScalarFieldEnum | Collateral_tx_inScalarFieldEnum[]
  }

  /**
   * collateral_tx_in create
   */
  export type collateral_tx_inCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * The data needed to create a collateral_tx_in.
     */
    data: XOR<collateral_tx_inCreateInput, collateral_tx_inUncheckedCreateInput>
  }

  /**
   * collateral_tx_in createMany
   */
  export type collateral_tx_inCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collateral_tx_ins.
     */
    data: collateral_tx_inCreateManyInput | collateral_tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_tx_in createManyAndReturn
   */
  export type collateral_tx_inCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * The data used to create many collateral_tx_ins.
     */
    data: collateral_tx_inCreateManyInput | collateral_tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_tx_in update
   */
  export type collateral_tx_inUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * The data needed to update a collateral_tx_in.
     */
    data: XOR<collateral_tx_inUpdateInput, collateral_tx_inUncheckedUpdateInput>
    /**
     * Choose, which collateral_tx_in to update.
     */
    where: collateral_tx_inWhereUniqueInput
  }

  /**
   * collateral_tx_in updateMany
   */
  export type collateral_tx_inUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collateral_tx_ins.
     */
    data: XOR<collateral_tx_inUpdateManyMutationInput, collateral_tx_inUncheckedUpdateManyInput>
    /**
     * Filter which collateral_tx_ins to update
     */
    where?: collateral_tx_inWhereInput
    /**
     * Limit how many collateral_tx_ins to update.
     */
    limit?: number
  }

  /**
   * collateral_tx_in updateManyAndReturn
   */
  export type collateral_tx_inUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * The data used to update collateral_tx_ins.
     */
    data: XOR<collateral_tx_inUpdateManyMutationInput, collateral_tx_inUncheckedUpdateManyInput>
    /**
     * Filter which collateral_tx_ins to update
     */
    where?: collateral_tx_inWhereInput
    /**
     * Limit how many collateral_tx_ins to update.
     */
    limit?: number
  }

  /**
   * collateral_tx_in upsert
   */
  export type collateral_tx_inUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * The filter to search for the collateral_tx_in to update in case it exists.
     */
    where: collateral_tx_inWhereUniqueInput
    /**
     * In case the collateral_tx_in found by the `where` argument doesn't exist, create a new collateral_tx_in with this data.
     */
    create: XOR<collateral_tx_inCreateInput, collateral_tx_inUncheckedCreateInput>
    /**
     * In case the collateral_tx_in was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collateral_tx_inUpdateInput, collateral_tx_inUncheckedUpdateInput>
  }

  /**
   * collateral_tx_in delete
   */
  export type collateral_tx_inDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
    /**
     * Filter which collateral_tx_in to delete.
     */
    where: collateral_tx_inWhereUniqueInput
  }

  /**
   * collateral_tx_in deleteMany
   */
  export type collateral_tx_inDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_tx_ins to delete
     */
    where?: collateral_tx_inWhereInput
    /**
     * Limit how many collateral_tx_ins to delete.
     */
    limit?: number
  }

  /**
   * collateral_tx_in without action
   */
  export type collateral_tx_inDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_in
     */
    select?: collateral_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_in
     */
    omit?: collateral_tx_inOmit<ExtArgs> | null
  }


  /**
   * Model collateral_tx_out
   */

  export type AggregateCollateral_tx_out = {
    _count: Collateral_tx_outCountAggregateOutputType | null
    _avg: Collateral_tx_outAvgAggregateOutputType | null
    _sum: Collateral_tx_outSumAggregateOutputType | null
    _min: Collateral_tx_outMinAggregateOutputType | null
    _max: Collateral_tx_outMaxAggregateOutputType | null
  }

  export type Collateral_tx_outAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    index: number | null
    stake_address_id: number | null
    value: Decimal | null
    inline_datum_id: number | null
    reference_script_id: number | null
  }

  export type Collateral_tx_outSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    stake_address_id: bigint | null
    value: Decimal | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
  }

  export type Collateral_tx_outMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    address: string | null
    address_has_script: boolean | null
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal | null
    data_hash: Uint8Array | null
    multi_assets_descr: string | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
  }

  export type Collateral_tx_outMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    address: string | null
    address_has_script: boolean | null
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal | null
    data_hash: Uint8Array | null
    multi_assets_descr: string | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
  }

  export type Collateral_tx_outCountAggregateOutputType = {
    id: number
    tx_id: number
    index: number
    address: number
    address_has_script: number
    payment_cred: number
    stake_address_id: number
    value: number
    data_hash: number
    multi_assets_descr: number
    inline_datum_id: number
    reference_script_id: number
    _all: number
  }


  export type Collateral_tx_outAvgAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    stake_address_id?: true
    value?: true
    inline_datum_id?: true
    reference_script_id?: true
  }

  export type Collateral_tx_outSumAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    stake_address_id?: true
    value?: true
    inline_datum_id?: true
    reference_script_id?: true
  }

  export type Collateral_tx_outMinAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    multi_assets_descr?: true
    inline_datum_id?: true
    reference_script_id?: true
  }

  export type Collateral_tx_outMaxAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    multi_assets_descr?: true
    inline_datum_id?: true
    reference_script_id?: true
  }

  export type Collateral_tx_outCountAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    multi_assets_descr?: true
    inline_datum_id?: true
    reference_script_id?: true
    _all?: true
  }

  export type Collateral_tx_outAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_tx_out to aggregate.
     */
    where?: collateral_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_outs to fetch.
     */
    orderBy?: collateral_tx_outOrderByWithRelationInput | collateral_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collateral_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collateral_tx_outs
    **/
    _count?: true | Collateral_tx_outCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collateral_tx_outAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collateral_tx_outSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collateral_tx_outMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collateral_tx_outMaxAggregateInputType
  }

  export type GetCollateral_tx_outAggregateType<T extends Collateral_tx_outAggregateArgs> = {
        [P in keyof T & keyof AggregateCollateral_tx_out]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollateral_tx_out[P]>
      : GetScalarType<T[P], AggregateCollateral_tx_out[P]>
  }




  export type collateral_tx_outGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collateral_tx_outWhereInput
    orderBy?: collateral_tx_outOrderByWithAggregationInput | collateral_tx_outOrderByWithAggregationInput[]
    by: Collateral_tx_outScalarFieldEnum[] | Collateral_tx_outScalarFieldEnum
    having?: collateral_tx_outScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collateral_tx_outCountAggregateInputType | true
    _avg?: Collateral_tx_outAvgAggregateInputType
    _sum?: Collateral_tx_outSumAggregateInputType
    _min?: Collateral_tx_outMinAggregateInputType
    _max?: Collateral_tx_outMaxAggregateInputType
  }

  export type Collateral_tx_outGroupByOutputType = {
    id: bigint
    tx_id: bigint
    index: number
    address: string
    address_has_script: boolean
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal
    data_hash: Uint8Array | null
    multi_assets_descr: string
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
    _count: Collateral_tx_outCountAggregateOutputType | null
    _avg: Collateral_tx_outAvgAggregateOutputType | null
    _sum: Collateral_tx_outSumAggregateOutputType | null
    _min: Collateral_tx_outMinAggregateOutputType | null
    _max: Collateral_tx_outMaxAggregateOutputType | null
  }

  type GetCollateral_tx_outGroupByPayload<T extends collateral_tx_outGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collateral_tx_outGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collateral_tx_outGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collateral_tx_outGroupByOutputType[P]>
            : GetScalarType<T[P], Collateral_tx_outGroupByOutputType[P]>
        }
      >
    >


  export type collateral_tx_outSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    multi_assets_descr?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
  }, ExtArgs["result"]["collateral_tx_out"]>

  export type collateral_tx_outSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    multi_assets_descr?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
  }, ExtArgs["result"]["collateral_tx_out"]>

  export type collateral_tx_outSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    multi_assets_descr?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
  }, ExtArgs["result"]["collateral_tx_out"]>

  export type collateral_tx_outSelectScalar = {
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    multi_assets_descr?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
  }

  export type collateral_tx_outOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "index" | "address" | "address_has_script" | "payment_cred" | "stake_address_id" | "value" | "data_hash" | "multi_assets_descr" | "inline_datum_id" | "reference_script_id", ExtArgs["result"]["collateral_tx_out"]>

  export type $collateral_tx_outPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collateral_tx_out"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      index: number
      address: string
      address_has_script: boolean
      payment_cred: Uint8Array | null
      stake_address_id: bigint | null
      value: Prisma.Decimal
      data_hash: Uint8Array | null
      multi_assets_descr: string
      inline_datum_id: bigint | null
      reference_script_id: bigint | null
    }, ExtArgs["result"]["collateral_tx_out"]>
    composites: {}
  }

  type collateral_tx_outGetPayload<S extends boolean | null | undefined | collateral_tx_outDefaultArgs> = $Result.GetResult<Prisma.$collateral_tx_outPayload, S>

  type collateral_tx_outCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collateral_tx_outFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Collateral_tx_outCountAggregateInputType | true
    }

  export interface collateral_tx_outDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collateral_tx_out'], meta: { name: 'collateral_tx_out' } }
    /**
     * Find zero or one Collateral_tx_out that matches the filter.
     * @param {collateral_tx_outFindUniqueArgs} args - Arguments to find a Collateral_tx_out
     * @example
     * // Get one Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collateral_tx_outFindUniqueArgs>(args: SelectSubset<T, collateral_tx_outFindUniqueArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Collateral_tx_out that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collateral_tx_outFindUniqueOrThrowArgs} args - Arguments to find a Collateral_tx_out
     * @example
     * // Get one Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collateral_tx_outFindUniqueOrThrowArgs>(args: SelectSubset<T, collateral_tx_outFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Collateral_tx_out that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outFindFirstArgs} args - Arguments to find a Collateral_tx_out
     * @example
     * // Get one Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collateral_tx_outFindFirstArgs>(args?: SelectSubset<T, collateral_tx_outFindFirstArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Collateral_tx_out that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outFindFirstOrThrowArgs} args - Arguments to find a Collateral_tx_out
     * @example
     * // Get one Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collateral_tx_outFindFirstOrThrowArgs>(args?: SelectSubset<T, collateral_tx_outFindFirstOrThrowArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Collateral_tx_outs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collateral_tx_outs
     * const collateral_tx_outs = await prisma.collateral_tx_out.findMany()
     * 
     * // Get first 10 Collateral_tx_outs
     * const collateral_tx_outs = await prisma.collateral_tx_out.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collateral_tx_outWithIdOnly = await prisma.collateral_tx_out.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends collateral_tx_outFindManyArgs>(args?: SelectSubset<T, collateral_tx_outFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Collateral_tx_out.
     * @param {collateral_tx_outCreateArgs} args - Arguments to create a Collateral_tx_out.
     * @example
     * // Create one Collateral_tx_out
     * const Collateral_tx_out = await prisma.collateral_tx_out.create({
     *   data: {
     *     // ... data to create a Collateral_tx_out
     *   }
     * })
     * 
     */
    create<T extends collateral_tx_outCreateArgs>(args: SelectSubset<T, collateral_tx_outCreateArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Collateral_tx_outs.
     * @param {collateral_tx_outCreateManyArgs} args - Arguments to create many Collateral_tx_outs.
     * @example
     * // Create many Collateral_tx_outs
     * const collateral_tx_out = await prisma.collateral_tx_out.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collateral_tx_outCreateManyArgs>(args?: SelectSubset<T, collateral_tx_outCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collateral_tx_outs and returns the data saved in the database.
     * @param {collateral_tx_outCreateManyAndReturnArgs} args - Arguments to create many Collateral_tx_outs.
     * @example
     * // Create many Collateral_tx_outs
     * const collateral_tx_out = await prisma.collateral_tx_out.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collateral_tx_outs and only return the `id`
     * const collateral_tx_outWithIdOnly = await prisma.collateral_tx_out.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collateral_tx_outCreateManyAndReturnArgs>(args?: SelectSubset<T, collateral_tx_outCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Collateral_tx_out.
     * @param {collateral_tx_outDeleteArgs} args - Arguments to delete one Collateral_tx_out.
     * @example
     * // Delete one Collateral_tx_out
     * const Collateral_tx_out = await prisma.collateral_tx_out.delete({
     *   where: {
     *     // ... filter to delete one Collateral_tx_out
     *   }
     * })
     * 
     */
    delete<T extends collateral_tx_outDeleteArgs>(args: SelectSubset<T, collateral_tx_outDeleteArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Collateral_tx_out.
     * @param {collateral_tx_outUpdateArgs} args - Arguments to update one Collateral_tx_out.
     * @example
     * // Update one Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collateral_tx_outUpdateArgs>(args: SelectSubset<T, collateral_tx_outUpdateArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Collateral_tx_outs.
     * @param {collateral_tx_outDeleteManyArgs} args - Arguments to filter Collateral_tx_outs to delete.
     * @example
     * // Delete a few Collateral_tx_outs
     * const { count } = await prisma.collateral_tx_out.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collateral_tx_outDeleteManyArgs>(args?: SelectSubset<T, collateral_tx_outDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collateral_tx_outs
     * const collateral_tx_out = await prisma.collateral_tx_out.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collateral_tx_outUpdateManyArgs>(args: SelectSubset<T, collateral_tx_outUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collateral_tx_outs and returns the data updated in the database.
     * @param {collateral_tx_outUpdateManyAndReturnArgs} args - Arguments to update many Collateral_tx_outs.
     * @example
     * // Update many Collateral_tx_outs
     * const collateral_tx_out = await prisma.collateral_tx_out.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collateral_tx_outs and only return the `id`
     * const collateral_tx_outWithIdOnly = await prisma.collateral_tx_out.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collateral_tx_outUpdateManyAndReturnArgs>(args: SelectSubset<T, collateral_tx_outUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Collateral_tx_out.
     * @param {collateral_tx_outUpsertArgs} args - Arguments to update or create a Collateral_tx_out.
     * @example
     * // Update or create a Collateral_tx_out
     * const collateral_tx_out = await prisma.collateral_tx_out.upsert({
     *   create: {
     *     // ... data to create a Collateral_tx_out
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collateral_tx_out we want to update
     *   }
     * })
     */
    upsert<T extends collateral_tx_outUpsertArgs>(args: SelectSubset<T, collateral_tx_outUpsertArgs<ExtArgs>>): Prisma__collateral_tx_outClient<$Result.GetResult<Prisma.$collateral_tx_outPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Collateral_tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outCountArgs} args - Arguments to filter Collateral_tx_outs to count.
     * @example
     * // Count the number of Collateral_tx_outs
     * const count = await prisma.collateral_tx_out.count({
     *   where: {
     *     // ... the filter for the Collateral_tx_outs we want to count
     *   }
     * })
    **/
    count<T extends collateral_tx_outCountArgs>(
      args?: Subset<T, collateral_tx_outCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collateral_tx_outCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collateral_tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collateral_tx_outAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collateral_tx_outAggregateArgs>(args: Subset<T, Collateral_tx_outAggregateArgs>): Prisma.PrismaPromise<GetCollateral_tx_outAggregateType<T>>

    /**
     * Group by Collateral_tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collateral_tx_outGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collateral_tx_outGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collateral_tx_outGroupByArgs['orderBy'] }
        : { orderBy?: collateral_tx_outGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collateral_tx_outGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollateral_tx_outGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collateral_tx_out model
   */
  readonly fields: collateral_tx_outFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collateral_tx_out.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collateral_tx_outClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collateral_tx_out model
   */ 
  interface collateral_tx_outFieldRefs {
    readonly id: FieldRef<"collateral_tx_out", 'BigInt'>
    readonly tx_id: FieldRef<"collateral_tx_out", 'BigInt'>
    readonly index: FieldRef<"collateral_tx_out", 'Int'>
    readonly address: FieldRef<"collateral_tx_out", 'String'>
    readonly address_has_script: FieldRef<"collateral_tx_out", 'Boolean'>
    readonly payment_cred: FieldRef<"collateral_tx_out", 'Bytes'>
    readonly stake_address_id: FieldRef<"collateral_tx_out", 'BigInt'>
    readonly value: FieldRef<"collateral_tx_out", 'Decimal'>
    readonly data_hash: FieldRef<"collateral_tx_out", 'Bytes'>
    readonly multi_assets_descr: FieldRef<"collateral_tx_out", 'String'>
    readonly inline_datum_id: FieldRef<"collateral_tx_out", 'BigInt'>
    readonly reference_script_id: FieldRef<"collateral_tx_out", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * collateral_tx_out findUnique
   */
  export type collateral_tx_outFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_out to fetch.
     */
    where: collateral_tx_outWhereUniqueInput
  }

  /**
   * collateral_tx_out findUniqueOrThrow
   */
  export type collateral_tx_outFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_out to fetch.
     */
    where: collateral_tx_outWhereUniqueInput
  }

  /**
   * collateral_tx_out findFirst
   */
  export type collateral_tx_outFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_out to fetch.
     */
    where?: collateral_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_outs to fetch.
     */
    orderBy?: collateral_tx_outOrderByWithRelationInput | collateral_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_tx_outs.
     */
    cursor?: collateral_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_tx_outs.
     */
    distinct?: Collateral_tx_outScalarFieldEnum | Collateral_tx_outScalarFieldEnum[]
  }

  /**
   * collateral_tx_out findFirstOrThrow
   */
  export type collateral_tx_outFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_out to fetch.
     */
    where?: collateral_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_outs to fetch.
     */
    orderBy?: collateral_tx_outOrderByWithRelationInput | collateral_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collateral_tx_outs.
     */
    cursor?: collateral_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collateral_tx_outs.
     */
    distinct?: Collateral_tx_outScalarFieldEnum | Collateral_tx_outScalarFieldEnum[]
  }

  /**
   * collateral_tx_out findMany
   */
  export type collateral_tx_outFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which collateral_tx_outs to fetch.
     */
    where?: collateral_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collateral_tx_outs to fetch.
     */
    orderBy?: collateral_tx_outOrderByWithRelationInput | collateral_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collateral_tx_outs.
     */
    cursor?: collateral_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collateral_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collateral_tx_outs.
     */
    skip?: number
    distinct?: Collateral_tx_outScalarFieldEnum | Collateral_tx_outScalarFieldEnum[]
  }

  /**
   * collateral_tx_out create
   */
  export type collateral_tx_outCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * The data needed to create a collateral_tx_out.
     */
    data: XOR<collateral_tx_outCreateInput, collateral_tx_outUncheckedCreateInput>
  }

  /**
   * collateral_tx_out createMany
   */
  export type collateral_tx_outCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collateral_tx_outs.
     */
    data: collateral_tx_outCreateManyInput | collateral_tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_tx_out createManyAndReturn
   */
  export type collateral_tx_outCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * The data used to create many collateral_tx_outs.
     */
    data: collateral_tx_outCreateManyInput | collateral_tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collateral_tx_out update
   */
  export type collateral_tx_outUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * The data needed to update a collateral_tx_out.
     */
    data: XOR<collateral_tx_outUpdateInput, collateral_tx_outUncheckedUpdateInput>
    /**
     * Choose, which collateral_tx_out to update.
     */
    where: collateral_tx_outWhereUniqueInput
  }

  /**
   * collateral_tx_out updateMany
   */
  export type collateral_tx_outUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collateral_tx_outs.
     */
    data: XOR<collateral_tx_outUpdateManyMutationInput, collateral_tx_outUncheckedUpdateManyInput>
    /**
     * Filter which collateral_tx_outs to update
     */
    where?: collateral_tx_outWhereInput
    /**
     * Limit how many collateral_tx_outs to update.
     */
    limit?: number
  }

  /**
   * collateral_tx_out updateManyAndReturn
   */
  export type collateral_tx_outUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * The data used to update collateral_tx_outs.
     */
    data: XOR<collateral_tx_outUpdateManyMutationInput, collateral_tx_outUncheckedUpdateManyInput>
    /**
     * Filter which collateral_tx_outs to update
     */
    where?: collateral_tx_outWhereInput
    /**
     * Limit how many collateral_tx_outs to update.
     */
    limit?: number
  }

  /**
   * collateral_tx_out upsert
   */
  export type collateral_tx_outUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * The filter to search for the collateral_tx_out to update in case it exists.
     */
    where: collateral_tx_outWhereUniqueInput
    /**
     * In case the collateral_tx_out found by the `where` argument doesn't exist, create a new collateral_tx_out with this data.
     */
    create: XOR<collateral_tx_outCreateInput, collateral_tx_outUncheckedCreateInput>
    /**
     * In case the collateral_tx_out was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collateral_tx_outUpdateInput, collateral_tx_outUncheckedUpdateInput>
  }

  /**
   * collateral_tx_out delete
   */
  export type collateral_tx_outDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
    /**
     * Filter which collateral_tx_out to delete.
     */
    where: collateral_tx_outWhereUniqueInput
  }

  /**
   * collateral_tx_out deleteMany
   */
  export type collateral_tx_outDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collateral_tx_outs to delete
     */
    where?: collateral_tx_outWhereInput
    /**
     * Limit how many collateral_tx_outs to delete.
     */
    limit?: number
  }

  /**
   * collateral_tx_out without action
   */
  export type collateral_tx_outDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collateral_tx_out
     */
    select?: collateral_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collateral_tx_out
     */
    omit?: collateral_tx_outOmit<ExtArgs> | null
  }


  /**
   * Model committee
   */

  export type AggregateCommittee = {
    _count: CommitteeCountAggregateOutputType | null
    _avg: CommitteeAvgAggregateOutputType | null
    _sum: CommitteeSumAggregateOutputType | null
    _min: CommitteeMinAggregateOutputType | null
    _max: CommitteeMaxAggregateOutputType | null
  }

  export type CommitteeAvgAggregateOutputType = {
    id: number | null
    gov_action_proposal_id: number | null
    quorum_numerator: number | null
    quorum_denominator: number | null
  }

  export type CommitteeSumAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type CommitteeMinAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type CommitteeMaxAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type CommitteeCountAggregateOutputType = {
    id: number
    gov_action_proposal_id: number
    quorum_numerator: number
    quorum_denominator: number
    _all: number
  }


  export type CommitteeAvgAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type CommitteeSumAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type CommitteeMinAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type CommitteeMaxAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type CommitteeCountAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
    _all?: true
  }

  export type CommitteeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee to aggregate.
     */
    where?: committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committees to fetch.
     */
    orderBy?: committeeOrderByWithRelationInput | committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned committees
    **/
    _count?: true | CommitteeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommitteeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommitteeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommitteeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommitteeMaxAggregateInputType
  }

  export type GetCommitteeAggregateType<T extends CommitteeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommittee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommittee[P]>
      : GetScalarType<T[P], AggregateCommittee[P]>
  }




  export type committeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committeeWhereInput
    orderBy?: committeeOrderByWithAggregationInput | committeeOrderByWithAggregationInput[]
    by: CommitteeScalarFieldEnum[] | CommitteeScalarFieldEnum
    having?: committeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommitteeCountAggregateInputType | true
    _avg?: CommitteeAvgAggregateInputType
    _sum?: CommitteeSumAggregateInputType
    _min?: CommitteeMinAggregateInputType
    _max?: CommitteeMaxAggregateInputType
  }

  export type CommitteeGroupByOutputType = {
    id: bigint
    gov_action_proposal_id: bigint | null
    quorum_numerator: bigint
    quorum_denominator: bigint
    _count: CommitteeCountAggregateOutputType | null
    _avg: CommitteeAvgAggregateOutputType | null
    _sum: CommitteeSumAggregateOutputType | null
    _min: CommitteeMinAggregateOutputType | null
    _max: CommitteeMaxAggregateOutputType | null
  }

  type GetCommitteeGroupByPayload<T extends committeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommitteeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommitteeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommitteeGroupByOutputType[P]>
            : GetScalarType<T[P], CommitteeGroupByOutputType[P]>
        }
      >
    >


  export type committeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
    committee_member?: boolean | committee$committee_memberArgs<ExtArgs>
    _count?: boolean | CommitteeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["committee"]>

  export type committeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }, ExtArgs["result"]["committee"]>

  export type committeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }, ExtArgs["result"]["committee"]>

  export type committeeSelectScalar = {
    id?: boolean
    gov_action_proposal_id?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }

  export type committeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gov_action_proposal_id" | "quorum_numerator" | "quorum_denominator", ExtArgs["result"]["committee"]>
  export type committeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    committee_member?: boolean | committee$committee_memberArgs<ExtArgs>
    _count?: boolean | CommitteeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type committeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type committeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $committeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "committee"
    objects: {
      committee_member: Prisma.$committee_memberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      gov_action_proposal_id: bigint | null
      quorum_numerator: bigint
      quorum_denominator: bigint
    }, ExtArgs["result"]["committee"]>
    composites: {}
  }

  type committeeGetPayload<S extends boolean | null | undefined | committeeDefaultArgs> = $Result.GetResult<Prisma.$committeePayload, S>

  type committeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<committeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommitteeCountAggregateInputType | true
    }

  export interface committeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['committee'], meta: { name: 'committee' } }
    /**
     * Find zero or one Committee that matches the filter.
     * @param {committeeFindUniqueArgs} args - Arguments to find a Committee
     * @example
     * // Get one Committee
     * const committee = await prisma.committee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends committeeFindUniqueArgs>(args: SelectSubset<T, committeeFindUniqueArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Committee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {committeeFindUniqueOrThrowArgs} args - Arguments to find a Committee
     * @example
     * // Get one Committee
     * const committee = await prisma.committee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends committeeFindUniqueOrThrowArgs>(args: SelectSubset<T, committeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Committee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeFindFirstArgs} args - Arguments to find a Committee
     * @example
     * // Get one Committee
     * const committee = await prisma.committee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends committeeFindFirstArgs>(args?: SelectSubset<T, committeeFindFirstArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Committee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeFindFirstOrThrowArgs} args - Arguments to find a Committee
     * @example
     * // Get one Committee
     * const committee = await prisma.committee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends committeeFindFirstOrThrowArgs>(args?: SelectSubset<T, committeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Committees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Committees
     * const committees = await prisma.committee.findMany()
     * 
     * // Get first 10 Committees
     * const committees = await prisma.committee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committeeWithIdOnly = await prisma.committee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends committeeFindManyArgs>(args?: SelectSubset<T, committeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Committee.
     * @param {committeeCreateArgs} args - Arguments to create a Committee.
     * @example
     * // Create one Committee
     * const Committee = await prisma.committee.create({
     *   data: {
     *     // ... data to create a Committee
     *   }
     * })
     * 
     */
    create<T extends committeeCreateArgs>(args: SelectSubset<T, committeeCreateArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Committees.
     * @param {committeeCreateManyArgs} args - Arguments to create many Committees.
     * @example
     * // Create many Committees
     * const committee = await prisma.committee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends committeeCreateManyArgs>(args?: SelectSubset<T, committeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Committees and returns the data saved in the database.
     * @param {committeeCreateManyAndReturnArgs} args - Arguments to create many Committees.
     * @example
     * // Create many Committees
     * const committee = await prisma.committee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Committees and only return the `id`
     * const committeeWithIdOnly = await prisma.committee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends committeeCreateManyAndReturnArgs>(args?: SelectSubset<T, committeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Committee.
     * @param {committeeDeleteArgs} args - Arguments to delete one Committee.
     * @example
     * // Delete one Committee
     * const Committee = await prisma.committee.delete({
     *   where: {
     *     // ... filter to delete one Committee
     *   }
     * })
     * 
     */
    delete<T extends committeeDeleteArgs>(args: SelectSubset<T, committeeDeleteArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Committee.
     * @param {committeeUpdateArgs} args - Arguments to update one Committee.
     * @example
     * // Update one Committee
     * const committee = await prisma.committee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends committeeUpdateArgs>(args: SelectSubset<T, committeeUpdateArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Committees.
     * @param {committeeDeleteManyArgs} args - Arguments to filter Committees to delete.
     * @example
     * // Delete a few Committees
     * const { count } = await prisma.committee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends committeeDeleteManyArgs>(args?: SelectSubset<T, committeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Committees
     * const committee = await prisma.committee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends committeeUpdateManyArgs>(args: SelectSubset<T, committeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committees and returns the data updated in the database.
     * @param {committeeUpdateManyAndReturnArgs} args - Arguments to update many Committees.
     * @example
     * // Update many Committees
     * const committee = await prisma.committee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Committees and only return the `id`
     * const committeeWithIdOnly = await prisma.committee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends committeeUpdateManyAndReturnArgs>(args: SelectSubset<T, committeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Committee.
     * @param {committeeUpsertArgs} args - Arguments to update or create a Committee.
     * @example
     * // Update or create a Committee
     * const committee = await prisma.committee.upsert({
     *   create: {
     *     // ... data to create a Committee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Committee we want to update
     *   }
     * })
     */
    upsert<T extends committeeUpsertArgs>(args: SelectSubset<T, committeeUpsertArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Committees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeCountArgs} args - Arguments to filter Committees to count.
     * @example
     * // Count the number of Committees
     * const count = await prisma.committee.count({
     *   where: {
     *     // ... the filter for the Committees we want to count
     *   }
     * })
    **/
    count<T extends committeeCountArgs>(
      args?: Subset<T, committeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommitteeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Committee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitteeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommitteeAggregateArgs>(args: Subset<T, CommitteeAggregateArgs>): Prisma.PrismaPromise<GetCommitteeAggregateType<T>>

    /**
     * Group by Committee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends committeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: committeeGroupByArgs['orderBy'] }
        : { orderBy?: committeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, committeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommitteeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the committee model
   */
  readonly fields: committeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for committee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__committeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    committee_member<T extends committee$committee_memberArgs<ExtArgs> = {}>(args?: Subset<T, committee$committee_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the committee model
   */ 
  interface committeeFieldRefs {
    readonly id: FieldRef<"committee", 'BigInt'>
    readonly gov_action_proposal_id: FieldRef<"committee", 'BigInt'>
    readonly quorum_numerator: FieldRef<"committee", 'BigInt'>
    readonly quorum_denominator: FieldRef<"committee", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * committee findUnique
   */
  export type committeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter, which committee to fetch.
     */
    where: committeeWhereUniqueInput
  }

  /**
   * committee findUniqueOrThrow
   */
  export type committeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter, which committee to fetch.
     */
    where: committeeWhereUniqueInput
  }

  /**
   * committee findFirst
   */
  export type committeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter, which committee to fetch.
     */
    where?: committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committees to fetch.
     */
    orderBy?: committeeOrderByWithRelationInput | committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committees.
     */
    cursor?: committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committees.
     */
    distinct?: CommitteeScalarFieldEnum | CommitteeScalarFieldEnum[]
  }

  /**
   * committee findFirstOrThrow
   */
  export type committeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter, which committee to fetch.
     */
    where?: committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committees to fetch.
     */
    orderBy?: committeeOrderByWithRelationInput | committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committees.
     */
    cursor?: committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committees.
     */
    distinct?: CommitteeScalarFieldEnum | CommitteeScalarFieldEnum[]
  }

  /**
   * committee findMany
   */
  export type committeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter, which committees to fetch.
     */
    where?: committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committees to fetch.
     */
    orderBy?: committeeOrderByWithRelationInput | committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing committees.
     */
    cursor?: committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committees.
     */
    skip?: number
    distinct?: CommitteeScalarFieldEnum | CommitteeScalarFieldEnum[]
  }

  /**
   * committee create
   */
  export type committeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * The data needed to create a committee.
     */
    data: XOR<committeeCreateInput, committeeUncheckedCreateInput>
  }

  /**
   * committee createMany
   */
  export type committeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many committees.
     */
    data: committeeCreateManyInput | committeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee createManyAndReturn
   */
  export type committeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * The data used to create many committees.
     */
    data: committeeCreateManyInput | committeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee update
   */
  export type committeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * The data needed to update a committee.
     */
    data: XOR<committeeUpdateInput, committeeUncheckedUpdateInput>
    /**
     * Choose, which committee to update.
     */
    where: committeeWhereUniqueInput
  }

  /**
   * committee updateMany
   */
  export type committeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update committees.
     */
    data: XOR<committeeUpdateManyMutationInput, committeeUncheckedUpdateManyInput>
    /**
     * Filter which committees to update
     */
    where?: committeeWhereInput
    /**
     * Limit how many committees to update.
     */
    limit?: number
  }

  /**
   * committee updateManyAndReturn
   */
  export type committeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * The data used to update committees.
     */
    data: XOR<committeeUpdateManyMutationInput, committeeUncheckedUpdateManyInput>
    /**
     * Filter which committees to update
     */
    where?: committeeWhereInput
    /**
     * Limit how many committees to update.
     */
    limit?: number
  }

  /**
   * committee upsert
   */
  export type committeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * The filter to search for the committee to update in case it exists.
     */
    where: committeeWhereUniqueInput
    /**
     * In case the committee found by the `where` argument doesn't exist, create a new committee with this data.
     */
    create: XOR<committeeCreateInput, committeeUncheckedCreateInput>
    /**
     * In case the committee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<committeeUpdateInput, committeeUncheckedUpdateInput>
  }

  /**
   * committee delete
   */
  export type committeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
    /**
     * Filter which committee to delete.
     */
    where: committeeWhereUniqueInput
  }

  /**
   * committee deleteMany
   */
  export type committeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committees to delete
     */
    where?: committeeWhereInput
    /**
     * Limit how many committees to delete.
     */
    limit?: number
  }

  /**
   * committee.committee_member
   */
  export type committee$committee_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    where?: committee_memberWhereInput
    orderBy?: committee_memberOrderByWithRelationInput | committee_memberOrderByWithRelationInput[]
    cursor?: committee_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Committee_memberScalarFieldEnum | Committee_memberScalarFieldEnum[]
  }

  /**
   * committee without action
   */
  export type committeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee
     */
    select?: committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee
     */
    omit?: committeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committeeInclude<ExtArgs> | null
  }


  /**
   * Model committee_de_registration
   */

  export type AggregateCommittee_de_registration = {
    _count: Committee_de_registrationCountAggregateOutputType | null
    _avg: Committee_de_registrationAvgAggregateOutputType | null
    _sum: Committee_de_registrationSumAggregateOutputType | null
    _min: Committee_de_registrationMinAggregateOutputType | null
    _max: Committee_de_registrationMaxAggregateOutputType | null
  }

  export type Committee_de_registrationAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    cert_index: number | null
    voting_anchor_id: number | null
    cold_key_id: number | null
  }

  export type Committee_de_registrationSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    voting_anchor_id: bigint | null
    cold_key_id: bigint | null
  }

  export type Committee_de_registrationMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    voting_anchor_id: bigint | null
    cold_key_id: bigint | null
  }

  export type Committee_de_registrationMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    voting_anchor_id: bigint | null
    cold_key_id: bigint | null
  }

  export type Committee_de_registrationCountAggregateOutputType = {
    id: number
    tx_id: number
    cert_index: number
    voting_anchor_id: number
    cold_key_id: number
    _all: number
  }


  export type Committee_de_registrationAvgAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    voting_anchor_id?: true
    cold_key_id?: true
  }

  export type Committee_de_registrationSumAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    voting_anchor_id?: true
    cold_key_id?: true
  }

  export type Committee_de_registrationMinAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    voting_anchor_id?: true
    cold_key_id?: true
  }

  export type Committee_de_registrationMaxAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    voting_anchor_id?: true
    cold_key_id?: true
  }

  export type Committee_de_registrationCountAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    voting_anchor_id?: true
    cold_key_id?: true
    _all?: true
  }

  export type Committee_de_registrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_de_registration to aggregate.
     */
    where?: committee_de_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_de_registrations to fetch.
     */
    orderBy?: committee_de_registrationOrderByWithRelationInput | committee_de_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: committee_de_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_de_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_de_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned committee_de_registrations
    **/
    _count?: true | Committee_de_registrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Committee_de_registrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Committee_de_registrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Committee_de_registrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Committee_de_registrationMaxAggregateInputType
  }

  export type GetCommittee_de_registrationAggregateType<T extends Committee_de_registrationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommittee_de_registration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommittee_de_registration[P]>
      : GetScalarType<T[P], AggregateCommittee_de_registration[P]>
  }




  export type committee_de_registrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committee_de_registrationWhereInput
    orderBy?: committee_de_registrationOrderByWithAggregationInput | committee_de_registrationOrderByWithAggregationInput[]
    by: Committee_de_registrationScalarFieldEnum[] | Committee_de_registrationScalarFieldEnum
    having?: committee_de_registrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Committee_de_registrationCountAggregateInputType | true
    _avg?: Committee_de_registrationAvgAggregateInputType
    _sum?: Committee_de_registrationSumAggregateInputType
    _min?: Committee_de_registrationMinAggregateInputType
    _max?: Committee_de_registrationMaxAggregateInputType
  }

  export type Committee_de_registrationGroupByOutputType = {
    id: bigint
    tx_id: bigint
    cert_index: number
    voting_anchor_id: bigint | null
    cold_key_id: bigint
    _count: Committee_de_registrationCountAggregateOutputType | null
    _avg: Committee_de_registrationAvgAggregateOutputType | null
    _sum: Committee_de_registrationSumAggregateOutputType | null
    _min: Committee_de_registrationMinAggregateOutputType | null
    _max: Committee_de_registrationMaxAggregateOutputType | null
  }

  type GetCommittee_de_registrationGroupByPayload<T extends committee_de_registrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Committee_de_registrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Committee_de_registrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Committee_de_registrationGroupByOutputType[P]>
            : GetScalarType<T[P], Committee_de_registrationGroupByOutputType[P]>
        }
      >
    >


  export type committee_de_registrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    voting_anchor_id?: boolean
    cold_key_id?: boolean
  }, ExtArgs["result"]["committee_de_registration"]>

  export type committee_de_registrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    voting_anchor_id?: boolean
    cold_key_id?: boolean
  }, ExtArgs["result"]["committee_de_registration"]>

  export type committee_de_registrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    voting_anchor_id?: boolean
    cold_key_id?: boolean
  }, ExtArgs["result"]["committee_de_registration"]>

  export type committee_de_registrationSelectScalar = {
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    voting_anchor_id?: boolean
    cold_key_id?: boolean
  }

  export type committee_de_registrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "cert_index" | "voting_anchor_id" | "cold_key_id", ExtArgs["result"]["committee_de_registration"]>

  export type $committee_de_registrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "committee_de_registration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      cert_index: number
      voting_anchor_id: bigint | null
      cold_key_id: bigint
    }, ExtArgs["result"]["committee_de_registration"]>
    composites: {}
  }

  type committee_de_registrationGetPayload<S extends boolean | null | undefined | committee_de_registrationDefaultArgs> = $Result.GetResult<Prisma.$committee_de_registrationPayload, S>

  type committee_de_registrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<committee_de_registrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Committee_de_registrationCountAggregateInputType | true
    }

  export interface committee_de_registrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['committee_de_registration'], meta: { name: 'committee_de_registration' } }
    /**
     * Find zero or one Committee_de_registration that matches the filter.
     * @param {committee_de_registrationFindUniqueArgs} args - Arguments to find a Committee_de_registration
     * @example
     * // Get one Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends committee_de_registrationFindUniqueArgs>(args: SelectSubset<T, committee_de_registrationFindUniqueArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Committee_de_registration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {committee_de_registrationFindUniqueOrThrowArgs} args - Arguments to find a Committee_de_registration
     * @example
     * // Get one Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends committee_de_registrationFindUniqueOrThrowArgs>(args: SelectSubset<T, committee_de_registrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_de_registration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationFindFirstArgs} args - Arguments to find a Committee_de_registration
     * @example
     * // Get one Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends committee_de_registrationFindFirstArgs>(args?: SelectSubset<T, committee_de_registrationFindFirstArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_de_registration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationFindFirstOrThrowArgs} args - Arguments to find a Committee_de_registration
     * @example
     * // Get one Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends committee_de_registrationFindFirstOrThrowArgs>(args?: SelectSubset<T, committee_de_registrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Committee_de_registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Committee_de_registrations
     * const committee_de_registrations = await prisma.committee_de_registration.findMany()
     * 
     * // Get first 10 Committee_de_registrations
     * const committee_de_registrations = await prisma.committee_de_registration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committee_de_registrationWithIdOnly = await prisma.committee_de_registration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends committee_de_registrationFindManyArgs>(args?: SelectSubset<T, committee_de_registrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Committee_de_registration.
     * @param {committee_de_registrationCreateArgs} args - Arguments to create a Committee_de_registration.
     * @example
     * // Create one Committee_de_registration
     * const Committee_de_registration = await prisma.committee_de_registration.create({
     *   data: {
     *     // ... data to create a Committee_de_registration
     *   }
     * })
     * 
     */
    create<T extends committee_de_registrationCreateArgs>(args: SelectSubset<T, committee_de_registrationCreateArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Committee_de_registrations.
     * @param {committee_de_registrationCreateManyArgs} args - Arguments to create many Committee_de_registrations.
     * @example
     * // Create many Committee_de_registrations
     * const committee_de_registration = await prisma.committee_de_registration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends committee_de_registrationCreateManyArgs>(args?: SelectSubset<T, committee_de_registrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Committee_de_registrations and returns the data saved in the database.
     * @param {committee_de_registrationCreateManyAndReturnArgs} args - Arguments to create many Committee_de_registrations.
     * @example
     * // Create many Committee_de_registrations
     * const committee_de_registration = await prisma.committee_de_registration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Committee_de_registrations and only return the `id`
     * const committee_de_registrationWithIdOnly = await prisma.committee_de_registration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends committee_de_registrationCreateManyAndReturnArgs>(args?: SelectSubset<T, committee_de_registrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Committee_de_registration.
     * @param {committee_de_registrationDeleteArgs} args - Arguments to delete one Committee_de_registration.
     * @example
     * // Delete one Committee_de_registration
     * const Committee_de_registration = await prisma.committee_de_registration.delete({
     *   where: {
     *     // ... filter to delete one Committee_de_registration
     *   }
     * })
     * 
     */
    delete<T extends committee_de_registrationDeleteArgs>(args: SelectSubset<T, committee_de_registrationDeleteArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Committee_de_registration.
     * @param {committee_de_registrationUpdateArgs} args - Arguments to update one Committee_de_registration.
     * @example
     * // Update one Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends committee_de_registrationUpdateArgs>(args: SelectSubset<T, committee_de_registrationUpdateArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Committee_de_registrations.
     * @param {committee_de_registrationDeleteManyArgs} args - Arguments to filter Committee_de_registrations to delete.
     * @example
     * // Delete a few Committee_de_registrations
     * const { count } = await prisma.committee_de_registration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends committee_de_registrationDeleteManyArgs>(args?: SelectSubset<T, committee_de_registrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_de_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Committee_de_registrations
     * const committee_de_registration = await prisma.committee_de_registration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends committee_de_registrationUpdateManyArgs>(args: SelectSubset<T, committee_de_registrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_de_registrations and returns the data updated in the database.
     * @param {committee_de_registrationUpdateManyAndReturnArgs} args - Arguments to update many Committee_de_registrations.
     * @example
     * // Update many Committee_de_registrations
     * const committee_de_registration = await prisma.committee_de_registration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Committee_de_registrations and only return the `id`
     * const committee_de_registrationWithIdOnly = await prisma.committee_de_registration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends committee_de_registrationUpdateManyAndReturnArgs>(args: SelectSubset<T, committee_de_registrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Committee_de_registration.
     * @param {committee_de_registrationUpsertArgs} args - Arguments to update or create a Committee_de_registration.
     * @example
     * // Update or create a Committee_de_registration
     * const committee_de_registration = await prisma.committee_de_registration.upsert({
     *   create: {
     *     // ... data to create a Committee_de_registration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Committee_de_registration we want to update
     *   }
     * })
     */
    upsert<T extends committee_de_registrationUpsertArgs>(args: SelectSubset<T, committee_de_registrationUpsertArgs<ExtArgs>>): Prisma__committee_de_registrationClient<$Result.GetResult<Prisma.$committee_de_registrationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Committee_de_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationCountArgs} args - Arguments to filter Committee_de_registrations to count.
     * @example
     * // Count the number of Committee_de_registrations
     * const count = await prisma.committee_de_registration.count({
     *   where: {
     *     // ... the filter for the Committee_de_registrations we want to count
     *   }
     * })
    **/
    count<T extends committee_de_registrationCountArgs>(
      args?: Subset<T, committee_de_registrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Committee_de_registrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Committee_de_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Committee_de_registrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Committee_de_registrationAggregateArgs>(args: Subset<T, Committee_de_registrationAggregateArgs>): Prisma.PrismaPromise<GetCommittee_de_registrationAggregateType<T>>

    /**
     * Group by Committee_de_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_de_registrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends committee_de_registrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: committee_de_registrationGroupByArgs['orderBy'] }
        : { orderBy?: committee_de_registrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, committee_de_registrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommittee_de_registrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the committee_de_registration model
   */
  readonly fields: committee_de_registrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for committee_de_registration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__committee_de_registrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the committee_de_registration model
   */ 
  interface committee_de_registrationFieldRefs {
    readonly id: FieldRef<"committee_de_registration", 'BigInt'>
    readonly tx_id: FieldRef<"committee_de_registration", 'BigInt'>
    readonly cert_index: FieldRef<"committee_de_registration", 'Int'>
    readonly voting_anchor_id: FieldRef<"committee_de_registration", 'BigInt'>
    readonly cold_key_id: FieldRef<"committee_de_registration", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * committee_de_registration findUnique
   */
  export type committee_de_registrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_de_registration to fetch.
     */
    where: committee_de_registrationWhereUniqueInput
  }

  /**
   * committee_de_registration findUniqueOrThrow
   */
  export type committee_de_registrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_de_registration to fetch.
     */
    where: committee_de_registrationWhereUniqueInput
  }

  /**
   * committee_de_registration findFirst
   */
  export type committee_de_registrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_de_registration to fetch.
     */
    where?: committee_de_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_de_registrations to fetch.
     */
    orderBy?: committee_de_registrationOrderByWithRelationInput | committee_de_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_de_registrations.
     */
    cursor?: committee_de_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_de_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_de_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_de_registrations.
     */
    distinct?: Committee_de_registrationScalarFieldEnum | Committee_de_registrationScalarFieldEnum[]
  }

  /**
   * committee_de_registration findFirstOrThrow
   */
  export type committee_de_registrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_de_registration to fetch.
     */
    where?: committee_de_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_de_registrations to fetch.
     */
    orderBy?: committee_de_registrationOrderByWithRelationInput | committee_de_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_de_registrations.
     */
    cursor?: committee_de_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_de_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_de_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_de_registrations.
     */
    distinct?: Committee_de_registrationScalarFieldEnum | Committee_de_registrationScalarFieldEnum[]
  }

  /**
   * committee_de_registration findMany
   */
  export type committee_de_registrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_de_registrations to fetch.
     */
    where?: committee_de_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_de_registrations to fetch.
     */
    orderBy?: committee_de_registrationOrderByWithRelationInput | committee_de_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing committee_de_registrations.
     */
    cursor?: committee_de_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_de_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_de_registrations.
     */
    skip?: number
    distinct?: Committee_de_registrationScalarFieldEnum | Committee_de_registrationScalarFieldEnum[]
  }

  /**
   * committee_de_registration create
   */
  export type committee_de_registrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * The data needed to create a committee_de_registration.
     */
    data: XOR<committee_de_registrationCreateInput, committee_de_registrationUncheckedCreateInput>
  }

  /**
   * committee_de_registration createMany
   */
  export type committee_de_registrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many committee_de_registrations.
     */
    data: committee_de_registrationCreateManyInput | committee_de_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_de_registration createManyAndReturn
   */
  export type committee_de_registrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * The data used to create many committee_de_registrations.
     */
    data: committee_de_registrationCreateManyInput | committee_de_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_de_registration update
   */
  export type committee_de_registrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * The data needed to update a committee_de_registration.
     */
    data: XOR<committee_de_registrationUpdateInput, committee_de_registrationUncheckedUpdateInput>
    /**
     * Choose, which committee_de_registration to update.
     */
    where: committee_de_registrationWhereUniqueInput
  }

  /**
   * committee_de_registration updateMany
   */
  export type committee_de_registrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update committee_de_registrations.
     */
    data: XOR<committee_de_registrationUpdateManyMutationInput, committee_de_registrationUncheckedUpdateManyInput>
    /**
     * Filter which committee_de_registrations to update
     */
    where?: committee_de_registrationWhereInput
    /**
     * Limit how many committee_de_registrations to update.
     */
    limit?: number
  }

  /**
   * committee_de_registration updateManyAndReturn
   */
  export type committee_de_registrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * The data used to update committee_de_registrations.
     */
    data: XOR<committee_de_registrationUpdateManyMutationInput, committee_de_registrationUncheckedUpdateManyInput>
    /**
     * Filter which committee_de_registrations to update
     */
    where?: committee_de_registrationWhereInput
    /**
     * Limit how many committee_de_registrations to update.
     */
    limit?: number
  }

  /**
   * committee_de_registration upsert
   */
  export type committee_de_registrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * The filter to search for the committee_de_registration to update in case it exists.
     */
    where: committee_de_registrationWhereUniqueInput
    /**
     * In case the committee_de_registration found by the `where` argument doesn't exist, create a new committee_de_registration with this data.
     */
    create: XOR<committee_de_registrationCreateInput, committee_de_registrationUncheckedCreateInput>
    /**
     * In case the committee_de_registration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<committee_de_registrationUpdateInput, committee_de_registrationUncheckedUpdateInput>
  }

  /**
   * committee_de_registration delete
   */
  export type committee_de_registrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
    /**
     * Filter which committee_de_registration to delete.
     */
    where: committee_de_registrationWhereUniqueInput
  }

  /**
   * committee_de_registration deleteMany
   */
  export type committee_de_registrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_de_registrations to delete
     */
    where?: committee_de_registrationWhereInput
    /**
     * Limit how many committee_de_registrations to delete.
     */
    limit?: number
  }

  /**
   * committee_de_registration without action
   */
  export type committee_de_registrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_de_registration
     */
    select?: committee_de_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_de_registration
     */
    omit?: committee_de_registrationOmit<ExtArgs> | null
  }


  /**
   * Model committee_hash
   */

  export type AggregateCommittee_hash = {
    _count: Committee_hashCountAggregateOutputType | null
    _avg: Committee_hashAvgAggregateOutputType | null
    _sum: Committee_hashSumAggregateOutputType | null
    _min: Committee_hashMinAggregateOutputType | null
    _max: Committee_hashMaxAggregateOutputType | null
  }

  export type Committee_hashAvgAggregateOutputType = {
    id: number | null
  }

  export type Committee_hashSumAggregateOutputType = {
    id: bigint | null
  }

  export type Committee_hashMinAggregateOutputType = {
    id: bigint | null
    raw: Uint8Array | null
    has_script: boolean | null
  }

  export type Committee_hashMaxAggregateOutputType = {
    id: bigint | null
    raw: Uint8Array | null
    has_script: boolean | null
  }

  export type Committee_hashCountAggregateOutputType = {
    id: number
    raw: number
    has_script: number
    _all: number
  }


  export type Committee_hashAvgAggregateInputType = {
    id?: true
  }

  export type Committee_hashSumAggregateInputType = {
    id?: true
  }

  export type Committee_hashMinAggregateInputType = {
    id?: true
    raw?: true
    has_script?: true
  }

  export type Committee_hashMaxAggregateInputType = {
    id?: true
    raw?: true
    has_script?: true
  }

  export type Committee_hashCountAggregateInputType = {
    id?: true
    raw?: true
    has_script?: true
    _all?: true
  }

  export type Committee_hashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_hash to aggregate.
     */
    where?: committee_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_hashes to fetch.
     */
    orderBy?: committee_hashOrderByWithRelationInput | committee_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: committee_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned committee_hashes
    **/
    _count?: true | Committee_hashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Committee_hashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Committee_hashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Committee_hashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Committee_hashMaxAggregateInputType
  }

  export type GetCommittee_hashAggregateType<T extends Committee_hashAggregateArgs> = {
        [P in keyof T & keyof AggregateCommittee_hash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommittee_hash[P]>
      : GetScalarType<T[P], AggregateCommittee_hash[P]>
  }




  export type committee_hashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committee_hashWhereInput
    orderBy?: committee_hashOrderByWithAggregationInput | committee_hashOrderByWithAggregationInput[]
    by: Committee_hashScalarFieldEnum[] | Committee_hashScalarFieldEnum
    having?: committee_hashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Committee_hashCountAggregateInputType | true
    _avg?: Committee_hashAvgAggregateInputType
    _sum?: Committee_hashSumAggregateInputType
    _min?: Committee_hashMinAggregateInputType
    _max?: Committee_hashMaxAggregateInputType
  }

  export type Committee_hashGroupByOutputType = {
    id: bigint
    raw: Uint8Array
    has_script: boolean
    _count: Committee_hashCountAggregateOutputType | null
    _avg: Committee_hashAvgAggregateOutputType | null
    _sum: Committee_hashSumAggregateOutputType | null
    _min: Committee_hashMinAggregateOutputType | null
    _max: Committee_hashMaxAggregateOutputType | null
  }

  type GetCommittee_hashGroupByPayload<T extends committee_hashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Committee_hashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Committee_hashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Committee_hashGroupByOutputType[P]>
            : GetScalarType<T[P], Committee_hashGroupByOutputType[P]>
        }
      >
    >


  export type committee_hashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["committee_hash"]>

  export type committee_hashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["committee_hash"]>

  export type committee_hashSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["committee_hash"]>

  export type committee_hashSelectScalar = {
    id?: boolean
    raw?: boolean
    has_script?: boolean
  }

  export type committee_hashOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raw" | "has_script", ExtArgs["result"]["committee_hash"]>

  export type $committee_hashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "committee_hash"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      raw: Uint8Array
      has_script: boolean
    }, ExtArgs["result"]["committee_hash"]>
    composites: {}
  }

  type committee_hashGetPayload<S extends boolean | null | undefined | committee_hashDefaultArgs> = $Result.GetResult<Prisma.$committee_hashPayload, S>

  type committee_hashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<committee_hashFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Committee_hashCountAggregateInputType | true
    }

  export interface committee_hashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['committee_hash'], meta: { name: 'committee_hash' } }
    /**
     * Find zero or one Committee_hash that matches the filter.
     * @param {committee_hashFindUniqueArgs} args - Arguments to find a Committee_hash
     * @example
     * // Get one Committee_hash
     * const committee_hash = await prisma.committee_hash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends committee_hashFindUniqueArgs>(args: SelectSubset<T, committee_hashFindUniqueArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Committee_hash that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {committee_hashFindUniqueOrThrowArgs} args - Arguments to find a Committee_hash
     * @example
     * // Get one Committee_hash
     * const committee_hash = await prisma.committee_hash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends committee_hashFindUniqueOrThrowArgs>(args: SelectSubset<T, committee_hashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_hash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashFindFirstArgs} args - Arguments to find a Committee_hash
     * @example
     * // Get one Committee_hash
     * const committee_hash = await prisma.committee_hash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends committee_hashFindFirstArgs>(args?: SelectSubset<T, committee_hashFindFirstArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_hash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashFindFirstOrThrowArgs} args - Arguments to find a Committee_hash
     * @example
     * // Get one Committee_hash
     * const committee_hash = await prisma.committee_hash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends committee_hashFindFirstOrThrowArgs>(args?: SelectSubset<T, committee_hashFindFirstOrThrowArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Committee_hashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Committee_hashes
     * const committee_hashes = await prisma.committee_hash.findMany()
     * 
     * // Get first 10 Committee_hashes
     * const committee_hashes = await prisma.committee_hash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committee_hashWithIdOnly = await prisma.committee_hash.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends committee_hashFindManyArgs>(args?: SelectSubset<T, committee_hashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Committee_hash.
     * @param {committee_hashCreateArgs} args - Arguments to create a Committee_hash.
     * @example
     * // Create one Committee_hash
     * const Committee_hash = await prisma.committee_hash.create({
     *   data: {
     *     // ... data to create a Committee_hash
     *   }
     * })
     * 
     */
    create<T extends committee_hashCreateArgs>(args: SelectSubset<T, committee_hashCreateArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Committee_hashes.
     * @param {committee_hashCreateManyArgs} args - Arguments to create many Committee_hashes.
     * @example
     * // Create many Committee_hashes
     * const committee_hash = await prisma.committee_hash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends committee_hashCreateManyArgs>(args?: SelectSubset<T, committee_hashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Committee_hashes and returns the data saved in the database.
     * @param {committee_hashCreateManyAndReturnArgs} args - Arguments to create many Committee_hashes.
     * @example
     * // Create many Committee_hashes
     * const committee_hash = await prisma.committee_hash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Committee_hashes and only return the `id`
     * const committee_hashWithIdOnly = await prisma.committee_hash.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends committee_hashCreateManyAndReturnArgs>(args?: SelectSubset<T, committee_hashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Committee_hash.
     * @param {committee_hashDeleteArgs} args - Arguments to delete one Committee_hash.
     * @example
     * // Delete one Committee_hash
     * const Committee_hash = await prisma.committee_hash.delete({
     *   where: {
     *     // ... filter to delete one Committee_hash
     *   }
     * })
     * 
     */
    delete<T extends committee_hashDeleteArgs>(args: SelectSubset<T, committee_hashDeleteArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Committee_hash.
     * @param {committee_hashUpdateArgs} args - Arguments to update one Committee_hash.
     * @example
     * // Update one Committee_hash
     * const committee_hash = await prisma.committee_hash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends committee_hashUpdateArgs>(args: SelectSubset<T, committee_hashUpdateArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Committee_hashes.
     * @param {committee_hashDeleteManyArgs} args - Arguments to filter Committee_hashes to delete.
     * @example
     * // Delete a few Committee_hashes
     * const { count } = await prisma.committee_hash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends committee_hashDeleteManyArgs>(args?: SelectSubset<T, committee_hashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Committee_hashes
     * const committee_hash = await prisma.committee_hash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends committee_hashUpdateManyArgs>(args: SelectSubset<T, committee_hashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_hashes and returns the data updated in the database.
     * @param {committee_hashUpdateManyAndReturnArgs} args - Arguments to update many Committee_hashes.
     * @example
     * // Update many Committee_hashes
     * const committee_hash = await prisma.committee_hash.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Committee_hashes and only return the `id`
     * const committee_hashWithIdOnly = await prisma.committee_hash.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends committee_hashUpdateManyAndReturnArgs>(args: SelectSubset<T, committee_hashUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Committee_hash.
     * @param {committee_hashUpsertArgs} args - Arguments to update or create a Committee_hash.
     * @example
     * // Update or create a Committee_hash
     * const committee_hash = await prisma.committee_hash.upsert({
     *   create: {
     *     // ... data to create a Committee_hash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Committee_hash we want to update
     *   }
     * })
     */
    upsert<T extends committee_hashUpsertArgs>(args: SelectSubset<T, committee_hashUpsertArgs<ExtArgs>>): Prisma__committee_hashClient<$Result.GetResult<Prisma.$committee_hashPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Committee_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashCountArgs} args - Arguments to filter Committee_hashes to count.
     * @example
     * // Count the number of Committee_hashes
     * const count = await prisma.committee_hash.count({
     *   where: {
     *     // ... the filter for the Committee_hashes we want to count
     *   }
     * })
    **/
    count<T extends committee_hashCountArgs>(
      args?: Subset<T, committee_hashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Committee_hashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Committee_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Committee_hashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Committee_hashAggregateArgs>(args: Subset<T, Committee_hashAggregateArgs>): Prisma.PrismaPromise<GetCommittee_hashAggregateType<T>>

    /**
     * Group by Committee_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_hashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends committee_hashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: committee_hashGroupByArgs['orderBy'] }
        : { orderBy?: committee_hashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, committee_hashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommittee_hashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the committee_hash model
   */
  readonly fields: committee_hashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for committee_hash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__committee_hashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the committee_hash model
   */ 
  interface committee_hashFieldRefs {
    readonly id: FieldRef<"committee_hash", 'BigInt'>
    readonly raw: FieldRef<"committee_hash", 'Bytes'>
    readonly has_script: FieldRef<"committee_hash", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * committee_hash findUnique
   */
  export type committee_hashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter, which committee_hash to fetch.
     */
    where: committee_hashWhereUniqueInput
  }

  /**
   * committee_hash findUniqueOrThrow
   */
  export type committee_hashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter, which committee_hash to fetch.
     */
    where: committee_hashWhereUniqueInput
  }

  /**
   * committee_hash findFirst
   */
  export type committee_hashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter, which committee_hash to fetch.
     */
    where?: committee_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_hashes to fetch.
     */
    orderBy?: committee_hashOrderByWithRelationInput | committee_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_hashes.
     */
    cursor?: committee_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_hashes.
     */
    distinct?: Committee_hashScalarFieldEnum | Committee_hashScalarFieldEnum[]
  }

  /**
   * committee_hash findFirstOrThrow
   */
  export type committee_hashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter, which committee_hash to fetch.
     */
    where?: committee_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_hashes to fetch.
     */
    orderBy?: committee_hashOrderByWithRelationInput | committee_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_hashes.
     */
    cursor?: committee_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_hashes.
     */
    distinct?: Committee_hashScalarFieldEnum | Committee_hashScalarFieldEnum[]
  }

  /**
   * committee_hash findMany
   */
  export type committee_hashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter, which committee_hashes to fetch.
     */
    where?: committee_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_hashes to fetch.
     */
    orderBy?: committee_hashOrderByWithRelationInput | committee_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing committee_hashes.
     */
    cursor?: committee_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_hashes.
     */
    skip?: number
    distinct?: Committee_hashScalarFieldEnum | Committee_hashScalarFieldEnum[]
  }

  /**
   * committee_hash create
   */
  export type committee_hashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * The data needed to create a committee_hash.
     */
    data: XOR<committee_hashCreateInput, committee_hashUncheckedCreateInput>
  }

  /**
   * committee_hash createMany
   */
  export type committee_hashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many committee_hashes.
     */
    data: committee_hashCreateManyInput | committee_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_hash createManyAndReturn
   */
  export type committee_hashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * The data used to create many committee_hashes.
     */
    data: committee_hashCreateManyInput | committee_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_hash update
   */
  export type committee_hashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * The data needed to update a committee_hash.
     */
    data: XOR<committee_hashUpdateInput, committee_hashUncheckedUpdateInput>
    /**
     * Choose, which committee_hash to update.
     */
    where: committee_hashWhereUniqueInput
  }

  /**
   * committee_hash updateMany
   */
  export type committee_hashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update committee_hashes.
     */
    data: XOR<committee_hashUpdateManyMutationInput, committee_hashUncheckedUpdateManyInput>
    /**
     * Filter which committee_hashes to update
     */
    where?: committee_hashWhereInput
    /**
     * Limit how many committee_hashes to update.
     */
    limit?: number
  }

  /**
   * committee_hash updateManyAndReturn
   */
  export type committee_hashUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * The data used to update committee_hashes.
     */
    data: XOR<committee_hashUpdateManyMutationInput, committee_hashUncheckedUpdateManyInput>
    /**
     * Filter which committee_hashes to update
     */
    where?: committee_hashWhereInput
    /**
     * Limit how many committee_hashes to update.
     */
    limit?: number
  }

  /**
   * committee_hash upsert
   */
  export type committee_hashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * The filter to search for the committee_hash to update in case it exists.
     */
    where: committee_hashWhereUniqueInput
    /**
     * In case the committee_hash found by the `where` argument doesn't exist, create a new committee_hash with this data.
     */
    create: XOR<committee_hashCreateInput, committee_hashUncheckedCreateInput>
    /**
     * In case the committee_hash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<committee_hashUpdateInput, committee_hashUncheckedUpdateInput>
  }

  /**
   * committee_hash delete
   */
  export type committee_hashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
    /**
     * Filter which committee_hash to delete.
     */
    where: committee_hashWhereUniqueInput
  }

  /**
   * committee_hash deleteMany
   */
  export type committee_hashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_hashes to delete
     */
    where?: committee_hashWhereInput
    /**
     * Limit how many committee_hashes to delete.
     */
    limit?: number
  }

  /**
   * committee_hash without action
   */
  export type committee_hashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_hash
     */
    select?: committee_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_hash
     */
    omit?: committee_hashOmit<ExtArgs> | null
  }


  /**
   * Model committee_member
   */

  export type AggregateCommittee_member = {
    _count: Committee_memberCountAggregateOutputType | null
    _avg: Committee_memberAvgAggregateOutputType | null
    _sum: Committee_memberSumAggregateOutputType | null
    _min: Committee_memberMinAggregateOutputType | null
    _max: Committee_memberMaxAggregateOutputType | null
  }

  export type Committee_memberAvgAggregateOutputType = {
    id: number | null
    committee_id: number | null
    committee_hash_id: number | null
    expiration_epoch: number | null
  }

  export type Committee_memberSumAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    committee_hash_id: bigint | null
    expiration_epoch: number | null
  }

  export type Committee_memberMinAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    committee_hash_id: bigint | null
    expiration_epoch: number | null
  }

  export type Committee_memberMaxAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    committee_hash_id: bigint | null
    expiration_epoch: number | null
  }

  export type Committee_memberCountAggregateOutputType = {
    id: number
    committee_id: number
    committee_hash_id: number
    expiration_epoch: number
    _all: number
  }


  export type Committee_memberAvgAggregateInputType = {
    id?: true
    committee_id?: true
    committee_hash_id?: true
    expiration_epoch?: true
  }

  export type Committee_memberSumAggregateInputType = {
    id?: true
    committee_id?: true
    committee_hash_id?: true
    expiration_epoch?: true
  }

  export type Committee_memberMinAggregateInputType = {
    id?: true
    committee_id?: true
    committee_hash_id?: true
    expiration_epoch?: true
  }

  export type Committee_memberMaxAggregateInputType = {
    id?: true
    committee_id?: true
    committee_hash_id?: true
    expiration_epoch?: true
  }

  export type Committee_memberCountAggregateInputType = {
    id?: true
    committee_id?: true
    committee_hash_id?: true
    expiration_epoch?: true
    _all?: true
  }

  export type Committee_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_member to aggregate.
     */
    where?: committee_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_members to fetch.
     */
    orderBy?: committee_memberOrderByWithRelationInput | committee_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: committee_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned committee_members
    **/
    _count?: true | Committee_memberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Committee_memberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Committee_memberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Committee_memberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Committee_memberMaxAggregateInputType
  }

  export type GetCommittee_memberAggregateType<T extends Committee_memberAggregateArgs> = {
        [P in keyof T & keyof AggregateCommittee_member]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommittee_member[P]>
      : GetScalarType<T[P], AggregateCommittee_member[P]>
  }




  export type committee_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committee_memberWhereInput
    orderBy?: committee_memberOrderByWithAggregationInput | committee_memberOrderByWithAggregationInput[]
    by: Committee_memberScalarFieldEnum[] | Committee_memberScalarFieldEnum
    having?: committee_memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Committee_memberCountAggregateInputType | true
    _avg?: Committee_memberAvgAggregateInputType
    _sum?: Committee_memberSumAggregateInputType
    _min?: Committee_memberMinAggregateInputType
    _max?: Committee_memberMaxAggregateInputType
  }

  export type Committee_memberGroupByOutputType = {
    id: bigint
    committee_id: bigint
    committee_hash_id: bigint
    expiration_epoch: number
    _count: Committee_memberCountAggregateOutputType | null
    _avg: Committee_memberAvgAggregateOutputType | null
    _sum: Committee_memberSumAggregateOutputType | null
    _min: Committee_memberMinAggregateOutputType | null
    _max: Committee_memberMaxAggregateOutputType | null
  }

  type GetCommittee_memberGroupByPayload<T extends committee_memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Committee_memberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Committee_memberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Committee_memberGroupByOutputType[P]>
            : GetScalarType<T[P], Committee_memberGroupByOutputType[P]>
        }
      >
    >


  export type committee_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    committee_hash_id?: boolean
    expiration_epoch?: boolean
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["committee_member"]>

  export type committee_memberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    committee_hash_id?: boolean
    expiration_epoch?: boolean
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["committee_member"]>

  export type committee_memberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    committee_hash_id?: boolean
    expiration_epoch?: boolean
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["committee_member"]>

  export type committee_memberSelectScalar = {
    id?: boolean
    committee_id?: boolean
    committee_hash_id?: boolean
    expiration_epoch?: boolean
  }

  export type committee_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "committee_id" | "committee_hash_id" | "expiration_epoch", ExtArgs["result"]["committee_member"]>
  export type committee_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }
  export type committee_memberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }
  export type committee_memberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    committee?: boolean | committeeDefaultArgs<ExtArgs>
  }

  export type $committee_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "committee_member"
    objects: {
      committee: Prisma.$committeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      committee_id: bigint
      committee_hash_id: bigint
      expiration_epoch: number
    }, ExtArgs["result"]["committee_member"]>
    composites: {}
  }

  type committee_memberGetPayload<S extends boolean | null | undefined | committee_memberDefaultArgs> = $Result.GetResult<Prisma.$committee_memberPayload, S>

  type committee_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<committee_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Committee_memberCountAggregateInputType | true
    }

  export interface committee_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['committee_member'], meta: { name: 'committee_member' } }
    /**
     * Find zero or one Committee_member that matches the filter.
     * @param {committee_memberFindUniqueArgs} args - Arguments to find a Committee_member
     * @example
     * // Get one Committee_member
     * const committee_member = await prisma.committee_member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends committee_memberFindUniqueArgs>(args: SelectSubset<T, committee_memberFindUniqueArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Committee_member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {committee_memberFindUniqueOrThrowArgs} args - Arguments to find a Committee_member
     * @example
     * // Get one Committee_member
     * const committee_member = await prisma.committee_member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends committee_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, committee_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberFindFirstArgs} args - Arguments to find a Committee_member
     * @example
     * // Get one Committee_member
     * const committee_member = await prisma.committee_member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends committee_memberFindFirstArgs>(args?: SelectSubset<T, committee_memberFindFirstArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberFindFirstOrThrowArgs} args - Arguments to find a Committee_member
     * @example
     * // Get one Committee_member
     * const committee_member = await prisma.committee_member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends committee_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, committee_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Committee_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Committee_members
     * const committee_members = await prisma.committee_member.findMany()
     * 
     * // Get first 10 Committee_members
     * const committee_members = await prisma.committee_member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committee_memberWithIdOnly = await prisma.committee_member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends committee_memberFindManyArgs>(args?: SelectSubset<T, committee_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Committee_member.
     * @param {committee_memberCreateArgs} args - Arguments to create a Committee_member.
     * @example
     * // Create one Committee_member
     * const Committee_member = await prisma.committee_member.create({
     *   data: {
     *     // ... data to create a Committee_member
     *   }
     * })
     * 
     */
    create<T extends committee_memberCreateArgs>(args: SelectSubset<T, committee_memberCreateArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Committee_members.
     * @param {committee_memberCreateManyArgs} args - Arguments to create many Committee_members.
     * @example
     * // Create many Committee_members
     * const committee_member = await prisma.committee_member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends committee_memberCreateManyArgs>(args?: SelectSubset<T, committee_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Committee_members and returns the data saved in the database.
     * @param {committee_memberCreateManyAndReturnArgs} args - Arguments to create many Committee_members.
     * @example
     * // Create many Committee_members
     * const committee_member = await prisma.committee_member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Committee_members and only return the `id`
     * const committee_memberWithIdOnly = await prisma.committee_member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends committee_memberCreateManyAndReturnArgs>(args?: SelectSubset<T, committee_memberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Committee_member.
     * @param {committee_memberDeleteArgs} args - Arguments to delete one Committee_member.
     * @example
     * // Delete one Committee_member
     * const Committee_member = await prisma.committee_member.delete({
     *   where: {
     *     // ... filter to delete one Committee_member
     *   }
     * })
     * 
     */
    delete<T extends committee_memberDeleteArgs>(args: SelectSubset<T, committee_memberDeleteArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Committee_member.
     * @param {committee_memberUpdateArgs} args - Arguments to update one Committee_member.
     * @example
     * // Update one Committee_member
     * const committee_member = await prisma.committee_member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends committee_memberUpdateArgs>(args: SelectSubset<T, committee_memberUpdateArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Committee_members.
     * @param {committee_memberDeleteManyArgs} args - Arguments to filter Committee_members to delete.
     * @example
     * // Delete a few Committee_members
     * const { count } = await prisma.committee_member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends committee_memberDeleteManyArgs>(args?: SelectSubset<T, committee_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Committee_members
     * const committee_member = await prisma.committee_member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends committee_memberUpdateManyArgs>(args: SelectSubset<T, committee_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_members and returns the data updated in the database.
     * @param {committee_memberUpdateManyAndReturnArgs} args - Arguments to update many Committee_members.
     * @example
     * // Update many Committee_members
     * const committee_member = await prisma.committee_member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Committee_members and only return the `id`
     * const committee_memberWithIdOnly = await prisma.committee_member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends committee_memberUpdateManyAndReturnArgs>(args: SelectSubset<T, committee_memberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Committee_member.
     * @param {committee_memberUpsertArgs} args - Arguments to update or create a Committee_member.
     * @example
     * // Update or create a Committee_member
     * const committee_member = await prisma.committee_member.upsert({
     *   create: {
     *     // ... data to create a Committee_member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Committee_member we want to update
     *   }
     * })
     */
    upsert<T extends committee_memberUpsertArgs>(args: SelectSubset<T, committee_memberUpsertArgs<ExtArgs>>): Prisma__committee_memberClient<$Result.GetResult<Prisma.$committee_memberPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Committee_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberCountArgs} args - Arguments to filter Committee_members to count.
     * @example
     * // Count the number of Committee_members
     * const count = await prisma.committee_member.count({
     *   where: {
     *     // ... the filter for the Committee_members we want to count
     *   }
     * })
    **/
    count<T extends committee_memberCountArgs>(
      args?: Subset<T, committee_memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Committee_memberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Committee_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Committee_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Committee_memberAggregateArgs>(args: Subset<T, Committee_memberAggregateArgs>): Prisma.PrismaPromise<GetCommittee_memberAggregateType<T>>

    /**
     * Group by Committee_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends committee_memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: committee_memberGroupByArgs['orderBy'] }
        : { orderBy?: committee_memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, committee_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommittee_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the committee_member model
   */
  readonly fields: committee_memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for committee_member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__committee_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    committee<T extends committeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, committeeDefaultArgs<ExtArgs>>): Prisma__committeeClient<$Result.GetResult<Prisma.$committeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the committee_member model
   */ 
  interface committee_memberFieldRefs {
    readonly id: FieldRef<"committee_member", 'BigInt'>
    readonly committee_id: FieldRef<"committee_member", 'BigInt'>
    readonly committee_hash_id: FieldRef<"committee_member", 'BigInt'>
    readonly expiration_epoch: FieldRef<"committee_member", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * committee_member findUnique
   */
  export type committee_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter, which committee_member to fetch.
     */
    where: committee_memberWhereUniqueInput
  }

  /**
   * committee_member findUniqueOrThrow
   */
  export type committee_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter, which committee_member to fetch.
     */
    where: committee_memberWhereUniqueInput
  }

  /**
   * committee_member findFirst
   */
  export type committee_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter, which committee_member to fetch.
     */
    where?: committee_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_members to fetch.
     */
    orderBy?: committee_memberOrderByWithRelationInput | committee_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_members.
     */
    cursor?: committee_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_members.
     */
    distinct?: Committee_memberScalarFieldEnum | Committee_memberScalarFieldEnum[]
  }

  /**
   * committee_member findFirstOrThrow
   */
  export type committee_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter, which committee_member to fetch.
     */
    where?: committee_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_members to fetch.
     */
    orderBy?: committee_memberOrderByWithRelationInput | committee_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_members.
     */
    cursor?: committee_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_members.
     */
    distinct?: Committee_memberScalarFieldEnum | Committee_memberScalarFieldEnum[]
  }

  /**
   * committee_member findMany
   */
  export type committee_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter, which committee_members to fetch.
     */
    where?: committee_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_members to fetch.
     */
    orderBy?: committee_memberOrderByWithRelationInput | committee_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing committee_members.
     */
    cursor?: committee_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_members.
     */
    skip?: number
    distinct?: Committee_memberScalarFieldEnum | Committee_memberScalarFieldEnum[]
  }

  /**
   * committee_member create
   */
  export type committee_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * The data needed to create a committee_member.
     */
    data: XOR<committee_memberCreateInput, committee_memberUncheckedCreateInput>
  }

  /**
   * committee_member createMany
   */
  export type committee_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many committee_members.
     */
    data: committee_memberCreateManyInput | committee_memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_member createManyAndReturn
   */
  export type committee_memberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * The data used to create many committee_members.
     */
    data: committee_memberCreateManyInput | committee_memberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * committee_member update
   */
  export type committee_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * The data needed to update a committee_member.
     */
    data: XOR<committee_memberUpdateInput, committee_memberUncheckedUpdateInput>
    /**
     * Choose, which committee_member to update.
     */
    where: committee_memberWhereUniqueInput
  }

  /**
   * committee_member updateMany
   */
  export type committee_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update committee_members.
     */
    data: XOR<committee_memberUpdateManyMutationInput, committee_memberUncheckedUpdateManyInput>
    /**
     * Filter which committee_members to update
     */
    where?: committee_memberWhereInput
    /**
     * Limit how many committee_members to update.
     */
    limit?: number
  }

  /**
   * committee_member updateManyAndReturn
   */
  export type committee_memberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * The data used to update committee_members.
     */
    data: XOR<committee_memberUpdateManyMutationInput, committee_memberUncheckedUpdateManyInput>
    /**
     * Filter which committee_members to update
     */
    where?: committee_memberWhereInput
    /**
     * Limit how many committee_members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * committee_member upsert
   */
  export type committee_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * The filter to search for the committee_member to update in case it exists.
     */
    where: committee_memberWhereUniqueInput
    /**
     * In case the committee_member found by the `where` argument doesn't exist, create a new committee_member with this data.
     */
    create: XOR<committee_memberCreateInput, committee_memberUncheckedCreateInput>
    /**
     * In case the committee_member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<committee_memberUpdateInput, committee_memberUncheckedUpdateInput>
  }

  /**
   * committee_member delete
   */
  export type committee_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
    /**
     * Filter which committee_member to delete.
     */
    where: committee_memberWhereUniqueInput
  }

  /**
   * committee_member deleteMany
   */
  export type committee_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_members to delete
     */
    where?: committee_memberWhereInput
    /**
     * Limit how many committee_members to delete.
     */
    limit?: number
  }

  /**
   * committee_member without action
   */
  export type committee_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_member
     */
    select?: committee_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_member
     */
    omit?: committee_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: committee_memberInclude<ExtArgs> | null
  }


  /**
   * Model committee_registration
   */

  export type AggregateCommittee_registration = {
    _count: Committee_registrationCountAggregateOutputType | null
    _avg: Committee_registrationAvgAggregateOutputType | null
    _sum: Committee_registrationSumAggregateOutputType | null
    _min: Committee_registrationMinAggregateOutputType | null
    _max: Committee_registrationMaxAggregateOutputType | null
  }

  export type Committee_registrationAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    cert_index: number | null
    cold_key_id: number | null
    hot_key_id: number | null
  }

  export type Committee_registrationSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    cold_key_id: bigint | null
    hot_key_id: bigint | null
  }

  export type Committee_registrationMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    cold_key_id: bigint | null
    hot_key_id: bigint | null
  }

  export type Committee_registrationMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    cold_key_id: bigint | null
    hot_key_id: bigint | null
  }

  export type Committee_registrationCountAggregateOutputType = {
    id: number
    tx_id: number
    cert_index: number
    cold_key_id: number
    hot_key_id: number
    _all: number
  }


  export type Committee_registrationAvgAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    cold_key_id?: true
    hot_key_id?: true
  }

  export type Committee_registrationSumAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    cold_key_id?: true
    hot_key_id?: true
  }

  export type Committee_registrationMinAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    cold_key_id?: true
    hot_key_id?: true
  }

  export type Committee_registrationMaxAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    cold_key_id?: true
    hot_key_id?: true
  }

  export type Committee_registrationCountAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    cold_key_id?: true
    hot_key_id?: true
    _all?: true
  }

  export type Committee_registrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_registration to aggregate.
     */
    where?: committee_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_registrations to fetch.
     */
    orderBy?: committee_registrationOrderByWithRelationInput | committee_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: committee_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned committee_registrations
    **/
    _count?: true | Committee_registrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Committee_registrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Committee_registrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Committee_registrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Committee_registrationMaxAggregateInputType
  }

  export type GetCommittee_registrationAggregateType<T extends Committee_registrationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommittee_registration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommittee_registration[P]>
      : GetScalarType<T[P], AggregateCommittee_registration[P]>
  }




  export type committee_registrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: committee_registrationWhereInput
    orderBy?: committee_registrationOrderByWithAggregationInput | committee_registrationOrderByWithAggregationInput[]
    by: Committee_registrationScalarFieldEnum[] | Committee_registrationScalarFieldEnum
    having?: committee_registrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Committee_registrationCountAggregateInputType | true
    _avg?: Committee_registrationAvgAggregateInputType
    _sum?: Committee_registrationSumAggregateInputType
    _min?: Committee_registrationMinAggregateInputType
    _max?: Committee_registrationMaxAggregateInputType
  }

  export type Committee_registrationGroupByOutputType = {
    id: bigint
    tx_id: bigint
    cert_index: number
    cold_key_id: bigint
    hot_key_id: bigint
    _count: Committee_registrationCountAggregateOutputType | null
    _avg: Committee_registrationAvgAggregateOutputType | null
    _sum: Committee_registrationSumAggregateOutputType | null
    _min: Committee_registrationMinAggregateOutputType | null
    _max: Committee_registrationMaxAggregateOutputType | null
  }

  type GetCommittee_registrationGroupByPayload<T extends committee_registrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Committee_registrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Committee_registrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Committee_registrationGroupByOutputType[P]>
            : GetScalarType<T[P], Committee_registrationGroupByOutputType[P]>
        }
      >
    >


  export type committee_registrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    cold_key_id?: boolean
    hot_key_id?: boolean
  }, ExtArgs["result"]["committee_registration"]>

  export type committee_registrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    cold_key_id?: boolean
    hot_key_id?: boolean
  }, ExtArgs["result"]["committee_registration"]>

  export type committee_registrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    cold_key_id?: boolean
    hot_key_id?: boolean
  }, ExtArgs["result"]["committee_registration"]>

  export type committee_registrationSelectScalar = {
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    cold_key_id?: boolean
    hot_key_id?: boolean
  }

  export type committee_registrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "cert_index" | "cold_key_id" | "hot_key_id", ExtArgs["result"]["committee_registration"]>

  export type $committee_registrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "committee_registration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      cert_index: number
      cold_key_id: bigint
      hot_key_id: bigint
    }, ExtArgs["result"]["committee_registration"]>
    composites: {}
  }

  type committee_registrationGetPayload<S extends boolean | null | undefined | committee_registrationDefaultArgs> = $Result.GetResult<Prisma.$committee_registrationPayload, S>

  type committee_registrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<committee_registrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Committee_registrationCountAggregateInputType | true
    }

  export interface committee_registrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['committee_registration'], meta: { name: 'committee_registration' } }
    /**
     * Find zero or one Committee_registration that matches the filter.
     * @param {committee_registrationFindUniqueArgs} args - Arguments to find a Committee_registration
     * @example
     * // Get one Committee_registration
     * const committee_registration = await prisma.committee_registration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends committee_registrationFindUniqueArgs>(args: SelectSubset<T, committee_registrationFindUniqueArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Committee_registration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {committee_registrationFindUniqueOrThrowArgs} args - Arguments to find a Committee_registration
     * @example
     * // Get one Committee_registration
     * const committee_registration = await prisma.committee_registration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends committee_registrationFindUniqueOrThrowArgs>(args: SelectSubset<T, committee_registrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_registration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationFindFirstArgs} args - Arguments to find a Committee_registration
     * @example
     * // Get one Committee_registration
     * const committee_registration = await prisma.committee_registration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends committee_registrationFindFirstArgs>(args?: SelectSubset<T, committee_registrationFindFirstArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Committee_registration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationFindFirstOrThrowArgs} args - Arguments to find a Committee_registration
     * @example
     * // Get one Committee_registration
     * const committee_registration = await prisma.committee_registration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends committee_registrationFindFirstOrThrowArgs>(args?: SelectSubset<T, committee_registrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Committee_registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Committee_registrations
     * const committee_registrations = await prisma.committee_registration.findMany()
     * 
     * // Get first 10 Committee_registrations
     * const committee_registrations = await prisma.committee_registration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const committee_registrationWithIdOnly = await prisma.committee_registration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends committee_registrationFindManyArgs>(args?: SelectSubset<T, committee_registrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Committee_registration.
     * @param {committee_registrationCreateArgs} args - Arguments to create a Committee_registration.
     * @example
     * // Create one Committee_registration
     * const Committee_registration = await prisma.committee_registration.create({
     *   data: {
     *     // ... data to create a Committee_registration
     *   }
     * })
     * 
     */
    create<T extends committee_registrationCreateArgs>(args: SelectSubset<T, committee_registrationCreateArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Committee_registrations.
     * @param {committee_registrationCreateManyArgs} args - Arguments to create many Committee_registrations.
     * @example
     * // Create many Committee_registrations
     * const committee_registration = await prisma.committee_registration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends committee_registrationCreateManyArgs>(args?: SelectSubset<T, committee_registrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Committee_registrations and returns the data saved in the database.
     * @param {committee_registrationCreateManyAndReturnArgs} args - Arguments to create many Committee_registrations.
     * @example
     * // Create many Committee_registrations
     * const committee_registration = await prisma.committee_registration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Committee_registrations and only return the `id`
     * const committee_registrationWithIdOnly = await prisma.committee_registration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends committee_registrationCreateManyAndReturnArgs>(args?: SelectSubset<T, committee_registrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Committee_registration.
     * @param {committee_registrationDeleteArgs} args - Arguments to delete one Committee_registration.
     * @example
     * // Delete one Committee_registration
     * const Committee_registration = await prisma.committee_registration.delete({
     *   where: {
     *     // ... filter to delete one Committee_registration
     *   }
     * })
     * 
     */
    delete<T extends committee_registrationDeleteArgs>(args: SelectSubset<T, committee_registrationDeleteArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Committee_registration.
     * @param {committee_registrationUpdateArgs} args - Arguments to update one Committee_registration.
     * @example
     * // Update one Committee_registration
     * const committee_registration = await prisma.committee_registration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends committee_registrationUpdateArgs>(args: SelectSubset<T, committee_registrationUpdateArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Committee_registrations.
     * @param {committee_registrationDeleteManyArgs} args - Arguments to filter Committee_registrations to delete.
     * @example
     * // Delete a few Committee_registrations
     * const { count } = await prisma.committee_registration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends committee_registrationDeleteManyArgs>(args?: SelectSubset<T, committee_registrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Committee_registrations
     * const committee_registration = await prisma.committee_registration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends committee_registrationUpdateManyArgs>(args: SelectSubset<T, committee_registrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Committee_registrations and returns the data updated in the database.
     * @param {committee_registrationUpdateManyAndReturnArgs} args - Arguments to update many Committee_registrations.
     * @example
     * // Update many Committee_registrations
     * const committee_registration = await prisma.committee_registration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Committee_registrations and only return the `id`
     * const committee_registrationWithIdOnly = await prisma.committee_registration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends committee_registrationUpdateManyAndReturnArgs>(args: SelectSubset<T, committee_registrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Committee_registration.
     * @param {committee_registrationUpsertArgs} args - Arguments to update or create a Committee_registration.
     * @example
     * // Update or create a Committee_registration
     * const committee_registration = await prisma.committee_registration.upsert({
     *   create: {
     *     // ... data to create a Committee_registration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Committee_registration we want to update
     *   }
     * })
     */
    upsert<T extends committee_registrationUpsertArgs>(args: SelectSubset<T, committee_registrationUpsertArgs<ExtArgs>>): Prisma__committee_registrationClient<$Result.GetResult<Prisma.$committee_registrationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Committee_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationCountArgs} args - Arguments to filter Committee_registrations to count.
     * @example
     * // Count the number of Committee_registrations
     * const count = await prisma.committee_registration.count({
     *   where: {
     *     // ... the filter for the Committee_registrations we want to count
     *   }
     * })
    **/
    count<T extends committee_registrationCountArgs>(
      args?: Subset<T, committee_registrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Committee_registrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Committee_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Committee_registrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Committee_registrationAggregateArgs>(args: Subset<T, Committee_registrationAggregateArgs>): Prisma.PrismaPromise<GetCommittee_registrationAggregateType<T>>

    /**
     * Group by Committee_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {committee_registrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends committee_registrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: committee_registrationGroupByArgs['orderBy'] }
        : { orderBy?: committee_registrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, committee_registrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommittee_registrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the committee_registration model
   */
  readonly fields: committee_registrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for committee_registration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__committee_registrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the committee_registration model
   */ 
  interface committee_registrationFieldRefs {
    readonly id: FieldRef<"committee_registration", 'BigInt'>
    readonly tx_id: FieldRef<"committee_registration", 'BigInt'>
    readonly cert_index: FieldRef<"committee_registration", 'Int'>
    readonly cold_key_id: FieldRef<"committee_registration", 'BigInt'>
    readonly hot_key_id: FieldRef<"committee_registration", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * committee_registration findUnique
   */
  export type committee_registrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_registration to fetch.
     */
    where: committee_registrationWhereUniqueInput
  }

  /**
   * committee_registration findUniqueOrThrow
   */
  export type committee_registrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_registration to fetch.
     */
    where: committee_registrationWhereUniqueInput
  }

  /**
   * committee_registration findFirst
   */
  export type committee_registrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_registration to fetch.
     */
    where?: committee_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_registrations to fetch.
     */
    orderBy?: committee_registrationOrderByWithRelationInput | committee_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_registrations.
     */
    cursor?: committee_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_registrations.
     */
    distinct?: Committee_registrationScalarFieldEnum | Committee_registrationScalarFieldEnum[]
  }

  /**
   * committee_registration findFirstOrThrow
   */
  export type committee_registrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_registration to fetch.
     */
    where?: committee_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_registrations to fetch.
     */
    orderBy?: committee_registrationOrderByWithRelationInput | committee_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for committee_registrations.
     */
    cursor?: committee_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of committee_registrations.
     */
    distinct?: Committee_registrationScalarFieldEnum | Committee_registrationScalarFieldEnum[]
  }

  /**
   * committee_registration findMany
   */
  export type committee_registrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter, which committee_registrations to fetch.
     */
    where?: committee_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of committee_registrations to fetch.
     */
    orderBy?: committee_registrationOrderByWithRelationInput | committee_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing committee_registrations.
     */
    cursor?: committee_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` committee_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` committee_registrations.
     */
    skip?: number
    distinct?: Committee_registrationScalarFieldEnum | Committee_registrationScalarFieldEnum[]
  }

  /**
   * committee_registration create
   */
  export type committee_registrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * The data needed to create a committee_registration.
     */
    data: XOR<committee_registrationCreateInput, committee_registrationUncheckedCreateInput>
  }

  /**
   * committee_registration createMany
   */
  export type committee_registrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many committee_registrations.
     */
    data: committee_registrationCreateManyInput | committee_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_registration createManyAndReturn
   */
  export type committee_registrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * The data used to create many committee_registrations.
     */
    data: committee_registrationCreateManyInput | committee_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * committee_registration update
   */
  export type committee_registrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * The data needed to update a committee_registration.
     */
    data: XOR<committee_registrationUpdateInput, committee_registrationUncheckedUpdateInput>
    /**
     * Choose, which committee_registration to update.
     */
    where: committee_registrationWhereUniqueInput
  }

  /**
   * committee_registration updateMany
   */
  export type committee_registrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update committee_registrations.
     */
    data: XOR<committee_registrationUpdateManyMutationInput, committee_registrationUncheckedUpdateManyInput>
    /**
     * Filter which committee_registrations to update
     */
    where?: committee_registrationWhereInput
    /**
     * Limit how many committee_registrations to update.
     */
    limit?: number
  }

  /**
   * committee_registration updateManyAndReturn
   */
  export type committee_registrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * The data used to update committee_registrations.
     */
    data: XOR<committee_registrationUpdateManyMutationInput, committee_registrationUncheckedUpdateManyInput>
    /**
     * Filter which committee_registrations to update
     */
    where?: committee_registrationWhereInput
    /**
     * Limit how many committee_registrations to update.
     */
    limit?: number
  }

  /**
   * committee_registration upsert
   */
  export type committee_registrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * The filter to search for the committee_registration to update in case it exists.
     */
    where: committee_registrationWhereUniqueInput
    /**
     * In case the committee_registration found by the `where` argument doesn't exist, create a new committee_registration with this data.
     */
    create: XOR<committee_registrationCreateInput, committee_registrationUncheckedCreateInput>
    /**
     * In case the committee_registration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<committee_registrationUpdateInput, committee_registrationUncheckedUpdateInput>
  }

  /**
   * committee_registration delete
   */
  export type committee_registrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
    /**
     * Filter which committee_registration to delete.
     */
    where: committee_registrationWhereUniqueInput
  }

  /**
   * committee_registration deleteMany
   */
  export type committee_registrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which committee_registrations to delete
     */
    where?: committee_registrationWhereInput
    /**
     * Limit how many committee_registrations to delete.
     */
    limit?: number
  }

  /**
   * committee_registration without action
   */
  export type committee_registrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the committee_registration
     */
    select?: committee_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the committee_registration
     */
    omit?: committee_registrationOmit<ExtArgs> | null
  }


  /**
   * Model constitution
   */

  export type AggregateConstitution = {
    _count: ConstitutionCountAggregateOutputType | null
    _avg: ConstitutionAvgAggregateOutputType | null
    _sum: ConstitutionSumAggregateOutputType | null
    _min: ConstitutionMinAggregateOutputType | null
    _max: ConstitutionMaxAggregateOutputType | null
  }

  export type ConstitutionAvgAggregateOutputType = {
    id: number | null
    gov_action_proposal_id: number | null
    voting_anchor_id: number | null
  }

  export type ConstitutionSumAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    voting_anchor_id: bigint | null
  }

  export type ConstitutionMinAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    voting_anchor_id: bigint | null
    script_hash: Uint8Array | null
  }

  export type ConstitutionMaxAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    voting_anchor_id: bigint | null
    script_hash: Uint8Array | null
  }

  export type ConstitutionCountAggregateOutputType = {
    id: number
    gov_action_proposal_id: number
    voting_anchor_id: number
    script_hash: number
    _all: number
  }


  export type ConstitutionAvgAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    voting_anchor_id?: true
  }

  export type ConstitutionSumAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    voting_anchor_id?: true
  }

  export type ConstitutionMinAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    voting_anchor_id?: true
    script_hash?: true
  }

  export type ConstitutionMaxAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    voting_anchor_id?: true
    script_hash?: true
  }

  export type ConstitutionCountAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    voting_anchor_id?: true
    script_hash?: true
    _all?: true
  }

  export type ConstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which constitution to aggregate.
     */
    where?: constitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of constitutions to fetch.
     */
    orderBy?: constitutionOrderByWithRelationInput | constitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: constitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` constitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` constitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned constitutions
    **/
    _count?: true | ConstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConstitutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConstitutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConstitutionMaxAggregateInputType
  }

  export type GetConstitutionAggregateType<T extends ConstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateConstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstitution[P]>
      : GetScalarType<T[P], AggregateConstitution[P]>
  }




  export type constitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: constitutionWhereInput
    orderBy?: constitutionOrderByWithAggregationInput | constitutionOrderByWithAggregationInput[]
    by: ConstitutionScalarFieldEnum[] | ConstitutionScalarFieldEnum
    having?: constitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConstitutionCountAggregateInputType | true
    _avg?: ConstitutionAvgAggregateInputType
    _sum?: ConstitutionSumAggregateInputType
    _min?: ConstitutionMinAggregateInputType
    _max?: ConstitutionMaxAggregateInputType
  }

  export type ConstitutionGroupByOutputType = {
    id: bigint
    gov_action_proposal_id: bigint | null
    voting_anchor_id: bigint
    script_hash: Uint8Array | null
    _count: ConstitutionCountAggregateOutputType | null
    _avg: ConstitutionAvgAggregateOutputType | null
    _sum: ConstitutionSumAggregateOutputType | null
    _min: ConstitutionMinAggregateOutputType | null
    _max: ConstitutionMaxAggregateOutputType | null
  }

  type GetConstitutionGroupByPayload<T extends constitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], ConstitutionGroupByOutputType[P]>
        }
      >
    >


  export type constitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    voting_anchor_id?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["constitution"]>

  export type constitutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    voting_anchor_id?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["constitution"]>

  export type constitutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    voting_anchor_id?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["constitution"]>

  export type constitutionSelectScalar = {
    id?: boolean
    gov_action_proposal_id?: boolean
    voting_anchor_id?: boolean
    script_hash?: boolean
  }

  export type constitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gov_action_proposal_id" | "voting_anchor_id" | "script_hash", ExtArgs["result"]["constitution"]>

  export type $constitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "constitution"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      gov_action_proposal_id: bigint | null
      voting_anchor_id: bigint
      script_hash: Uint8Array | null
    }, ExtArgs["result"]["constitution"]>
    composites: {}
  }

  type constitutionGetPayload<S extends boolean | null | undefined | constitutionDefaultArgs> = $Result.GetResult<Prisma.$constitutionPayload, S>

  type constitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<constitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConstitutionCountAggregateInputType | true
    }

  export interface constitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['constitution'], meta: { name: 'constitution' } }
    /**
     * Find zero or one Constitution that matches the filter.
     * @param {constitutionFindUniqueArgs} args - Arguments to find a Constitution
     * @example
     * // Get one Constitution
     * const constitution = await prisma.constitution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends constitutionFindUniqueArgs>(args: SelectSubset<T, constitutionFindUniqueArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Constitution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {constitutionFindUniqueOrThrowArgs} args - Arguments to find a Constitution
     * @example
     * // Get one Constitution
     * const constitution = await prisma.constitution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends constitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, constitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Constitution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionFindFirstArgs} args - Arguments to find a Constitution
     * @example
     * // Get one Constitution
     * const constitution = await prisma.constitution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends constitutionFindFirstArgs>(args?: SelectSubset<T, constitutionFindFirstArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Constitution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionFindFirstOrThrowArgs} args - Arguments to find a Constitution
     * @example
     * // Get one Constitution
     * const constitution = await prisma.constitution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends constitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, constitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Constitutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Constitutions
     * const constitutions = await prisma.constitution.findMany()
     * 
     * // Get first 10 Constitutions
     * const constitutions = await prisma.constitution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const constitutionWithIdOnly = await prisma.constitution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends constitutionFindManyArgs>(args?: SelectSubset<T, constitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Constitution.
     * @param {constitutionCreateArgs} args - Arguments to create a Constitution.
     * @example
     * // Create one Constitution
     * const Constitution = await prisma.constitution.create({
     *   data: {
     *     // ... data to create a Constitution
     *   }
     * })
     * 
     */
    create<T extends constitutionCreateArgs>(args: SelectSubset<T, constitutionCreateArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Constitutions.
     * @param {constitutionCreateManyArgs} args - Arguments to create many Constitutions.
     * @example
     * // Create many Constitutions
     * const constitution = await prisma.constitution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends constitutionCreateManyArgs>(args?: SelectSubset<T, constitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Constitutions and returns the data saved in the database.
     * @param {constitutionCreateManyAndReturnArgs} args - Arguments to create many Constitutions.
     * @example
     * // Create many Constitutions
     * const constitution = await prisma.constitution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Constitutions and only return the `id`
     * const constitutionWithIdOnly = await prisma.constitution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends constitutionCreateManyAndReturnArgs>(args?: SelectSubset<T, constitutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Constitution.
     * @param {constitutionDeleteArgs} args - Arguments to delete one Constitution.
     * @example
     * // Delete one Constitution
     * const Constitution = await prisma.constitution.delete({
     *   where: {
     *     // ... filter to delete one Constitution
     *   }
     * })
     * 
     */
    delete<T extends constitutionDeleteArgs>(args: SelectSubset<T, constitutionDeleteArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Constitution.
     * @param {constitutionUpdateArgs} args - Arguments to update one Constitution.
     * @example
     * // Update one Constitution
     * const constitution = await prisma.constitution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends constitutionUpdateArgs>(args: SelectSubset<T, constitutionUpdateArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Constitutions.
     * @param {constitutionDeleteManyArgs} args - Arguments to filter Constitutions to delete.
     * @example
     * // Delete a few Constitutions
     * const { count } = await prisma.constitution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends constitutionDeleteManyArgs>(args?: SelectSubset<T, constitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Constitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Constitutions
     * const constitution = await prisma.constitution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends constitutionUpdateManyArgs>(args: SelectSubset<T, constitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Constitutions and returns the data updated in the database.
     * @param {constitutionUpdateManyAndReturnArgs} args - Arguments to update many Constitutions.
     * @example
     * // Update many Constitutions
     * const constitution = await prisma.constitution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Constitutions and only return the `id`
     * const constitutionWithIdOnly = await prisma.constitution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends constitutionUpdateManyAndReturnArgs>(args: SelectSubset<T, constitutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Constitution.
     * @param {constitutionUpsertArgs} args - Arguments to update or create a Constitution.
     * @example
     * // Update or create a Constitution
     * const constitution = await prisma.constitution.upsert({
     *   create: {
     *     // ... data to create a Constitution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Constitution we want to update
     *   }
     * })
     */
    upsert<T extends constitutionUpsertArgs>(args: SelectSubset<T, constitutionUpsertArgs<ExtArgs>>): Prisma__constitutionClient<$Result.GetResult<Prisma.$constitutionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Constitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionCountArgs} args - Arguments to filter Constitutions to count.
     * @example
     * // Count the number of Constitutions
     * const count = await prisma.constitution.count({
     *   where: {
     *     // ... the filter for the Constitutions we want to count
     *   }
     * })
    **/
    count<T extends constitutionCountArgs>(
      args?: Subset<T, constitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Constitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConstitutionAggregateArgs>(args: Subset<T, ConstitutionAggregateArgs>): Prisma.PrismaPromise<GetConstitutionAggregateType<T>>

    /**
     * Group by Constitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {constitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends constitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: constitutionGroupByArgs['orderBy'] }
        : { orderBy?: constitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, constitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the constitution model
   */
  readonly fields: constitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for constitution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__constitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the constitution model
   */ 
  interface constitutionFieldRefs {
    readonly id: FieldRef<"constitution", 'BigInt'>
    readonly gov_action_proposal_id: FieldRef<"constitution", 'BigInt'>
    readonly voting_anchor_id: FieldRef<"constitution", 'BigInt'>
    readonly script_hash: FieldRef<"constitution", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * constitution findUnique
   */
  export type constitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter, which constitution to fetch.
     */
    where: constitutionWhereUniqueInput
  }

  /**
   * constitution findUniqueOrThrow
   */
  export type constitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter, which constitution to fetch.
     */
    where: constitutionWhereUniqueInput
  }

  /**
   * constitution findFirst
   */
  export type constitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter, which constitution to fetch.
     */
    where?: constitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of constitutions to fetch.
     */
    orderBy?: constitutionOrderByWithRelationInput | constitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for constitutions.
     */
    cursor?: constitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` constitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` constitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of constitutions.
     */
    distinct?: ConstitutionScalarFieldEnum | ConstitutionScalarFieldEnum[]
  }

  /**
   * constitution findFirstOrThrow
   */
  export type constitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter, which constitution to fetch.
     */
    where?: constitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of constitutions to fetch.
     */
    orderBy?: constitutionOrderByWithRelationInput | constitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for constitutions.
     */
    cursor?: constitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` constitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` constitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of constitutions.
     */
    distinct?: ConstitutionScalarFieldEnum | ConstitutionScalarFieldEnum[]
  }

  /**
   * constitution findMany
   */
  export type constitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter, which constitutions to fetch.
     */
    where?: constitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of constitutions to fetch.
     */
    orderBy?: constitutionOrderByWithRelationInput | constitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing constitutions.
     */
    cursor?: constitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` constitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` constitutions.
     */
    skip?: number
    distinct?: ConstitutionScalarFieldEnum | ConstitutionScalarFieldEnum[]
  }

  /**
   * constitution create
   */
  export type constitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * The data needed to create a constitution.
     */
    data: XOR<constitutionCreateInput, constitutionUncheckedCreateInput>
  }

  /**
   * constitution createMany
   */
  export type constitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many constitutions.
     */
    data: constitutionCreateManyInput | constitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * constitution createManyAndReturn
   */
  export type constitutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * The data used to create many constitutions.
     */
    data: constitutionCreateManyInput | constitutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * constitution update
   */
  export type constitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * The data needed to update a constitution.
     */
    data: XOR<constitutionUpdateInput, constitutionUncheckedUpdateInput>
    /**
     * Choose, which constitution to update.
     */
    where: constitutionWhereUniqueInput
  }

  /**
   * constitution updateMany
   */
  export type constitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update constitutions.
     */
    data: XOR<constitutionUpdateManyMutationInput, constitutionUncheckedUpdateManyInput>
    /**
     * Filter which constitutions to update
     */
    where?: constitutionWhereInput
    /**
     * Limit how many constitutions to update.
     */
    limit?: number
  }

  /**
   * constitution updateManyAndReturn
   */
  export type constitutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * The data used to update constitutions.
     */
    data: XOR<constitutionUpdateManyMutationInput, constitutionUncheckedUpdateManyInput>
    /**
     * Filter which constitutions to update
     */
    where?: constitutionWhereInput
    /**
     * Limit how many constitutions to update.
     */
    limit?: number
  }

  /**
   * constitution upsert
   */
  export type constitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * The filter to search for the constitution to update in case it exists.
     */
    where: constitutionWhereUniqueInput
    /**
     * In case the constitution found by the `where` argument doesn't exist, create a new constitution with this data.
     */
    create: XOR<constitutionCreateInput, constitutionUncheckedCreateInput>
    /**
     * In case the constitution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<constitutionUpdateInput, constitutionUncheckedUpdateInput>
  }

  /**
   * constitution delete
   */
  export type constitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
    /**
     * Filter which constitution to delete.
     */
    where: constitutionWhereUniqueInput
  }

  /**
   * constitution deleteMany
   */
  export type constitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which constitutions to delete
     */
    where?: constitutionWhereInput
    /**
     * Limit how many constitutions to delete.
     */
    limit?: number
  }

  /**
   * constitution without action
   */
  export type constitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the constitution
     */
    select?: constitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the constitution
     */
    omit?: constitutionOmit<ExtArgs> | null
  }


  /**
   * Model cost_model
   */

  export type AggregateCost_model = {
    _count: Cost_modelCountAggregateOutputType | null
    _avg: Cost_modelAvgAggregateOutputType | null
    _sum: Cost_modelSumAggregateOutputType | null
    _min: Cost_modelMinAggregateOutputType | null
    _max: Cost_modelMaxAggregateOutputType | null
  }

  export type Cost_modelAvgAggregateOutputType = {
    id: number | null
  }

  export type Cost_modelSumAggregateOutputType = {
    id: bigint | null
  }

  export type Cost_modelMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
  }

  export type Cost_modelMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
  }

  export type Cost_modelCountAggregateOutputType = {
    id: number
    costs: number
    hash: number
    _all: number
  }


  export type Cost_modelAvgAggregateInputType = {
    id?: true
  }

  export type Cost_modelSumAggregateInputType = {
    id?: true
  }

  export type Cost_modelMinAggregateInputType = {
    id?: true
    hash?: true
  }

  export type Cost_modelMaxAggregateInputType = {
    id?: true
    hash?: true
  }

  export type Cost_modelCountAggregateInputType = {
    id?: true
    costs?: true
    hash?: true
    _all?: true
  }

  export type Cost_modelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cost_model to aggregate.
     */
    where?: cost_modelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cost_models to fetch.
     */
    orderBy?: cost_modelOrderByWithRelationInput | cost_modelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cost_modelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cost_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cost_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cost_models
    **/
    _count?: true | Cost_modelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cost_modelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cost_modelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cost_modelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cost_modelMaxAggregateInputType
  }

  export type GetCost_modelAggregateType<T extends Cost_modelAggregateArgs> = {
        [P in keyof T & keyof AggregateCost_model]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCost_model[P]>
      : GetScalarType<T[P], AggregateCost_model[P]>
  }




  export type cost_modelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cost_modelWhereInput
    orderBy?: cost_modelOrderByWithAggregationInput | cost_modelOrderByWithAggregationInput[]
    by: Cost_modelScalarFieldEnum[] | Cost_modelScalarFieldEnum
    having?: cost_modelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cost_modelCountAggregateInputType | true
    _avg?: Cost_modelAvgAggregateInputType
    _sum?: Cost_modelSumAggregateInputType
    _min?: Cost_modelMinAggregateInputType
    _max?: Cost_modelMaxAggregateInputType
  }

  export type Cost_modelGroupByOutputType = {
    id: bigint
    costs: JsonValue
    hash: Uint8Array
    _count: Cost_modelCountAggregateOutputType | null
    _avg: Cost_modelAvgAggregateOutputType | null
    _sum: Cost_modelSumAggregateOutputType | null
    _min: Cost_modelMinAggregateOutputType | null
    _max: Cost_modelMaxAggregateOutputType | null
  }

  type GetCost_modelGroupByPayload<T extends cost_modelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cost_modelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cost_modelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cost_modelGroupByOutputType[P]>
            : GetScalarType<T[P], Cost_modelGroupByOutputType[P]>
        }
      >
    >


  export type cost_modelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costs?: boolean
    hash?: boolean
  }, ExtArgs["result"]["cost_model"]>

  export type cost_modelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costs?: boolean
    hash?: boolean
  }, ExtArgs["result"]["cost_model"]>

  export type cost_modelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costs?: boolean
    hash?: boolean
  }, ExtArgs["result"]["cost_model"]>

  export type cost_modelSelectScalar = {
    id?: boolean
    costs?: boolean
    hash?: boolean
  }

  export type cost_modelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "costs" | "hash", ExtArgs["result"]["cost_model"]>

  export type $cost_modelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cost_model"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      costs: Prisma.JsonValue
      hash: Uint8Array
    }, ExtArgs["result"]["cost_model"]>
    composites: {}
  }

  type cost_modelGetPayload<S extends boolean | null | undefined | cost_modelDefaultArgs> = $Result.GetResult<Prisma.$cost_modelPayload, S>

  type cost_modelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cost_modelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cost_modelCountAggregateInputType | true
    }

  export interface cost_modelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cost_model'], meta: { name: 'cost_model' } }
    /**
     * Find zero or one Cost_model that matches the filter.
     * @param {cost_modelFindUniqueArgs} args - Arguments to find a Cost_model
     * @example
     * // Get one Cost_model
     * const cost_model = await prisma.cost_model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cost_modelFindUniqueArgs>(args: SelectSubset<T, cost_modelFindUniqueArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cost_model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cost_modelFindUniqueOrThrowArgs} args - Arguments to find a Cost_model
     * @example
     * // Get one Cost_model
     * const cost_model = await prisma.cost_model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cost_modelFindUniqueOrThrowArgs>(args: SelectSubset<T, cost_modelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cost_model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelFindFirstArgs} args - Arguments to find a Cost_model
     * @example
     * // Get one Cost_model
     * const cost_model = await prisma.cost_model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cost_modelFindFirstArgs>(args?: SelectSubset<T, cost_modelFindFirstArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cost_model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelFindFirstOrThrowArgs} args - Arguments to find a Cost_model
     * @example
     * // Get one Cost_model
     * const cost_model = await prisma.cost_model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cost_modelFindFirstOrThrowArgs>(args?: SelectSubset<T, cost_modelFindFirstOrThrowArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cost_models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cost_models
     * const cost_models = await prisma.cost_model.findMany()
     * 
     * // Get first 10 Cost_models
     * const cost_models = await prisma.cost_model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cost_modelWithIdOnly = await prisma.cost_model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cost_modelFindManyArgs>(args?: SelectSubset<T, cost_modelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cost_model.
     * @param {cost_modelCreateArgs} args - Arguments to create a Cost_model.
     * @example
     * // Create one Cost_model
     * const Cost_model = await prisma.cost_model.create({
     *   data: {
     *     // ... data to create a Cost_model
     *   }
     * })
     * 
     */
    create<T extends cost_modelCreateArgs>(args: SelectSubset<T, cost_modelCreateArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cost_models.
     * @param {cost_modelCreateManyArgs} args - Arguments to create many Cost_models.
     * @example
     * // Create many Cost_models
     * const cost_model = await prisma.cost_model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cost_modelCreateManyArgs>(args?: SelectSubset<T, cost_modelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cost_models and returns the data saved in the database.
     * @param {cost_modelCreateManyAndReturnArgs} args - Arguments to create many Cost_models.
     * @example
     * // Create many Cost_models
     * const cost_model = await prisma.cost_model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cost_models and only return the `id`
     * const cost_modelWithIdOnly = await prisma.cost_model.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cost_modelCreateManyAndReturnArgs>(args?: SelectSubset<T, cost_modelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cost_model.
     * @param {cost_modelDeleteArgs} args - Arguments to delete one Cost_model.
     * @example
     * // Delete one Cost_model
     * const Cost_model = await prisma.cost_model.delete({
     *   where: {
     *     // ... filter to delete one Cost_model
     *   }
     * })
     * 
     */
    delete<T extends cost_modelDeleteArgs>(args: SelectSubset<T, cost_modelDeleteArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cost_model.
     * @param {cost_modelUpdateArgs} args - Arguments to update one Cost_model.
     * @example
     * // Update one Cost_model
     * const cost_model = await prisma.cost_model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cost_modelUpdateArgs>(args: SelectSubset<T, cost_modelUpdateArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cost_models.
     * @param {cost_modelDeleteManyArgs} args - Arguments to filter Cost_models to delete.
     * @example
     * // Delete a few Cost_models
     * const { count } = await prisma.cost_model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cost_modelDeleteManyArgs>(args?: SelectSubset<T, cost_modelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cost_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cost_models
     * const cost_model = await prisma.cost_model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cost_modelUpdateManyArgs>(args: SelectSubset<T, cost_modelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cost_models and returns the data updated in the database.
     * @param {cost_modelUpdateManyAndReturnArgs} args - Arguments to update many Cost_models.
     * @example
     * // Update many Cost_models
     * const cost_model = await prisma.cost_model.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cost_models and only return the `id`
     * const cost_modelWithIdOnly = await prisma.cost_model.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cost_modelUpdateManyAndReturnArgs>(args: SelectSubset<T, cost_modelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cost_model.
     * @param {cost_modelUpsertArgs} args - Arguments to update or create a Cost_model.
     * @example
     * // Update or create a Cost_model
     * const cost_model = await prisma.cost_model.upsert({
     *   create: {
     *     // ... data to create a Cost_model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cost_model we want to update
     *   }
     * })
     */
    upsert<T extends cost_modelUpsertArgs>(args: SelectSubset<T, cost_modelUpsertArgs<ExtArgs>>): Prisma__cost_modelClient<$Result.GetResult<Prisma.$cost_modelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cost_models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelCountArgs} args - Arguments to filter Cost_models to count.
     * @example
     * // Count the number of Cost_models
     * const count = await prisma.cost_model.count({
     *   where: {
     *     // ... the filter for the Cost_models we want to count
     *   }
     * })
    **/
    count<T extends cost_modelCountArgs>(
      args?: Subset<T, cost_modelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cost_modelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cost_model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cost_modelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cost_modelAggregateArgs>(args: Subset<T, Cost_modelAggregateArgs>): Prisma.PrismaPromise<GetCost_modelAggregateType<T>>

    /**
     * Group by Cost_model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cost_modelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cost_modelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cost_modelGroupByArgs['orderBy'] }
        : { orderBy?: cost_modelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cost_modelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCost_modelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cost_model model
   */
  readonly fields: cost_modelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cost_model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cost_modelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cost_model model
   */ 
  interface cost_modelFieldRefs {
    readonly id: FieldRef<"cost_model", 'BigInt'>
    readonly costs: FieldRef<"cost_model", 'Json'>
    readonly hash: FieldRef<"cost_model", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * cost_model findUnique
   */
  export type cost_modelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter, which cost_model to fetch.
     */
    where: cost_modelWhereUniqueInput
  }

  /**
   * cost_model findUniqueOrThrow
   */
  export type cost_modelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter, which cost_model to fetch.
     */
    where: cost_modelWhereUniqueInput
  }

  /**
   * cost_model findFirst
   */
  export type cost_modelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter, which cost_model to fetch.
     */
    where?: cost_modelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cost_models to fetch.
     */
    orderBy?: cost_modelOrderByWithRelationInput | cost_modelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cost_models.
     */
    cursor?: cost_modelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cost_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cost_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cost_models.
     */
    distinct?: Cost_modelScalarFieldEnum | Cost_modelScalarFieldEnum[]
  }

  /**
   * cost_model findFirstOrThrow
   */
  export type cost_modelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter, which cost_model to fetch.
     */
    where?: cost_modelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cost_models to fetch.
     */
    orderBy?: cost_modelOrderByWithRelationInput | cost_modelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cost_models.
     */
    cursor?: cost_modelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cost_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cost_models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cost_models.
     */
    distinct?: Cost_modelScalarFieldEnum | Cost_modelScalarFieldEnum[]
  }

  /**
   * cost_model findMany
   */
  export type cost_modelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter, which cost_models to fetch.
     */
    where?: cost_modelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cost_models to fetch.
     */
    orderBy?: cost_modelOrderByWithRelationInput | cost_modelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cost_models.
     */
    cursor?: cost_modelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cost_models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cost_models.
     */
    skip?: number
    distinct?: Cost_modelScalarFieldEnum | Cost_modelScalarFieldEnum[]
  }

  /**
   * cost_model create
   */
  export type cost_modelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * The data needed to create a cost_model.
     */
    data: XOR<cost_modelCreateInput, cost_modelUncheckedCreateInput>
  }

  /**
   * cost_model createMany
   */
  export type cost_modelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cost_models.
     */
    data: cost_modelCreateManyInput | cost_modelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cost_model createManyAndReturn
   */
  export type cost_modelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * The data used to create many cost_models.
     */
    data: cost_modelCreateManyInput | cost_modelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cost_model update
   */
  export type cost_modelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * The data needed to update a cost_model.
     */
    data: XOR<cost_modelUpdateInput, cost_modelUncheckedUpdateInput>
    /**
     * Choose, which cost_model to update.
     */
    where: cost_modelWhereUniqueInput
  }

  /**
   * cost_model updateMany
   */
  export type cost_modelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cost_models.
     */
    data: XOR<cost_modelUpdateManyMutationInput, cost_modelUncheckedUpdateManyInput>
    /**
     * Filter which cost_models to update
     */
    where?: cost_modelWhereInput
    /**
     * Limit how many cost_models to update.
     */
    limit?: number
  }

  /**
   * cost_model updateManyAndReturn
   */
  export type cost_modelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * The data used to update cost_models.
     */
    data: XOR<cost_modelUpdateManyMutationInput, cost_modelUncheckedUpdateManyInput>
    /**
     * Filter which cost_models to update
     */
    where?: cost_modelWhereInput
    /**
     * Limit how many cost_models to update.
     */
    limit?: number
  }

  /**
   * cost_model upsert
   */
  export type cost_modelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * The filter to search for the cost_model to update in case it exists.
     */
    where: cost_modelWhereUniqueInput
    /**
     * In case the cost_model found by the `where` argument doesn't exist, create a new cost_model with this data.
     */
    create: XOR<cost_modelCreateInput, cost_modelUncheckedCreateInput>
    /**
     * In case the cost_model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cost_modelUpdateInput, cost_modelUncheckedUpdateInput>
  }

  /**
   * cost_model delete
   */
  export type cost_modelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
    /**
     * Filter which cost_model to delete.
     */
    where: cost_modelWhereUniqueInput
  }

  /**
   * cost_model deleteMany
   */
  export type cost_modelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cost_models to delete
     */
    where?: cost_modelWhereInput
    /**
     * Limit how many cost_models to delete.
     */
    limit?: number
  }

  /**
   * cost_model without action
   */
  export type cost_modelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cost_model
     */
    select?: cost_modelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cost_model
     */
    omit?: cost_modelOmit<ExtArgs> | null
  }


  /**
   * Model datum
   */

  export type AggregateDatum = {
    _count: DatumCountAggregateOutputType | null
    _avg: DatumAvgAggregateOutputType | null
    _sum: DatumSumAggregateOutputType | null
    _min: DatumMinAggregateOutputType | null
    _max: DatumMaxAggregateOutputType | null
  }

  export type DatumAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
  }

  export type DatumSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
  }

  export type DatumMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type DatumMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type DatumCountAggregateOutputType = {
    id: number
    hash: number
    tx_id: number
    value: number
    bytes: number
    _all: number
  }


  export type DatumAvgAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type DatumSumAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type DatumMinAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    bytes?: true
  }

  export type DatumMaxAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    bytes?: true
  }

  export type DatumCountAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    value?: true
    bytes?: true
    _all?: true
  }

  export type DatumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which datum to aggregate.
     */
    where?: datumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data to fetch.
     */
    orderBy?: datumOrderByWithRelationInput | datumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: datumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned data
    **/
    _count?: true | DatumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatumMaxAggregateInputType
  }

  export type GetDatumAggregateType<T extends DatumAggregateArgs> = {
        [P in keyof T & keyof AggregateDatum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatum[P]>
      : GetScalarType<T[P], AggregateDatum[P]>
  }




  export type datumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: datumWhereInput
    orderBy?: datumOrderByWithAggregationInput | datumOrderByWithAggregationInput[]
    by: DatumScalarFieldEnum[] | DatumScalarFieldEnum
    having?: datumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatumCountAggregateInputType | true
    _avg?: DatumAvgAggregateInputType
    _sum?: DatumSumAggregateInputType
    _min?: DatumMinAggregateInputType
    _max?: DatumMaxAggregateInputType
  }

  export type DatumGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    tx_id: bigint
    value: JsonValue | null
    bytes: Uint8Array
    _count: DatumCountAggregateOutputType | null
    _avg: DatumAvgAggregateOutputType | null
    _sum: DatumSumAggregateOutputType | null
    _min: DatumMinAggregateOutputType | null
    _max: DatumMaxAggregateOutputType | null
  }

  type GetDatumGroupByPayload<T extends datumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatumGroupByOutputType[P]>
            : GetScalarType<T[P], DatumGroupByOutputType[P]>
        }
      >
    >


  export type datumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["datum"]>

  export type datumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["datum"]>

  export type datumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["datum"]>

  export type datumSelectScalar = {
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }

  export type datumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "tx_id" | "value" | "bytes", ExtArgs["result"]["datum"]>

  export type $datumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "datum"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      tx_id: bigint
      value: Prisma.JsonValue | null
      bytes: Uint8Array
    }, ExtArgs["result"]["datum"]>
    composites: {}
  }

  type datumGetPayload<S extends boolean | null | undefined | datumDefaultArgs> = $Result.GetResult<Prisma.$datumPayload, S>

  type datumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<datumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatumCountAggregateInputType | true
    }

  export interface datumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['datum'], meta: { name: 'datum' } }
    /**
     * Find zero or one Datum that matches the filter.
     * @param {datumFindUniqueArgs} args - Arguments to find a Datum
     * @example
     * // Get one Datum
     * const datum = await prisma.datum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends datumFindUniqueArgs>(args: SelectSubset<T, datumFindUniqueArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Datum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {datumFindUniqueOrThrowArgs} args - Arguments to find a Datum
     * @example
     * // Get one Datum
     * const datum = await prisma.datum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends datumFindUniqueOrThrowArgs>(args: SelectSubset<T, datumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Datum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumFindFirstArgs} args - Arguments to find a Datum
     * @example
     * // Get one Datum
     * const datum = await prisma.datum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends datumFindFirstArgs>(args?: SelectSubset<T, datumFindFirstArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Datum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumFindFirstOrThrowArgs} args - Arguments to find a Datum
     * @example
     * // Get one Datum
     * const datum = await prisma.datum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends datumFindFirstOrThrowArgs>(args?: SelectSubset<T, datumFindFirstOrThrowArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Data
     * const data = await prisma.datum.findMany()
     * 
     * // Get first 10 Data
     * const data = await prisma.datum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datumWithIdOnly = await prisma.datum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends datumFindManyArgs>(args?: SelectSubset<T, datumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Datum.
     * @param {datumCreateArgs} args - Arguments to create a Datum.
     * @example
     * // Create one Datum
     * const Datum = await prisma.datum.create({
     *   data: {
     *     // ... data to create a Datum
     *   }
     * })
     * 
     */
    create<T extends datumCreateArgs>(args: SelectSubset<T, datumCreateArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Data.
     * @param {datumCreateManyArgs} args - Arguments to create many Data.
     * @example
     * // Create many Data
     * const datum = await prisma.datum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends datumCreateManyArgs>(args?: SelectSubset<T, datumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Data and returns the data saved in the database.
     * @param {datumCreateManyAndReturnArgs} args - Arguments to create many Data.
     * @example
     * // Create many Data
     * const datum = await prisma.datum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Data and only return the `id`
     * const datumWithIdOnly = await prisma.datum.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends datumCreateManyAndReturnArgs>(args?: SelectSubset<T, datumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Datum.
     * @param {datumDeleteArgs} args - Arguments to delete one Datum.
     * @example
     * // Delete one Datum
     * const Datum = await prisma.datum.delete({
     *   where: {
     *     // ... filter to delete one Datum
     *   }
     * })
     * 
     */
    delete<T extends datumDeleteArgs>(args: SelectSubset<T, datumDeleteArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Datum.
     * @param {datumUpdateArgs} args - Arguments to update one Datum.
     * @example
     * // Update one Datum
     * const datum = await prisma.datum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends datumUpdateArgs>(args: SelectSubset<T, datumUpdateArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Data.
     * @param {datumDeleteManyArgs} args - Arguments to filter Data to delete.
     * @example
     * // Delete a few Data
     * const { count } = await prisma.datum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends datumDeleteManyArgs>(args?: SelectSubset<T, datumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Data
     * const datum = await prisma.datum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends datumUpdateManyArgs>(args: SelectSubset<T, datumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Data and returns the data updated in the database.
     * @param {datumUpdateManyAndReturnArgs} args - Arguments to update many Data.
     * @example
     * // Update many Data
     * const datum = await prisma.datum.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Data and only return the `id`
     * const datumWithIdOnly = await prisma.datum.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends datumUpdateManyAndReturnArgs>(args: SelectSubset<T, datumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Datum.
     * @param {datumUpsertArgs} args - Arguments to update or create a Datum.
     * @example
     * // Update or create a Datum
     * const datum = await prisma.datum.upsert({
     *   create: {
     *     // ... data to create a Datum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Datum we want to update
     *   }
     * })
     */
    upsert<T extends datumUpsertArgs>(args: SelectSubset<T, datumUpsertArgs<ExtArgs>>): Prisma__datumClient<$Result.GetResult<Prisma.$datumPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumCountArgs} args - Arguments to filter Data to count.
     * @example
     * // Count the number of Data
     * const count = await prisma.datum.count({
     *   where: {
     *     // ... the filter for the Data we want to count
     *   }
     * })
    **/
    count<T extends datumCountArgs>(
      args?: Subset<T, datumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Datum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatumAggregateArgs>(args: Subset<T, DatumAggregateArgs>): Prisma.PrismaPromise<GetDatumAggregateType<T>>

    /**
     * Group by Datum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {datumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends datumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: datumGroupByArgs['orderBy'] }
        : { orderBy?: datumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, datumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the datum model
   */
  readonly fields: datumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for datum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__datumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the datum model
   */ 
  interface datumFieldRefs {
    readonly id: FieldRef<"datum", 'BigInt'>
    readonly hash: FieldRef<"datum", 'Bytes'>
    readonly tx_id: FieldRef<"datum", 'BigInt'>
    readonly value: FieldRef<"datum", 'Json'>
    readonly bytes: FieldRef<"datum", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * datum findUnique
   */
  export type datumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter, which datum to fetch.
     */
    where: datumWhereUniqueInput
  }

  /**
   * datum findUniqueOrThrow
   */
  export type datumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter, which datum to fetch.
     */
    where: datumWhereUniqueInput
  }

  /**
   * datum findFirst
   */
  export type datumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter, which datum to fetch.
     */
    where?: datumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data to fetch.
     */
    orderBy?: datumOrderByWithRelationInput | datumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for data.
     */
    cursor?: datumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of data.
     */
    distinct?: DatumScalarFieldEnum | DatumScalarFieldEnum[]
  }

  /**
   * datum findFirstOrThrow
   */
  export type datumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter, which datum to fetch.
     */
    where?: datumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data to fetch.
     */
    orderBy?: datumOrderByWithRelationInput | datumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for data.
     */
    cursor?: datumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of data.
     */
    distinct?: DatumScalarFieldEnum | DatumScalarFieldEnum[]
  }

  /**
   * datum findMany
   */
  export type datumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter, which data to fetch.
     */
    where?: datumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data to fetch.
     */
    orderBy?: datumOrderByWithRelationInput | datumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing data.
     */
    cursor?: datumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data.
     */
    skip?: number
    distinct?: DatumScalarFieldEnum | DatumScalarFieldEnum[]
  }

  /**
   * datum create
   */
  export type datumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * The data needed to create a datum.
     */
    data: XOR<datumCreateInput, datumUncheckedCreateInput>
  }

  /**
   * datum createMany
   */
  export type datumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many data.
     */
    data: datumCreateManyInput | datumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * datum createManyAndReturn
   */
  export type datumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * The data used to create many data.
     */
    data: datumCreateManyInput | datumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * datum update
   */
  export type datumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * The data needed to update a datum.
     */
    data: XOR<datumUpdateInput, datumUncheckedUpdateInput>
    /**
     * Choose, which datum to update.
     */
    where: datumWhereUniqueInput
  }

  /**
   * datum updateMany
   */
  export type datumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update data.
     */
    data: XOR<datumUpdateManyMutationInput, datumUncheckedUpdateManyInput>
    /**
     * Filter which data to update
     */
    where?: datumWhereInput
    /**
     * Limit how many data to update.
     */
    limit?: number
  }

  /**
   * datum updateManyAndReturn
   */
  export type datumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * The data used to update data.
     */
    data: XOR<datumUpdateManyMutationInput, datumUncheckedUpdateManyInput>
    /**
     * Filter which data to update
     */
    where?: datumWhereInput
    /**
     * Limit how many data to update.
     */
    limit?: number
  }

  /**
   * datum upsert
   */
  export type datumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * The filter to search for the datum to update in case it exists.
     */
    where: datumWhereUniqueInput
    /**
     * In case the datum found by the `where` argument doesn't exist, create a new datum with this data.
     */
    create: XOR<datumCreateInput, datumUncheckedCreateInput>
    /**
     * In case the datum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<datumUpdateInput, datumUncheckedUpdateInput>
  }

  /**
   * datum delete
   */
  export type datumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
    /**
     * Filter which datum to delete.
     */
    where: datumWhereUniqueInput
  }

  /**
   * datum deleteMany
   */
  export type datumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which data to delete
     */
    where?: datumWhereInput
    /**
     * Limit how many data to delete.
     */
    limit?: number
  }

  /**
   * datum without action
   */
  export type datumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the datum
     */
    select?: datumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the datum
     */
    omit?: datumOmit<ExtArgs> | null
  }


  /**
   * Model delegation
   */

  export type AggregateDelegation = {
    _count: DelegationCountAggregateOutputType | null
    _avg: DelegationAvgAggregateOutputType | null
    _sum: DelegationSumAggregateOutputType | null
    _min: DelegationMinAggregateOutputType | null
    _max: DelegationMaxAggregateOutputType | null
  }

  export type DelegationAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    pool_hash_id: number | null
    active_epoch_no: number | null
    tx_id: number | null
    slot_no: number | null
    redeemer_id: number | null
  }

  export type DelegationSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    pool_hash_id: bigint | null
    active_epoch_no: bigint | null
    tx_id: bigint | null
    slot_no: bigint | null
    redeemer_id: bigint | null
  }

  export type DelegationMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    pool_hash_id: bigint | null
    active_epoch_no: bigint | null
    tx_id: bigint | null
    slot_no: bigint | null
    redeemer_id: bigint | null
  }

  export type DelegationMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    pool_hash_id: bigint | null
    active_epoch_no: bigint | null
    tx_id: bigint | null
    slot_no: bigint | null
    redeemer_id: bigint | null
  }

  export type DelegationCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    pool_hash_id: number
    active_epoch_no: number
    tx_id: number
    slot_no: number
    redeemer_id: number
    _all: number
  }


  export type DelegationAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    pool_hash_id?: true
    active_epoch_no?: true
    tx_id?: true
    slot_no?: true
    redeemer_id?: true
  }

  export type DelegationSumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    pool_hash_id?: true
    active_epoch_no?: true
    tx_id?: true
    slot_no?: true
    redeemer_id?: true
  }

  export type DelegationMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    pool_hash_id?: true
    active_epoch_no?: true
    tx_id?: true
    slot_no?: true
    redeemer_id?: true
  }

  export type DelegationMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    pool_hash_id?: true
    active_epoch_no?: true
    tx_id?: true
    slot_no?: true
    redeemer_id?: true
  }

  export type DelegationCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    pool_hash_id?: true
    active_epoch_no?: true
    tx_id?: true
    slot_no?: true
    redeemer_id?: true
    _all?: true
  }

  export type DelegationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delegation to aggregate.
     */
    where?: delegationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegations to fetch.
     */
    orderBy?: delegationOrderByWithRelationInput | delegationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: delegationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned delegations
    **/
    _count?: true | DelegationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DelegationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DelegationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelegationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelegationMaxAggregateInputType
  }

  export type GetDelegationAggregateType<T extends DelegationAggregateArgs> = {
        [P in keyof T & keyof AggregateDelegation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelegation[P]>
      : GetScalarType<T[P], AggregateDelegation[P]>
  }




  export type delegationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delegationWhereInput
    orderBy?: delegationOrderByWithAggregationInput | delegationOrderByWithAggregationInput[]
    by: DelegationScalarFieldEnum[] | DelegationScalarFieldEnum
    having?: delegationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelegationCountAggregateInputType | true
    _avg?: DelegationAvgAggregateInputType
    _sum?: DelegationSumAggregateInputType
    _min?: DelegationMinAggregateInputType
    _max?: DelegationMaxAggregateInputType
  }

  export type DelegationGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    pool_hash_id: bigint
    active_epoch_no: bigint
    tx_id: bigint
    slot_no: bigint
    redeemer_id: bigint | null
    _count: DelegationCountAggregateOutputType | null
    _avg: DelegationAvgAggregateOutputType | null
    _sum: DelegationSumAggregateOutputType | null
    _min: DelegationMinAggregateOutputType | null
    _max: DelegationMaxAggregateOutputType | null
  }

  type GetDelegationGroupByPayload<T extends delegationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelegationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelegationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelegationGroupByOutputType[P]>
            : GetScalarType<T[P], DelegationGroupByOutputType[P]>
        }
      >
    >


  export type delegationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    pool_hash_id?: boolean
    active_epoch_no?: boolean
    tx_id?: boolean
    slot_no?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation"]>

  export type delegationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    pool_hash_id?: boolean
    active_epoch_no?: boolean
    tx_id?: boolean
    slot_no?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation"]>

  export type delegationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    pool_hash_id?: boolean
    active_epoch_no?: boolean
    tx_id?: boolean
    slot_no?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation"]>

  export type delegationSelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    pool_hash_id?: boolean
    active_epoch_no?: boolean
    tx_id?: boolean
    slot_no?: boolean
    redeemer_id?: boolean
  }

  export type delegationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "pool_hash_id" | "active_epoch_no" | "tx_id" | "slot_no" | "redeemer_id", ExtArgs["result"]["delegation"]>

  export type $delegationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "delegation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      pool_hash_id: bigint
      active_epoch_no: bigint
      tx_id: bigint
      slot_no: bigint
      redeemer_id: bigint | null
    }, ExtArgs["result"]["delegation"]>
    composites: {}
  }

  type delegationGetPayload<S extends boolean | null | undefined | delegationDefaultArgs> = $Result.GetResult<Prisma.$delegationPayload, S>

  type delegationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<delegationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelegationCountAggregateInputType | true
    }

  export interface delegationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['delegation'], meta: { name: 'delegation' } }
    /**
     * Find zero or one Delegation that matches the filter.
     * @param {delegationFindUniqueArgs} args - Arguments to find a Delegation
     * @example
     * // Get one Delegation
     * const delegation = await prisma.delegation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends delegationFindUniqueArgs>(args: SelectSubset<T, delegationFindUniqueArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Delegation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {delegationFindUniqueOrThrowArgs} args - Arguments to find a Delegation
     * @example
     * // Get one Delegation
     * const delegation = await prisma.delegation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends delegationFindUniqueOrThrowArgs>(args: SelectSubset<T, delegationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Delegation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationFindFirstArgs} args - Arguments to find a Delegation
     * @example
     * // Get one Delegation
     * const delegation = await prisma.delegation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends delegationFindFirstArgs>(args?: SelectSubset<T, delegationFindFirstArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Delegation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationFindFirstOrThrowArgs} args - Arguments to find a Delegation
     * @example
     * // Get one Delegation
     * const delegation = await prisma.delegation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends delegationFindFirstOrThrowArgs>(args?: SelectSubset<T, delegationFindFirstOrThrowArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Delegations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delegations
     * const delegations = await prisma.delegation.findMany()
     * 
     * // Get first 10 Delegations
     * const delegations = await prisma.delegation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delegationWithIdOnly = await prisma.delegation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends delegationFindManyArgs>(args?: SelectSubset<T, delegationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Delegation.
     * @param {delegationCreateArgs} args - Arguments to create a Delegation.
     * @example
     * // Create one Delegation
     * const Delegation = await prisma.delegation.create({
     *   data: {
     *     // ... data to create a Delegation
     *   }
     * })
     * 
     */
    create<T extends delegationCreateArgs>(args: SelectSubset<T, delegationCreateArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Delegations.
     * @param {delegationCreateManyArgs} args - Arguments to create many Delegations.
     * @example
     * // Create many Delegations
     * const delegation = await prisma.delegation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends delegationCreateManyArgs>(args?: SelectSubset<T, delegationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delegations and returns the data saved in the database.
     * @param {delegationCreateManyAndReturnArgs} args - Arguments to create many Delegations.
     * @example
     * // Create many Delegations
     * const delegation = await prisma.delegation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delegations and only return the `id`
     * const delegationWithIdOnly = await prisma.delegation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends delegationCreateManyAndReturnArgs>(args?: SelectSubset<T, delegationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Delegation.
     * @param {delegationDeleteArgs} args - Arguments to delete one Delegation.
     * @example
     * // Delete one Delegation
     * const Delegation = await prisma.delegation.delete({
     *   where: {
     *     // ... filter to delete one Delegation
     *   }
     * })
     * 
     */
    delete<T extends delegationDeleteArgs>(args: SelectSubset<T, delegationDeleteArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Delegation.
     * @param {delegationUpdateArgs} args - Arguments to update one Delegation.
     * @example
     * // Update one Delegation
     * const delegation = await prisma.delegation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends delegationUpdateArgs>(args: SelectSubset<T, delegationUpdateArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Delegations.
     * @param {delegationDeleteManyArgs} args - Arguments to filter Delegations to delete.
     * @example
     * // Delete a few Delegations
     * const { count } = await prisma.delegation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends delegationDeleteManyArgs>(args?: SelectSubset<T, delegationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delegations
     * const delegation = await prisma.delegation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends delegationUpdateManyArgs>(args: SelectSubset<T, delegationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegations and returns the data updated in the database.
     * @param {delegationUpdateManyAndReturnArgs} args - Arguments to update many Delegations.
     * @example
     * // Update many Delegations
     * const delegation = await prisma.delegation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delegations and only return the `id`
     * const delegationWithIdOnly = await prisma.delegation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends delegationUpdateManyAndReturnArgs>(args: SelectSubset<T, delegationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Delegation.
     * @param {delegationUpsertArgs} args - Arguments to update or create a Delegation.
     * @example
     * // Update or create a Delegation
     * const delegation = await prisma.delegation.upsert({
     *   create: {
     *     // ... data to create a Delegation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delegation we want to update
     *   }
     * })
     */
    upsert<T extends delegationUpsertArgs>(args: SelectSubset<T, delegationUpsertArgs<ExtArgs>>): Prisma__delegationClient<$Result.GetResult<Prisma.$delegationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Delegations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationCountArgs} args - Arguments to filter Delegations to count.
     * @example
     * // Count the number of Delegations
     * const count = await prisma.delegation.count({
     *   where: {
     *     // ... the filter for the Delegations we want to count
     *   }
     * })
    **/
    count<T extends delegationCountArgs>(
      args?: Subset<T, delegationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelegationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delegation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelegationAggregateArgs>(args: Subset<T, DelegationAggregateArgs>): Prisma.PrismaPromise<GetDelegationAggregateType<T>>

    /**
     * Group by Delegation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends delegationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: delegationGroupByArgs['orderBy'] }
        : { orderBy?: delegationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, delegationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelegationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the delegation model
   */
  readonly fields: delegationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for delegation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__delegationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the delegation model
   */ 
  interface delegationFieldRefs {
    readonly id: FieldRef<"delegation", 'BigInt'>
    readonly addr_id: FieldRef<"delegation", 'BigInt'>
    readonly cert_index: FieldRef<"delegation", 'Int'>
    readonly pool_hash_id: FieldRef<"delegation", 'BigInt'>
    readonly active_epoch_no: FieldRef<"delegation", 'BigInt'>
    readonly tx_id: FieldRef<"delegation", 'BigInt'>
    readonly slot_no: FieldRef<"delegation", 'BigInt'>
    readonly redeemer_id: FieldRef<"delegation", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * delegation findUnique
   */
  export type delegationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter, which delegation to fetch.
     */
    where: delegationWhereUniqueInput
  }

  /**
   * delegation findUniqueOrThrow
   */
  export type delegationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter, which delegation to fetch.
     */
    where: delegationWhereUniqueInput
  }

  /**
   * delegation findFirst
   */
  export type delegationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter, which delegation to fetch.
     */
    where?: delegationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegations to fetch.
     */
    orderBy?: delegationOrderByWithRelationInput | delegationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delegations.
     */
    cursor?: delegationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delegations.
     */
    distinct?: DelegationScalarFieldEnum | DelegationScalarFieldEnum[]
  }

  /**
   * delegation findFirstOrThrow
   */
  export type delegationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter, which delegation to fetch.
     */
    where?: delegationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegations to fetch.
     */
    orderBy?: delegationOrderByWithRelationInput | delegationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delegations.
     */
    cursor?: delegationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delegations.
     */
    distinct?: DelegationScalarFieldEnum | DelegationScalarFieldEnum[]
  }

  /**
   * delegation findMany
   */
  export type delegationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter, which delegations to fetch.
     */
    where?: delegationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegations to fetch.
     */
    orderBy?: delegationOrderByWithRelationInput | delegationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing delegations.
     */
    cursor?: delegationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegations.
     */
    skip?: number
    distinct?: DelegationScalarFieldEnum | DelegationScalarFieldEnum[]
  }

  /**
   * delegation create
   */
  export type delegationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * The data needed to create a delegation.
     */
    data: XOR<delegationCreateInput, delegationUncheckedCreateInput>
  }

  /**
   * delegation createMany
   */
  export type delegationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many delegations.
     */
    data: delegationCreateManyInput | delegationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delegation createManyAndReturn
   */
  export type delegationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * The data used to create many delegations.
     */
    data: delegationCreateManyInput | delegationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delegation update
   */
  export type delegationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * The data needed to update a delegation.
     */
    data: XOR<delegationUpdateInput, delegationUncheckedUpdateInput>
    /**
     * Choose, which delegation to update.
     */
    where: delegationWhereUniqueInput
  }

  /**
   * delegation updateMany
   */
  export type delegationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update delegations.
     */
    data: XOR<delegationUpdateManyMutationInput, delegationUncheckedUpdateManyInput>
    /**
     * Filter which delegations to update
     */
    where?: delegationWhereInput
    /**
     * Limit how many delegations to update.
     */
    limit?: number
  }

  /**
   * delegation updateManyAndReturn
   */
  export type delegationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * The data used to update delegations.
     */
    data: XOR<delegationUpdateManyMutationInput, delegationUncheckedUpdateManyInput>
    /**
     * Filter which delegations to update
     */
    where?: delegationWhereInput
    /**
     * Limit how many delegations to update.
     */
    limit?: number
  }

  /**
   * delegation upsert
   */
  export type delegationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * The filter to search for the delegation to update in case it exists.
     */
    where: delegationWhereUniqueInput
    /**
     * In case the delegation found by the `where` argument doesn't exist, create a new delegation with this data.
     */
    create: XOR<delegationCreateInput, delegationUncheckedCreateInput>
    /**
     * In case the delegation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<delegationUpdateInput, delegationUncheckedUpdateInput>
  }

  /**
   * delegation delete
   */
  export type delegationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
    /**
     * Filter which delegation to delete.
     */
    where: delegationWhereUniqueInput
  }

  /**
   * delegation deleteMany
   */
  export type delegationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delegations to delete
     */
    where?: delegationWhereInput
    /**
     * Limit how many delegations to delete.
     */
    limit?: number
  }

  /**
   * delegation without action
   */
  export type delegationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation
     */
    select?: delegationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation
     */
    omit?: delegationOmit<ExtArgs> | null
  }


  /**
   * Model delegation_vote
   */

  export type AggregateDelegation_vote = {
    _count: Delegation_voteCountAggregateOutputType | null
    _avg: Delegation_voteAvgAggregateOutputType | null
    _sum: Delegation_voteSumAggregateOutputType | null
    _min: Delegation_voteMinAggregateOutputType | null
    _max: Delegation_voteMaxAggregateOutputType | null
  }

  export type Delegation_voteAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    drep_hash_id: number | null
    tx_id: number | null
    redeemer_id: number | null
  }

  export type Delegation_voteSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    drep_hash_id: bigint | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Delegation_voteMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    drep_hash_id: bigint | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Delegation_voteMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    drep_hash_id: bigint | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Delegation_voteCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    drep_hash_id: number
    tx_id: number
    redeemer_id: number
    _all: number
  }


  export type Delegation_voteAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    drep_hash_id?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Delegation_voteSumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    drep_hash_id?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Delegation_voteMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    drep_hash_id?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Delegation_voteMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    drep_hash_id?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Delegation_voteCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    drep_hash_id?: true
    tx_id?: true
    redeemer_id?: true
    _all?: true
  }

  export type Delegation_voteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delegation_vote to aggregate.
     */
    where?: delegation_voteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegation_votes to fetch.
     */
    orderBy?: delegation_voteOrderByWithRelationInput | delegation_voteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: delegation_voteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegation_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegation_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned delegation_votes
    **/
    _count?: true | Delegation_voteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Delegation_voteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Delegation_voteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Delegation_voteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Delegation_voteMaxAggregateInputType
  }

  export type GetDelegation_voteAggregateType<T extends Delegation_voteAggregateArgs> = {
        [P in keyof T & keyof AggregateDelegation_vote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelegation_vote[P]>
      : GetScalarType<T[P], AggregateDelegation_vote[P]>
  }




  export type delegation_voteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delegation_voteWhereInput
    orderBy?: delegation_voteOrderByWithAggregationInput | delegation_voteOrderByWithAggregationInput[]
    by: Delegation_voteScalarFieldEnum[] | Delegation_voteScalarFieldEnum
    having?: delegation_voteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Delegation_voteCountAggregateInputType | true
    _avg?: Delegation_voteAvgAggregateInputType
    _sum?: Delegation_voteSumAggregateInputType
    _min?: Delegation_voteMinAggregateInputType
    _max?: Delegation_voteMaxAggregateInputType
  }

  export type Delegation_voteGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    drep_hash_id: bigint
    tx_id: bigint
    redeemer_id: bigint | null
    _count: Delegation_voteCountAggregateOutputType | null
    _avg: Delegation_voteAvgAggregateOutputType | null
    _sum: Delegation_voteSumAggregateOutputType | null
    _min: Delegation_voteMinAggregateOutputType | null
    _max: Delegation_voteMaxAggregateOutputType | null
  }

  type GetDelegation_voteGroupByPayload<T extends delegation_voteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Delegation_voteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Delegation_voteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Delegation_voteGroupByOutputType[P]>
            : GetScalarType<T[P], Delegation_voteGroupByOutputType[P]>
        }
      >
    >


  export type delegation_voteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    drep_hash_id?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation_vote"]>

  export type delegation_voteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    drep_hash_id?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation_vote"]>

  export type delegation_voteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    drep_hash_id?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["delegation_vote"]>

  export type delegation_voteSelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    drep_hash_id?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }

  export type delegation_voteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "drep_hash_id" | "tx_id" | "redeemer_id", ExtArgs["result"]["delegation_vote"]>

  export type $delegation_votePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "delegation_vote"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      drep_hash_id: bigint
      tx_id: bigint
      redeemer_id: bigint | null
    }, ExtArgs["result"]["delegation_vote"]>
    composites: {}
  }

  type delegation_voteGetPayload<S extends boolean | null | undefined | delegation_voteDefaultArgs> = $Result.GetResult<Prisma.$delegation_votePayload, S>

  type delegation_voteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<delegation_voteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Delegation_voteCountAggregateInputType | true
    }

  export interface delegation_voteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['delegation_vote'], meta: { name: 'delegation_vote' } }
    /**
     * Find zero or one Delegation_vote that matches the filter.
     * @param {delegation_voteFindUniqueArgs} args - Arguments to find a Delegation_vote
     * @example
     * // Get one Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends delegation_voteFindUniqueArgs>(args: SelectSubset<T, delegation_voteFindUniqueArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Delegation_vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {delegation_voteFindUniqueOrThrowArgs} args - Arguments to find a Delegation_vote
     * @example
     * // Get one Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends delegation_voteFindUniqueOrThrowArgs>(args: SelectSubset<T, delegation_voteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Delegation_vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteFindFirstArgs} args - Arguments to find a Delegation_vote
     * @example
     * // Get one Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends delegation_voteFindFirstArgs>(args?: SelectSubset<T, delegation_voteFindFirstArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Delegation_vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteFindFirstOrThrowArgs} args - Arguments to find a Delegation_vote
     * @example
     * // Get one Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends delegation_voteFindFirstOrThrowArgs>(args?: SelectSubset<T, delegation_voteFindFirstOrThrowArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Delegation_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delegation_votes
     * const delegation_votes = await prisma.delegation_vote.findMany()
     * 
     * // Get first 10 Delegation_votes
     * const delegation_votes = await prisma.delegation_vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delegation_voteWithIdOnly = await prisma.delegation_vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends delegation_voteFindManyArgs>(args?: SelectSubset<T, delegation_voteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Delegation_vote.
     * @param {delegation_voteCreateArgs} args - Arguments to create a Delegation_vote.
     * @example
     * // Create one Delegation_vote
     * const Delegation_vote = await prisma.delegation_vote.create({
     *   data: {
     *     // ... data to create a Delegation_vote
     *   }
     * })
     * 
     */
    create<T extends delegation_voteCreateArgs>(args: SelectSubset<T, delegation_voteCreateArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Delegation_votes.
     * @param {delegation_voteCreateManyArgs} args - Arguments to create many Delegation_votes.
     * @example
     * // Create many Delegation_votes
     * const delegation_vote = await prisma.delegation_vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends delegation_voteCreateManyArgs>(args?: SelectSubset<T, delegation_voteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delegation_votes and returns the data saved in the database.
     * @param {delegation_voteCreateManyAndReturnArgs} args - Arguments to create many Delegation_votes.
     * @example
     * // Create many Delegation_votes
     * const delegation_vote = await prisma.delegation_vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delegation_votes and only return the `id`
     * const delegation_voteWithIdOnly = await prisma.delegation_vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends delegation_voteCreateManyAndReturnArgs>(args?: SelectSubset<T, delegation_voteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Delegation_vote.
     * @param {delegation_voteDeleteArgs} args - Arguments to delete one Delegation_vote.
     * @example
     * // Delete one Delegation_vote
     * const Delegation_vote = await prisma.delegation_vote.delete({
     *   where: {
     *     // ... filter to delete one Delegation_vote
     *   }
     * })
     * 
     */
    delete<T extends delegation_voteDeleteArgs>(args: SelectSubset<T, delegation_voteDeleteArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Delegation_vote.
     * @param {delegation_voteUpdateArgs} args - Arguments to update one Delegation_vote.
     * @example
     * // Update one Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends delegation_voteUpdateArgs>(args: SelectSubset<T, delegation_voteUpdateArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Delegation_votes.
     * @param {delegation_voteDeleteManyArgs} args - Arguments to filter Delegation_votes to delete.
     * @example
     * // Delete a few Delegation_votes
     * const { count } = await prisma.delegation_vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends delegation_voteDeleteManyArgs>(args?: SelectSubset<T, delegation_voteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegation_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delegation_votes
     * const delegation_vote = await prisma.delegation_vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends delegation_voteUpdateManyArgs>(args: SelectSubset<T, delegation_voteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegation_votes and returns the data updated in the database.
     * @param {delegation_voteUpdateManyAndReturnArgs} args - Arguments to update many Delegation_votes.
     * @example
     * // Update many Delegation_votes
     * const delegation_vote = await prisma.delegation_vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delegation_votes and only return the `id`
     * const delegation_voteWithIdOnly = await prisma.delegation_vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends delegation_voteUpdateManyAndReturnArgs>(args: SelectSubset<T, delegation_voteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Delegation_vote.
     * @param {delegation_voteUpsertArgs} args - Arguments to update or create a Delegation_vote.
     * @example
     * // Update or create a Delegation_vote
     * const delegation_vote = await prisma.delegation_vote.upsert({
     *   create: {
     *     // ... data to create a Delegation_vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delegation_vote we want to update
     *   }
     * })
     */
    upsert<T extends delegation_voteUpsertArgs>(args: SelectSubset<T, delegation_voteUpsertArgs<ExtArgs>>): Prisma__delegation_voteClient<$Result.GetResult<Prisma.$delegation_votePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Delegation_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteCountArgs} args - Arguments to filter Delegation_votes to count.
     * @example
     * // Count the number of Delegation_votes
     * const count = await prisma.delegation_vote.count({
     *   where: {
     *     // ... the filter for the Delegation_votes we want to count
     *   }
     * })
    **/
    count<T extends delegation_voteCountArgs>(
      args?: Subset<T, delegation_voteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Delegation_voteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delegation_vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Delegation_voteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Delegation_voteAggregateArgs>(args: Subset<T, Delegation_voteAggregateArgs>): Prisma.PrismaPromise<GetDelegation_voteAggregateType<T>>

    /**
     * Group by Delegation_vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delegation_voteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends delegation_voteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: delegation_voteGroupByArgs['orderBy'] }
        : { orderBy?: delegation_voteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, delegation_voteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelegation_voteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the delegation_vote model
   */
  readonly fields: delegation_voteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for delegation_vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__delegation_voteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the delegation_vote model
   */ 
  interface delegation_voteFieldRefs {
    readonly id: FieldRef<"delegation_vote", 'BigInt'>
    readonly addr_id: FieldRef<"delegation_vote", 'BigInt'>
    readonly cert_index: FieldRef<"delegation_vote", 'Int'>
    readonly drep_hash_id: FieldRef<"delegation_vote", 'BigInt'>
    readonly tx_id: FieldRef<"delegation_vote", 'BigInt'>
    readonly redeemer_id: FieldRef<"delegation_vote", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * delegation_vote findUnique
   */
  export type delegation_voteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter, which delegation_vote to fetch.
     */
    where: delegation_voteWhereUniqueInput
  }

  /**
   * delegation_vote findUniqueOrThrow
   */
  export type delegation_voteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter, which delegation_vote to fetch.
     */
    where: delegation_voteWhereUniqueInput
  }

  /**
   * delegation_vote findFirst
   */
  export type delegation_voteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter, which delegation_vote to fetch.
     */
    where?: delegation_voteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegation_votes to fetch.
     */
    orderBy?: delegation_voteOrderByWithRelationInput | delegation_voteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delegation_votes.
     */
    cursor?: delegation_voteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegation_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegation_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delegation_votes.
     */
    distinct?: Delegation_voteScalarFieldEnum | Delegation_voteScalarFieldEnum[]
  }

  /**
   * delegation_vote findFirstOrThrow
   */
  export type delegation_voteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter, which delegation_vote to fetch.
     */
    where?: delegation_voteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegation_votes to fetch.
     */
    orderBy?: delegation_voteOrderByWithRelationInput | delegation_voteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delegation_votes.
     */
    cursor?: delegation_voteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegation_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegation_votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delegation_votes.
     */
    distinct?: Delegation_voteScalarFieldEnum | Delegation_voteScalarFieldEnum[]
  }

  /**
   * delegation_vote findMany
   */
  export type delegation_voteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter, which delegation_votes to fetch.
     */
    where?: delegation_voteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delegation_votes to fetch.
     */
    orderBy?: delegation_voteOrderByWithRelationInput | delegation_voteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing delegation_votes.
     */
    cursor?: delegation_voteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delegation_votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delegation_votes.
     */
    skip?: number
    distinct?: Delegation_voteScalarFieldEnum | Delegation_voteScalarFieldEnum[]
  }

  /**
   * delegation_vote create
   */
  export type delegation_voteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * The data needed to create a delegation_vote.
     */
    data: XOR<delegation_voteCreateInput, delegation_voteUncheckedCreateInput>
  }

  /**
   * delegation_vote createMany
   */
  export type delegation_voteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many delegation_votes.
     */
    data: delegation_voteCreateManyInput | delegation_voteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delegation_vote createManyAndReturn
   */
  export type delegation_voteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * The data used to create many delegation_votes.
     */
    data: delegation_voteCreateManyInput | delegation_voteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delegation_vote update
   */
  export type delegation_voteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * The data needed to update a delegation_vote.
     */
    data: XOR<delegation_voteUpdateInput, delegation_voteUncheckedUpdateInput>
    /**
     * Choose, which delegation_vote to update.
     */
    where: delegation_voteWhereUniqueInput
  }

  /**
   * delegation_vote updateMany
   */
  export type delegation_voteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update delegation_votes.
     */
    data: XOR<delegation_voteUpdateManyMutationInput, delegation_voteUncheckedUpdateManyInput>
    /**
     * Filter which delegation_votes to update
     */
    where?: delegation_voteWhereInput
    /**
     * Limit how many delegation_votes to update.
     */
    limit?: number
  }

  /**
   * delegation_vote updateManyAndReturn
   */
  export type delegation_voteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * The data used to update delegation_votes.
     */
    data: XOR<delegation_voteUpdateManyMutationInput, delegation_voteUncheckedUpdateManyInput>
    /**
     * Filter which delegation_votes to update
     */
    where?: delegation_voteWhereInput
    /**
     * Limit how many delegation_votes to update.
     */
    limit?: number
  }

  /**
   * delegation_vote upsert
   */
  export type delegation_voteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * The filter to search for the delegation_vote to update in case it exists.
     */
    where: delegation_voteWhereUniqueInput
    /**
     * In case the delegation_vote found by the `where` argument doesn't exist, create a new delegation_vote with this data.
     */
    create: XOR<delegation_voteCreateInput, delegation_voteUncheckedCreateInput>
    /**
     * In case the delegation_vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<delegation_voteUpdateInput, delegation_voteUncheckedUpdateInput>
  }

  /**
   * delegation_vote delete
   */
  export type delegation_voteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
    /**
     * Filter which delegation_vote to delete.
     */
    where: delegation_voteWhereUniqueInput
  }

  /**
   * delegation_vote deleteMany
   */
  export type delegation_voteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delegation_votes to delete
     */
    where?: delegation_voteWhereInput
    /**
     * Limit how many delegation_votes to delete.
     */
    limit?: number
  }

  /**
   * delegation_vote without action
   */
  export type delegation_voteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delegation_vote
     */
    select?: delegation_voteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delegation_vote
     */
    omit?: delegation_voteOmit<ExtArgs> | null
  }


  /**
   * Model delisted_pool
   */

  export type AggregateDelisted_pool = {
    _count: Delisted_poolCountAggregateOutputType | null
    _avg: Delisted_poolAvgAggregateOutputType | null
    _sum: Delisted_poolSumAggregateOutputType | null
    _min: Delisted_poolMinAggregateOutputType | null
    _max: Delisted_poolMaxAggregateOutputType | null
  }

  export type Delisted_poolAvgAggregateOutputType = {
    id: number | null
  }

  export type Delisted_poolSumAggregateOutputType = {
    id: bigint | null
  }

  export type Delisted_poolMinAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
  }

  export type Delisted_poolMaxAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
  }

  export type Delisted_poolCountAggregateOutputType = {
    id: number
    hash_raw: number
    _all: number
  }


  export type Delisted_poolAvgAggregateInputType = {
    id?: true
  }

  export type Delisted_poolSumAggregateInputType = {
    id?: true
  }

  export type Delisted_poolMinAggregateInputType = {
    id?: true
    hash_raw?: true
  }

  export type Delisted_poolMaxAggregateInputType = {
    id?: true
    hash_raw?: true
  }

  export type Delisted_poolCountAggregateInputType = {
    id?: true
    hash_raw?: true
    _all?: true
  }

  export type Delisted_poolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delisted_pool to aggregate.
     */
    where?: delisted_poolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delisted_pools to fetch.
     */
    orderBy?: delisted_poolOrderByWithRelationInput | delisted_poolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: delisted_poolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delisted_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delisted_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned delisted_pools
    **/
    _count?: true | Delisted_poolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Delisted_poolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Delisted_poolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Delisted_poolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Delisted_poolMaxAggregateInputType
  }

  export type GetDelisted_poolAggregateType<T extends Delisted_poolAggregateArgs> = {
        [P in keyof T & keyof AggregateDelisted_pool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelisted_pool[P]>
      : GetScalarType<T[P], AggregateDelisted_pool[P]>
  }




  export type delisted_poolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: delisted_poolWhereInput
    orderBy?: delisted_poolOrderByWithAggregationInput | delisted_poolOrderByWithAggregationInput[]
    by: Delisted_poolScalarFieldEnum[] | Delisted_poolScalarFieldEnum
    having?: delisted_poolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Delisted_poolCountAggregateInputType | true
    _avg?: Delisted_poolAvgAggregateInputType
    _sum?: Delisted_poolSumAggregateInputType
    _min?: Delisted_poolMinAggregateInputType
    _max?: Delisted_poolMaxAggregateInputType
  }

  export type Delisted_poolGroupByOutputType = {
    id: bigint
    hash_raw: Uint8Array
    _count: Delisted_poolCountAggregateOutputType | null
    _avg: Delisted_poolAvgAggregateOutputType | null
    _sum: Delisted_poolSumAggregateOutputType | null
    _min: Delisted_poolMinAggregateOutputType | null
    _max: Delisted_poolMaxAggregateOutputType | null
  }

  type GetDelisted_poolGroupByPayload<T extends delisted_poolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Delisted_poolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Delisted_poolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Delisted_poolGroupByOutputType[P]>
            : GetScalarType<T[P], Delisted_poolGroupByOutputType[P]>
        }
      >
    >


  export type delisted_poolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
  }, ExtArgs["result"]["delisted_pool"]>

  export type delisted_poolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
  }, ExtArgs["result"]["delisted_pool"]>

  export type delisted_poolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
  }, ExtArgs["result"]["delisted_pool"]>

  export type delisted_poolSelectScalar = {
    id?: boolean
    hash_raw?: boolean
  }

  export type delisted_poolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_raw", ExtArgs["result"]["delisted_pool"]>

  export type $delisted_poolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "delisted_pool"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_raw: Uint8Array
    }, ExtArgs["result"]["delisted_pool"]>
    composites: {}
  }

  type delisted_poolGetPayload<S extends boolean | null | undefined | delisted_poolDefaultArgs> = $Result.GetResult<Prisma.$delisted_poolPayload, S>

  type delisted_poolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<delisted_poolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Delisted_poolCountAggregateInputType | true
    }

  export interface delisted_poolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['delisted_pool'], meta: { name: 'delisted_pool' } }
    /**
     * Find zero or one Delisted_pool that matches the filter.
     * @param {delisted_poolFindUniqueArgs} args - Arguments to find a Delisted_pool
     * @example
     * // Get one Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends delisted_poolFindUniqueArgs>(args: SelectSubset<T, delisted_poolFindUniqueArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Delisted_pool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {delisted_poolFindUniqueOrThrowArgs} args - Arguments to find a Delisted_pool
     * @example
     * // Get one Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends delisted_poolFindUniqueOrThrowArgs>(args: SelectSubset<T, delisted_poolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Delisted_pool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolFindFirstArgs} args - Arguments to find a Delisted_pool
     * @example
     * // Get one Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends delisted_poolFindFirstArgs>(args?: SelectSubset<T, delisted_poolFindFirstArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Delisted_pool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolFindFirstOrThrowArgs} args - Arguments to find a Delisted_pool
     * @example
     * // Get one Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends delisted_poolFindFirstOrThrowArgs>(args?: SelectSubset<T, delisted_poolFindFirstOrThrowArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Delisted_pools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delisted_pools
     * const delisted_pools = await prisma.delisted_pool.findMany()
     * 
     * // Get first 10 Delisted_pools
     * const delisted_pools = await prisma.delisted_pool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delisted_poolWithIdOnly = await prisma.delisted_pool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends delisted_poolFindManyArgs>(args?: SelectSubset<T, delisted_poolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Delisted_pool.
     * @param {delisted_poolCreateArgs} args - Arguments to create a Delisted_pool.
     * @example
     * // Create one Delisted_pool
     * const Delisted_pool = await prisma.delisted_pool.create({
     *   data: {
     *     // ... data to create a Delisted_pool
     *   }
     * })
     * 
     */
    create<T extends delisted_poolCreateArgs>(args: SelectSubset<T, delisted_poolCreateArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Delisted_pools.
     * @param {delisted_poolCreateManyArgs} args - Arguments to create many Delisted_pools.
     * @example
     * // Create many Delisted_pools
     * const delisted_pool = await prisma.delisted_pool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends delisted_poolCreateManyArgs>(args?: SelectSubset<T, delisted_poolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Delisted_pools and returns the data saved in the database.
     * @param {delisted_poolCreateManyAndReturnArgs} args - Arguments to create many Delisted_pools.
     * @example
     * // Create many Delisted_pools
     * const delisted_pool = await prisma.delisted_pool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Delisted_pools and only return the `id`
     * const delisted_poolWithIdOnly = await prisma.delisted_pool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends delisted_poolCreateManyAndReturnArgs>(args?: SelectSubset<T, delisted_poolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Delisted_pool.
     * @param {delisted_poolDeleteArgs} args - Arguments to delete one Delisted_pool.
     * @example
     * // Delete one Delisted_pool
     * const Delisted_pool = await prisma.delisted_pool.delete({
     *   where: {
     *     // ... filter to delete one Delisted_pool
     *   }
     * })
     * 
     */
    delete<T extends delisted_poolDeleteArgs>(args: SelectSubset<T, delisted_poolDeleteArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Delisted_pool.
     * @param {delisted_poolUpdateArgs} args - Arguments to update one Delisted_pool.
     * @example
     * // Update one Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends delisted_poolUpdateArgs>(args: SelectSubset<T, delisted_poolUpdateArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Delisted_pools.
     * @param {delisted_poolDeleteManyArgs} args - Arguments to filter Delisted_pools to delete.
     * @example
     * // Delete a few Delisted_pools
     * const { count } = await prisma.delisted_pool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends delisted_poolDeleteManyArgs>(args?: SelectSubset<T, delisted_poolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delisted_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delisted_pools
     * const delisted_pool = await prisma.delisted_pool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends delisted_poolUpdateManyArgs>(args: SelectSubset<T, delisted_poolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delisted_pools and returns the data updated in the database.
     * @param {delisted_poolUpdateManyAndReturnArgs} args - Arguments to update many Delisted_pools.
     * @example
     * // Update many Delisted_pools
     * const delisted_pool = await prisma.delisted_pool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Delisted_pools and only return the `id`
     * const delisted_poolWithIdOnly = await prisma.delisted_pool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends delisted_poolUpdateManyAndReturnArgs>(args: SelectSubset<T, delisted_poolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Delisted_pool.
     * @param {delisted_poolUpsertArgs} args - Arguments to update or create a Delisted_pool.
     * @example
     * // Update or create a Delisted_pool
     * const delisted_pool = await prisma.delisted_pool.upsert({
     *   create: {
     *     // ... data to create a Delisted_pool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delisted_pool we want to update
     *   }
     * })
     */
    upsert<T extends delisted_poolUpsertArgs>(args: SelectSubset<T, delisted_poolUpsertArgs<ExtArgs>>): Prisma__delisted_poolClient<$Result.GetResult<Prisma.$delisted_poolPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Delisted_pools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolCountArgs} args - Arguments to filter Delisted_pools to count.
     * @example
     * // Count the number of Delisted_pools
     * const count = await prisma.delisted_pool.count({
     *   where: {
     *     // ... the filter for the Delisted_pools we want to count
     *   }
     * })
    **/
    count<T extends delisted_poolCountArgs>(
      args?: Subset<T, delisted_poolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Delisted_poolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delisted_pool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Delisted_poolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Delisted_poolAggregateArgs>(args: Subset<T, Delisted_poolAggregateArgs>): Prisma.PrismaPromise<GetDelisted_poolAggregateType<T>>

    /**
     * Group by Delisted_pool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {delisted_poolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends delisted_poolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: delisted_poolGroupByArgs['orderBy'] }
        : { orderBy?: delisted_poolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, delisted_poolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelisted_poolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the delisted_pool model
   */
  readonly fields: delisted_poolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for delisted_pool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__delisted_poolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the delisted_pool model
   */ 
  interface delisted_poolFieldRefs {
    readonly id: FieldRef<"delisted_pool", 'BigInt'>
    readonly hash_raw: FieldRef<"delisted_pool", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * delisted_pool findUnique
   */
  export type delisted_poolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter, which delisted_pool to fetch.
     */
    where: delisted_poolWhereUniqueInput
  }

  /**
   * delisted_pool findUniqueOrThrow
   */
  export type delisted_poolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter, which delisted_pool to fetch.
     */
    where: delisted_poolWhereUniqueInput
  }

  /**
   * delisted_pool findFirst
   */
  export type delisted_poolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter, which delisted_pool to fetch.
     */
    where?: delisted_poolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delisted_pools to fetch.
     */
    orderBy?: delisted_poolOrderByWithRelationInput | delisted_poolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delisted_pools.
     */
    cursor?: delisted_poolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delisted_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delisted_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delisted_pools.
     */
    distinct?: Delisted_poolScalarFieldEnum | Delisted_poolScalarFieldEnum[]
  }

  /**
   * delisted_pool findFirstOrThrow
   */
  export type delisted_poolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter, which delisted_pool to fetch.
     */
    where?: delisted_poolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delisted_pools to fetch.
     */
    orderBy?: delisted_poolOrderByWithRelationInput | delisted_poolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for delisted_pools.
     */
    cursor?: delisted_poolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delisted_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delisted_pools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of delisted_pools.
     */
    distinct?: Delisted_poolScalarFieldEnum | Delisted_poolScalarFieldEnum[]
  }

  /**
   * delisted_pool findMany
   */
  export type delisted_poolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter, which delisted_pools to fetch.
     */
    where?: delisted_poolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of delisted_pools to fetch.
     */
    orderBy?: delisted_poolOrderByWithRelationInput | delisted_poolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing delisted_pools.
     */
    cursor?: delisted_poolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` delisted_pools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` delisted_pools.
     */
    skip?: number
    distinct?: Delisted_poolScalarFieldEnum | Delisted_poolScalarFieldEnum[]
  }

  /**
   * delisted_pool create
   */
  export type delisted_poolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * The data needed to create a delisted_pool.
     */
    data: XOR<delisted_poolCreateInput, delisted_poolUncheckedCreateInput>
  }

  /**
   * delisted_pool createMany
   */
  export type delisted_poolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many delisted_pools.
     */
    data: delisted_poolCreateManyInput | delisted_poolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delisted_pool createManyAndReturn
   */
  export type delisted_poolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * The data used to create many delisted_pools.
     */
    data: delisted_poolCreateManyInput | delisted_poolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * delisted_pool update
   */
  export type delisted_poolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * The data needed to update a delisted_pool.
     */
    data: XOR<delisted_poolUpdateInput, delisted_poolUncheckedUpdateInput>
    /**
     * Choose, which delisted_pool to update.
     */
    where: delisted_poolWhereUniqueInput
  }

  /**
   * delisted_pool updateMany
   */
  export type delisted_poolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update delisted_pools.
     */
    data: XOR<delisted_poolUpdateManyMutationInput, delisted_poolUncheckedUpdateManyInput>
    /**
     * Filter which delisted_pools to update
     */
    where?: delisted_poolWhereInput
    /**
     * Limit how many delisted_pools to update.
     */
    limit?: number
  }

  /**
   * delisted_pool updateManyAndReturn
   */
  export type delisted_poolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * The data used to update delisted_pools.
     */
    data: XOR<delisted_poolUpdateManyMutationInput, delisted_poolUncheckedUpdateManyInput>
    /**
     * Filter which delisted_pools to update
     */
    where?: delisted_poolWhereInput
    /**
     * Limit how many delisted_pools to update.
     */
    limit?: number
  }

  /**
   * delisted_pool upsert
   */
  export type delisted_poolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * The filter to search for the delisted_pool to update in case it exists.
     */
    where: delisted_poolWhereUniqueInput
    /**
     * In case the delisted_pool found by the `where` argument doesn't exist, create a new delisted_pool with this data.
     */
    create: XOR<delisted_poolCreateInput, delisted_poolUncheckedCreateInput>
    /**
     * In case the delisted_pool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<delisted_poolUpdateInput, delisted_poolUncheckedUpdateInput>
  }

  /**
   * delisted_pool delete
   */
  export type delisted_poolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
    /**
     * Filter which delisted_pool to delete.
     */
    where: delisted_poolWhereUniqueInput
  }

  /**
   * delisted_pool deleteMany
   */
  export type delisted_poolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which delisted_pools to delete
     */
    where?: delisted_poolWhereInput
    /**
     * Limit how many delisted_pools to delete.
     */
    limit?: number
  }

  /**
   * delisted_pool without action
   */
  export type delisted_poolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the delisted_pool
     */
    select?: delisted_poolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the delisted_pool
     */
    omit?: delisted_poolOmit<ExtArgs> | null
  }


  /**
   * Model drep_distr
   */

  export type AggregateDrep_distr = {
    _count: Drep_distrCountAggregateOutputType | null
    _avg: Drep_distrAvgAggregateOutputType | null
    _sum: Drep_distrSumAggregateOutputType | null
    _min: Drep_distrMinAggregateOutputType | null
    _max: Drep_distrMaxAggregateOutputType | null
  }

  export type Drep_distrAvgAggregateOutputType = {
    id: number | null
    hash_id: number | null
    amount: number | null
    epoch_no: number | null
    active_until: number | null
  }

  export type Drep_distrSumAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    amount: bigint | null
    epoch_no: number | null
    active_until: number | null
  }

  export type Drep_distrMinAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    amount: bigint | null
    epoch_no: number | null
    active_until: number | null
  }

  export type Drep_distrMaxAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    amount: bigint | null
    epoch_no: number | null
    active_until: number | null
  }

  export type Drep_distrCountAggregateOutputType = {
    id: number
    hash_id: number
    amount: number
    epoch_no: number
    active_until: number
    _all: number
  }


  export type Drep_distrAvgAggregateInputType = {
    id?: true
    hash_id?: true
    amount?: true
    epoch_no?: true
    active_until?: true
  }

  export type Drep_distrSumAggregateInputType = {
    id?: true
    hash_id?: true
    amount?: true
    epoch_no?: true
    active_until?: true
  }

  export type Drep_distrMinAggregateInputType = {
    id?: true
    hash_id?: true
    amount?: true
    epoch_no?: true
    active_until?: true
  }

  export type Drep_distrMaxAggregateInputType = {
    id?: true
    hash_id?: true
    amount?: true
    epoch_no?: true
    active_until?: true
  }

  export type Drep_distrCountAggregateInputType = {
    id?: true
    hash_id?: true
    amount?: true
    epoch_no?: true
    active_until?: true
    _all?: true
  }

  export type Drep_distrAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_distr to aggregate.
     */
    where?: drep_distrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_distrs to fetch.
     */
    orderBy?: drep_distrOrderByWithRelationInput | drep_distrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drep_distrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_distrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_distrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drep_distrs
    **/
    _count?: true | Drep_distrCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Drep_distrAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Drep_distrSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Drep_distrMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Drep_distrMaxAggregateInputType
  }

  export type GetDrep_distrAggregateType<T extends Drep_distrAggregateArgs> = {
        [P in keyof T & keyof AggregateDrep_distr]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrep_distr[P]>
      : GetScalarType<T[P], AggregateDrep_distr[P]>
  }




  export type drep_distrGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drep_distrWhereInput
    orderBy?: drep_distrOrderByWithAggregationInput | drep_distrOrderByWithAggregationInput[]
    by: Drep_distrScalarFieldEnum[] | Drep_distrScalarFieldEnum
    having?: drep_distrScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Drep_distrCountAggregateInputType | true
    _avg?: Drep_distrAvgAggregateInputType
    _sum?: Drep_distrSumAggregateInputType
    _min?: Drep_distrMinAggregateInputType
    _max?: Drep_distrMaxAggregateInputType
  }

  export type Drep_distrGroupByOutputType = {
    id: bigint
    hash_id: bigint
    amount: bigint
    epoch_no: number
    active_until: number | null
    _count: Drep_distrCountAggregateOutputType | null
    _avg: Drep_distrAvgAggregateOutputType | null
    _sum: Drep_distrSumAggregateOutputType | null
    _min: Drep_distrMinAggregateOutputType | null
    _max: Drep_distrMaxAggregateOutputType | null
  }

  type GetDrep_distrGroupByPayload<T extends drep_distrGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Drep_distrGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Drep_distrGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Drep_distrGroupByOutputType[P]>
            : GetScalarType<T[P], Drep_distrGroupByOutputType[P]>
        }
      >
    >


  export type drep_distrSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    amount?: boolean
    epoch_no?: boolean
    active_until?: boolean
  }, ExtArgs["result"]["drep_distr"]>

  export type drep_distrSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    amount?: boolean
    epoch_no?: boolean
    active_until?: boolean
  }, ExtArgs["result"]["drep_distr"]>

  export type drep_distrSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    amount?: boolean
    epoch_no?: boolean
    active_until?: boolean
  }, ExtArgs["result"]["drep_distr"]>

  export type drep_distrSelectScalar = {
    id?: boolean
    hash_id?: boolean
    amount?: boolean
    epoch_no?: boolean
    active_until?: boolean
  }

  export type drep_distrOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_id" | "amount" | "epoch_no" | "active_until", ExtArgs["result"]["drep_distr"]>

  export type $drep_distrPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "drep_distr"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_id: bigint
      amount: bigint
      epoch_no: number
      active_until: number | null
    }, ExtArgs["result"]["drep_distr"]>
    composites: {}
  }

  type drep_distrGetPayload<S extends boolean | null | undefined | drep_distrDefaultArgs> = $Result.GetResult<Prisma.$drep_distrPayload, S>

  type drep_distrCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<drep_distrFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Drep_distrCountAggregateInputType | true
    }

  export interface drep_distrDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['drep_distr'], meta: { name: 'drep_distr' } }
    /**
     * Find zero or one Drep_distr that matches the filter.
     * @param {drep_distrFindUniqueArgs} args - Arguments to find a Drep_distr
     * @example
     * // Get one Drep_distr
     * const drep_distr = await prisma.drep_distr.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends drep_distrFindUniqueArgs>(args: SelectSubset<T, drep_distrFindUniqueArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Drep_distr that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {drep_distrFindUniqueOrThrowArgs} args - Arguments to find a Drep_distr
     * @example
     * // Get one Drep_distr
     * const drep_distr = await prisma.drep_distr.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends drep_distrFindUniqueOrThrowArgs>(args: SelectSubset<T, drep_distrFindUniqueOrThrowArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_distr that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrFindFirstArgs} args - Arguments to find a Drep_distr
     * @example
     * // Get one Drep_distr
     * const drep_distr = await prisma.drep_distr.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends drep_distrFindFirstArgs>(args?: SelectSubset<T, drep_distrFindFirstArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_distr that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrFindFirstOrThrowArgs} args - Arguments to find a Drep_distr
     * @example
     * // Get one Drep_distr
     * const drep_distr = await prisma.drep_distr.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends drep_distrFindFirstOrThrowArgs>(args?: SelectSubset<T, drep_distrFindFirstOrThrowArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Drep_distrs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drep_distrs
     * const drep_distrs = await prisma.drep_distr.findMany()
     * 
     * // Get first 10 Drep_distrs
     * const drep_distrs = await prisma.drep_distr.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drep_distrWithIdOnly = await prisma.drep_distr.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends drep_distrFindManyArgs>(args?: SelectSubset<T, drep_distrFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Drep_distr.
     * @param {drep_distrCreateArgs} args - Arguments to create a Drep_distr.
     * @example
     * // Create one Drep_distr
     * const Drep_distr = await prisma.drep_distr.create({
     *   data: {
     *     // ... data to create a Drep_distr
     *   }
     * })
     * 
     */
    create<T extends drep_distrCreateArgs>(args: SelectSubset<T, drep_distrCreateArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Drep_distrs.
     * @param {drep_distrCreateManyArgs} args - Arguments to create many Drep_distrs.
     * @example
     * // Create many Drep_distrs
     * const drep_distr = await prisma.drep_distr.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends drep_distrCreateManyArgs>(args?: SelectSubset<T, drep_distrCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drep_distrs and returns the data saved in the database.
     * @param {drep_distrCreateManyAndReturnArgs} args - Arguments to create many Drep_distrs.
     * @example
     * // Create many Drep_distrs
     * const drep_distr = await prisma.drep_distr.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drep_distrs and only return the `id`
     * const drep_distrWithIdOnly = await prisma.drep_distr.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends drep_distrCreateManyAndReturnArgs>(args?: SelectSubset<T, drep_distrCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Drep_distr.
     * @param {drep_distrDeleteArgs} args - Arguments to delete one Drep_distr.
     * @example
     * // Delete one Drep_distr
     * const Drep_distr = await prisma.drep_distr.delete({
     *   where: {
     *     // ... filter to delete one Drep_distr
     *   }
     * })
     * 
     */
    delete<T extends drep_distrDeleteArgs>(args: SelectSubset<T, drep_distrDeleteArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Drep_distr.
     * @param {drep_distrUpdateArgs} args - Arguments to update one Drep_distr.
     * @example
     * // Update one Drep_distr
     * const drep_distr = await prisma.drep_distr.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends drep_distrUpdateArgs>(args: SelectSubset<T, drep_distrUpdateArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Drep_distrs.
     * @param {drep_distrDeleteManyArgs} args - Arguments to filter Drep_distrs to delete.
     * @example
     * // Delete a few Drep_distrs
     * const { count } = await prisma.drep_distr.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends drep_distrDeleteManyArgs>(args?: SelectSubset<T, drep_distrDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_distrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drep_distrs
     * const drep_distr = await prisma.drep_distr.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends drep_distrUpdateManyArgs>(args: SelectSubset<T, drep_distrUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_distrs and returns the data updated in the database.
     * @param {drep_distrUpdateManyAndReturnArgs} args - Arguments to update many Drep_distrs.
     * @example
     * // Update many Drep_distrs
     * const drep_distr = await prisma.drep_distr.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drep_distrs and only return the `id`
     * const drep_distrWithIdOnly = await prisma.drep_distr.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends drep_distrUpdateManyAndReturnArgs>(args: SelectSubset<T, drep_distrUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Drep_distr.
     * @param {drep_distrUpsertArgs} args - Arguments to update or create a Drep_distr.
     * @example
     * // Update or create a Drep_distr
     * const drep_distr = await prisma.drep_distr.upsert({
     *   create: {
     *     // ... data to create a Drep_distr
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drep_distr we want to update
     *   }
     * })
     */
    upsert<T extends drep_distrUpsertArgs>(args: SelectSubset<T, drep_distrUpsertArgs<ExtArgs>>): Prisma__drep_distrClient<$Result.GetResult<Prisma.$drep_distrPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Drep_distrs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrCountArgs} args - Arguments to filter Drep_distrs to count.
     * @example
     * // Count the number of Drep_distrs
     * const count = await prisma.drep_distr.count({
     *   where: {
     *     // ... the filter for the Drep_distrs we want to count
     *   }
     * })
    **/
    count<T extends drep_distrCountArgs>(
      args?: Subset<T, drep_distrCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Drep_distrCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drep_distr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drep_distrAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Drep_distrAggregateArgs>(args: Subset<T, Drep_distrAggregateArgs>): Prisma.PrismaPromise<GetDrep_distrAggregateType<T>>

    /**
     * Group by Drep_distr.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_distrGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends drep_distrGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: drep_distrGroupByArgs['orderBy'] }
        : { orderBy?: drep_distrGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, drep_distrGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrep_distrGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the drep_distr model
   */
  readonly fields: drep_distrFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for drep_distr.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__drep_distrClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the drep_distr model
   */ 
  interface drep_distrFieldRefs {
    readonly id: FieldRef<"drep_distr", 'BigInt'>
    readonly hash_id: FieldRef<"drep_distr", 'BigInt'>
    readonly amount: FieldRef<"drep_distr", 'BigInt'>
    readonly epoch_no: FieldRef<"drep_distr", 'Int'>
    readonly active_until: FieldRef<"drep_distr", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * drep_distr findUnique
   */
  export type drep_distrFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter, which drep_distr to fetch.
     */
    where: drep_distrWhereUniqueInput
  }

  /**
   * drep_distr findUniqueOrThrow
   */
  export type drep_distrFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter, which drep_distr to fetch.
     */
    where: drep_distrWhereUniqueInput
  }

  /**
   * drep_distr findFirst
   */
  export type drep_distrFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter, which drep_distr to fetch.
     */
    where?: drep_distrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_distrs to fetch.
     */
    orderBy?: drep_distrOrderByWithRelationInput | drep_distrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_distrs.
     */
    cursor?: drep_distrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_distrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_distrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_distrs.
     */
    distinct?: Drep_distrScalarFieldEnum | Drep_distrScalarFieldEnum[]
  }

  /**
   * drep_distr findFirstOrThrow
   */
  export type drep_distrFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter, which drep_distr to fetch.
     */
    where?: drep_distrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_distrs to fetch.
     */
    orderBy?: drep_distrOrderByWithRelationInput | drep_distrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_distrs.
     */
    cursor?: drep_distrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_distrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_distrs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_distrs.
     */
    distinct?: Drep_distrScalarFieldEnum | Drep_distrScalarFieldEnum[]
  }

  /**
   * drep_distr findMany
   */
  export type drep_distrFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter, which drep_distrs to fetch.
     */
    where?: drep_distrWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_distrs to fetch.
     */
    orderBy?: drep_distrOrderByWithRelationInput | drep_distrOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drep_distrs.
     */
    cursor?: drep_distrWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_distrs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_distrs.
     */
    skip?: number
    distinct?: Drep_distrScalarFieldEnum | Drep_distrScalarFieldEnum[]
  }

  /**
   * drep_distr create
   */
  export type drep_distrCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * The data needed to create a drep_distr.
     */
    data: XOR<drep_distrCreateInput, drep_distrUncheckedCreateInput>
  }

  /**
   * drep_distr createMany
   */
  export type drep_distrCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drep_distrs.
     */
    data: drep_distrCreateManyInput | drep_distrCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_distr createManyAndReturn
   */
  export type drep_distrCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * The data used to create many drep_distrs.
     */
    data: drep_distrCreateManyInput | drep_distrCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_distr update
   */
  export type drep_distrUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * The data needed to update a drep_distr.
     */
    data: XOR<drep_distrUpdateInput, drep_distrUncheckedUpdateInput>
    /**
     * Choose, which drep_distr to update.
     */
    where: drep_distrWhereUniqueInput
  }

  /**
   * drep_distr updateMany
   */
  export type drep_distrUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drep_distrs.
     */
    data: XOR<drep_distrUpdateManyMutationInput, drep_distrUncheckedUpdateManyInput>
    /**
     * Filter which drep_distrs to update
     */
    where?: drep_distrWhereInput
    /**
     * Limit how many drep_distrs to update.
     */
    limit?: number
  }

  /**
   * drep_distr updateManyAndReturn
   */
  export type drep_distrUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * The data used to update drep_distrs.
     */
    data: XOR<drep_distrUpdateManyMutationInput, drep_distrUncheckedUpdateManyInput>
    /**
     * Filter which drep_distrs to update
     */
    where?: drep_distrWhereInput
    /**
     * Limit how many drep_distrs to update.
     */
    limit?: number
  }

  /**
   * drep_distr upsert
   */
  export type drep_distrUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * The filter to search for the drep_distr to update in case it exists.
     */
    where: drep_distrWhereUniqueInput
    /**
     * In case the drep_distr found by the `where` argument doesn't exist, create a new drep_distr with this data.
     */
    create: XOR<drep_distrCreateInput, drep_distrUncheckedCreateInput>
    /**
     * In case the drep_distr was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drep_distrUpdateInput, drep_distrUncheckedUpdateInput>
  }

  /**
   * drep_distr delete
   */
  export type drep_distrDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
    /**
     * Filter which drep_distr to delete.
     */
    where: drep_distrWhereUniqueInput
  }

  /**
   * drep_distr deleteMany
   */
  export type drep_distrDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_distrs to delete
     */
    where?: drep_distrWhereInput
    /**
     * Limit how many drep_distrs to delete.
     */
    limit?: number
  }

  /**
   * drep_distr without action
   */
  export type drep_distrDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_distr
     */
    select?: drep_distrSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_distr
     */
    omit?: drep_distrOmit<ExtArgs> | null
  }


  /**
   * Model drep_hash
   */

  export type AggregateDrep_hash = {
    _count: Drep_hashCountAggregateOutputType | null
    _avg: Drep_hashAvgAggregateOutputType | null
    _sum: Drep_hashSumAggregateOutputType | null
    _min: Drep_hashMinAggregateOutputType | null
    _max: Drep_hashMaxAggregateOutputType | null
  }

  export type Drep_hashAvgAggregateOutputType = {
    id: number | null
  }

  export type Drep_hashSumAggregateOutputType = {
    id: bigint | null
  }

  export type Drep_hashMinAggregateOutputType = {
    id: bigint | null
    raw: Uint8Array | null
    view: string | null
    has_script: boolean | null
  }

  export type Drep_hashMaxAggregateOutputType = {
    id: bigint | null
    raw: Uint8Array | null
    view: string | null
    has_script: boolean | null
  }

  export type Drep_hashCountAggregateOutputType = {
    id: number
    raw: number
    view: number
    has_script: number
    _all: number
  }


  export type Drep_hashAvgAggregateInputType = {
    id?: true
  }

  export type Drep_hashSumAggregateInputType = {
    id?: true
  }

  export type Drep_hashMinAggregateInputType = {
    id?: true
    raw?: true
    view?: true
    has_script?: true
  }

  export type Drep_hashMaxAggregateInputType = {
    id?: true
    raw?: true
    view?: true
    has_script?: true
  }

  export type Drep_hashCountAggregateInputType = {
    id?: true
    raw?: true
    view?: true
    has_script?: true
    _all?: true
  }

  export type Drep_hashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_hash to aggregate.
     */
    where?: drep_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_hashes to fetch.
     */
    orderBy?: drep_hashOrderByWithRelationInput | drep_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drep_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drep_hashes
    **/
    _count?: true | Drep_hashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Drep_hashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Drep_hashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Drep_hashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Drep_hashMaxAggregateInputType
  }

  export type GetDrep_hashAggregateType<T extends Drep_hashAggregateArgs> = {
        [P in keyof T & keyof AggregateDrep_hash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrep_hash[P]>
      : GetScalarType<T[P], AggregateDrep_hash[P]>
  }




  export type drep_hashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drep_hashWhereInput
    orderBy?: drep_hashOrderByWithAggregationInput | drep_hashOrderByWithAggregationInput[]
    by: Drep_hashScalarFieldEnum[] | Drep_hashScalarFieldEnum
    having?: drep_hashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Drep_hashCountAggregateInputType | true
    _avg?: Drep_hashAvgAggregateInputType
    _sum?: Drep_hashSumAggregateInputType
    _min?: Drep_hashMinAggregateInputType
    _max?: Drep_hashMaxAggregateInputType
  }

  export type Drep_hashGroupByOutputType = {
    id: bigint
    raw: Uint8Array | null
    view: string
    has_script: boolean
    _count: Drep_hashCountAggregateOutputType | null
    _avg: Drep_hashAvgAggregateOutputType | null
    _sum: Drep_hashSumAggregateOutputType | null
    _min: Drep_hashMinAggregateOutputType | null
    _max: Drep_hashMaxAggregateOutputType | null
  }

  type GetDrep_hashGroupByPayload<T extends drep_hashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Drep_hashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Drep_hashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Drep_hashGroupByOutputType[P]>
            : GetScalarType<T[P], Drep_hashGroupByOutputType[P]>
        }
      >
    >


  export type drep_hashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    view?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["drep_hash"]>

  export type drep_hashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    view?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["drep_hash"]>

  export type drep_hashSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raw?: boolean
    view?: boolean
    has_script?: boolean
  }, ExtArgs["result"]["drep_hash"]>

  export type drep_hashSelectScalar = {
    id?: boolean
    raw?: boolean
    view?: boolean
    has_script?: boolean
  }

  export type drep_hashOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "raw" | "view" | "has_script", ExtArgs["result"]["drep_hash"]>

  export type $drep_hashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "drep_hash"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      raw: Uint8Array | null
      view: string
      has_script: boolean
    }, ExtArgs["result"]["drep_hash"]>
    composites: {}
  }

  type drep_hashGetPayload<S extends boolean | null | undefined | drep_hashDefaultArgs> = $Result.GetResult<Prisma.$drep_hashPayload, S>

  type drep_hashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<drep_hashFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Drep_hashCountAggregateInputType | true
    }

  export interface drep_hashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['drep_hash'], meta: { name: 'drep_hash' } }
    /**
     * Find zero or one Drep_hash that matches the filter.
     * @param {drep_hashFindUniqueArgs} args - Arguments to find a Drep_hash
     * @example
     * // Get one Drep_hash
     * const drep_hash = await prisma.drep_hash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends drep_hashFindUniqueArgs>(args: SelectSubset<T, drep_hashFindUniqueArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Drep_hash that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {drep_hashFindUniqueOrThrowArgs} args - Arguments to find a Drep_hash
     * @example
     * // Get one Drep_hash
     * const drep_hash = await prisma.drep_hash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends drep_hashFindUniqueOrThrowArgs>(args: SelectSubset<T, drep_hashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_hash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashFindFirstArgs} args - Arguments to find a Drep_hash
     * @example
     * // Get one Drep_hash
     * const drep_hash = await prisma.drep_hash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends drep_hashFindFirstArgs>(args?: SelectSubset<T, drep_hashFindFirstArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_hash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashFindFirstOrThrowArgs} args - Arguments to find a Drep_hash
     * @example
     * // Get one Drep_hash
     * const drep_hash = await prisma.drep_hash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends drep_hashFindFirstOrThrowArgs>(args?: SelectSubset<T, drep_hashFindFirstOrThrowArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Drep_hashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drep_hashes
     * const drep_hashes = await prisma.drep_hash.findMany()
     * 
     * // Get first 10 Drep_hashes
     * const drep_hashes = await prisma.drep_hash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drep_hashWithIdOnly = await prisma.drep_hash.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends drep_hashFindManyArgs>(args?: SelectSubset<T, drep_hashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Drep_hash.
     * @param {drep_hashCreateArgs} args - Arguments to create a Drep_hash.
     * @example
     * // Create one Drep_hash
     * const Drep_hash = await prisma.drep_hash.create({
     *   data: {
     *     // ... data to create a Drep_hash
     *   }
     * })
     * 
     */
    create<T extends drep_hashCreateArgs>(args: SelectSubset<T, drep_hashCreateArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Drep_hashes.
     * @param {drep_hashCreateManyArgs} args - Arguments to create many Drep_hashes.
     * @example
     * // Create many Drep_hashes
     * const drep_hash = await prisma.drep_hash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends drep_hashCreateManyArgs>(args?: SelectSubset<T, drep_hashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drep_hashes and returns the data saved in the database.
     * @param {drep_hashCreateManyAndReturnArgs} args - Arguments to create many Drep_hashes.
     * @example
     * // Create many Drep_hashes
     * const drep_hash = await prisma.drep_hash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drep_hashes and only return the `id`
     * const drep_hashWithIdOnly = await prisma.drep_hash.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends drep_hashCreateManyAndReturnArgs>(args?: SelectSubset<T, drep_hashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Drep_hash.
     * @param {drep_hashDeleteArgs} args - Arguments to delete one Drep_hash.
     * @example
     * // Delete one Drep_hash
     * const Drep_hash = await prisma.drep_hash.delete({
     *   where: {
     *     // ... filter to delete one Drep_hash
     *   }
     * })
     * 
     */
    delete<T extends drep_hashDeleteArgs>(args: SelectSubset<T, drep_hashDeleteArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Drep_hash.
     * @param {drep_hashUpdateArgs} args - Arguments to update one Drep_hash.
     * @example
     * // Update one Drep_hash
     * const drep_hash = await prisma.drep_hash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends drep_hashUpdateArgs>(args: SelectSubset<T, drep_hashUpdateArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Drep_hashes.
     * @param {drep_hashDeleteManyArgs} args - Arguments to filter Drep_hashes to delete.
     * @example
     * // Delete a few Drep_hashes
     * const { count } = await prisma.drep_hash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends drep_hashDeleteManyArgs>(args?: SelectSubset<T, drep_hashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drep_hashes
     * const drep_hash = await prisma.drep_hash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends drep_hashUpdateManyArgs>(args: SelectSubset<T, drep_hashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_hashes and returns the data updated in the database.
     * @param {drep_hashUpdateManyAndReturnArgs} args - Arguments to update many Drep_hashes.
     * @example
     * // Update many Drep_hashes
     * const drep_hash = await prisma.drep_hash.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drep_hashes and only return the `id`
     * const drep_hashWithIdOnly = await prisma.drep_hash.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends drep_hashUpdateManyAndReturnArgs>(args: SelectSubset<T, drep_hashUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Drep_hash.
     * @param {drep_hashUpsertArgs} args - Arguments to update or create a Drep_hash.
     * @example
     * // Update or create a Drep_hash
     * const drep_hash = await prisma.drep_hash.upsert({
     *   create: {
     *     // ... data to create a Drep_hash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drep_hash we want to update
     *   }
     * })
     */
    upsert<T extends drep_hashUpsertArgs>(args: SelectSubset<T, drep_hashUpsertArgs<ExtArgs>>): Prisma__drep_hashClient<$Result.GetResult<Prisma.$drep_hashPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Drep_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashCountArgs} args - Arguments to filter Drep_hashes to count.
     * @example
     * // Count the number of Drep_hashes
     * const count = await prisma.drep_hash.count({
     *   where: {
     *     // ... the filter for the Drep_hashes we want to count
     *   }
     * })
    **/
    count<T extends drep_hashCountArgs>(
      args?: Subset<T, drep_hashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Drep_hashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drep_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drep_hashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Drep_hashAggregateArgs>(args: Subset<T, Drep_hashAggregateArgs>): Prisma.PrismaPromise<GetDrep_hashAggregateType<T>>

    /**
     * Group by Drep_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_hashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends drep_hashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: drep_hashGroupByArgs['orderBy'] }
        : { orderBy?: drep_hashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, drep_hashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrep_hashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the drep_hash model
   */
  readonly fields: drep_hashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for drep_hash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__drep_hashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the drep_hash model
   */ 
  interface drep_hashFieldRefs {
    readonly id: FieldRef<"drep_hash", 'BigInt'>
    readonly raw: FieldRef<"drep_hash", 'Bytes'>
    readonly view: FieldRef<"drep_hash", 'String'>
    readonly has_script: FieldRef<"drep_hash", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * drep_hash findUnique
   */
  export type drep_hashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter, which drep_hash to fetch.
     */
    where: drep_hashWhereUniqueInput
  }

  /**
   * drep_hash findUniqueOrThrow
   */
  export type drep_hashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter, which drep_hash to fetch.
     */
    where: drep_hashWhereUniqueInput
  }

  /**
   * drep_hash findFirst
   */
  export type drep_hashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter, which drep_hash to fetch.
     */
    where?: drep_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_hashes to fetch.
     */
    orderBy?: drep_hashOrderByWithRelationInput | drep_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_hashes.
     */
    cursor?: drep_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_hashes.
     */
    distinct?: Drep_hashScalarFieldEnum | Drep_hashScalarFieldEnum[]
  }

  /**
   * drep_hash findFirstOrThrow
   */
  export type drep_hashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter, which drep_hash to fetch.
     */
    where?: drep_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_hashes to fetch.
     */
    orderBy?: drep_hashOrderByWithRelationInput | drep_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_hashes.
     */
    cursor?: drep_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_hashes.
     */
    distinct?: Drep_hashScalarFieldEnum | Drep_hashScalarFieldEnum[]
  }

  /**
   * drep_hash findMany
   */
  export type drep_hashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter, which drep_hashes to fetch.
     */
    where?: drep_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_hashes to fetch.
     */
    orderBy?: drep_hashOrderByWithRelationInput | drep_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drep_hashes.
     */
    cursor?: drep_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_hashes.
     */
    skip?: number
    distinct?: Drep_hashScalarFieldEnum | Drep_hashScalarFieldEnum[]
  }

  /**
   * drep_hash create
   */
  export type drep_hashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * The data needed to create a drep_hash.
     */
    data: XOR<drep_hashCreateInput, drep_hashUncheckedCreateInput>
  }

  /**
   * drep_hash createMany
   */
  export type drep_hashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drep_hashes.
     */
    data: drep_hashCreateManyInput | drep_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_hash createManyAndReturn
   */
  export type drep_hashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * The data used to create many drep_hashes.
     */
    data: drep_hashCreateManyInput | drep_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_hash update
   */
  export type drep_hashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * The data needed to update a drep_hash.
     */
    data: XOR<drep_hashUpdateInput, drep_hashUncheckedUpdateInput>
    /**
     * Choose, which drep_hash to update.
     */
    where: drep_hashWhereUniqueInput
  }

  /**
   * drep_hash updateMany
   */
  export type drep_hashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drep_hashes.
     */
    data: XOR<drep_hashUpdateManyMutationInput, drep_hashUncheckedUpdateManyInput>
    /**
     * Filter which drep_hashes to update
     */
    where?: drep_hashWhereInput
    /**
     * Limit how many drep_hashes to update.
     */
    limit?: number
  }

  /**
   * drep_hash updateManyAndReturn
   */
  export type drep_hashUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * The data used to update drep_hashes.
     */
    data: XOR<drep_hashUpdateManyMutationInput, drep_hashUncheckedUpdateManyInput>
    /**
     * Filter which drep_hashes to update
     */
    where?: drep_hashWhereInput
    /**
     * Limit how many drep_hashes to update.
     */
    limit?: number
  }

  /**
   * drep_hash upsert
   */
  export type drep_hashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * The filter to search for the drep_hash to update in case it exists.
     */
    where: drep_hashWhereUniqueInput
    /**
     * In case the drep_hash found by the `where` argument doesn't exist, create a new drep_hash with this data.
     */
    create: XOR<drep_hashCreateInput, drep_hashUncheckedCreateInput>
    /**
     * In case the drep_hash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drep_hashUpdateInput, drep_hashUncheckedUpdateInput>
  }

  /**
   * drep_hash delete
   */
  export type drep_hashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
    /**
     * Filter which drep_hash to delete.
     */
    where: drep_hashWhereUniqueInput
  }

  /**
   * drep_hash deleteMany
   */
  export type drep_hashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_hashes to delete
     */
    where?: drep_hashWhereInput
    /**
     * Limit how many drep_hashes to delete.
     */
    limit?: number
  }

  /**
   * drep_hash without action
   */
  export type drep_hashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_hash
     */
    select?: drep_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_hash
     */
    omit?: drep_hashOmit<ExtArgs> | null
  }


  /**
   * Model drep_registration
   */

  export type AggregateDrep_registration = {
    _count: Drep_registrationCountAggregateOutputType | null
    _avg: Drep_registrationAvgAggregateOutputType | null
    _sum: Drep_registrationSumAggregateOutputType | null
    _min: Drep_registrationMinAggregateOutputType | null
    _max: Drep_registrationMaxAggregateOutputType | null
  }

  export type Drep_registrationAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    cert_index: number | null
    deposit: number | null
    drep_hash_id: number | null
    voting_anchor_id: number | null
  }

  export type Drep_registrationSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    deposit: bigint | null
    drep_hash_id: bigint | null
    voting_anchor_id: bigint | null
  }

  export type Drep_registrationMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    deposit: bigint | null
    drep_hash_id: bigint | null
    voting_anchor_id: bigint | null
  }

  export type Drep_registrationMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    cert_index: number | null
    deposit: bigint | null
    drep_hash_id: bigint | null
    voting_anchor_id: bigint | null
  }

  export type Drep_registrationCountAggregateOutputType = {
    id: number
    tx_id: number
    cert_index: number
    deposit: number
    drep_hash_id: number
    voting_anchor_id: number
    _all: number
  }


  export type Drep_registrationAvgAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    deposit?: true
    drep_hash_id?: true
    voting_anchor_id?: true
  }

  export type Drep_registrationSumAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    deposit?: true
    drep_hash_id?: true
    voting_anchor_id?: true
  }

  export type Drep_registrationMinAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    deposit?: true
    drep_hash_id?: true
    voting_anchor_id?: true
  }

  export type Drep_registrationMaxAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    deposit?: true
    drep_hash_id?: true
    voting_anchor_id?: true
  }

  export type Drep_registrationCountAggregateInputType = {
    id?: true
    tx_id?: true
    cert_index?: true
    deposit?: true
    drep_hash_id?: true
    voting_anchor_id?: true
    _all?: true
  }

  export type Drep_registrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_registration to aggregate.
     */
    where?: drep_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_registrations to fetch.
     */
    orderBy?: drep_registrationOrderByWithRelationInput | drep_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drep_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drep_registrations
    **/
    _count?: true | Drep_registrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Drep_registrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Drep_registrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Drep_registrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Drep_registrationMaxAggregateInputType
  }

  export type GetDrep_registrationAggregateType<T extends Drep_registrationAggregateArgs> = {
        [P in keyof T & keyof AggregateDrep_registration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrep_registration[P]>
      : GetScalarType<T[P], AggregateDrep_registration[P]>
  }




  export type drep_registrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: drep_registrationWhereInput
    orderBy?: drep_registrationOrderByWithAggregationInput | drep_registrationOrderByWithAggregationInput[]
    by: Drep_registrationScalarFieldEnum[] | Drep_registrationScalarFieldEnum
    having?: drep_registrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Drep_registrationCountAggregateInputType | true
    _avg?: Drep_registrationAvgAggregateInputType
    _sum?: Drep_registrationSumAggregateInputType
    _min?: Drep_registrationMinAggregateInputType
    _max?: Drep_registrationMaxAggregateInputType
  }

  export type Drep_registrationGroupByOutputType = {
    id: bigint
    tx_id: bigint
    cert_index: number
    deposit: bigint | null
    drep_hash_id: bigint
    voting_anchor_id: bigint | null
    _count: Drep_registrationCountAggregateOutputType | null
    _avg: Drep_registrationAvgAggregateOutputType | null
    _sum: Drep_registrationSumAggregateOutputType | null
    _min: Drep_registrationMinAggregateOutputType | null
    _max: Drep_registrationMaxAggregateOutputType | null
  }

  type GetDrep_registrationGroupByPayload<T extends drep_registrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Drep_registrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Drep_registrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Drep_registrationGroupByOutputType[P]>
            : GetScalarType<T[P], Drep_registrationGroupByOutputType[P]>
        }
      >
    >


  export type drep_registrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    deposit?: boolean
    drep_hash_id?: boolean
    voting_anchor_id?: boolean
  }, ExtArgs["result"]["drep_registration"]>

  export type drep_registrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    deposit?: boolean
    drep_hash_id?: boolean
    voting_anchor_id?: boolean
  }, ExtArgs["result"]["drep_registration"]>

  export type drep_registrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    deposit?: boolean
    drep_hash_id?: boolean
    voting_anchor_id?: boolean
  }, ExtArgs["result"]["drep_registration"]>

  export type drep_registrationSelectScalar = {
    id?: boolean
    tx_id?: boolean
    cert_index?: boolean
    deposit?: boolean
    drep_hash_id?: boolean
    voting_anchor_id?: boolean
  }

  export type drep_registrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "cert_index" | "deposit" | "drep_hash_id" | "voting_anchor_id", ExtArgs["result"]["drep_registration"]>

  export type $drep_registrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "drep_registration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      cert_index: number
      deposit: bigint | null
      drep_hash_id: bigint
      voting_anchor_id: bigint | null
    }, ExtArgs["result"]["drep_registration"]>
    composites: {}
  }

  type drep_registrationGetPayload<S extends boolean | null | undefined | drep_registrationDefaultArgs> = $Result.GetResult<Prisma.$drep_registrationPayload, S>

  type drep_registrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<drep_registrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Drep_registrationCountAggregateInputType | true
    }

  export interface drep_registrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['drep_registration'], meta: { name: 'drep_registration' } }
    /**
     * Find zero or one Drep_registration that matches the filter.
     * @param {drep_registrationFindUniqueArgs} args - Arguments to find a Drep_registration
     * @example
     * // Get one Drep_registration
     * const drep_registration = await prisma.drep_registration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends drep_registrationFindUniqueArgs>(args: SelectSubset<T, drep_registrationFindUniqueArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Drep_registration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {drep_registrationFindUniqueOrThrowArgs} args - Arguments to find a Drep_registration
     * @example
     * // Get one Drep_registration
     * const drep_registration = await prisma.drep_registration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends drep_registrationFindUniqueOrThrowArgs>(args: SelectSubset<T, drep_registrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_registration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationFindFirstArgs} args - Arguments to find a Drep_registration
     * @example
     * // Get one Drep_registration
     * const drep_registration = await prisma.drep_registration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends drep_registrationFindFirstArgs>(args?: SelectSubset<T, drep_registrationFindFirstArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Drep_registration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationFindFirstOrThrowArgs} args - Arguments to find a Drep_registration
     * @example
     * // Get one Drep_registration
     * const drep_registration = await prisma.drep_registration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends drep_registrationFindFirstOrThrowArgs>(args?: SelectSubset<T, drep_registrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Drep_registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drep_registrations
     * const drep_registrations = await prisma.drep_registration.findMany()
     * 
     * // Get first 10 Drep_registrations
     * const drep_registrations = await prisma.drep_registration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drep_registrationWithIdOnly = await prisma.drep_registration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends drep_registrationFindManyArgs>(args?: SelectSubset<T, drep_registrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Drep_registration.
     * @param {drep_registrationCreateArgs} args - Arguments to create a Drep_registration.
     * @example
     * // Create one Drep_registration
     * const Drep_registration = await prisma.drep_registration.create({
     *   data: {
     *     // ... data to create a Drep_registration
     *   }
     * })
     * 
     */
    create<T extends drep_registrationCreateArgs>(args: SelectSubset<T, drep_registrationCreateArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Drep_registrations.
     * @param {drep_registrationCreateManyArgs} args - Arguments to create many Drep_registrations.
     * @example
     * // Create many Drep_registrations
     * const drep_registration = await prisma.drep_registration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends drep_registrationCreateManyArgs>(args?: SelectSubset<T, drep_registrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drep_registrations and returns the data saved in the database.
     * @param {drep_registrationCreateManyAndReturnArgs} args - Arguments to create many Drep_registrations.
     * @example
     * // Create many Drep_registrations
     * const drep_registration = await prisma.drep_registration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drep_registrations and only return the `id`
     * const drep_registrationWithIdOnly = await prisma.drep_registration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends drep_registrationCreateManyAndReturnArgs>(args?: SelectSubset<T, drep_registrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Drep_registration.
     * @param {drep_registrationDeleteArgs} args - Arguments to delete one Drep_registration.
     * @example
     * // Delete one Drep_registration
     * const Drep_registration = await prisma.drep_registration.delete({
     *   where: {
     *     // ... filter to delete one Drep_registration
     *   }
     * })
     * 
     */
    delete<T extends drep_registrationDeleteArgs>(args: SelectSubset<T, drep_registrationDeleteArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Drep_registration.
     * @param {drep_registrationUpdateArgs} args - Arguments to update one Drep_registration.
     * @example
     * // Update one Drep_registration
     * const drep_registration = await prisma.drep_registration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends drep_registrationUpdateArgs>(args: SelectSubset<T, drep_registrationUpdateArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Drep_registrations.
     * @param {drep_registrationDeleteManyArgs} args - Arguments to filter Drep_registrations to delete.
     * @example
     * // Delete a few Drep_registrations
     * const { count } = await prisma.drep_registration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends drep_registrationDeleteManyArgs>(args?: SelectSubset<T, drep_registrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drep_registrations
     * const drep_registration = await prisma.drep_registration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends drep_registrationUpdateManyArgs>(args: SelectSubset<T, drep_registrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drep_registrations and returns the data updated in the database.
     * @param {drep_registrationUpdateManyAndReturnArgs} args - Arguments to update many Drep_registrations.
     * @example
     * // Update many Drep_registrations
     * const drep_registration = await prisma.drep_registration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drep_registrations and only return the `id`
     * const drep_registrationWithIdOnly = await prisma.drep_registration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends drep_registrationUpdateManyAndReturnArgs>(args: SelectSubset<T, drep_registrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Drep_registration.
     * @param {drep_registrationUpsertArgs} args - Arguments to update or create a Drep_registration.
     * @example
     * // Update or create a Drep_registration
     * const drep_registration = await prisma.drep_registration.upsert({
     *   create: {
     *     // ... data to create a Drep_registration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drep_registration we want to update
     *   }
     * })
     */
    upsert<T extends drep_registrationUpsertArgs>(args: SelectSubset<T, drep_registrationUpsertArgs<ExtArgs>>): Prisma__drep_registrationClient<$Result.GetResult<Prisma.$drep_registrationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Drep_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationCountArgs} args - Arguments to filter Drep_registrations to count.
     * @example
     * // Count the number of Drep_registrations
     * const count = await prisma.drep_registration.count({
     *   where: {
     *     // ... the filter for the Drep_registrations we want to count
     *   }
     * })
    **/
    count<T extends drep_registrationCountArgs>(
      args?: Subset<T, drep_registrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Drep_registrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drep_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drep_registrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Drep_registrationAggregateArgs>(args: Subset<T, Drep_registrationAggregateArgs>): Prisma.PrismaPromise<GetDrep_registrationAggregateType<T>>

    /**
     * Group by Drep_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drep_registrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends drep_registrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: drep_registrationGroupByArgs['orderBy'] }
        : { orderBy?: drep_registrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, drep_registrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrep_registrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the drep_registration model
   */
  readonly fields: drep_registrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for drep_registration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__drep_registrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the drep_registration model
   */ 
  interface drep_registrationFieldRefs {
    readonly id: FieldRef<"drep_registration", 'BigInt'>
    readonly tx_id: FieldRef<"drep_registration", 'BigInt'>
    readonly cert_index: FieldRef<"drep_registration", 'Int'>
    readonly deposit: FieldRef<"drep_registration", 'BigInt'>
    readonly drep_hash_id: FieldRef<"drep_registration", 'BigInt'>
    readonly voting_anchor_id: FieldRef<"drep_registration", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * drep_registration findUnique
   */
  export type drep_registrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter, which drep_registration to fetch.
     */
    where: drep_registrationWhereUniqueInput
  }

  /**
   * drep_registration findUniqueOrThrow
   */
  export type drep_registrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter, which drep_registration to fetch.
     */
    where: drep_registrationWhereUniqueInput
  }

  /**
   * drep_registration findFirst
   */
  export type drep_registrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter, which drep_registration to fetch.
     */
    where?: drep_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_registrations to fetch.
     */
    orderBy?: drep_registrationOrderByWithRelationInput | drep_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_registrations.
     */
    cursor?: drep_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_registrations.
     */
    distinct?: Drep_registrationScalarFieldEnum | Drep_registrationScalarFieldEnum[]
  }

  /**
   * drep_registration findFirstOrThrow
   */
  export type drep_registrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter, which drep_registration to fetch.
     */
    where?: drep_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_registrations to fetch.
     */
    orderBy?: drep_registrationOrderByWithRelationInput | drep_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drep_registrations.
     */
    cursor?: drep_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drep_registrations.
     */
    distinct?: Drep_registrationScalarFieldEnum | Drep_registrationScalarFieldEnum[]
  }

  /**
   * drep_registration findMany
   */
  export type drep_registrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter, which drep_registrations to fetch.
     */
    where?: drep_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drep_registrations to fetch.
     */
    orderBy?: drep_registrationOrderByWithRelationInput | drep_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drep_registrations.
     */
    cursor?: drep_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drep_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drep_registrations.
     */
    skip?: number
    distinct?: Drep_registrationScalarFieldEnum | Drep_registrationScalarFieldEnum[]
  }

  /**
   * drep_registration create
   */
  export type drep_registrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * The data needed to create a drep_registration.
     */
    data: XOR<drep_registrationCreateInput, drep_registrationUncheckedCreateInput>
  }

  /**
   * drep_registration createMany
   */
  export type drep_registrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many drep_registrations.
     */
    data: drep_registrationCreateManyInput | drep_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_registration createManyAndReturn
   */
  export type drep_registrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * The data used to create many drep_registrations.
     */
    data: drep_registrationCreateManyInput | drep_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * drep_registration update
   */
  export type drep_registrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * The data needed to update a drep_registration.
     */
    data: XOR<drep_registrationUpdateInput, drep_registrationUncheckedUpdateInput>
    /**
     * Choose, which drep_registration to update.
     */
    where: drep_registrationWhereUniqueInput
  }

  /**
   * drep_registration updateMany
   */
  export type drep_registrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update drep_registrations.
     */
    data: XOR<drep_registrationUpdateManyMutationInput, drep_registrationUncheckedUpdateManyInput>
    /**
     * Filter which drep_registrations to update
     */
    where?: drep_registrationWhereInput
    /**
     * Limit how many drep_registrations to update.
     */
    limit?: number
  }

  /**
   * drep_registration updateManyAndReturn
   */
  export type drep_registrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * The data used to update drep_registrations.
     */
    data: XOR<drep_registrationUpdateManyMutationInput, drep_registrationUncheckedUpdateManyInput>
    /**
     * Filter which drep_registrations to update
     */
    where?: drep_registrationWhereInput
    /**
     * Limit how many drep_registrations to update.
     */
    limit?: number
  }

  /**
   * drep_registration upsert
   */
  export type drep_registrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * The filter to search for the drep_registration to update in case it exists.
     */
    where: drep_registrationWhereUniqueInput
    /**
     * In case the drep_registration found by the `where` argument doesn't exist, create a new drep_registration with this data.
     */
    create: XOR<drep_registrationCreateInput, drep_registrationUncheckedCreateInput>
    /**
     * In case the drep_registration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drep_registrationUpdateInput, drep_registrationUncheckedUpdateInput>
  }

  /**
   * drep_registration delete
   */
  export type drep_registrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
    /**
     * Filter which drep_registration to delete.
     */
    where: drep_registrationWhereUniqueInput
  }

  /**
   * drep_registration deleteMany
   */
  export type drep_registrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which drep_registrations to delete
     */
    where?: drep_registrationWhereInput
    /**
     * Limit how many drep_registrations to delete.
     */
    limit?: number
  }

  /**
   * drep_registration without action
   */
  export type drep_registrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the drep_registration
     */
    select?: drep_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the drep_registration
     */
    omit?: drep_registrationOmit<ExtArgs> | null
  }


  /**
   * Model epoch
   */

  export type AggregateEpoch = {
    _count: EpochCountAggregateOutputType | null
    _avg: EpochAvgAggregateOutputType | null
    _sum: EpochSumAggregateOutputType | null
    _min: EpochMinAggregateOutputType | null
    _max: EpochMaxAggregateOutputType | null
  }

  export type EpochAvgAggregateOutputType = {
    id: number | null
    out_sum: Decimal | null
    fees: Decimal | null
    tx_count: number | null
    blk_count: number | null
    no: number | null
  }

  export type EpochSumAggregateOutputType = {
    id: bigint | null
    out_sum: Decimal | null
    fees: Decimal | null
    tx_count: number | null
    blk_count: number | null
    no: number | null
  }

  export type EpochMinAggregateOutputType = {
    id: bigint | null
    out_sum: Decimal | null
    fees: Decimal | null
    tx_count: number | null
    blk_count: number | null
    no: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type EpochMaxAggregateOutputType = {
    id: bigint | null
    out_sum: Decimal | null
    fees: Decimal | null
    tx_count: number | null
    blk_count: number | null
    no: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type EpochCountAggregateOutputType = {
    id: number
    out_sum: number
    fees: number
    tx_count: number
    blk_count: number
    no: number
    start_time: number
    end_time: number
    _all: number
  }


  export type EpochAvgAggregateInputType = {
    id?: true
    out_sum?: true
    fees?: true
    tx_count?: true
    blk_count?: true
    no?: true
  }

  export type EpochSumAggregateInputType = {
    id?: true
    out_sum?: true
    fees?: true
    tx_count?: true
    blk_count?: true
    no?: true
  }

  export type EpochMinAggregateInputType = {
    id?: true
    out_sum?: true
    fees?: true
    tx_count?: true
    blk_count?: true
    no?: true
    start_time?: true
    end_time?: true
  }

  export type EpochMaxAggregateInputType = {
    id?: true
    out_sum?: true
    fees?: true
    tx_count?: true
    blk_count?: true
    no?: true
    start_time?: true
    end_time?: true
  }

  export type EpochCountAggregateInputType = {
    id?: true
    out_sum?: true
    fees?: true
    tx_count?: true
    blk_count?: true
    no?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type EpochAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch to aggregate.
     */
    where?: epochWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoches to fetch.
     */
    orderBy?: epochOrderByWithRelationInput | epochOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epochWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoches
    **/
    _count?: true | EpochCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpochAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpochSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpochMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpochMaxAggregateInputType
  }

  export type GetEpochAggregateType<T extends EpochAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch[P]>
      : GetScalarType<T[P], AggregateEpoch[P]>
  }




  export type epochGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epochWhereInput
    orderBy?: epochOrderByWithAggregationInput | epochOrderByWithAggregationInput[]
    by: EpochScalarFieldEnum[] | EpochScalarFieldEnum
    having?: epochScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpochCountAggregateInputType | true
    _avg?: EpochAvgAggregateInputType
    _sum?: EpochSumAggregateInputType
    _min?: EpochMinAggregateInputType
    _max?: EpochMaxAggregateInputType
  }

  export type EpochGroupByOutputType = {
    id: bigint
    out_sum: Decimal
    fees: Decimal
    tx_count: number
    blk_count: number
    no: number
    start_time: Date
    end_time: Date
    _count: EpochCountAggregateOutputType | null
    _avg: EpochAvgAggregateOutputType | null
    _sum: EpochSumAggregateOutputType | null
    _min: EpochMinAggregateOutputType | null
    _max: EpochMaxAggregateOutputType | null
  }

  type GetEpochGroupByPayload<T extends epochGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpochGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpochGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpochGroupByOutputType[P]>
            : GetScalarType<T[P], EpochGroupByOutputType[P]>
        }
      >
    >


  export type epochSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    out_sum?: boolean
    fees?: boolean
    tx_count?: boolean
    blk_count?: boolean
    no?: boolean
    start_time?: boolean
    end_time?: boolean
  }, ExtArgs["result"]["epoch"]>

  export type epochSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    out_sum?: boolean
    fees?: boolean
    tx_count?: boolean
    blk_count?: boolean
    no?: boolean
    start_time?: boolean
    end_time?: boolean
  }, ExtArgs["result"]["epoch"]>

  export type epochSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    out_sum?: boolean
    fees?: boolean
    tx_count?: boolean
    blk_count?: boolean
    no?: boolean
    start_time?: boolean
    end_time?: boolean
  }, ExtArgs["result"]["epoch"]>

  export type epochSelectScalar = {
    id?: boolean
    out_sum?: boolean
    fees?: boolean
    tx_count?: boolean
    blk_count?: boolean
    no?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type epochOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "out_sum" | "fees" | "tx_count" | "blk_count" | "no" | "start_time" | "end_time", ExtArgs["result"]["epoch"]>

  export type $epochPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      out_sum: Prisma.Decimal
      fees: Prisma.Decimal
      tx_count: number
      blk_count: number
      no: number
      start_time: Date
      end_time: Date
    }, ExtArgs["result"]["epoch"]>
    composites: {}
  }

  type epochGetPayload<S extends boolean | null | undefined | epochDefaultArgs> = $Result.GetResult<Prisma.$epochPayload, S>

  type epochCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epochFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EpochCountAggregateInputType | true
    }

  export interface epochDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch'], meta: { name: 'epoch' } }
    /**
     * Find zero or one Epoch that matches the filter.
     * @param {epochFindUniqueArgs} args - Arguments to find a Epoch
     * @example
     * // Get one Epoch
     * const epoch = await prisma.epoch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epochFindUniqueArgs>(args: SelectSubset<T, epochFindUniqueArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epochFindUniqueOrThrowArgs} args - Arguments to find a Epoch
     * @example
     * // Get one Epoch
     * const epoch = await prisma.epoch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epochFindUniqueOrThrowArgs>(args: SelectSubset<T, epochFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochFindFirstArgs} args - Arguments to find a Epoch
     * @example
     * // Get one Epoch
     * const epoch = await prisma.epoch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epochFindFirstArgs>(args?: SelectSubset<T, epochFindFirstArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochFindFirstOrThrowArgs} args - Arguments to find a Epoch
     * @example
     * // Get one Epoch
     * const epoch = await prisma.epoch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epochFindFirstOrThrowArgs>(args?: SelectSubset<T, epochFindFirstOrThrowArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoches
     * const epoches = await prisma.epoch.findMany()
     * 
     * // Get first 10 Epoches
     * const epoches = await prisma.epoch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epochWithIdOnly = await prisma.epoch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epochFindManyArgs>(args?: SelectSubset<T, epochFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch.
     * @param {epochCreateArgs} args - Arguments to create a Epoch.
     * @example
     * // Create one Epoch
     * const Epoch = await prisma.epoch.create({
     *   data: {
     *     // ... data to create a Epoch
     *   }
     * })
     * 
     */
    create<T extends epochCreateArgs>(args: SelectSubset<T, epochCreateArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoches.
     * @param {epochCreateManyArgs} args - Arguments to create many Epoches.
     * @example
     * // Create many Epoches
     * const epoch = await prisma.epoch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epochCreateManyArgs>(args?: SelectSubset<T, epochCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoches and returns the data saved in the database.
     * @param {epochCreateManyAndReturnArgs} args - Arguments to create many Epoches.
     * @example
     * // Create many Epoches
     * const epoch = await prisma.epoch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoches and only return the `id`
     * const epochWithIdOnly = await prisma.epoch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epochCreateManyAndReturnArgs>(args?: SelectSubset<T, epochCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch.
     * @param {epochDeleteArgs} args - Arguments to delete one Epoch.
     * @example
     * // Delete one Epoch
     * const Epoch = await prisma.epoch.delete({
     *   where: {
     *     // ... filter to delete one Epoch
     *   }
     * })
     * 
     */
    delete<T extends epochDeleteArgs>(args: SelectSubset<T, epochDeleteArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch.
     * @param {epochUpdateArgs} args - Arguments to update one Epoch.
     * @example
     * // Update one Epoch
     * const epoch = await prisma.epoch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epochUpdateArgs>(args: SelectSubset<T, epochUpdateArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoches.
     * @param {epochDeleteManyArgs} args - Arguments to filter Epoches to delete.
     * @example
     * // Delete a few Epoches
     * const { count } = await prisma.epoch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epochDeleteManyArgs>(args?: SelectSubset<T, epochDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoches
     * const epoch = await prisma.epoch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epochUpdateManyArgs>(args: SelectSubset<T, epochUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoches and returns the data updated in the database.
     * @param {epochUpdateManyAndReturnArgs} args - Arguments to update many Epoches.
     * @example
     * // Update many Epoches
     * const epoch = await prisma.epoch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoches and only return the `id`
     * const epochWithIdOnly = await prisma.epoch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epochUpdateManyAndReturnArgs>(args: SelectSubset<T, epochUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch.
     * @param {epochUpsertArgs} args - Arguments to update or create a Epoch.
     * @example
     * // Update or create a Epoch
     * const epoch = await prisma.epoch.upsert({
     *   create: {
     *     // ... data to create a Epoch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch we want to update
     *   }
     * })
     */
    upsert<T extends epochUpsertArgs>(args: SelectSubset<T, epochUpsertArgs<ExtArgs>>): Prisma__epochClient<$Result.GetResult<Prisma.$epochPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochCountArgs} args - Arguments to filter Epoches to count.
     * @example
     * // Count the number of Epoches
     * const count = await prisma.epoch.count({
     *   where: {
     *     // ... the filter for the Epoches we want to count
     *   }
     * })
    **/
    count<T extends epochCountArgs>(
      args?: Subset<T, epochCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpochCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpochAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpochAggregateArgs>(args: Subset<T, EpochAggregateArgs>): Prisma.PrismaPromise<GetEpochAggregateType<T>>

    /**
     * Group by Epoch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epochGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epochGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epochGroupByArgs['orderBy'] }
        : { orderBy?: epochGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epochGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpochGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch model
   */
  readonly fields: epochFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epochClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch model
   */ 
  interface epochFieldRefs {
    readonly id: FieldRef<"epoch", 'BigInt'>
    readonly out_sum: FieldRef<"epoch", 'Decimal'>
    readonly fees: FieldRef<"epoch", 'Decimal'>
    readonly tx_count: FieldRef<"epoch", 'Int'>
    readonly blk_count: FieldRef<"epoch", 'Int'>
    readonly no: FieldRef<"epoch", 'Int'>
    readonly start_time: FieldRef<"epoch", 'DateTime'>
    readonly end_time: FieldRef<"epoch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * epoch findUnique
   */
  export type epochFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter, which epoch to fetch.
     */
    where: epochWhereUniqueInput
  }

  /**
   * epoch findUniqueOrThrow
   */
  export type epochFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter, which epoch to fetch.
     */
    where: epochWhereUniqueInput
  }

  /**
   * epoch findFirst
   */
  export type epochFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter, which epoch to fetch.
     */
    where?: epochWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoches to fetch.
     */
    orderBy?: epochOrderByWithRelationInput | epochOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoches.
     */
    cursor?: epochWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoches.
     */
    distinct?: EpochScalarFieldEnum | EpochScalarFieldEnum[]
  }

  /**
   * epoch findFirstOrThrow
   */
  export type epochFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter, which epoch to fetch.
     */
    where?: epochWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoches to fetch.
     */
    orderBy?: epochOrderByWithRelationInput | epochOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoches.
     */
    cursor?: epochWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoches.
     */
    distinct?: EpochScalarFieldEnum | EpochScalarFieldEnum[]
  }

  /**
   * epoch findMany
   */
  export type epochFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter, which epoches to fetch.
     */
    where?: epochWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoches to fetch.
     */
    orderBy?: epochOrderByWithRelationInput | epochOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoches.
     */
    cursor?: epochWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoches.
     */
    skip?: number
    distinct?: EpochScalarFieldEnum | EpochScalarFieldEnum[]
  }

  /**
   * epoch create
   */
  export type epochCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch.
     */
    data: XOR<epochCreateInput, epochUncheckedCreateInput>
  }

  /**
   * epoch createMany
   */
  export type epochCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoches.
     */
    data: epochCreateManyInput | epochCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch createManyAndReturn
   */
  export type epochCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * The data used to create many epoches.
     */
    data: epochCreateManyInput | epochCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch update
   */
  export type epochUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch.
     */
    data: XOR<epochUpdateInput, epochUncheckedUpdateInput>
    /**
     * Choose, which epoch to update.
     */
    where: epochWhereUniqueInput
  }

  /**
   * epoch updateMany
   */
  export type epochUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoches.
     */
    data: XOR<epochUpdateManyMutationInput, epochUncheckedUpdateManyInput>
    /**
     * Filter which epoches to update
     */
    where?: epochWhereInput
    /**
     * Limit how many epoches to update.
     */
    limit?: number
  }

  /**
   * epoch updateManyAndReturn
   */
  export type epochUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * The data used to update epoches.
     */
    data: XOR<epochUpdateManyMutationInput, epochUncheckedUpdateManyInput>
    /**
     * Filter which epoches to update
     */
    where?: epochWhereInput
    /**
     * Limit how many epoches to update.
     */
    limit?: number
  }

  /**
   * epoch upsert
   */
  export type epochUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch to update in case it exists.
     */
    where: epochWhereUniqueInput
    /**
     * In case the epoch found by the `where` argument doesn't exist, create a new epoch with this data.
     */
    create: XOR<epochCreateInput, epochUncheckedCreateInput>
    /**
     * In case the epoch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epochUpdateInput, epochUncheckedUpdateInput>
  }

  /**
   * epoch delete
   */
  export type epochDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
    /**
     * Filter which epoch to delete.
     */
    where: epochWhereUniqueInput
  }

  /**
   * epoch deleteMany
   */
  export type epochDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoches to delete
     */
    where?: epochWhereInput
    /**
     * Limit how many epoches to delete.
     */
    limit?: number
  }

  /**
   * epoch without action
   */
  export type epochDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch
     */
    select?: epochSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch
     */
    omit?: epochOmit<ExtArgs> | null
  }


  /**
   * Model epoch_param
   */

  export type AggregateEpoch_param = {
    _count: Epoch_paramCountAggregateOutputType | null
    _avg: Epoch_paramAvgAggregateOutputType | null
    _sum: Epoch_paramSumAggregateOutputType | null
    _min: Epoch_paramMinAggregateOutputType | null
    _max: Epoch_paramMaxAggregateOutputType | null
  }

  export type Epoch_paramAvgAggregateOutputType = {
    id: number | null
    epoch_no: number | null
    min_fee_a: number | null
    min_fee_b: number | null
    max_block_size: number | null
    max_tx_size: number | null
    max_bh_size: number | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: number | null
    optimal_pool_count: number | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: number | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    block_id: number | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Epoch_paramSumAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    min_fee_a: number | null
    min_fee_b: number | null
    max_block_size: number | null
    max_tx_size: number | null
    max_bh_size: number | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: number | null
    optimal_pool_count: number | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    block_id: bigint | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Epoch_paramMinAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    min_fee_a: number | null
    min_fee_b: number | null
    max_block_size: number | null
    max_tx_size: number | null
    max_bh_size: number | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: number | null
    optimal_pool_count: number | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    nonce: Uint8Array | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    block_id: bigint | null
    extra_entropy: Uint8Array | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Epoch_paramMaxAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    min_fee_a: number | null
    min_fee_b: number | null
    max_block_size: number | null
    max_tx_size: number | null
    max_bh_size: number | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: number | null
    optimal_pool_count: number | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    nonce: Uint8Array | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    block_id: bigint | null
    extra_entropy: Uint8Array | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Epoch_paramCountAggregateOutputType = {
    id: number
    epoch_no: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: number
    pool_deposit: number
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: number
    min_pool_cost: number
    nonce: number
    cost_model_id: number
    price_mem: number
    price_step: number
    max_tx_ex_mem: number
    max_tx_ex_steps: number
    max_block_ex_mem: number
    max_block_ex_steps: number
    max_val_size: number
    collateral_percent: number
    max_collateral_inputs: number
    block_id: number
    extra_entropy: number
    coins_per_utxo_size: number
    pvt_motion_no_confidence: number
    pvt_committee_normal: number
    pvt_committee_no_confidence: number
    pvt_hard_fork_initiation: number
    dvt_motion_no_confidence: number
    dvt_committee_normal: number
    dvt_committee_no_confidence: number
    dvt_update_to_constitution: number
    dvt_hard_fork_initiation: number
    dvt_p_p_network_group: number
    dvt_p_p_economic_group: number
    dvt_p_p_technical_group: number
    dvt_p_p_gov_group: number
    dvt_treasury_withdrawal: number
    committee_min_size: number
    committee_max_term_length: number
    gov_action_lifetime: number
    gov_action_deposit: number
    drep_deposit: number
    drep_activity: number
    pvtpp_security_group: number
    min_fee_ref_script_cost_per_byte: number
    _all: number
  }


  export type Epoch_paramAvgAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    block_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Epoch_paramSumAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    block_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Epoch_paramMinAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    nonce?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    block_id?: true
    extra_entropy?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Epoch_paramMaxAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    nonce?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    block_id?: true
    extra_entropy?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Epoch_paramCountAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    nonce?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    block_id?: true
    extra_entropy?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
    _all?: true
  }

  export type Epoch_paramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_param to aggregate.
     */
    where?: epoch_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_params to fetch.
     */
    orderBy?: epoch_paramOrderByWithRelationInput | epoch_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epoch_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoch_params
    **/
    _count?: true | Epoch_paramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epoch_paramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epoch_paramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epoch_paramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epoch_paramMaxAggregateInputType
  }

  export type GetEpoch_paramAggregateType<T extends Epoch_paramAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch_param]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch_param[P]>
      : GetScalarType<T[P], AggregateEpoch_param[P]>
  }




  export type epoch_paramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epoch_paramWhereInput
    orderBy?: epoch_paramOrderByWithAggregationInput | epoch_paramOrderByWithAggregationInput[]
    by: Epoch_paramScalarFieldEnum[] | Epoch_paramScalarFieldEnum
    having?: epoch_paramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epoch_paramCountAggregateInputType | true
    _avg?: Epoch_paramAvgAggregateInputType
    _sum?: Epoch_paramSumAggregateInputType
    _min?: Epoch_paramMinAggregateInputType
    _max?: Epoch_paramMaxAggregateInputType
  }

  export type Epoch_paramGroupByOutputType = {
    id: bigint
    epoch_no: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: Decimal
    pool_deposit: Decimal
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: Decimal
    min_pool_cost: Decimal
    nonce: Uint8Array | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    block_id: bigint
    extra_entropy: Uint8Array | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
    _count: Epoch_paramCountAggregateOutputType | null
    _avg: Epoch_paramAvgAggregateOutputType | null
    _sum: Epoch_paramSumAggregateOutputType | null
    _min: Epoch_paramMinAggregateOutputType | null
    _max: Epoch_paramMaxAggregateOutputType | null
  }

  type GetEpoch_paramGroupByPayload<T extends epoch_paramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epoch_paramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epoch_paramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epoch_paramGroupByOutputType[P]>
            : GetScalarType<T[P], Epoch_paramGroupByOutputType[P]>
        }
      >
    >


  export type epoch_paramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    nonce?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    block_id?: boolean
    extra_entropy?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["epoch_param"]>

  export type epoch_paramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    nonce?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    block_id?: boolean
    extra_entropy?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["epoch_param"]>

  export type epoch_paramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    nonce?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    block_id?: boolean
    extra_entropy?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["epoch_param"]>

  export type epoch_paramSelectScalar = {
    id?: boolean
    epoch_no?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    nonce?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    block_id?: boolean
    extra_entropy?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }

  export type epoch_paramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "epoch_no" | "min_fee_a" | "min_fee_b" | "max_block_size" | "max_tx_size" | "max_bh_size" | "key_deposit" | "pool_deposit" | "max_epoch" | "optimal_pool_count" | "influence" | "monetary_expand_rate" | "treasury_growth_rate" | "decentralisation" | "protocol_major" | "protocol_minor" | "min_utxo_value" | "min_pool_cost" | "nonce" | "cost_model_id" | "price_mem" | "price_step" | "max_tx_ex_mem" | "max_tx_ex_steps" | "max_block_ex_mem" | "max_block_ex_steps" | "max_val_size" | "collateral_percent" | "max_collateral_inputs" | "block_id" | "extra_entropy" | "coins_per_utxo_size" | "pvt_motion_no_confidence" | "pvt_committee_normal" | "pvt_committee_no_confidence" | "pvt_hard_fork_initiation" | "dvt_motion_no_confidence" | "dvt_committee_normal" | "dvt_committee_no_confidence" | "dvt_update_to_constitution" | "dvt_hard_fork_initiation" | "dvt_p_p_network_group" | "dvt_p_p_economic_group" | "dvt_p_p_technical_group" | "dvt_p_p_gov_group" | "dvt_treasury_withdrawal" | "committee_min_size" | "committee_max_term_length" | "gov_action_lifetime" | "gov_action_deposit" | "drep_deposit" | "drep_activity" | "pvtpp_security_group" | "min_fee_ref_script_cost_per_byte", ExtArgs["result"]["epoch_param"]>

  export type $epoch_paramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch_param"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      epoch_no: number
      min_fee_a: number
      min_fee_b: number
      max_block_size: number
      max_tx_size: number
      max_bh_size: number
      key_deposit: Prisma.Decimal
      pool_deposit: Prisma.Decimal
      max_epoch: number
      optimal_pool_count: number
      influence: number
      monetary_expand_rate: number
      treasury_growth_rate: number
      decentralisation: number
      protocol_major: number
      protocol_minor: number
      min_utxo_value: Prisma.Decimal
      min_pool_cost: Prisma.Decimal
      nonce: Uint8Array | null
      cost_model_id: bigint | null
      price_mem: number | null
      price_step: number | null
      max_tx_ex_mem: Prisma.Decimal | null
      max_tx_ex_steps: Prisma.Decimal | null
      max_block_ex_mem: Prisma.Decimal | null
      max_block_ex_steps: Prisma.Decimal | null
      max_val_size: Prisma.Decimal | null
      collateral_percent: number | null
      max_collateral_inputs: number | null
      block_id: bigint
      extra_entropy: Uint8Array | null
      coins_per_utxo_size: Prisma.Decimal | null
      pvt_motion_no_confidence: number | null
      pvt_committee_normal: number | null
      pvt_committee_no_confidence: number | null
      pvt_hard_fork_initiation: number | null
      dvt_motion_no_confidence: number | null
      dvt_committee_normal: number | null
      dvt_committee_no_confidence: number | null
      dvt_update_to_constitution: number | null
      dvt_hard_fork_initiation: number | null
      dvt_p_p_network_group: number | null
      dvt_p_p_economic_group: number | null
      dvt_p_p_technical_group: number | null
      dvt_p_p_gov_group: number | null
      dvt_treasury_withdrawal: number | null
      committee_min_size: Prisma.Decimal | null
      committee_max_term_length: Prisma.Decimal | null
      gov_action_lifetime: Prisma.Decimal | null
      gov_action_deposit: Prisma.Decimal | null
      drep_deposit: Prisma.Decimal | null
      drep_activity: Prisma.Decimal | null
      pvtpp_security_group: number | null
      min_fee_ref_script_cost_per_byte: number | null
    }, ExtArgs["result"]["epoch_param"]>
    composites: {}
  }

  type epoch_paramGetPayload<S extends boolean | null | undefined | epoch_paramDefaultArgs> = $Result.GetResult<Prisma.$epoch_paramPayload, S>

  type epoch_paramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epoch_paramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Epoch_paramCountAggregateInputType | true
    }

  export interface epoch_paramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch_param'], meta: { name: 'epoch_param' } }
    /**
     * Find zero or one Epoch_param that matches the filter.
     * @param {epoch_paramFindUniqueArgs} args - Arguments to find a Epoch_param
     * @example
     * // Get one Epoch_param
     * const epoch_param = await prisma.epoch_param.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epoch_paramFindUniqueArgs>(args: SelectSubset<T, epoch_paramFindUniqueArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch_param that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epoch_paramFindUniqueOrThrowArgs} args - Arguments to find a Epoch_param
     * @example
     * // Get one Epoch_param
     * const epoch_param = await prisma.epoch_param.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epoch_paramFindUniqueOrThrowArgs>(args: SelectSubset<T, epoch_paramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_param that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramFindFirstArgs} args - Arguments to find a Epoch_param
     * @example
     * // Get one Epoch_param
     * const epoch_param = await prisma.epoch_param.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epoch_paramFindFirstArgs>(args?: SelectSubset<T, epoch_paramFindFirstArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_param that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramFindFirstOrThrowArgs} args - Arguments to find a Epoch_param
     * @example
     * // Get one Epoch_param
     * const epoch_param = await prisma.epoch_param.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epoch_paramFindFirstOrThrowArgs>(args?: SelectSubset<T, epoch_paramFindFirstOrThrowArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoch_params that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoch_params
     * const epoch_params = await prisma.epoch_param.findMany()
     * 
     * // Get first 10 Epoch_params
     * const epoch_params = await prisma.epoch_param.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epoch_paramWithIdOnly = await prisma.epoch_param.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epoch_paramFindManyArgs>(args?: SelectSubset<T, epoch_paramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch_param.
     * @param {epoch_paramCreateArgs} args - Arguments to create a Epoch_param.
     * @example
     * // Create one Epoch_param
     * const Epoch_param = await prisma.epoch_param.create({
     *   data: {
     *     // ... data to create a Epoch_param
     *   }
     * })
     * 
     */
    create<T extends epoch_paramCreateArgs>(args: SelectSubset<T, epoch_paramCreateArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoch_params.
     * @param {epoch_paramCreateManyArgs} args - Arguments to create many Epoch_params.
     * @example
     * // Create many Epoch_params
     * const epoch_param = await prisma.epoch_param.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epoch_paramCreateManyArgs>(args?: SelectSubset<T, epoch_paramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoch_params and returns the data saved in the database.
     * @param {epoch_paramCreateManyAndReturnArgs} args - Arguments to create many Epoch_params.
     * @example
     * // Create many Epoch_params
     * const epoch_param = await prisma.epoch_param.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoch_params and only return the `id`
     * const epoch_paramWithIdOnly = await prisma.epoch_param.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epoch_paramCreateManyAndReturnArgs>(args?: SelectSubset<T, epoch_paramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch_param.
     * @param {epoch_paramDeleteArgs} args - Arguments to delete one Epoch_param.
     * @example
     * // Delete one Epoch_param
     * const Epoch_param = await prisma.epoch_param.delete({
     *   where: {
     *     // ... filter to delete one Epoch_param
     *   }
     * })
     * 
     */
    delete<T extends epoch_paramDeleteArgs>(args: SelectSubset<T, epoch_paramDeleteArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch_param.
     * @param {epoch_paramUpdateArgs} args - Arguments to update one Epoch_param.
     * @example
     * // Update one Epoch_param
     * const epoch_param = await prisma.epoch_param.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epoch_paramUpdateArgs>(args: SelectSubset<T, epoch_paramUpdateArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoch_params.
     * @param {epoch_paramDeleteManyArgs} args - Arguments to filter Epoch_params to delete.
     * @example
     * // Delete a few Epoch_params
     * const { count } = await prisma.epoch_param.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epoch_paramDeleteManyArgs>(args?: SelectSubset<T, epoch_paramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoch_params
     * const epoch_param = await prisma.epoch_param.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epoch_paramUpdateManyArgs>(args: SelectSubset<T, epoch_paramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_params and returns the data updated in the database.
     * @param {epoch_paramUpdateManyAndReturnArgs} args - Arguments to update many Epoch_params.
     * @example
     * // Update many Epoch_params
     * const epoch_param = await prisma.epoch_param.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoch_params and only return the `id`
     * const epoch_paramWithIdOnly = await prisma.epoch_param.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epoch_paramUpdateManyAndReturnArgs>(args: SelectSubset<T, epoch_paramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch_param.
     * @param {epoch_paramUpsertArgs} args - Arguments to update or create a Epoch_param.
     * @example
     * // Update or create a Epoch_param
     * const epoch_param = await prisma.epoch_param.upsert({
     *   create: {
     *     // ... data to create a Epoch_param
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch_param we want to update
     *   }
     * })
     */
    upsert<T extends epoch_paramUpsertArgs>(args: SelectSubset<T, epoch_paramUpsertArgs<ExtArgs>>): Prisma__epoch_paramClient<$Result.GetResult<Prisma.$epoch_paramPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoch_params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramCountArgs} args - Arguments to filter Epoch_params to count.
     * @example
     * // Count the number of Epoch_params
     * const count = await prisma.epoch_param.count({
     *   where: {
     *     // ... the filter for the Epoch_params we want to count
     *   }
     * })
    **/
    count<T extends epoch_paramCountArgs>(
      args?: Subset<T, epoch_paramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epoch_paramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch_param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epoch_paramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epoch_paramAggregateArgs>(args: Subset<T, Epoch_paramAggregateArgs>): Prisma.PrismaPromise<GetEpoch_paramAggregateType<T>>

    /**
     * Group by Epoch_param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_paramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epoch_paramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epoch_paramGroupByArgs['orderBy'] }
        : { orderBy?: epoch_paramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epoch_paramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpoch_paramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch_param model
   */
  readonly fields: epoch_paramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch_param.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epoch_paramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch_param model
   */ 
  interface epoch_paramFieldRefs {
    readonly id: FieldRef<"epoch_param", 'BigInt'>
    readonly epoch_no: FieldRef<"epoch_param", 'Int'>
    readonly min_fee_a: FieldRef<"epoch_param", 'Int'>
    readonly min_fee_b: FieldRef<"epoch_param", 'Int'>
    readonly max_block_size: FieldRef<"epoch_param", 'Int'>
    readonly max_tx_size: FieldRef<"epoch_param", 'Int'>
    readonly max_bh_size: FieldRef<"epoch_param", 'Int'>
    readonly key_deposit: FieldRef<"epoch_param", 'Decimal'>
    readonly pool_deposit: FieldRef<"epoch_param", 'Decimal'>
    readonly max_epoch: FieldRef<"epoch_param", 'Int'>
    readonly optimal_pool_count: FieldRef<"epoch_param", 'Int'>
    readonly influence: FieldRef<"epoch_param", 'Float'>
    readonly monetary_expand_rate: FieldRef<"epoch_param", 'Float'>
    readonly treasury_growth_rate: FieldRef<"epoch_param", 'Float'>
    readonly decentralisation: FieldRef<"epoch_param", 'Float'>
    readonly protocol_major: FieldRef<"epoch_param", 'Int'>
    readonly protocol_minor: FieldRef<"epoch_param", 'Int'>
    readonly min_utxo_value: FieldRef<"epoch_param", 'Decimal'>
    readonly min_pool_cost: FieldRef<"epoch_param", 'Decimal'>
    readonly nonce: FieldRef<"epoch_param", 'Bytes'>
    readonly cost_model_id: FieldRef<"epoch_param", 'BigInt'>
    readonly price_mem: FieldRef<"epoch_param", 'Float'>
    readonly price_step: FieldRef<"epoch_param", 'Float'>
    readonly max_tx_ex_mem: FieldRef<"epoch_param", 'Decimal'>
    readonly max_tx_ex_steps: FieldRef<"epoch_param", 'Decimal'>
    readonly max_block_ex_mem: FieldRef<"epoch_param", 'Decimal'>
    readonly max_block_ex_steps: FieldRef<"epoch_param", 'Decimal'>
    readonly max_val_size: FieldRef<"epoch_param", 'Decimal'>
    readonly collateral_percent: FieldRef<"epoch_param", 'Int'>
    readonly max_collateral_inputs: FieldRef<"epoch_param", 'Int'>
    readonly block_id: FieldRef<"epoch_param", 'BigInt'>
    readonly extra_entropy: FieldRef<"epoch_param", 'Bytes'>
    readonly coins_per_utxo_size: FieldRef<"epoch_param", 'Decimal'>
    readonly pvt_motion_no_confidence: FieldRef<"epoch_param", 'Float'>
    readonly pvt_committee_normal: FieldRef<"epoch_param", 'Float'>
    readonly pvt_committee_no_confidence: FieldRef<"epoch_param", 'Float'>
    readonly pvt_hard_fork_initiation: FieldRef<"epoch_param", 'Float'>
    readonly dvt_motion_no_confidence: FieldRef<"epoch_param", 'Float'>
    readonly dvt_committee_normal: FieldRef<"epoch_param", 'Float'>
    readonly dvt_committee_no_confidence: FieldRef<"epoch_param", 'Float'>
    readonly dvt_update_to_constitution: FieldRef<"epoch_param", 'Float'>
    readonly dvt_hard_fork_initiation: FieldRef<"epoch_param", 'Float'>
    readonly dvt_p_p_network_group: FieldRef<"epoch_param", 'Float'>
    readonly dvt_p_p_economic_group: FieldRef<"epoch_param", 'Float'>
    readonly dvt_p_p_technical_group: FieldRef<"epoch_param", 'Float'>
    readonly dvt_p_p_gov_group: FieldRef<"epoch_param", 'Float'>
    readonly dvt_treasury_withdrawal: FieldRef<"epoch_param", 'Float'>
    readonly committee_min_size: FieldRef<"epoch_param", 'Decimal'>
    readonly committee_max_term_length: FieldRef<"epoch_param", 'Decimal'>
    readonly gov_action_lifetime: FieldRef<"epoch_param", 'Decimal'>
    readonly gov_action_deposit: FieldRef<"epoch_param", 'Decimal'>
    readonly drep_deposit: FieldRef<"epoch_param", 'Decimal'>
    readonly drep_activity: FieldRef<"epoch_param", 'Decimal'>
    readonly pvtpp_security_group: FieldRef<"epoch_param", 'Float'>
    readonly min_fee_ref_script_cost_per_byte: FieldRef<"epoch_param", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * epoch_param findUnique
   */
  export type epoch_paramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter, which epoch_param to fetch.
     */
    where: epoch_paramWhereUniqueInput
  }

  /**
   * epoch_param findUniqueOrThrow
   */
  export type epoch_paramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter, which epoch_param to fetch.
     */
    where: epoch_paramWhereUniqueInput
  }

  /**
   * epoch_param findFirst
   */
  export type epoch_paramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter, which epoch_param to fetch.
     */
    where?: epoch_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_params to fetch.
     */
    orderBy?: epoch_paramOrderByWithRelationInput | epoch_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_params.
     */
    cursor?: epoch_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_params.
     */
    distinct?: Epoch_paramScalarFieldEnum | Epoch_paramScalarFieldEnum[]
  }

  /**
   * epoch_param findFirstOrThrow
   */
  export type epoch_paramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter, which epoch_param to fetch.
     */
    where?: epoch_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_params to fetch.
     */
    orderBy?: epoch_paramOrderByWithRelationInput | epoch_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_params.
     */
    cursor?: epoch_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_params.
     */
    distinct?: Epoch_paramScalarFieldEnum | Epoch_paramScalarFieldEnum[]
  }

  /**
   * epoch_param findMany
   */
  export type epoch_paramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter, which epoch_params to fetch.
     */
    where?: epoch_paramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_params to fetch.
     */
    orderBy?: epoch_paramOrderByWithRelationInput | epoch_paramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoch_params.
     */
    cursor?: epoch_paramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_params.
     */
    skip?: number
    distinct?: Epoch_paramScalarFieldEnum | Epoch_paramScalarFieldEnum[]
  }

  /**
   * epoch_param create
   */
  export type epoch_paramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch_param.
     */
    data: XOR<epoch_paramCreateInput, epoch_paramUncheckedCreateInput>
  }

  /**
   * epoch_param createMany
   */
  export type epoch_paramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoch_params.
     */
    data: epoch_paramCreateManyInput | epoch_paramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_param createManyAndReturn
   */
  export type epoch_paramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * The data used to create many epoch_params.
     */
    data: epoch_paramCreateManyInput | epoch_paramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_param update
   */
  export type epoch_paramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch_param.
     */
    data: XOR<epoch_paramUpdateInput, epoch_paramUncheckedUpdateInput>
    /**
     * Choose, which epoch_param to update.
     */
    where: epoch_paramWhereUniqueInput
  }

  /**
   * epoch_param updateMany
   */
  export type epoch_paramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoch_params.
     */
    data: XOR<epoch_paramUpdateManyMutationInput, epoch_paramUncheckedUpdateManyInput>
    /**
     * Filter which epoch_params to update
     */
    where?: epoch_paramWhereInput
    /**
     * Limit how many epoch_params to update.
     */
    limit?: number
  }

  /**
   * epoch_param updateManyAndReturn
   */
  export type epoch_paramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * The data used to update epoch_params.
     */
    data: XOR<epoch_paramUpdateManyMutationInput, epoch_paramUncheckedUpdateManyInput>
    /**
     * Filter which epoch_params to update
     */
    where?: epoch_paramWhereInput
    /**
     * Limit how many epoch_params to update.
     */
    limit?: number
  }

  /**
   * epoch_param upsert
   */
  export type epoch_paramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch_param to update in case it exists.
     */
    where: epoch_paramWhereUniqueInput
    /**
     * In case the epoch_param found by the `where` argument doesn't exist, create a new epoch_param with this data.
     */
    create: XOR<epoch_paramCreateInput, epoch_paramUncheckedCreateInput>
    /**
     * In case the epoch_param was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epoch_paramUpdateInput, epoch_paramUncheckedUpdateInput>
  }

  /**
   * epoch_param delete
   */
  export type epoch_paramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
    /**
     * Filter which epoch_param to delete.
     */
    where: epoch_paramWhereUniqueInput
  }

  /**
   * epoch_param deleteMany
   */
  export type epoch_paramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_params to delete
     */
    where?: epoch_paramWhereInput
    /**
     * Limit how many epoch_params to delete.
     */
    limit?: number
  }

  /**
   * epoch_param without action
   */
  export type epoch_paramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_param
     */
    select?: epoch_paramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_param
     */
    omit?: epoch_paramOmit<ExtArgs> | null
  }


  /**
   * Model epoch_stake
   */

  export type AggregateEpoch_stake = {
    _count: Epoch_stakeCountAggregateOutputType | null
    _avg: Epoch_stakeAvgAggregateOutputType | null
    _sum: Epoch_stakeSumAggregateOutputType | null
    _min: Epoch_stakeMinAggregateOutputType | null
    _max: Epoch_stakeMaxAggregateOutputType | null
  }

  export type Epoch_stakeAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    pool_id: number | null
    amount: Decimal | null
    epoch_no: number | null
  }

  export type Epoch_stakeSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_id: bigint | null
    amount: Decimal | null
    epoch_no: number | null
  }

  export type Epoch_stakeMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_id: bigint | null
    amount: Decimal | null
    epoch_no: number | null
  }

  export type Epoch_stakeMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_id: bigint | null
    amount: Decimal | null
    epoch_no: number | null
  }

  export type Epoch_stakeCountAggregateOutputType = {
    id: number
    addr_id: number
    pool_id: number
    amount: number
    epoch_no: number
    _all: number
  }


  export type Epoch_stakeAvgAggregateInputType = {
    id?: true
    addr_id?: true
    pool_id?: true
    amount?: true
    epoch_no?: true
  }

  export type Epoch_stakeSumAggregateInputType = {
    id?: true
    addr_id?: true
    pool_id?: true
    amount?: true
    epoch_no?: true
  }

  export type Epoch_stakeMinAggregateInputType = {
    id?: true
    addr_id?: true
    pool_id?: true
    amount?: true
    epoch_no?: true
  }

  export type Epoch_stakeMaxAggregateInputType = {
    id?: true
    addr_id?: true
    pool_id?: true
    amount?: true
    epoch_no?: true
  }

  export type Epoch_stakeCountAggregateInputType = {
    id?: true
    addr_id?: true
    pool_id?: true
    amount?: true
    epoch_no?: true
    _all?: true
  }

  export type Epoch_stakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_stake to aggregate.
     */
    where?: epoch_stakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stakes to fetch.
     */
    orderBy?: epoch_stakeOrderByWithRelationInput | epoch_stakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epoch_stakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoch_stakes
    **/
    _count?: true | Epoch_stakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epoch_stakeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epoch_stakeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epoch_stakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epoch_stakeMaxAggregateInputType
  }

  export type GetEpoch_stakeAggregateType<T extends Epoch_stakeAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch_stake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch_stake[P]>
      : GetScalarType<T[P], AggregateEpoch_stake[P]>
  }




  export type epoch_stakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epoch_stakeWhereInput
    orderBy?: epoch_stakeOrderByWithAggregationInput | epoch_stakeOrderByWithAggregationInput[]
    by: Epoch_stakeScalarFieldEnum[] | Epoch_stakeScalarFieldEnum
    having?: epoch_stakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epoch_stakeCountAggregateInputType | true
    _avg?: Epoch_stakeAvgAggregateInputType
    _sum?: Epoch_stakeSumAggregateInputType
    _min?: Epoch_stakeMinAggregateInputType
    _max?: Epoch_stakeMaxAggregateInputType
  }

  export type Epoch_stakeGroupByOutputType = {
    id: bigint
    addr_id: bigint
    pool_id: bigint
    amount: Decimal
    epoch_no: number
    _count: Epoch_stakeCountAggregateOutputType | null
    _avg: Epoch_stakeAvgAggregateOutputType | null
    _sum: Epoch_stakeSumAggregateOutputType | null
    _min: Epoch_stakeMinAggregateOutputType | null
    _max: Epoch_stakeMaxAggregateOutputType | null
  }

  type GetEpoch_stakeGroupByPayload<T extends epoch_stakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epoch_stakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epoch_stakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epoch_stakeGroupByOutputType[P]>
            : GetScalarType<T[P], Epoch_stakeGroupByOutputType[P]>
        }
      >
    >


  export type epoch_stakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_id?: boolean
    amount?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_stake"]>

  export type epoch_stakeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_id?: boolean
    amount?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_stake"]>

  export type epoch_stakeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_id?: boolean
    amount?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_stake"]>

  export type epoch_stakeSelectScalar = {
    id?: boolean
    addr_id?: boolean
    pool_id?: boolean
    amount?: boolean
    epoch_no?: boolean
  }

  export type epoch_stakeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "pool_id" | "amount" | "epoch_no", ExtArgs["result"]["epoch_stake"]>

  export type $epoch_stakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch_stake"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      pool_id: bigint
      amount: Prisma.Decimal
      epoch_no: number
    }, ExtArgs["result"]["epoch_stake"]>
    composites: {}
  }

  type epoch_stakeGetPayload<S extends boolean | null | undefined | epoch_stakeDefaultArgs> = $Result.GetResult<Prisma.$epoch_stakePayload, S>

  type epoch_stakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epoch_stakeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Epoch_stakeCountAggregateInputType | true
    }

  export interface epoch_stakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch_stake'], meta: { name: 'epoch_stake' } }
    /**
     * Find zero or one Epoch_stake that matches the filter.
     * @param {epoch_stakeFindUniqueArgs} args - Arguments to find a Epoch_stake
     * @example
     * // Get one Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epoch_stakeFindUniqueArgs>(args: SelectSubset<T, epoch_stakeFindUniqueArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch_stake that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epoch_stakeFindUniqueOrThrowArgs} args - Arguments to find a Epoch_stake
     * @example
     * // Get one Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epoch_stakeFindUniqueOrThrowArgs>(args: SelectSubset<T, epoch_stakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_stake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeFindFirstArgs} args - Arguments to find a Epoch_stake
     * @example
     * // Get one Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epoch_stakeFindFirstArgs>(args?: SelectSubset<T, epoch_stakeFindFirstArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_stake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeFindFirstOrThrowArgs} args - Arguments to find a Epoch_stake
     * @example
     * // Get one Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epoch_stakeFindFirstOrThrowArgs>(args?: SelectSubset<T, epoch_stakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoch_stakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoch_stakes
     * const epoch_stakes = await prisma.epoch_stake.findMany()
     * 
     * // Get first 10 Epoch_stakes
     * const epoch_stakes = await prisma.epoch_stake.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epoch_stakeWithIdOnly = await prisma.epoch_stake.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epoch_stakeFindManyArgs>(args?: SelectSubset<T, epoch_stakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch_stake.
     * @param {epoch_stakeCreateArgs} args - Arguments to create a Epoch_stake.
     * @example
     * // Create one Epoch_stake
     * const Epoch_stake = await prisma.epoch_stake.create({
     *   data: {
     *     // ... data to create a Epoch_stake
     *   }
     * })
     * 
     */
    create<T extends epoch_stakeCreateArgs>(args: SelectSubset<T, epoch_stakeCreateArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoch_stakes.
     * @param {epoch_stakeCreateManyArgs} args - Arguments to create many Epoch_stakes.
     * @example
     * // Create many Epoch_stakes
     * const epoch_stake = await prisma.epoch_stake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epoch_stakeCreateManyArgs>(args?: SelectSubset<T, epoch_stakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoch_stakes and returns the data saved in the database.
     * @param {epoch_stakeCreateManyAndReturnArgs} args - Arguments to create many Epoch_stakes.
     * @example
     * // Create many Epoch_stakes
     * const epoch_stake = await prisma.epoch_stake.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoch_stakes and only return the `id`
     * const epoch_stakeWithIdOnly = await prisma.epoch_stake.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epoch_stakeCreateManyAndReturnArgs>(args?: SelectSubset<T, epoch_stakeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch_stake.
     * @param {epoch_stakeDeleteArgs} args - Arguments to delete one Epoch_stake.
     * @example
     * // Delete one Epoch_stake
     * const Epoch_stake = await prisma.epoch_stake.delete({
     *   where: {
     *     // ... filter to delete one Epoch_stake
     *   }
     * })
     * 
     */
    delete<T extends epoch_stakeDeleteArgs>(args: SelectSubset<T, epoch_stakeDeleteArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch_stake.
     * @param {epoch_stakeUpdateArgs} args - Arguments to update one Epoch_stake.
     * @example
     * // Update one Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epoch_stakeUpdateArgs>(args: SelectSubset<T, epoch_stakeUpdateArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoch_stakes.
     * @param {epoch_stakeDeleteManyArgs} args - Arguments to filter Epoch_stakes to delete.
     * @example
     * // Delete a few Epoch_stakes
     * const { count } = await prisma.epoch_stake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epoch_stakeDeleteManyArgs>(args?: SelectSubset<T, epoch_stakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoch_stakes
     * const epoch_stake = await prisma.epoch_stake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epoch_stakeUpdateManyArgs>(args: SelectSubset<T, epoch_stakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_stakes and returns the data updated in the database.
     * @param {epoch_stakeUpdateManyAndReturnArgs} args - Arguments to update many Epoch_stakes.
     * @example
     * // Update many Epoch_stakes
     * const epoch_stake = await prisma.epoch_stake.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoch_stakes and only return the `id`
     * const epoch_stakeWithIdOnly = await prisma.epoch_stake.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epoch_stakeUpdateManyAndReturnArgs>(args: SelectSubset<T, epoch_stakeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch_stake.
     * @param {epoch_stakeUpsertArgs} args - Arguments to update or create a Epoch_stake.
     * @example
     * // Update or create a Epoch_stake
     * const epoch_stake = await prisma.epoch_stake.upsert({
     *   create: {
     *     // ... data to create a Epoch_stake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch_stake we want to update
     *   }
     * })
     */
    upsert<T extends epoch_stakeUpsertArgs>(args: SelectSubset<T, epoch_stakeUpsertArgs<ExtArgs>>): Prisma__epoch_stakeClient<$Result.GetResult<Prisma.$epoch_stakePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoch_stakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeCountArgs} args - Arguments to filter Epoch_stakes to count.
     * @example
     * // Count the number of Epoch_stakes
     * const count = await prisma.epoch_stake.count({
     *   where: {
     *     // ... the filter for the Epoch_stakes we want to count
     *   }
     * })
    **/
    count<T extends epoch_stakeCountArgs>(
      args?: Subset<T, epoch_stakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epoch_stakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch_stake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epoch_stakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epoch_stakeAggregateArgs>(args: Subset<T, Epoch_stakeAggregateArgs>): Prisma.PrismaPromise<GetEpoch_stakeAggregateType<T>>

    /**
     * Group by Epoch_stake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epoch_stakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epoch_stakeGroupByArgs['orderBy'] }
        : { orderBy?: epoch_stakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epoch_stakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpoch_stakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch_stake model
   */
  readonly fields: epoch_stakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch_stake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epoch_stakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch_stake model
   */ 
  interface epoch_stakeFieldRefs {
    readonly id: FieldRef<"epoch_stake", 'BigInt'>
    readonly addr_id: FieldRef<"epoch_stake", 'BigInt'>
    readonly pool_id: FieldRef<"epoch_stake", 'BigInt'>
    readonly amount: FieldRef<"epoch_stake", 'Decimal'>
    readonly epoch_no: FieldRef<"epoch_stake", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * epoch_stake findUnique
   */
  export type epoch_stakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake to fetch.
     */
    where: epoch_stakeWhereUniqueInput
  }

  /**
   * epoch_stake findUniqueOrThrow
   */
  export type epoch_stakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake to fetch.
     */
    where: epoch_stakeWhereUniqueInput
  }

  /**
   * epoch_stake findFirst
   */
  export type epoch_stakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake to fetch.
     */
    where?: epoch_stakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stakes to fetch.
     */
    orderBy?: epoch_stakeOrderByWithRelationInput | epoch_stakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_stakes.
     */
    cursor?: epoch_stakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_stakes.
     */
    distinct?: Epoch_stakeScalarFieldEnum | Epoch_stakeScalarFieldEnum[]
  }

  /**
   * epoch_stake findFirstOrThrow
   */
  export type epoch_stakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake to fetch.
     */
    where?: epoch_stakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stakes to fetch.
     */
    orderBy?: epoch_stakeOrderByWithRelationInput | epoch_stakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_stakes.
     */
    cursor?: epoch_stakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_stakes.
     */
    distinct?: Epoch_stakeScalarFieldEnum | Epoch_stakeScalarFieldEnum[]
  }

  /**
   * epoch_stake findMany
   */
  export type epoch_stakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stakes to fetch.
     */
    where?: epoch_stakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stakes to fetch.
     */
    orderBy?: epoch_stakeOrderByWithRelationInput | epoch_stakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoch_stakes.
     */
    cursor?: epoch_stakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stakes.
     */
    skip?: number
    distinct?: Epoch_stakeScalarFieldEnum | Epoch_stakeScalarFieldEnum[]
  }

  /**
   * epoch_stake create
   */
  export type epoch_stakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch_stake.
     */
    data: XOR<epoch_stakeCreateInput, epoch_stakeUncheckedCreateInput>
  }

  /**
   * epoch_stake createMany
   */
  export type epoch_stakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoch_stakes.
     */
    data: epoch_stakeCreateManyInput | epoch_stakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_stake createManyAndReturn
   */
  export type epoch_stakeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * The data used to create many epoch_stakes.
     */
    data: epoch_stakeCreateManyInput | epoch_stakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_stake update
   */
  export type epoch_stakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch_stake.
     */
    data: XOR<epoch_stakeUpdateInput, epoch_stakeUncheckedUpdateInput>
    /**
     * Choose, which epoch_stake to update.
     */
    where: epoch_stakeWhereUniqueInput
  }

  /**
   * epoch_stake updateMany
   */
  export type epoch_stakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoch_stakes.
     */
    data: XOR<epoch_stakeUpdateManyMutationInput, epoch_stakeUncheckedUpdateManyInput>
    /**
     * Filter which epoch_stakes to update
     */
    where?: epoch_stakeWhereInput
    /**
     * Limit how many epoch_stakes to update.
     */
    limit?: number
  }

  /**
   * epoch_stake updateManyAndReturn
   */
  export type epoch_stakeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * The data used to update epoch_stakes.
     */
    data: XOR<epoch_stakeUpdateManyMutationInput, epoch_stakeUncheckedUpdateManyInput>
    /**
     * Filter which epoch_stakes to update
     */
    where?: epoch_stakeWhereInput
    /**
     * Limit how many epoch_stakes to update.
     */
    limit?: number
  }

  /**
   * epoch_stake upsert
   */
  export type epoch_stakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch_stake to update in case it exists.
     */
    where: epoch_stakeWhereUniqueInput
    /**
     * In case the epoch_stake found by the `where` argument doesn't exist, create a new epoch_stake with this data.
     */
    create: XOR<epoch_stakeCreateInput, epoch_stakeUncheckedCreateInput>
    /**
     * In case the epoch_stake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epoch_stakeUpdateInput, epoch_stakeUncheckedUpdateInput>
  }

  /**
   * epoch_stake delete
   */
  export type epoch_stakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
    /**
     * Filter which epoch_stake to delete.
     */
    where: epoch_stakeWhereUniqueInput
  }

  /**
   * epoch_stake deleteMany
   */
  export type epoch_stakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_stakes to delete
     */
    where?: epoch_stakeWhereInput
    /**
     * Limit how many epoch_stakes to delete.
     */
    limit?: number
  }

  /**
   * epoch_stake without action
   */
  export type epoch_stakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake
     */
    select?: epoch_stakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake
     */
    omit?: epoch_stakeOmit<ExtArgs> | null
  }


  /**
   * Model epoch_stake_progress
   */

  export type AggregateEpoch_stake_progress = {
    _count: Epoch_stake_progressCountAggregateOutputType | null
    _avg: Epoch_stake_progressAvgAggregateOutputType | null
    _sum: Epoch_stake_progressSumAggregateOutputType | null
    _min: Epoch_stake_progressMinAggregateOutputType | null
    _max: Epoch_stake_progressMaxAggregateOutputType | null
  }

  export type Epoch_stake_progressAvgAggregateOutputType = {
    id: number | null
    epoch_no: number | null
  }

  export type Epoch_stake_progressSumAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
  }

  export type Epoch_stake_progressMinAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    completed: boolean | null
  }

  export type Epoch_stake_progressMaxAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    completed: boolean | null
  }

  export type Epoch_stake_progressCountAggregateOutputType = {
    id: number
    epoch_no: number
    completed: number
    _all: number
  }


  export type Epoch_stake_progressAvgAggregateInputType = {
    id?: true
    epoch_no?: true
  }

  export type Epoch_stake_progressSumAggregateInputType = {
    id?: true
    epoch_no?: true
  }

  export type Epoch_stake_progressMinAggregateInputType = {
    id?: true
    epoch_no?: true
    completed?: true
  }

  export type Epoch_stake_progressMaxAggregateInputType = {
    id?: true
    epoch_no?: true
    completed?: true
  }

  export type Epoch_stake_progressCountAggregateInputType = {
    id?: true
    epoch_no?: true
    completed?: true
    _all?: true
  }

  export type Epoch_stake_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_stake_progress to aggregate.
     */
    where?: epoch_stake_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stake_progresses to fetch.
     */
    orderBy?: epoch_stake_progressOrderByWithRelationInput | epoch_stake_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epoch_stake_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stake_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stake_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoch_stake_progresses
    **/
    _count?: true | Epoch_stake_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epoch_stake_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epoch_stake_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epoch_stake_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epoch_stake_progressMaxAggregateInputType
  }

  export type GetEpoch_stake_progressAggregateType<T extends Epoch_stake_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch_stake_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch_stake_progress[P]>
      : GetScalarType<T[P], AggregateEpoch_stake_progress[P]>
  }




  export type epoch_stake_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epoch_stake_progressWhereInput
    orderBy?: epoch_stake_progressOrderByWithAggregationInput | epoch_stake_progressOrderByWithAggregationInput[]
    by: Epoch_stake_progressScalarFieldEnum[] | Epoch_stake_progressScalarFieldEnum
    having?: epoch_stake_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epoch_stake_progressCountAggregateInputType | true
    _avg?: Epoch_stake_progressAvgAggregateInputType
    _sum?: Epoch_stake_progressSumAggregateInputType
    _min?: Epoch_stake_progressMinAggregateInputType
    _max?: Epoch_stake_progressMaxAggregateInputType
  }

  export type Epoch_stake_progressGroupByOutputType = {
    id: bigint
    epoch_no: number
    completed: boolean
    _count: Epoch_stake_progressCountAggregateOutputType | null
    _avg: Epoch_stake_progressAvgAggregateOutputType | null
    _sum: Epoch_stake_progressSumAggregateOutputType | null
    _min: Epoch_stake_progressMinAggregateOutputType | null
    _max: Epoch_stake_progressMaxAggregateOutputType | null
  }

  type GetEpoch_stake_progressGroupByPayload<T extends epoch_stake_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epoch_stake_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epoch_stake_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epoch_stake_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Epoch_stake_progressGroupByOutputType[P]>
        }
      >
    >


  export type epoch_stake_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    completed?: boolean
  }, ExtArgs["result"]["epoch_stake_progress"]>

  export type epoch_stake_progressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    completed?: boolean
  }, ExtArgs["result"]["epoch_stake_progress"]>

  export type epoch_stake_progressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    completed?: boolean
  }, ExtArgs["result"]["epoch_stake_progress"]>

  export type epoch_stake_progressSelectScalar = {
    id?: boolean
    epoch_no?: boolean
    completed?: boolean
  }

  export type epoch_stake_progressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "epoch_no" | "completed", ExtArgs["result"]["epoch_stake_progress"]>

  export type $epoch_stake_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch_stake_progress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      epoch_no: number
      completed: boolean
    }, ExtArgs["result"]["epoch_stake_progress"]>
    composites: {}
  }

  type epoch_stake_progressGetPayload<S extends boolean | null | undefined | epoch_stake_progressDefaultArgs> = $Result.GetResult<Prisma.$epoch_stake_progressPayload, S>

  type epoch_stake_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epoch_stake_progressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Epoch_stake_progressCountAggregateInputType | true
    }

  export interface epoch_stake_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch_stake_progress'], meta: { name: 'epoch_stake_progress' } }
    /**
     * Find zero or one Epoch_stake_progress that matches the filter.
     * @param {epoch_stake_progressFindUniqueArgs} args - Arguments to find a Epoch_stake_progress
     * @example
     * // Get one Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epoch_stake_progressFindUniqueArgs>(args: SelectSubset<T, epoch_stake_progressFindUniqueArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch_stake_progress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epoch_stake_progressFindUniqueOrThrowArgs} args - Arguments to find a Epoch_stake_progress
     * @example
     * // Get one Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epoch_stake_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, epoch_stake_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_stake_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressFindFirstArgs} args - Arguments to find a Epoch_stake_progress
     * @example
     * // Get one Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epoch_stake_progressFindFirstArgs>(args?: SelectSubset<T, epoch_stake_progressFindFirstArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_stake_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressFindFirstOrThrowArgs} args - Arguments to find a Epoch_stake_progress
     * @example
     * // Get one Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epoch_stake_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, epoch_stake_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoch_stake_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoch_stake_progresses
     * const epoch_stake_progresses = await prisma.epoch_stake_progress.findMany()
     * 
     * // Get first 10 Epoch_stake_progresses
     * const epoch_stake_progresses = await prisma.epoch_stake_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epoch_stake_progressWithIdOnly = await prisma.epoch_stake_progress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epoch_stake_progressFindManyArgs>(args?: SelectSubset<T, epoch_stake_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch_stake_progress.
     * @param {epoch_stake_progressCreateArgs} args - Arguments to create a Epoch_stake_progress.
     * @example
     * // Create one Epoch_stake_progress
     * const Epoch_stake_progress = await prisma.epoch_stake_progress.create({
     *   data: {
     *     // ... data to create a Epoch_stake_progress
     *   }
     * })
     * 
     */
    create<T extends epoch_stake_progressCreateArgs>(args: SelectSubset<T, epoch_stake_progressCreateArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoch_stake_progresses.
     * @param {epoch_stake_progressCreateManyArgs} args - Arguments to create many Epoch_stake_progresses.
     * @example
     * // Create many Epoch_stake_progresses
     * const epoch_stake_progress = await prisma.epoch_stake_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epoch_stake_progressCreateManyArgs>(args?: SelectSubset<T, epoch_stake_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoch_stake_progresses and returns the data saved in the database.
     * @param {epoch_stake_progressCreateManyAndReturnArgs} args - Arguments to create many Epoch_stake_progresses.
     * @example
     * // Create many Epoch_stake_progresses
     * const epoch_stake_progress = await prisma.epoch_stake_progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoch_stake_progresses and only return the `id`
     * const epoch_stake_progressWithIdOnly = await prisma.epoch_stake_progress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epoch_stake_progressCreateManyAndReturnArgs>(args?: SelectSubset<T, epoch_stake_progressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch_stake_progress.
     * @param {epoch_stake_progressDeleteArgs} args - Arguments to delete one Epoch_stake_progress.
     * @example
     * // Delete one Epoch_stake_progress
     * const Epoch_stake_progress = await prisma.epoch_stake_progress.delete({
     *   where: {
     *     // ... filter to delete one Epoch_stake_progress
     *   }
     * })
     * 
     */
    delete<T extends epoch_stake_progressDeleteArgs>(args: SelectSubset<T, epoch_stake_progressDeleteArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch_stake_progress.
     * @param {epoch_stake_progressUpdateArgs} args - Arguments to update one Epoch_stake_progress.
     * @example
     * // Update one Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epoch_stake_progressUpdateArgs>(args: SelectSubset<T, epoch_stake_progressUpdateArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoch_stake_progresses.
     * @param {epoch_stake_progressDeleteManyArgs} args - Arguments to filter Epoch_stake_progresses to delete.
     * @example
     * // Delete a few Epoch_stake_progresses
     * const { count } = await prisma.epoch_stake_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epoch_stake_progressDeleteManyArgs>(args?: SelectSubset<T, epoch_stake_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_stake_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoch_stake_progresses
     * const epoch_stake_progress = await prisma.epoch_stake_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epoch_stake_progressUpdateManyArgs>(args: SelectSubset<T, epoch_stake_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_stake_progresses and returns the data updated in the database.
     * @param {epoch_stake_progressUpdateManyAndReturnArgs} args - Arguments to update many Epoch_stake_progresses.
     * @example
     * // Update many Epoch_stake_progresses
     * const epoch_stake_progress = await prisma.epoch_stake_progress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoch_stake_progresses and only return the `id`
     * const epoch_stake_progressWithIdOnly = await prisma.epoch_stake_progress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epoch_stake_progressUpdateManyAndReturnArgs>(args: SelectSubset<T, epoch_stake_progressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch_stake_progress.
     * @param {epoch_stake_progressUpsertArgs} args - Arguments to update or create a Epoch_stake_progress.
     * @example
     * // Update or create a Epoch_stake_progress
     * const epoch_stake_progress = await prisma.epoch_stake_progress.upsert({
     *   create: {
     *     // ... data to create a Epoch_stake_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch_stake_progress we want to update
     *   }
     * })
     */
    upsert<T extends epoch_stake_progressUpsertArgs>(args: SelectSubset<T, epoch_stake_progressUpsertArgs<ExtArgs>>): Prisma__epoch_stake_progressClient<$Result.GetResult<Prisma.$epoch_stake_progressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoch_stake_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressCountArgs} args - Arguments to filter Epoch_stake_progresses to count.
     * @example
     * // Count the number of Epoch_stake_progresses
     * const count = await prisma.epoch_stake_progress.count({
     *   where: {
     *     // ... the filter for the Epoch_stake_progresses we want to count
     *   }
     * })
    **/
    count<T extends epoch_stake_progressCountArgs>(
      args?: Subset<T, epoch_stake_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epoch_stake_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch_stake_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epoch_stake_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epoch_stake_progressAggregateArgs>(args: Subset<T, Epoch_stake_progressAggregateArgs>): Prisma.PrismaPromise<GetEpoch_stake_progressAggregateType<T>>

    /**
     * Group by Epoch_stake_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stake_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epoch_stake_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epoch_stake_progressGroupByArgs['orderBy'] }
        : { orderBy?: epoch_stake_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epoch_stake_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpoch_stake_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch_stake_progress model
   */
  readonly fields: epoch_stake_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch_stake_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epoch_stake_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch_stake_progress model
   */ 
  interface epoch_stake_progressFieldRefs {
    readonly id: FieldRef<"epoch_stake_progress", 'BigInt'>
    readonly epoch_no: FieldRef<"epoch_stake_progress", 'Int'>
    readonly completed: FieldRef<"epoch_stake_progress", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * epoch_stake_progress findUnique
   */
  export type epoch_stake_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake_progress to fetch.
     */
    where: epoch_stake_progressWhereUniqueInput
  }

  /**
   * epoch_stake_progress findUniqueOrThrow
   */
  export type epoch_stake_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake_progress to fetch.
     */
    where: epoch_stake_progressWhereUniqueInput
  }

  /**
   * epoch_stake_progress findFirst
   */
  export type epoch_stake_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake_progress to fetch.
     */
    where?: epoch_stake_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stake_progresses to fetch.
     */
    orderBy?: epoch_stake_progressOrderByWithRelationInput | epoch_stake_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_stake_progresses.
     */
    cursor?: epoch_stake_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stake_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stake_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_stake_progresses.
     */
    distinct?: Epoch_stake_progressScalarFieldEnum | Epoch_stake_progressScalarFieldEnum[]
  }

  /**
   * epoch_stake_progress findFirstOrThrow
   */
  export type epoch_stake_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake_progress to fetch.
     */
    where?: epoch_stake_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stake_progresses to fetch.
     */
    orderBy?: epoch_stake_progressOrderByWithRelationInput | epoch_stake_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_stake_progresses.
     */
    cursor?: epoch_stake_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stake_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stake_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_stake_progresses.
     */
    distinct?: Epoch_stake_progressScalarFieldEnum | Epoch_stake_progressScalarFieldEnum[]
  }

  /**
   * epoch_stake_progress findMany
   */
  export type epoch_stake_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter, which epoch_stake_progresses to fetch.
     */
    where?: epoch_stake_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_stake_progresses to fetch.
     */
    orderBy?: epoch_stake_progressOrderByWithRelationInput | epoch_stake_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoch_stake_progresses.
     */
    cursor?: epoch_stake_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_stake_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_stake_progresses.
     */
    skip?: number
    distinct?: Epoch_stake_progressScalarFieldEnum | Epoch_stake_progressScalarFieldEnum[]
  }

  /**
   * epoch_stake_progress create
   */
  export type epoch_stake_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch_stake_progress.
     */
    data: XOR<epoch_stake_progressCreateInput, epoch_stake_progressUncheckedCreateInput>
  }

  /**
   * epoch_stake_progress createMany
   */
  export type epoch_stake_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoch_stake_progresses.
     */
    data: epoch_stake_progressCreateManyInput | epoch_stake_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_stake_progress createManyAndReturn
   */
  export type epoch_stake_progressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * The data used to create many epoch_stake_progresses.
     */
    data: epoch_stake_progressCreateManyInput | epoch_stake_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_stake_progress update
   */
  export type epoch_stake_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch_stake_progress.
     */
    data: XOR<epoch_stake_progressUpdateInput, epoch_stake_progressUncheckedUpdateInput>
    /**
     * Choose, which epoch_stake_progress to update.
     */
    where: epoch_stake_progressWhereUniqueInput
  }

  /**
   * epoch_stake_progress updateMany
   */
  export type epoch_stake_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoch_stake_progresses.
     */
    data: XOR<epoch_stake_progressUpdateManyMutationInput, epoch_stake_progressUncheckedUpdateManyInput>
    /**
     * Filter which epoch_stake_progresses to update
     */
    where?: epoch_stake_progressWhereInput
    /**
     * Limit how many epoch_stake_progresses to update.
     */
    limit?: number
  }

  /**
   * epoch_stake_progress updateManyAndReturn
   */
  export type epoch_stake_progressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * The data used to update epoch_stake_progresses.
     */
    data: XOR<epoch_stake_progressUpdateManyMutationInput, epoch_stake_progressUncheckedUpdateManyInput>
    /**
     * Filter which epoch_stake_progresses to update
     */
    where?: epoch_stake_progressWhereInput
    /**
     * Limit how many epoch_stake_progresses to update.
     */
    limit?: number
  }

  /**
   * epoch_stake_progress upsert
   */
  export type epoch_stake_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch_stake_progress to update in case it exists.
     */
    where: epoch_stake_progressWhereUniqueInput
    /**
     * In case the epoch_stake_progress found by the `where` argument doesn't exist, create a new epoch_stake_progress with this data.
     */
    create: XOR<epoch_stake_progressCreateInput, epoch_stake_progressUncheckedCreateInput>
    /**
     * In case the epoch_stake_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epoch_stake_progressUpdateInput, epoch_stake_progressUncheckedUpdateInput>
  }

  /**
   * epoch_stake_progress delete
   */
  export type epoch_stake_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
    /**
     * Filter which epoch_stake_progress to delete.
     */
    where: epoch_stake_progressWhereUniqueInput
  }

  /**
   * epoch_stake_progress deleteMany
   */
  export type epoch_stake_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_stake_progresses to delete
     */
    where?: epoch_stake_progressWhereInput
    /**
     * Limit how many epoch_stake_progresses to delete.
     */
    limit?: number
  }

  /**
   * epoch_stake_progress without action
   */
  export type epoch_stake_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_stake_progress
     */
    select?: epoch_stake_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_stake_progress
     */
    omit?: epoch_stake_progressOmit<ExtArgs> | null
  }


  /**
   * Model epoch_state
   */

  export type AggregateEpoch_state = {
    _count: Epoch_stateCountAggregateOutputType | null
    _avg: Epoch_stateAvgAggregateOutputType | null
    _sum: Epoch_stateSumAggregateOutputType | null
    _min: Epoch_stateMinAggregateOutputType | null
    _max: Epoch_stateMaxAggregateOutputType | null
  }

  export type Epoch_stateAvgAggregateOutputType = {
    id: number | null
    committee_id: number | null
    no_confidence_id: number | null
    constitution_id: number | null
    epoch_no: number | null
  }

  export type Epoch_stateSumAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    no_confidence_id: bigint | null
    constitution_id: bigint | null
    epoch_no: number | null
  }

  export type Epoch_stateMinAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    no_confidence_id: bigint | null
    constitution_id: bigint | null
    epoch_no: number | null
  }

  export type Epoch_stateMaxAggregateOutputType = {
    id: bigint | null
    committee_id: bigint | null
    no_confidence_id: bigint | null
    constitution_id: bigint | null
    epoch_no: number | null
  }

  export type Epoch_stateCountAggregateOutputType = {
    id: number
    committee_id: number
    no_confidence_id: number
    constitution_id: number
    epoch_no: number
    _all: number
  }


  export type Epoch_stateAvgAggregateInputType = {
    id?: true
    committee_id?: true
    no_confidence_id?: true
    constitution_id?: true
    epoch_no?: true
  }

  export type Epoch_stateSumAggregateInputType = {
    id?: true
    committee_id?: true
    no_confidence_id?: true
    constitution_id?: true
    epoch_no?: true
  }

  export type Epoch_stateMinAggregateInputType = {
    id?: true
    committee_id?: true
    no_confidence_id?: true
    constitution_id?: true
    epoch_no?: true
  }

  export type Epoch_stateMaxAggregateInputType = {
    id?: true
    committee_id?: true
    no_confidence_id?: true
    constitution_id?: true
    epoch_no?: true
  }

  export type Epoch_stateCountAggregateInputType = {
    id?: true
    committee_id?: true
    no_confidence_id?: true
    constitution_id?: true
    epoch_no?: true
    _all?: true
  }

  export type Epoch_stateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_state to aggregate.
     */
    where?: epoch_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_states to fetch.
     */
    orderBy?: epoch_stateOrderByWithRelationInput | epoch_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epoch_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoch_states
    **/
    _count?: true | Epoch_stateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epoch_stateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epoch_stateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epoch_stateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epoch_stateMaxAggregateInputType
  }

  export type GetEpoch_stateAggregateType<T extends Epoch_stateAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch_state]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch_state[P]>
      : GetScalarType<T[P], AggregateEpoch_state[P]>
  }




  export type epoch_stateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epoch_stateWhereInput
    orderBy?: epoch_stateOrderByWithAggregationInput | epoch_stateOrderByWithAggregationInput[]
    by: Epoch_stateScalarFieldEnum[] | Epoch_stateScalarFieldEnum
    having?: epoch_stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epoch_stateCountAggregateInputType | true
    _avg?: Epoch_stateAvgAggregateInputType
    _sum?: Epoch_stateSumAggregateInputType
    _min?: Epoch_stateMinAggregateInputType
    _max?: Epoch_stateMaxAggregateInputType
  }

  export type Epoch_stateGroupByOutputType = {
    id: bigint
    committee_id: bigint | null
    no_confidence_id: bigint | null
    constitution_id: bigint | null
    epoch_no: number
    _count: Epoch_stateCountAggregateOutputType | null
    _avg: Epoch_stateAvgAggregateOutputType | null
    _sum: Epoch_stateSumAggregateOutputType | null
    _min: Epoch_stateMinAggregateOutputType | null
    _max: Epoch_stateMaxAggregateOutputType | null
  }

  type GetEpoch_stateGroupByPayload<T extends epoch_stateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epoch_stateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epoch_stateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epoch_stateGroupByOutputType[P]>
            : GetScalarType<T[P], Epoch_stateGroupByOutputType[P]>
        }
      >
    >


  export type epoch_stateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    no_confidence_id?: boolean
    constitution_id?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_state"]>

  export type epoch_stateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    no_confidence_id?: boolean
    constitution_id?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_state"]>

  export type epoch_stateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    committee_id?: boolean
    no_confidence_id?: boolean
    constitution_id?: boolean
    epoch_no?: boolean
  }, ExtArgs["result"]["epoch_state"]>

  export type epoch_stateSelectScalar = {
    id?: boolean
    committee_id?: boolean
    no_confidence_id?: boolean
    constitution_id?: boolean
    epoch_no?: boolean
  }

  export type epoch_stateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "committee_id" | "no_confidence_id" | "constitution_id" | "epoch_no", ExtArgs["result"]["epoch_state"]>

  export type $epoch_statePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch_state"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      committee_id: bigint | null
      no_confidence_id: bigint | null
      constitution_id: bigint | null
      epoch_no: number
    }, ExtArgs["result"]["epoch_state"]>
    composites: {}
  }

  type epoch_stateGetPayload<S extends boolean | null | undefined | epoch_stateDefaultArgs> = $Result.GetResult<Prisma.$epoch_statePayload, S>

  type epoch_stateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epoch_stateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Epoch_stateCountAggregateInputType | true
    }

  export interface epoch_stateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch_state'], meta: { name: 'epoch_state' } }
    /**
     * Find zero or one Epoch_state that matches the filter.
     * @param {epoch_stateFindUniqueArgs} args - Arguments to find a Epoch_state
     * @example
     * // Get one Epoch_state
     * const epoch_state = await prisma.epoch_state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epoch_stateFindUniqueArgs>(args: SelectSubset<T, epoch_stateFindUniqueArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch_state that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epoch_stateFindUniqueOrThrowArgs} args - Arguments to find a Epoch_state
     * @example
     * // Get one Epoch_state
     * const epoch_state = await prisma.epoch_state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epoch_stateFindUniqueOrThrowArgs>(args: SelectSubset<T, epoch_stateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_state that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateFindFirstArgs} args - Arguments to find a Epoch_state
     * @example
     * // Get one Epoch_state
     * const epoch_state = await prisma.epoch_state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epoch_stateFindFirstArgs>(args?: SelectSubset<T, epoch_stateFindFirstArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_state that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateFindFirstOrThrowArgs} args - Arguments to find a Epoch_state
     * @example
     * // Get one Epoch_state
     * const epoch_state = await prisma.epoch_state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epoch_stateFindFirstOrThrowArgs>(args?: SelectSubset<T, epoch_stateFindFirstOrThrowArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoch_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoch_states
     * const epoch_states = await prisma.epoch_state.findMany()
     * 
     * // Get first 10 Epoch_states
     * const epoch_states = await prisma.epoch_state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epoch_stateWithIdOnly = await prisma.epoch_state.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epoch_stateFindManyArgs>(args?: SelectSubset<T, epoch_stateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch_state.
     * @param {epoch_stateCreateArgs} args - Arguments to create a Epoch_state.
     * @example
     * // Create one Epoch_state
     * const Epoch_state = await prisma.epoch_state.create({
     *   data: {
     *     // ... data to create a Epoch_state
     *   }
     * })
     * 
     */
    create<T extends epoch_stateCreateArgs>(args: SelectSubset<T, epoch_stateCreateArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoch_states.
     * @param {epoch_stateCreateManyArgs} args - Arguments to create many Epoch_states.
     * @example
     * // Create many Epoch_states
     * const epoch_state = await prisma.epoch_state.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epoch_stateCreateManyArgs>(args?: SelectSubset<T, epoch_stateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoch_states and returns the data saved in the database.
     * @param {epoch_stateCreateManyAndReturnArgs} args - Arguments to create many Epoch_states.
     * @example
     * // Create many Epoch_states
     * const epoch_state = await prisma.epoch_state.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoch_states and only return the `id`
     * const epoch_stateWithIdOnly = await prisma.epoch_state.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epoch_stateCreateManyAndReturnArgs>(args?: SelectSubset<T, epoch_stateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch_state.
     * @param {epoch_stateDeleteArgs} args - Arguments to delete one Epoch_state.
     * @example
     * // Delete one Epoch_state
     * const Epoch_state = await prisma.epoch_state.delete({
     *   where: {
     *     // ... filter to delete one Epoch_state
     *   }
     * })
     * 
     */
    delete<T extends epoch_stateDeleteArgs>(args: SelectSubset<T, epoch_stateDeleteArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch_state.
     * @param {epoch_stateUpdateArgs} args - Arguments to update one Epoch_state.
     * @example
     * // Update one Epoch_state
     * const epoch_state = await prisma.epoch_state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epoch_stateUpdateArgs>(args: SelectSubset<T, epoch_stateUpdateArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoch_states.
     * @param {epoch_stateDeleteManyArgs} args - Arguments to filter Epoch_states to delete.
     * @example
     * // Delete a few Epoch_states
     * const { count } = await prisma.epoch_state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epoch_stateDeleteManyArgs>(args?: SelectSubset<T, epoch_stateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoch_states
     * const epoch_state = await prisma.epoch_state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epoch_stateUpdateManyArgs>(args: SelectSubset<T, epoch_stateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_states and returns the data updated in the database.
     * @param {epoch_stateUpdateManyAndReturnArgs} args - Arguments to update many Epoch_states.
     * @example
     * // Update many Epoch_states
     * const epoch_state = await prisma.epoch_state.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoch_states and only return the `id`
     * const epoch_stateWithIdOnly = await prisma.epoch_state.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epoch_stateUpdateManyAndReturnArgs>(args: SelectSubset<T, epoch_stateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch_state.
     * @param {epoch_stateUpsertArgs} args - Arguments to update or create a Epoch_state.
     * @example
     * // Update or create a Epoch_state
     * const epoch_state = await prisma.epoch_state.upsert({
     *   create: {
     *     // ... data to create a Epoch_state
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch_state we want to update
     *   }
     * })
     */
    upsert<T extends epoch_stateUpsertArgs>(args: SelectSubset<T, epoch_stateUpsertArgs<ExtArgs>>): Prisma__epoch_stateClient<$Result.GetResult<Prisma.$epoch_statePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoch_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateCountArgs} args - Arguments to filter Epoch_states to count.
     * @example
     * // Count the number of Epoch_states
     * const count = await prisma.epoch_state.count({
     *   where: {
     *     // ... the filter for the Epoch_states we want to count
     *   }
     * })
    **/
    count<T extends epoch_stateCountArgs>(
      args?: Subset<T, epoch_stateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epoch_stateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epoch_stateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epoch_stateAggregateArgs>(args: Subset<T, Epoch_stateAggregateArgs>): Prisma.PrismaPromise<GetEpoch_stateAggregateType<T>>

    /**
     * Group by Epoch_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epoch_stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epoch_stateGroupByArgs['orderBy'] }
        : { orderBy?: epoch_stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epoch_stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpoch_stateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch_state model
   */
  readonly fields: epoch_stateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch_state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epoch_stateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch_state model
   */ 
  interface epoch_stateFieldRefs {
    readonly id: FieldRef<"epoch_state", 'BigInt'>
    readonly committee_id: FieldRef<"epoch_state", 'BigInt'>
    readonly no_confidence_id: FieldRef<"epoch_state", 'BigInt'>
    readonly constitution_id: FieldRef<"epoch_state", 'BigInt'>
    readonly epoch_no: FieldRef<"epoch_state", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * epoch_state findUnique
   */
  export type epoch_stateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter, which epoch_state to fetch.
     */
    where: epoch_stateWhereUniqueInput
  }

  /**
   * epoch_state findUniqueOrThrow
   */
  export type epoch_stateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter, which epoch_state to fetch.
     */
    where: epoch_stateWhereUniqueInput
  }

  /**
   * epoch_state findFirst
   */
  export type epoch_stateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter, which epoch_state to fetch.
     */
    where?: epoch_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_states to fetch.
     */
    orderBy?: epoch_stateOrderByWithRelationInput | epoch_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_states.
     */
    cursor?: epoch_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_states.
     */
    distinct?: Epoch_stateScalarFieldEnum | Epoch_stateScalarFieldEnum[]
  }

  /**
   * epoch_state findFirstOrThrow
   */
  export type epoch_stateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter, which epoch_state to fetch.
     */
    where?: epoch_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_states to fetch.
     */
    orderBy?: epoch_stateOrderByWithRelationInput | epoch_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_states.
     */
    cursor?: epoch_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_states.
     */
    distinct?: Epoch_stateScalarFieldEnum | Epoch_stateScalarFieldEnum[]
  }

  /**
   * epoch_state findMany
   */
  export type epoch_stateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter, which epoch_states to fetch.
     */
    where?: epoch_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_states to fetch.
     */
    orderBy?: epoch_stateOrderByWithRelationInput | epoch_stateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoch_states.
     */
    cursor?: epoch_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_states.
     */
    skip?: number
    distinct?: Epoch_stateScalarFieldEnum | Epoch_stateScalarFieldEnum[]
  }

  /**
   * epoch_state create
   */
  export type epoch_stateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch_state.
     */
    data: XOR<epoch_stateCreateInput, epoch_stateUncheckedCreateInput>
  }

  /**
   * epoch_state createMany
   */
  export type epoch_stateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoch_states.
     */
    data: epoch_stateCreateManyInput | epoch_stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_state createManyAndReturn
   */
  export type epoch_stateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * The data used to create many epoch_states.
     */
    data: epoch_stateCreateManyInput | epoch_stateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_state update
   */
  export type epoch_stateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch_state.
     */
    data: XOR<epoch_stateUpdateInput, epoch_stateUncheckedUpdateInput>
    /**
     * Choose, which epoch_state to update.
     */
    where: epoch_stateWhereUniqueInput
  }

  /**
   * epoch_state updateMany
   */
  export type epoch_stateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoch_states.
     */
    data: XOR<epoch_stateUpdateManyMutationInput, epoch_stateUncheckedUpdateManyInput>
    /**
     * Filter which epoch_states to update
     */
    where?: epoch_stateWhereInput
    /**
     * Limit how many epoch_states to update.
     */
    limit?: number
  }

  /**
   * epoch_state updateManyAndReturn
   */
  export type epoch_stateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * The data used to update epoch_states.
     */
    data: XOR<epoch_stateUpdateManyMutationInput, epoch_stateUncheckedUpdateManyInput>
    /**
     * Filter which epoch_states to update
     */
    where?: epoch_stateWhereInput
    /**
     * Limit how many epoch_states to update.
     */
    limit?: number
  }

  /**
   * epoch_state upsert
   */
  export type epoch_stateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch_state to update in case it exists.
     */
    where: epoch_stateWhereUniqueInput
    /**
     * In case the epoch_state found by the `where` argument doesn't exist, create a new epoch_state with this data.
     */
    create: XOR<epoch_stateCreateInput, epoch_stateUncheckedCreateInput>
    /**
     * In case the epoch_state was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epoch_stateUpdateInput, epoch_stateUncheckedUpdateInput>
  }

  /**
   * epoch_state delete
   */
  export type epoch_stateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
    /**
     * Filter which epoch_state to delete.
     */
    where: epoch_stateWhereUniqueInput
  }

  /**
   * epoch_state deleteMany
   */
  export type epoch_stateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_states to delete
     */
    where?: epoch_stateWhereInput
    /**
     * Limit how many epoch_states to delete.
     */
    limit?: number
  }

  /**
   * epoch_state without action
   */
  export type epoch_stateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_state
     */
    select?: epoch_stateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_state
     */
    omit?: epoch_stateOmit<ExtArgs> | null
  }


  /**
   * Model epoch_sync_time
   */

  export type AggregateEpoch_sync_time = {
    _count: Epoch_sync_timeCountAggregateOutputType | null
    _avg: Epoch_sync_timeAvgAggregateOutputType | null
    _sum: Epoch_sync_timeSumAggregateOutputType | null
    _min: Epoch_sync_timeMinAggregateOutputType | null
    _max: Epoch_sync_timeMaxAggregateOutputType | null
  }

  export type Epoch_sync_timeAvgAggregateOutputType = {
    id: number | null
    no: number | null
    seconds: number | null
  }

  export type Epoch_sync_timeSumAggregateOutputType = {
    id: bigint | null
    no: bigint | null
    seconds: bigint | null
  }

  export type Epoch_sync_timeMinAggregateOutputType = {
    id: bigint | null
    no: bigint | null
    seconds: bigint | null
    state: $Enums.syncstatetype | null
  }

  export type Epoch_sync_timeMaxAggregateOutputType = {
    id: bigint | null
    no: bigint | null
    seconds: bigint | null
    state: $Enums.syncstatetype | null
  }

  export type Epoch_sync_timeCountAggregateOutputType = {
    id: number
    no: number
    seconds: number
    state: number
    _all: number
  }


  export type Epoch_sync_timeAvgAggregateInputType = {
    id?: true
    no?: true
    seconds?: true
  }

  export type Epoch_sync_timeSumAggregateInputType = {
    id?: true
    no?: true
    seconds?: true
  }

  export type Epoch_sync_timeMinAggregateInputType = {
    id?: true
    no?: true
    seconds?: true
    state?: true
  }

  export type Epoch_sync_timeMaxAggregateInputType = {
    id?: true
    no?: true
    seconds?: true
    state?: true
  }

  export type Epoch_sync_timeCountAggregateInputType = {
    id?: true
    no?: true
    seconds?: true
    state?: true
    _all?: true
  }

  export type Epoch_sync_timeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_sync_time to aggregate.
     */
    where?: epoch_sync_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_sync_times to fetch.
     */
    orderBy?: epoch_sync_timeOrderByWithRelationInput | epoch_sync_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: epoch_sync_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_sync_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_sync_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned epoch_sync_times
    **/
    _count?: true | Epoch_sync_timeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Epoch_sync_timeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Epoch_sync_timeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Epoch_sync_timeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Epoch_sync_timeMaxAggregateInputType
  }

  export type GetEpoch_sync_timeAggregateType<T extends Epoch_sync_timeAggregateArgs> = {
        [P in keyof T & keyof AggregateEpoch_sync_time]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpoch_sync_time[P]>
      : GetScalarType<T[P], AggregateEpoch_sync_time[P]>
  }




  export type epoch_sync_timeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: epoch_sync_timeWhereInput
    orderBy?: epoch_sync_timeOrderByWithAggregationInput | epoch_sync_timeOrderByWithAggregationInput[]
    by: Epoch_sync_timeScalarFieldEnum[] | Epoch_sync_timeScalarFieldEnum
    having?: epoch_sync_timeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Epoch_sync_timeCountAggregateInputType | true
    _avg?: Epoch_sync_timeAvgAggregateInputType
    _sum?: Epoch_sync_timeSumAggregateInputType
    _min?: Epoch_sync_timeMinAggregateInputType
    _max?: Epoch_sync_timeMaxAggregateInputType
  }

  export type Epoch_sync_timeGroupByOutputType = {
    id: bigint
    no: bigint
    seconds: bigint
    state: $Enums.syncstatetype
    _count: Epoch_sync_timeCountAggregateOutputType | null
    _avg: Epoch_sync_timeAvgAggregateOutputType | null
    _sum: Epoch_sync_timeSumAggregateOutputType | null
    _min: Epoch_sync_timeMinAggregateOutputType | null
    _max: Epoch_sync_timeMaxAggregateOutputType | null
  }

  type GetEpoch_sync_timeGroupByPayload<T extends epoch_sync_timeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Epoch_sync_timeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Epoch_sync_timeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Epoch_sync_timeGroupByOutputType[P]>
            : GetScalarType<T[P], Epoch_sync_timeGroupByOutputType[P]>
        }
      >
    >


  export type epoch_sync_timeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    no?: boolean
    seconds?: boolean
    state?: boolean
  }, ExtArgs["result"]["epoch_sync_time"]>

  export type epoch_sync_timeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    no?: boolean
    seconds?: boolean
    state?: boolean
  }, ExtArgs["result"]["epoch_sync_time"]>

  export type epoch_sync_timeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    no?: boolean
    seconds?: boolean
    state?: boolean
  }, ExtArgs["result"]["epoch_sync_time"]>

  export type epoch_sync_timeSelectScalar = {
    id?: boolean
    no?: boolean
    seconds?: boolean
    state?: boolean
  }

  export type epoch_sync_timeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "no" | "seconds" | "state", ExtArgs["result"]["epoch_sync_time"]>

  export type $epoch_sync_timePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "epoch_sync_time"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      no: bigint
      seconds: bigint
      state: $Enums.syncstatetype
    }, ExtArgs["result"]["epoch_sync_time"]>
    composites: {}
  }

  type epoch_sync_timeGetPayload<S extends boolean | null | undefined | epoch_sync_timeDefaultArgs> = $Result.GetResult<Prisma.$epoch_sync_timePayload, S>

  type epoch_sync_timeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<epoch_sync_timeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Epoch_sync_timeCountAggregateInputType | true
    }

  export interface epoch_sync_timeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['epoch_sync_time'], meta: { name: 'epoch_sync_time' } }
    /**
     * Find zero or one Epoch_sync_time that matches the filter.
     * @param {epoch_sync_timeFindUniqueArgs} args - Arguments to find a Epoch_sync_time
     * @example
     * // Get one Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends epoch_sync_timeFindUniqueArgs>(args: SelectSubset<T, epoch_sync_timeFindUniqueArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Epoch_sync_time that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {epoch_sync_timeFindUniqueOrThrowArgs} args - Arguments to find a Epoch_sync_time
     * @example
     * // Get one Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends epoch_sync_timeFindUniqueOrThrowArgs>(args: SelectSubset<T, epoch_sync_timeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_sync_time that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeFindFirstArgs} args - Arguments to find a Epoch_sync_time
     * @example
     * // Get one Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends epoch_sync_timeFindFirstArgs>(args?: SelectSubset<T, epoch_sync_timeFindFirstArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Epoch_sync_time that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeFindFirstOrThrowArgs} args - Arguments to find a Epoch_sync_time
     * @example
     * // Get one Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends epoch_sync_timeFindFirstOrThrowArgs>(args?: SelectSubset<T, epoch_sync_timeFindFirstOrThrowArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Epoch_sync_times that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Epoch_sync_times
     * const epoch_sync_times = await prisma.epoch_sync_time.findMany()
     * 
     * // Get first 10 Epoch_sync_times
     * const epoch_sync_times = await prisma.epoch_sync_time.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const epoch_sync_timeWithIdOnly = await prisma.epoch_sync_time.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends epoch_sync_timeFindManyArgs>(args?: SelectSubset<T, epoch_sync_timeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Epoch_sync_time.
     * @param {epoch_sync_timeCreateArgs} args - Arguments to create a Epoch_sync_time.
     * @example
     * // Create one Epoch_sync_time
     * const Epoch_sync_time = await prisma.epoch_sync_time.create({
     *   data: {
     *     // ... data to create a Epoch_sync_time
     *   }
     * })
     * 
     */
    create<T extends epoch_sync_timeCreateArgs>(args: SelectSubset<T, epoch_sync_timeCreateArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Epoch_sync_times.
     * @param {epoch_sync_timeCreateManyArgs} args - Arguments to create many Epoch_sync_times.
     * @example
     * // Create many Epoch_sync_times
     * const epoch_sync_time = await prisma.epoch_sync_time.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends epoch_sync_timeCreateManyArgs>(args?: SelectSubset<T, epoch_sync_timeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Epoch_sync_times and returns the data saved in the database.
     * @param {epoch_sync_timeCreateManyAndReturnArgs} args - Arguments to create many Epoch_sync_times.
     * @example
     * // Create many Epoch_sync_times
     * const epoch_sync_time = await prisma.epoch_sync_time.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Epoch_sync_times and only return the `id`
     * const epoch_sync_timeWithIdOnly = await prisma.epoch_sync_time.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends epoch_sync_timeCreateManyAndReturnArgs>(args?: SelectSubset<T, epoch_sync_timeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Epoch_sync_time.
     * @param {epoch_sync_timeDeleteArgs} args - Arguments to delete one Epoch_sync_time.
     * @example
     * // Delete one Epoch_sync_time
     * const Epoch_sync_time = await prisma.epoch_sync_time.delete({
     *   where: {
     *     // ... filter to delete one Epoch_sync_time
     *   }
     * })
     * 
     */
    delete<T extends epoch_sync_timeDeleteArgs>(args: SelectSubset<T, epoch_sync_timeDeleteArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Epoch_sync_time.
     * @param {epoch_sync_timeUpdateArgs} args - Arguments to update one Epoch_sync_time.
     * @example
     * // Update one Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends epoch_sync_timeUpdateArgs>(args: SelectSubset<T, epoch_sync_timeUpdateArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Epoch_sync_times.
     * @param {epoch_sync_timeDeleteManyArgs} args - Arguments to filter Epoch_sync_times to delete.
     * @example
     * // Delete a few Epoch_sync_times
     * const { count } = await prisma.epoch_sync_time.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends epoch_sync_timeDeleteManyArgs>(args?: SelectSubset<T, epoch_sync_timeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_sync_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Epoch_sync_times
     * const epoch_sync_time = await prisma.epoch_sync_time.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends epoch_sync_timeUpdateManyArgs>(args: SelectSubset<T, epoch_sync_timeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Epoch_sync_times and returns the data updated in the database.
     * @param {epoch_sync_timeUpdateManyAndReturnArgs} args - Arguments to update many Epoch_sync_times.
     * @example
     * // Update many Epoch_sync_times
     * const epoch_sync_time = await prisma.epoch_sync_time.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Epoch_sync_times and only return the `id`
     * const epoch_sync_timeWithIdOnly = await prisma.epoch_sync_time.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends epoch_sync_timeUpdateManyAndReturnArgs>(args: SelectSubset<T, epoch_sync_timeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Epoch_sync_time.
     * @param {epoch_sync_timeUpsertArgs} args - Arguments to update or create a Epoch_sync_time.
     * @example
     * // Update or create a Epoch_sync_time
     * const epoch_sync_time = await prisma.epoch_sync_time.upsert({
     *   create: {
     *     // ... data to create a Epoch_sync_time
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Epoch_sync_time we want to update
     *   }
     * })
     */
    upsert<T extends epoch_sync_timeUpsertArgs>(args: SelectSubset<T, epoch_sync_timeUpsertArgs<ExtArgs>>): Prisma__epoch_sync_timeClient<$Result.GetResult<Prisma.$epoch_sync_timePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Epoch_sync_times.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeCountArgs} args - Arguments to filter Epoch_sync_times to count.
     * @example
     * // Count the number of Epoch_sync_times
     * const count = await prisma.epoch_sync_time.count({
     *   where: {
     *     // ... the filter for the Epoch_sync_times we want to count
     *   }
     * })
    **/
    count<T extends epoch_sync_timeCountArgs>(
      args?: Subset<T, epoch_sync_timeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Epoch_sync_timeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Epoch_sync_time.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Epoch_sync_timeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Epoch_sync_timeAggregateArgs>(args: Subset<T, Epoch_sync_timeAggregateArgs>): Prisma.PrismaPromise<GetEpoch_sync_timeAggregateType<T>>

    /**
     * Group by Epoch_sync_time.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {epoch_sync_timeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends epoch_sync_timeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: epoch_sync_timeGroupByArgs['orderBy'] }
        : { orderBy?: epoch_sync_timeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, epoch_sync_timeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpoch_sync_timeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the epoch_sync_time model
   */
  readonly fields: epoch_sync_timeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for epoch_sync_time.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__epoch_sync_timeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the epoch_sync_time model
   */ 
  interface epoch_sync_timeFieldRefs {
    readonly id: FieldRef<"epoch_sync_time", 'BigInt'>
    readonly no: FieldRef<"epoch_sync_time", 'BigInt'>
    readonly seconds: FieldRef<"epoch_sync_time", 'BigInt'>
    readonly state: FieldRef<"epoch_sync_time", 'syncstatetype'>
  }
    

  // Custom InputTypes
  /**
   * epoch_sync_time findUnique
   */
  export type epoch_sync_timeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_sync_time to fetch.
     */
    where: epoch_sync_timeWhereUniqueInput
  }

  /**
   * epoch_sync_time findUniqueOrThrow
   */
  export type epoch_sync_timeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_sync_time to fetch.
     */
    where: epoch_sync_timeWhereUniqueInput
  }

  /**
   * epoch_sync_time findFirst
   */
  export type epoch_sync_timeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_sync_time to fetch.
     */
    where?: epoch_sync_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_sync_times to fetch.
     */
    orderBy?: epoch_sync_timeOrderByWithRelationInput | epoch_sync_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_sync_times.
     */
    cursor?: epoch_sync_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_sync_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_sync_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_sync_times.
     */
    distinct?: Epoch_sync_timeScalarFieldEnum | Epoch_sync_timeScalarFieldEnum[]
  }

  /**
   * epoch_sync_time findFirstOrThrow
   */
  export type epoch_sync_timeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_sync_time to fetch.
     */
    where?: epoch_sync_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_sync_times to fetch.
     */
    orderBy?: epoch_sync_timeOrderByWithRelationInput | epoch_sync_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for epoch_sync_times.
     */
    cursor?: epoch_sync_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_sync_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_sync_times.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of epoch_sync_times.
     */
    distinct?: Epoch_sync_timeScalarFieldEnum | Epoch_sync_timeScalarFieldEnum[]
  }

  /**
   * epoch_sync_time findMany
   */
  export type epoch_sync_timeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter, which epoch_sync_times to fetch.
     */
    where?: epoch_sync_timeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of epoch_sync_times to fetch.
     */
    orderBy?: epoch_sync_timeOrderByWithRelationInput | epoch_sync_timeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing epoch_sync_times.
     */
    cursor?: epoch_sync_timeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` epoch_sync_times from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` epoch_sync_times.
     */
    skip?: number
    distinct?: Epoch_sync_timeScalarFieldEnum | Epoch_sync_timeScalarFieldEnum[]
  }

  /**
   * epoch_sync_time create
   */
  export type epoch_sync_timeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * The data needed to create a epoch_sync_time.
     */
    data: XOR<epoch_sync_timeCreateInput, epoch_sync_timeUncheckedCreateInput>
  }

  /**
   * epoch_sync_time createMany
   */
  export type epoch_sync_timeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many epoch_sync_times.
     */
    data: epoch_sync_timeCreateManyInput | epoch_sync_timeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_sync_time createManyAndReturn
   */
  export type epoch_sync_timeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * The data used to create many epoch_sync_times.
     */
    data: epoch_sync_timeCreateManyInput | epoch_sync_timeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * epoch_sync_time update
   */
  export type epoch_sync_timeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * The data needed to update a epoch_sync_time.
     */
    data: XOR<epoch_sync_timeUpdateInput, epoch_sync_timeUncheckedUpdateInput>
    /**
     * Choose, which epoch_sync_time to update.
     */
    where: epoch_sync_timeWhereUniqueInput
  }

  /**
   * epoch_sync_time updateMany
   */
  export type epoch_sync_timeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update epoch_sync_times.
     */
    data: XOR<epoch_sync_timeUpdateManyMutationInput, epoch_sync_timeUncheckedUpdateManyInput>
    /**
     * Filter which epoch_sync_times to update
     */
    where?: epoch_sync_timeWhereInput
    /**
     * Limit how many epoch_sync_times to update.
     */
    limit?: number
  }

  /**
   * epoch_sync_time updateManyAndReturn
   */
  export type epoch_sync_timeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * The data used to update epoch_sync_times.
     */
    data: XOR<epoch_sync_timeUpdateManyMutationInput, epoch_sync_timeUncheckedUpdateManyInput>
    /**
     * Filter which epoch_sync_times to update
     */
    where?: epoch_sync_timeWhereInput
    /**
     * Limit how many epoch_sync_times to update.
     */
    limit?: number
  }

  /**
   * epoch_sync_time upsert
   */
  export type epoch_sync_timeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * The filter to search for the epoch_sync_time to update in case it exists.
     */
    where: epoch_sync_timeWhereUniqueInput
    /**
     * In case the epoch_sync_time found by the `where` argument doesn't exist, create a new epoch_sync_time with this data.
     */
    create: XOR<epoch_sync_timeCreateInput, epoch_sync_timeUncheckedCreateInput>
    /**
     * In case the epoch_sync_time was found with the provided `where` argument, update it with this data.
     */
    update: XOR<epoch_sync_timeUpdateInput, epoch_sync_timeUncheckedUpdateInput>
  }

  /**
   * epoch_sync_time delete
   */
  export type epoch_sync_timeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
    /**
     * Filter which epoch_sync_time to delete.
     */
    where: epoch_sync_timeWhereUniqueInput
  }

  /**
   * epoch_sync_time deleteMany
   */
  export type epoch_sync_timeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which epoch_sync_times to delete
     */
    where?: epoch_sync_timeWhereInput
    /**
     * Limit how many epoch_sync_times to delete.
     */
    limit?: number
  }

  /**
   * epoch_sync_time without action
   */
  export type epoch_sync_timeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the epoch_sync_time
     */
    select?: epoch_sync_timeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the epoch_sync_time
     */
    omit?: epoch_sync_timeOmit<ExtArgs> | null
  }


  /**
   * Model event_info
   */

  export type AggregateEvent_info = {
    _count: Event_infoCountAggregateOutputType | null
    _avg: Event_infoAvgAggregateOutputType | null
    _sum: Event_infoSumAggregateOutputType | null
    _min: Event_infoMinAggregateOutputType | null
    _max: Event_infoMaxAggregateOutputType | null
  }

  export type Event_infoAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    epoch: number | null
  }

  export type Event_infoSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    epoch: number | null
  }

  export type Event_infoMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    epoch: number | null
    type: string | null
    explanation: string | null
  }

  export type Event_infoMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    epoch: number | null
    type: string | null
    explanation: string | null
  }

  export type Event_infoCountAggregateOutputType = {
    id: number
    tx_id: number
    epoch: number
    type: number
    explanation: number
    _all: number
  }


  export type Event_infoAvgAggregateInputType = {
    id?: true
    tx_id?: true
    epoch?: true
  }

  export type Event_infoSumAggregateInputType = {
    id?: true
    tx_id?: true
    epoch?: true
  }

  export type Event_infoMinAggregateInputType = {
    id?: true
    tx_id?: true
    epoch?: true
    type?: true
    explanation?: true
  }

  export type Event_infoMaxAggregateInputType = {
    id?: true
    tx_id?: true
    epoch?: true
    type?: true
    explanation?: true
  }

  export type Event_infoCountAggregateInputType = {
    id?: true
    tx_id?: true
    epoch?: true
    type?: true
    explanation?: true
    _all?: true
  }

  export type Event_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_info to aggregate.
     */
    where?: event_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_infos to fetch.
     */
    orderBy?: event_infoOrderByWithRelationInput | event_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: event_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_infos
    **/
    _count?: true | Event_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_infoMaxAggregateInputType
  }

  export type GetEvent_infoAggregateType<T extends Event_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_info[P]>
      : GetScalarType<T[P], AggregateEvent_info[P]>
  }




  export type event_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: event_infoWhereInput
    orderBy?: event_infoOrderByWithAggregationInput | event_infoOrderByWithAggregationInput[]
    by: Event_infoScalarFieldEnum[] | Event_infoScalarFieldEnum
    having?: event_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_infoCountAggregateInputType | true
    _avg?: Event_infoAvgAggregateInputType
    _sum?: Event_infoSumAggregateInputType
    _min?: Event_infoMinAggregateInputType
    _max?: Event_infoMaxAggregateInputType
  }

  export type Event_infoGroupByOutputType = {
    id: bigint
    tx_id: bigint | null
    epoch: number
    type: string
    explanation: string | null
    _count: Event_infoCountAggregateOutputType | null
    _avg: Event_infoAvgAggregateOutputType | null
    _sum: Event_infoSumAggregateOutputType | null
    _min: Event_infoMinAggregateOutputType | null
    _max: Event_infoMaxAggregateOutputType | null
  }

  type GetEvent_infoGroupByPayload<T extends event_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Event_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Event_infoGroupByOutputType[P]>
        }
      >
    >


  export type event_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    epoch?: boolean
    type?: boolean
    explanation?: boolean
  }, ExtArgs["result"]["event_info"]>

  export type event_infoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    epoch?: boolean
    type?: boolean
    explanation?: boolean
  }, ExtArgs["result"]["event_info"]>

  export type event_infoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    epoch?: boolean
    type?: boolean
    explanation?: boolean
  }, ExtArgs["result"]["event_info"]>

  export type event_infoSelectScalar = {
    id?: boolean
    tx_id?: boolean
    epoch?: boolean
    type?: boolean
    explanation?: boolean
  }

  export type event_infoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "epoch" | "type" | "explanation", ExtArgs["result"]["event_info"]>

  export type $event_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "event_info"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint | null
      epoch: number
      type: string
      explanation: string | null
    }, ExtArgs["result"]["event_info"]>
    composites: {}
  }

  type event_infoGetPayload<S extends boolean | null | undefined | event_infoDefaultArgs> = $Result.GetResult<Prisma.$event_infoPayload, S>

  type event_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<event_infoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Event_infoCountAggregateInputType | true
    }

  export interface event_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['event_info'], meta: { name: 'event_info' } }
    /**
     * Find zero or one Event_info that matches the filter.
     * @param {event_infoFindUniqueArgs} args - Arguments to find a Event_info
     * @example
     * // Get one Event_info
     * const event_info = await prisma.event_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends event_infoFindUniqueArgs>(args: SelectSubset<T, event_infoFindUniqueArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Event_info that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {event_infoFindUniqueOrThrowArgs} args - Arguments to find a Event_info
     * @example
     * // Get one Event_info
     * const event_info = await prisma.event_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends event_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, event_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Event_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoFindFirstArgs} args - Arguments to find a Event_info
     * @example
     * // Get one Event_info
     * const event_info = await prisma.event_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends event_infoFindFirstArgs>(args?: SelectSubset<T, event_infoFindFirstArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Event_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoFindFirstOrThrowArgs} args - Arguments to find a Event_info
     * @example
     * // Get one Event_info
     * const event_info = await prisma.event_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends event_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, event_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Event_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_infos
     * const event_infos = await prisma.event_info.findMany()
     * 
     * // Get first 10 Event_infos
     * const event_infos = await prisma.event_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const event_infoWithIdOnly = await prisma.event_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends event_infoFindManyArgs>(args?: SelectSubset<T, event_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Event_info.
     * @param {event_infoCreateArgs} args - Arguments to create a Event_info.
     * @example
     * // Create one Event_info
     * const Event_info = await prisma.event_info.create({
     *   data: {
     *     // ... data to create a Event_info
     *   }
     * })
     * 
     */
    create<T extends event_infoCreateArgs>(args: SelectSubset<T, event_infoCreateArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Event_infos.
     * @param {event_infoCreateManyArgs} args - Arguments to create many Event_infos.
     * @example
     * // Create many Event_infos
     * const event_info = await prisma.event_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends event_infoCreateManyArgs>(args?: SelectSubset<T, event_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Event_infos and returns the data saved in the database.
     * @param {event_infoCreateManyAndReturnArgs} args - Arguments to create many Event_infos.
     * @example
     * // Create many Event_infos
     * const event_info = await prisma.event_info.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Event_infos and only return the `id`
     * const event_infoWithIdOnly = await prisma.event_info.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends event_infoCreateManyAndReturnArgs>(args?: SelectSubset<T, event_infoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Event_info.
     * @param {event_infoDeleteArgs} args - Arguments to delete one Event_info.
     * @example
     * // Delete one Event_info
     * const Event_info = await prisma.event_info.delete({
     *   where: {
     *     // ... filter to delete one Event_info
     *   }
     * })
     * 
     */
    delete<T extends event_infoDeleteArgs>(args: SelectSubset<T, event_infoDeleteArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Event_info.
     * @param {event_infoUpdateArgs} args - Arguments to update one Event_info.
     * @example
     * // Update one Event_info
     * const event_info = await prisma.event_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends event_infoUpdateArgs>(args: SelectSubset<T, event_infoUpdateArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Event_infos.
     * @param {event_infoDeleteManyArgs} args - Arguments to filter Event_infos to delete.
     * @example
     * // Delete a few Event_infos
     * const { count } = await prisma.event_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends event_infoDeleteManyArgs>(args?: SelectSubset<T, event_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_infos
     * const event_info = await prisma.event_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends event_infoUpdateManyArgs>(args: SelectSubset<T, event_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_infos and returns the data updated in the database.
     * @param {event_infoUpdateManyAndReturnArgs} args - Arguments to update many Event_infos.
     * @example
     * // Update many Event_infos
     * const event_info = await prisma.event_info.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Event_infos and only return the `id`
     * const event_infoWithIdOnly = await prisma.event_info.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends event_infoUpdateManyAndReturnArgs>(args: SelectSubset<T, event_infoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Event_info.
     * @param {event_infoUpsertArgs} args - Arguments to update or create a Event_info.
     * @example
     * // Update or create a Event_info
     * const event_info = await prisma.event_info.upsert({
     *   create: {
     *     // ... data to create a Event_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_info we want to update
     *   }
     * })
     */
    upsert<T extends event_infoUpsertArgs>(args: SelectSubset<T, event_infoUpsertArgs<ExtArgs>>): Prisma__event_infoClient<$Result.GetResult<Prisma.$event_infoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Event_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoCountArgs} args - Arguments to filter Event_infos to count.
     * @example
     * // Count the number of Event_infos
     * const count = await prisma.event_info.count({
     *   where: {
     *     // ... the filter for the Event_infos we want to count
     *   }
     * })
    **/
    count<T extends event_infoCountArgs>(
      args?: Subset<T, event_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_infoAggregateArgs>(args: Subset<T, Event_infoAggregateArgs>): Prisma.PrismaPromise<GetEvent_infoAggregateType<T>>

    /**
     * Group by Event_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends event_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: event_infoGroupByArgs['orderBy'] }
        : { orderBy?: event_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, event_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the event_info model
   */
  readonly fields: event_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__event_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the event_info model
   */ 
  interface event_infoFieldRefs {
    readonly id: FieldRef<"event_info", 'BigInt'>
    readonly tx_id: FieldRef<"event_info", 'BigInt'>
    readonly epoch: FieldRef<"event_info", 'Int'>
    readonly type: FieldRef<"event_info", 'String'>
    readonly explanation: FieldRef<"event_info", 'String'>
  }
    

  // Custom InputTypes
  /**
   * event_info findUnique
   */
  export type event_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter, which event_info to fetch.
     */
    where: event_infoWhereUniqueInput
  }

  /**
   * event_info findUniqueOrThrow
   */
  export type event_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter, which event_info to fetch.
     */
    where: event_infoWhereUniqueInput
  }

  /**
   * event_info findFirst
   */
  export type event_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter, which event_info to fetch.
     */
    where?: event_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_infos to fetch.
     */
    orderBy?: event_infoOrderByWithRelationInput | event_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_infos.
     */
    cursor?: event_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_infos.
     */
    distinct?: Event_infoScalarFieldEnum | Event_infoScalarFieldEnum[]
  }

  /**
   * event_info findFirstOrThrow
   */
  export type event_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter, which event_info to fetch.
     */
    where?: event_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_infos to fetch.
     */
    orderBy?: event_infoOrderByWithRelationInput | event_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_infos.
     */
    cursor?: event_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_infos.
     */
    distinct?: Event_infoScalarFieldEnum | Event_infoScalarFieldEnum[]
  }

  /**
   * event_info findMany
   */
  export type event_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter, which event_infos to fetch.
     */
    where?: event_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_infos to fetch.
     */
    orderBy?: event_infoOrderByWithRelationInput | event_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_infos.
     */
    cursor?: event_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_infos.
     */
    skip?: number
    distinct?: Event_infoScalarFieldEnum | Event_infoScalarFieldEnum[]
  }

  /**
   * event_info create
   */
  export type event_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * The data needed to create a event_info.
     */
    data: XOR<event_infoCreateInput, event_infoUncheckedCreateInput>
  }

  /**
   * event_info createMany
   */
  export type event_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many event_infos.
     */
    data: event_infoCreateManyInput | event_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event_info createManyAndReturn
   */
  export type event_infoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * The data used to create many event_infos.
     */
    data: event_infoCreateManyInput | event_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * event_info update
   */
  export type event_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * The data needed to update a event_info.
     */
    data: XOR<event_infoUpdateInput, event_infoUncheckedUpdateInput>
    /**
     * Choose, which event_info to update.
     */
    where: event_infoWhereUniqueInput
  }

  /**
   * event_info updateMany
   */
  export type event_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update event_infos.
     */
    data: XOR<event_infoUpdateManyMutationInput, event_infoUncheckedUpdateManyInput>
    /**
     * Filter which event_infos to update
     */
    where?: event_infoWhereInput
    /**
     * Limit how many event_infos to update.
     */
    limit?: number
  }

  /**
   * event_info updateManyAndReturn
   */
  export type event_infoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * The data used to update event_infos.
     */
    data: XOR<event_infoUpdateManyMutationInput, event_infoUncheckedUpdateManyInput>
    /**
     * Filter which event_infos to update
     */
    where?: event_infoWhereInput
    /**
     * Limit how many event_infos to update.
     */
    limit?: number
  }

  /**
   * event_info upsert
   */
  export type event_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * The filter to search for the event_info to update in case it exists.
     */
    where: event_infoWhereUniqueInput
    /**
     * In case the event_info found by the `where` argument doesn't exist, create a new event_info with this data.
     */
    create: XOR<event_infoCreateInput, event_infoUncheckedCreateInput>
    /**
     * In case the event_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<event_infoUpdateInput, event_infoUncheckedUpdateInput>
  }

  /**
   * event_info delete
   */
  export type event_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
    /**
     * Filter which event_info to delete.
     */
    where: event_infoWhereUniqueInput
  }

  /**
   * event_info deleteMany
   */
  export type event_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which event_infos to delete
     */
    where?: event_infoWhereInput
    /**
     * Limit how many event_infos to delete.
     */
    limit?: number
  }

  /**
   * event_info without action
   */
  export type event_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the event_info
     */
    select?: event_infoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the event_info
     */
    omit?: event_infoOmit<ExtArgs> | null
  }


  /**
   * Model extra_key_witness
   */

  export type AggregateExtra_key_witness = {
    _count: Extra_key_witnessCountAggregateOutputType | null
    _avg: Extra_key_witnessAvgAggregateOutputType | null
    _sum: Extra_key_witnessSumAggregateOutputType | null
    _min: Extra_key_witnessMinAggregateOutputType | null
    _max: Extra_key_witnessMaxAggregateOutputType | null
  }

  export type Extra_key_witnessAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
  }

  export type Extra_key_witnessSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
  }

  export type Extra_key_witnessMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
  }

  export type Extra_key_witnessMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
  }

  export type Extra_key_witnessCountAggregateOutputType = {
    id: number
    hash: number
    tx_id: number
    _all: number
  }


  export type Extra_key_witnessAvgAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Extra_key_witnessSumAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Extra_key_witnessMinAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
  }

  export type Extra_key_witnessMaxAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
  }

  export type Extra_key_witnessCountAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    _all?: true
  }

  export type Extra_key_witnessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_key_witness to aggregate.
     */
    where?: extra_key_witnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_key_witnesses to fetch.
     */
    orderBy?: extra_key_witnessOrderByWithRelationInput | extra_key_witnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extra_key_witnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_key_witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_key_witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extra_key_witnesses
    **/
    _count?: true | Extra_key_witnessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Extra_key_witnessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Extra_key_witnessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Extra_key_witnessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Extra_key_witnessMaxAggregateInputType
  }

  export type GetExtra_key_witnessAggregateType<T extends Extra_key_witnessAggregateArgs> = {
        [P in keyof T & keyof AggregateExtra_key_witness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtra_key_witness[P]>
      : GetScalarType<T[P], AggregateExtra_key_witness[P]>
  }




  export type extra_key_witnessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extra_key_witnessWhereInput
    orderBy?: extra_key_witnessOrderByWithAggregationInput | extra_key_witnessOrderByWithAggregationInput[]
    by: Extra_key_witnessScalarFieldEnum[] | Extra_key_witnessScalarFieldEnum
    having?: extra_key_witnessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Extra_key_witnessCountAggregateInputType | true
    _avg?: Extra_key_witnessAvgAggregateInputType
    _sum?: Extra_key_witnessSumAggregateInputType
    _min?: Extra_key_witnessMinAggregateInputType
    _max?: Extra_key_witnessMaxAggregateInputType
  }

  export type Extra_key_witnessGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    tx_id: bigint
    _count: Extra_key_witnessCountAggregateOutputType | null
    _avg: Extra_key_witnessAvgAggregateOutputType | null
    _sum: Extra_key_witnessSumAggregateOutputType | null
    _min: Extra_key_witnessMinAggregateOutputType | null
    _max: Extra_key_witnessMaxAggregateOutputType | null
  }

  type GetExtra_key_witnessGroupByPayload<T extends extra_key_witnessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Extra_key_witnessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Extra_key_witnessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Extra_key_witnessGroupByOutputType[P]>
            : GetScalarType<T[P], Extra_key_witnessGroupByOutputType[P]>
        }
      >
    >


  export type extra_key_witnessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["extra_key_witness"]>

  export type extra_key_witnessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["extra_key_witness"]>

  export type extra_key_witnessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["extra_key_witness"]>

  export type extra_key_witnessSelectScalar = {
    id?: boolean
    hash?: boolean
    tx_id?: boolean
  }

  export type extra_key_witnessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "tx_id", ExtArgs["result"]["extra_key_witness"]>

  export type $extra_key_witnessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extra_key_witness"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      tx_id: bigint
    }, ExtArgs["result"]["extra_key_witness"]>
    composites: {}
  }

  type extra_key_witnessGetPayload<S extends boolean | null | undefined | extra_key_witnessDefaultArgs> = $Result.GetResult<Prisma.$extra_key_witnessPayload, S>

  type extra_key_witnessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<extra_key_witnessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Extra_key_witnessCountAggregateInputType | true
    }

  export interface extra_key_witnessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extra_key_witness'], meta: { name: 'extra_key_witness' } }
    /**
     * Find zero or one Extra_key_witness that matches the filter.
     * @param {extra_key_witnessFindUniqueArgs} args - Arguments to find a Extra_key_witness
     * @example
     * // Get one Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends extra_key_witnessFindUniqueArgs>(args: SelectSubset<T, extra_key_witnessFindUniqueArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Extra_key_witness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {extra_key_witnessFindUniqueOrThrowArgs} args - Arguments to find a Extra_key_witness
     * @example
     * // Get one Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends extra_key_witnessFindUniqueOrThrowArgs>(args: SelectSubset<T, extra_key_witnessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Extra_key_witness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessFindFirstArgs} args - Arguments to find a Extra_key_witness
     * @example
     * // Get one Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends extra_key_witnessFindFirstArgs>(args?: SelectSubset<T, extra_key_witnessFindFirstArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Extra_key_witness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessFindFirstOrThrowArgs} args - Arguments to find a Extra_key_witness
     * @example
     * // Get one Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends extra_key_witnessFindFirstOrThrowArgs>(args?: SelectSubset<T, extra_key_witnessFindFirstOrThrowArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Extra_key_witnesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extra_key_witnesses
     * const extra_key_witnesses = await prisma.extra_key_witness.findMany()
     * 
     * // Get first 10 Extra_key_witnesses
     * const extra_key_witnesses = await prisma.extra_key_witness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extra_key_witnessWithIdOnly = await prisma.extra_key_witness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends extra_key_witnessFindManyArgs>(args?: SelectSubset<T, extra_key_witnessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Extra_key_witness.
     * @param {extra_key_witnessCreateArgs} args - Arguments to create a Extra_key_witness.
     * @example
     * // Create one Extra_key_witness
     * const Extra_key_witness = await prisma.extra_key_witness.create({
     *   data: {
     *     // ... data to create a Extra_key_witness
     *   }
     * })
     * 
     */
    create<T extends extra_key_witnessCreateArgs>(args: SelectSubset<T, extra_key_witnessCreateArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Extra_key_witnesses.
     * @param {extra_key_witnessCreateManyArgs} args - Arguments to create many Extra_key_witnesses.
     * @example
     * // Create many Extra_key_witnesses
     * const extra_key_witness = await prisma.extra_key_witness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends extra_key_witnessCreateManyArgs>(args?: SelectSubset<T, extra_key_witnessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Extra_key_witnesses and returns the data saved in the database.
     * @param {extra_key_witnessCreateManyAndReturnArgs} args - Arguments to create many Extra_key_witnesses.
     * @example
     * // Create many Extra_key_witnesses
     * const extra_key_witness = await prisma.extra_key_witness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Extra_key_witnesses and only return the `id`
     * const extra_key_witnessWithIdOnly = await prisma.extra_key_witness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends extra_key_witnessCreateManyAndReturnArgs>(args?: SelectSubset<T, extra_key_witnessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Extra_key_witness.
     * @param {extra_key_witnessDeleteArgs} args - Arguments to delete one Extra_key_witness.
     * @example
     * // Delete one Extra_key_witness
     * const Extra_key_witness = await prisma.extra_key_witness.delete({
     *   where: {
     *     // ... filter to delete one Extra_key_witness
     *   }
     * })
     * 
     */
    delete<T extends extra_key_witnessDeleteArgs>(args: SelectSubset<T, extra_key_witnessDeleteArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Extra_key_witness.
     * @param {extra_key_witnessUpdateArgs} args - Arguments to update one Extra_key_witness.
     * @example
     * // Update one Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends extra_key_witnessUpdateArgs>(args: SelectSubset<T, extra_key_witnessUpdateArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Extra_key_witnesses.
     * @param {extra_key_witnessDeleteManyArgs} args - Arguments to filter Extra_key_witnesses to delete.
     * @example
     * // Delete a few Extra_key_witnesses
     * const { count } = await prisma.extra_key_witness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends extra_key_witnessDeleteManyArgs>(args?: SelectSubset<T, extra_key_witnessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extra_key_witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extra_key_witnesses
     * const extra_key_witness = await prisma.extra_key_witness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends extra_key_witnessUpdateManyArgs>(args: SelectSubset<T, extra_key_witnessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extra_key_witnesses and returns the data updated in the database.
     * @param {extra_key_witnessUpdateManyAndReturnArgs} args - Arguments to update many Extra_key_witnesses.
     * @example
     * // Update many Extra_key_witnesses
     * const extra_key_witness = await prisma.extra_key_witness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Extra_key_witnesses and only return the `id`
     * const extra_key_witnessWithIdOnly = await prisma.extra_key_witness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends extra_key_witnessUpdateManyAndReturnArgs>(args: SelectSubset<T, extra_key_witnessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Extra_key_witness.
     * @param {extra_key_witnessUpsertArgs} args - Arguments to update or create a Extra_key_witness.
     * @example
     * // Update or create a Extra_key_witness
     * const extra_key_witness = await prisma.extra_key_witness.upsert({
     *   create: {
     *     // ... data to create a Extra_key_witness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extra_key_witness we want to update
     *   }
     * })
     */
    upsert<T extends extra_key_witnessUpsertArgs>(args: SelectSubset<T, extra_key_witnessUpsertArgs<ExtArgs>>): Prisma__extra_key_witnessClient<$Result.GetResult<Prisma.$extra_key_witnessPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Extra_key_witnesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessCountArgs} args - Arguments to filter Extra_key_witnesses to count.
     * @example
     * // Count the number of Extra_key_witnesses
     * const count = await prisma.extra_key_witness.count({
     *   where: {
     *     // ... the filter for the Extra_key_witnesses we want to count
     *   }
     * })
    **/
    count<T extends extra_key_witnessCountArgs>(
      args?: Subset<T, extra_key_witnessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Extra_key_witnessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extra_key_witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Extra_key_witnessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Extra_key_witnessAggregateArgs>(args: Subset<T, Extra_key_witnessAggregateArgs>): Prisma.PrismaPromise<GetExtra_key_witnessAggregateType<T>>

    /**
     * Group by Extra_key_witness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_key_witnessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extra_key_witnessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extra_key_witnessGroupByArgs['orderBy'] }
        : { orderBy?: extra_key_witnessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extra_key_witnessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtra_key_witnessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extra_key_witness model
   */
  readonly fields: extra_key_witnessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extra_key_witness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extra_key_witnessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the extra_key_witness model
   */ 
  interface extra_key_witnessFieldRefs {
    readonly id: FieldRef<"extra_key_witness", 'BigInt'>
    readonly hash: FieldRef<"extra_key_witness", 'Bytes'>
    readonly tx_id: FieldRef<"extra_key_witness", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * extra_key_witness findUnique
   */
  export type extra_key_witnessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter, which extra_key_witness to fetch.
     */
    where: extra_key_witnessWhereUniqueInput
  }

  /**
   * extra_key_witness findUniqueOrThrow
   */
  export type extra_key_witnessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter, which extra_key_witness to fetch.
     */
    where: extra_key_witnessWhereUniqueInput
  }

  /**
   * extra_key_witness findFirst
   */
  export type extra_key_witnessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter, which extra_key_witness to fetch.
     */
    where?: extra_key_witnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_key_witnesses to fetch.
     */
    orderBy?: extra_key_witnessOrderByWithRelationInput | extra_key_witnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_key_witnesses.
     */
    cursor?: extra_key_witnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_key_witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_key_witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_key_witnesses.
     */
    distinct?: Extra_key_witnessScalarFieldEnum | Extra_key_witnessScalarFieldEnum[]
  }

  /**
   * extra_key_witness findFirstOrThrow
   */
  export type extra_key_witnessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter, which extra_key_witness to fetch.
     */
    where?: extra_key_witnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_key_witnesses to fetch.
     */
    orderBy?: extra_key_witnessOrderByWithRelationInput | extra_key_witnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_key_witnesses.
     */
    cursor?: extra_key_witnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_key_witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_key_witnesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_key_witnesses.
     */
    distinct?: Extra_key_witnessScalarFieldEnum | Extra_key_witnessScalarFieldEnum[]
  }

  /**
   * extra_key_witness findMany
   */
  export type extra_key_witnessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter, which extra_key_witnesses to fetch.
     */
    where?: extra_key_witnessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_key_witnesses to fetch.
     */
    orderBy?: extra_key_witnessOrderByWithRelationInput | extra_key_witnessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extra_key_witnesses.
     */
    cursor?: extra_key_witnessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_key_witnesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_key_witnesses.
     */
    skip?: number
    distinct?: Extra_key_witnessScalarFieldEnum | Extra_key_witnessScalarFieldEnum[]
  }

  /**
   * extra_key_witness create
   */
  export type extra_key_witnessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * The data needed to create a extra_key_witness.
     */
    data: XOR<extra_key_witnessCreateInput, extra_key_witnessUncheckedCreateInput>
  }

  /**
   * extra_key_witness createMany
   */
  export type extra_key_witnessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extra_key_witnesses.
     */
    data: extra_key_witnessCreateManyInput | extra_key_witnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extra_key_witness createManyAndReturn
   */
  export type extra_key_witnessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * The data used to create many extra_key_witnesses.
     */
    data: extra_key_witnessCreateManyInput | extra_key_witnessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extra_key_witness update
   */
  export type extra_key_witnessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * The data needed to update a extra_key_witness.
     */
    data: XOR<extra_key_witnessUpdateInput, extra_key_witnessUncheckedUpdateInput>
    /**
     * Choose, which extra_key_witness to update.
     */
    where: extra_key_witnessWhereUniqueInput
  }

  /**
   * extra_key_witness updateMany
   */
  export type extra_key_witnessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extra_key_witnesses.
     */
    data: XOR<extra_key_witnessUpdateManyMutationInput, extra_key_witnessUncheckedUpdateManyInput>
    /**
     * Filter which extra_key_witnesses to update
     */
    where?: extra_key_witnessWhereInput
    /**
     * Limit how many extra_key_witnesses to update.
     */
    limit?: number
  }

  /**
   * extra_key_witness updateManyAndReturn
   */
  export type extra_key_witnessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * The data used to update extra_key_witnesses.
     */
    data: XOR<extra_key_witnessUpdateManyMutationInput, extra_key_witnessUncheckedUpdateManyInput>
    /**
     * Filter which extra_key_witnesses to update
     */
    where?: extra_key_witnessWhereInput
    /**
     * Limit how many extra_key_witnesses to update.
     */
    limit?: number
  }

  /**
   * extra_key_witness upsert
   */
  export type extra_key_witnessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * The filter to search for the extra_key_witness to update in case it exists.
     */
    where: extra_key_witnessWhereUniqueInput
    /**
     * In case the extra_key_witness found by the `where` argument doesn't exist, create a new extra_key_witness with this data.
     */
    create: XOR<extra_key_witnessCreateInput, extra_key_witnessUncheckedCreateInput>
    /**
     * In case the extra_key_witness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extra_key_witnessUpdateInput, extra_key_witnessUncheckedUpdateInput>
  }

  /**
   * extra_key_witness delete
   */
  export type extra_key_witnessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
    /**
     * Filter which extra_key_witness to delete.
     */
    where: extra_key_witnessWhereUniqueInput
  }

  /**
   * extra_key_witness deleteMany
   */
  export type extra_key_witnessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_key_witnesses to delete
     */
    where?: extra_key_witnessWhereInput
    /**
     * Limit how many extra_key_witnesses to delete.
     */
    limit?: number
  }

  /**
   * extra_key_witness without action
   */
  export type extra_key_witnessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_key_witness
     */
    select?: extra_key_witnessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_key_witness
     */
    omit?: extra_key_witnessOmit<ExtArgs> | null
  }


  /**
   * Model extra_migrations
   */

  export type AggregateExtra_migrations = {
    _count: Extra_migrationsCountAggregateOutputType | null
    _avg: Extra_migrationsAvgAggregateOutputType | null
    _sum: Extra_migrationsSumAggregateOutputType | null
    _min: Extra_migrationsMinAggregateOutputType | null
    _max: Extra_migrationsMaxAggregateOutputType | null
  }

  export type Extra_migrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type Extra_migrationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Extra_migrationsMinAggregateOutputType = {
    id: bigint | null
    token: string | null
    description: string | null
  }

  export type Extra_migrationsMaxAggregateOutputType = {
    id: bigint | null
    token: string | null
    description: string | null
  }

  export type Extra_migrationsCountAggregateOutputType = {
    id: number
    token: number
    description: number
    _all: number
  }


  export type Extra_migrationsAvgAggregateInputType = {
    id?: true
  }

  export type Extra_migrationsSumAggregateInputType = {
    id?: true
  }

  export type Extra_migrationsMinAggregateInputType = {
    id?: true
    token?: true
    description?: true
  }

  export type Extra_migrationsMaxAggregateInputType = {
    id?: true
    token?: true
    description?: true
  }

  export type Extra_migrationsCountAggregateInputType = {
    id?: true
    token?: true
    description?: true
    _all?: true
  }

  export type Extra_migrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_migrations to aggregate.
     */
    where?: extra_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_migrations to fetch.
     */
    orderBy?: extra_migrationsOrderByWithRelationInput | extra_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: extra_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned extra_migrations
    **/
    _count?: true | Extra_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Extra_migrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Extra_migrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Extra_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Extra_migrationsMaxAggregateInputType
  }

  export type GetExtra_migrationsAggregateType<T extends Extra_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateExtra_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtra_migrations[P]>
      : GetScalarType<T[P], AggregateExtra_migrations[P]>
  }




  export type extra_migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: extra_migrationsWhereInput
    orderBy?: extra_migrationsOrderByWithAggregationInput | extra_migrationsOrderByWithAggregationInput[]
    by: Extra_migrationsScalarFieldEnum[] | Extra_migrationsScalarFieldEnum
    having?: extra_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Extra_migrationsCountAggregateInputType | true
    _avg?: Extra_migrationsAvgAggregateInputType
    _sum?: Extra_migrationsSumAggregateInputType
    _min?: Extra_migrationsMinAggregateInputType
    _max?: Extra_migrationsMaxAggregateInputType
  }

  export type Extra_migrationsGroupByOutputType = {
    id: bigint
    token: string
    description: string | null
    _count: Extra_migrationsCountAggregateOutputType | null
    _avg: Extra_migrationsAvgAggregateOutputType | null
    _sum: Extra_migrationsSumAggregateOutputType | null
    _min: Extra_migrationsMinAggregateOutputType | null
    _max: Extra_migrationsMaxAggregateOutputType | null
  }

  type GetExtra_migrationsGroupByPayload<T extends extra_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Extra_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Extra_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Extra_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Extra_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type extra_migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    description?: boolean
  }, ExtArgs["result"]["extra_migrations"]>

  export type extra_migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    description?: boolean
  }, ExtArgs["result"]["extra_migrations"]>

  export type extra_migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    description?: boolean
  }, ExtArgs["result"]["extra_migrations"]>

  export type extra_migrationsSelectScalar = {
    id?: boolean
    token?: boolean
    description?: boolean
  }

  export type extra_migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "description", ExtArgs["result"]["extra_migrations"]>

  export type $extra_migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "extra_migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      token: string
      description: string | null
    }, ExtArgs["result"]["extra_migrations"]>
    composites: {}
  }

  type extra_migrationsGetPayload<S extends boolean | null | undefined | extra_migrationsDefaultArgs> = $Result.GetResult<Prisma.$extra_migrationsPayload, S>

  type extra_migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<extra_migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Extra_migrationsCountAggregateInputType | true
    }

  export interface extra_migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['extra_migrations'], meta: { name: 'extra_migrations' } }
    /**
     * Find zero or one Extra_migrations that matches the filter.
     * @param {extra_migrationsFindUniqueArgs} args - Arguments to find a Extra_migrations
     * @example
     * // Get one Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends extra_migrationsFindUniqueArgs>(args: SelectSubset<T, extra_migrationsFindUniqueArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Extra_migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {extra_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Extra_migrations
     * @example
     * // Get one Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends extra_migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, extra_migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Extra_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsFindFirstArgs} args - Arguments to find a Extra_migrations
     * @example
     * // Get one Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends extra_migrationsFindFirstArgs>(args?: SelectSubset<T, extra_migrationsFindFirstArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Extra_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsFindFirstOrThrowArgs} args - Arguments to find a Extra_migrations
     * @example
     * // Get one Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends extra_migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, extra_migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Extra_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findMany()
     * 
     * // Get first 10 Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extra_migrationsWithIdOnly = await prisma.extra_migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends extra_migrationsFindManyArgs>(args?: SelectSubset<T, extra_migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Extra_migrations.
     * @param {extra_migrationsCreateArgs} args - Arguments to create a Extra_migrations.
     * @example
     * // Create one Extra_migrations
     * const Extra_migrations = await prisma.extra_migrations.create({
     *   data: {
     *     // ... data to create a Extra_migrations
     *   }
     * })
     * 
     */
    create<T extends extra_migrationsCreateArgs>(args: SelectSubset<T, extra_migrationsCreateArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Extra_migrations.
     * @param {extra_migrationsCreateManyArgs} args - Arguments to create many Extra_migrations.
     * @example
     * // Create many Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends extra_migrationsCreateManyArgs>(args?: SelectSubset<T, extra_migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Extra_migrations and returns the data saved in the database.
     * @param {extra_migrationsCreateManyAndReturnArgs} args - Arguments to create many Extra_migrations.
     * @example
     * // Create many Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Extra_migrations and only return the `id`
     * const extra_migrationsWithIdOnly = await prisma.extra_migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends extra_migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, extra_migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Extra_migrations.
     * @param {extra_migrationsDeleteArgs} args - Arguments to delete one Extra_migrations.
     * @example
     * // Delete one Extra_migrations
     * const Extra_migrations = await prisma.extra_migrations.delete({
     *   where: {
     *     // ... filter to delete one Extra_migrations
     *   }
     * })
     * 
     */
    delete<T extends extra_migrationsDeleteArgs>(args: SelectSubset<T, extra_migrationsDeleteArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Extra_migrations.
     * @param {extra_migrationsUpdateArgs} args - Arguments to update one Extra_migrations.
     * @example
     * // Update one Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends extra_migrationsUpdateArgs>(args: SelectSubset<T, extra_migrationsUpdateArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Extra_migrations.
     * @param {extra_migrationsDeleteManyArgs} args - Arguments to filter Extra_migrations to delete.
     * @example
     * // Delete a few Extra_migrations
     * const { count } = await prisma.extra_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends extra_migrationsDeleteManyArgs>(args?: SelectSubset<T, extra_migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extra_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends extra_migrationsUpdateManyArgs>(args: SelectSubset<T, extra_migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Extra_migrations and returns the data updated in the database.
     * @param {extra_migrationsUpdateManyAndReturnArgs} args - Arguments to update many Extra_migrations.
     * @example
     * // Update many Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Extra_migrations and only return the `id`
     * const extra_migrationsWithIdOnly = await prisma.extra_migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends extra_migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, extra_migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Extra_migrations.
     * @param {extra_migrationsUpsertArgs} args - Arguments to update or create a Extra_migrations.
     * @example
     * // Update or create a Extra_migrations
     * const extra_migrations = await prisma.extra_migrations.upsert({
     *   create: {
     *     // ... data to create a Extra_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Extra_migrations we want to update
     *   }
     * })
     */
    upsert<T extends extra_migrationsUpsertArgs>(args: SelectSubset<T, extra_migrationsUpsertArgs<ExtArgs>>): Prisma__extra_migrationsClient<$Result.GetResult<Prisma.$extra_migrationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Extra_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsCountArgs} args - Arguments to filter Extra_migrations to count.
     * @example
     * // Count the number of Extra_migrations
     * const count = await prisma.extra_migrations.count({
     *   where: {
     *     // ... the filter for the Extra_migrations we want to count
     *   }
     * })
    **/
    count<T extends extra_migrationsCountArgs>(
      args?: Subset<T, extra_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Extra_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Extra_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Extra_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Extra_migrationsAggregateArgs>(args: Subset<T, Extra_migrationsAggregateArgs>): Prisma.PrismaPromise<GetExtra_migrationsAggregateType<T>>

    /**
     * Group by Extra_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {extra_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends extra_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: extra_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: extra_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, extra_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtra_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the extra_migrations model
   */
  readonly fields: extra_migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for extra_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__extra_migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the extra_migrations model
   */ 
  interface extra_migrationsFieldRefs {
    readonly id: FieldRef<"extra_migrations", 'BigInt'>
    readonly token: FieldRef<"extra_migrations", 'String'>
    readonly description: FieldRef<"extra_migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * extra_migrations findUnique
   */
  export type extra_migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which extra_migrations to fetch.
     */
    where: extra_migrationsWhereUniqueInput
  }

  /**
   * extra_migrations findUniqueOrThrow
   */
  export type extra_migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which extra_migrations to fetch.
     */
    where: extra_migrationsWhereUniqueInput
  }

  /**
   * extra_migrations findFirst
   */
  export type extra_migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which extra_migrations to fetch.
     */
    where?: extra_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_migrations to fetch.
     */
    orderBy?: extra_migrationsOrderByWithRelationInput | extra_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_migrations.
     */
    cursor?: extra_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_migrations.
     */
    distinct?: Extra_migrationsScalarFieldEnum | Extra_migrationsScalarFieldEnum[]
  }

  /**
   * extra_migrations findFirstOrThrow
   */
  export type extra_migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which extra_migrations to fetch.
     */
    where?: extra_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_migrations to fetch.
     */
    orderBy?: extra_migrationsOrderByWithRelationInput | extra_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for extra_migrations.
     */
    cursor?: extra_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of extra_migrations.
     */
    distinct?: Extra_migrationsScalarFieldEnum | Extra_migrationsScalarFieldEnum[]
  }

  /**
   * extra_migrations findMany
   */
  export type extra_migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which extra_migrations to fetch.
     */
    where?: extra_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of extra_migrations to fetch.
     */
    orderBy?: extra_migrationsOrderByWithRelationInput | extra_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing extra_migrations.
     */
    cursor?: extra_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` extra_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` extra_migrations.
     */
    skip?: number
    distinct?: Extra_migrationsScalarFieldEnum | Extra_migrationsScalarFieldEnum[]
  }

  /**
   * extra_migrations create
   */
  export type extra_migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a extra_migrations.
     */
    data: XOR<extra_migrationsCreateInput, extra_migrationsUncheckedCreateInput>
  }

  /**
   * extra_migrations createMany
   */
  export type extra_migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many extra_migrations.
     */
    data: extra_migrationsCreateManyInput | extra_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extra_migrations createManyAndReturn
   */
  export type extra_migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many extra_migrations.
     */
    data: extra_migrationsCreateManyInput | extra_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * extra_migrations update
   */
  export type extra_migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a extra_migrations.
     */
    data: XOR<extra_migrationsUpdateInput, extra_migrationsUncheckedUpdateInput>
    /**
     * Choose, which extra_migrations to update.
     */
    where: extra_migrationsWhereUniqueInput
  }

  /**
   * extra_migrations updateMany
   */
  export type extra_migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update extra_migrations.
     */
    data: XOR<extra_migrationsUpdateManyMutationInput, extra_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which extra_migrations to update
     */
    where?: extra_migrationsWhereInput
    /**
     * Limit how many extra_migrations to update.
     */
    limit?: number
  }

  /**
   * extra_migrations updateManyAndReturn
   */
  export type extra_migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * The data used to update extra_migrations.
     */
    data: XOR<extra_migrationsUpdateManyMutationInput, extra_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which extra_migrations to update
     */
    where?: extra_migrationsWhereInput
    /**
     * Limit how many extra_migrations to update.
     */
    limit?: number
  }

  /**
   * extra_migrations upsert
   */
  export type extra_migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the extra_migrations to update in case it exists.
     */
    where: extra_migrationsWhereUniqueInput
    /**
     * In case the extra_migrations found by the `where` argument doesn't exist, create a new extra_migrations with this data.
     */
    create: XOR<extra_migrationsCreateInput, extra_migrationsUncheckedCreateInput>
    /**
     * In case the extra_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<extra_migrationsUpdateInput, extra_migrationsUncheckedUpdateInput>
  }

  /**
   * extra_migrations delete
   */
  export type extra_migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
    /**
     * Filter which extra_migrations to delete.
     */
    where: extra_migrationsWhereUniqueInput
  }

  /**
   * extra_migrations deleteMany
   */
  export type extra_migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which extra_migrations to delete
     */
    where?: extra_migrationsWhereInput
    /**
     * Limit how many extra_migrations to delete.
     */
    limit?: number
  }

  /**
   * extra_migrations without action
   */
  export type extra_migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the extra_migrations
     */
    select?: extra_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the extra_migrations
     */
    omit?: extra_migrationsOmit<ExtArgs> | null
  }


  /**
   * Model gov_action_proposal
   */

  export type AggregateGov_action_proposal = {
    _count: Gov_action_proposalCountAggregateOutputType | null
    _avg: Gov_action_proposalAvgAggregateOutputType | null
    _sum: Gov_action_proposalSumAggregateOutputType | null
    _min: Gov_action_proposalMinAggregateOutputType | null
    _max: Gov_action_proposalMaxAggregateOutputType | null
  }

  export type Gov_action_proposalAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    index: number | null
    prev_gov_action_proposal: number | null
    deposit: Decimal | null
    return_address: number | null
    expiration: number | null
    voting_anchor_id: number | null
    param_proposal: number | null
    ratified_epoch: number | null
    enacted_epoch: number | null
    dropped_epoch: number | null
    expired_epoch: number | null
  }

  export type Gov_action_proposalSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: bigint | null
    prev_gov_action_proposal: bigint | null
    deposit: Decimal | null
    return_address: bigint | null
    expiration: number | null
    voting_anchor_id: bigint | null
    param_proposal: bigint | null
    ratified_epoch: number | null
    enacted_epoch: number | null
    dropped_epoch: number | null
    expired_epoch: number | null
  }

  export type Gov_action_proposalMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: bigint | null
    prev_gov_action_proposal: bigint | null
    deposit: Decimal | null
    return_address: bigint | null
    expiration: number | null
    voting_anchor_id: bigint | null
    type: $Enums.govactiontype | null
    param_proposal: bigint | null
    ratified_epoch: number | null
    enacted_epoch: number | null
    dropped_epoch: number | null
    expired_epoch: number | null
  }

  export type Gov_action_proposalMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: bigint | null
    prev_gov_action_proposal: bigint | null
    deposit: Decimal | null
    return_address: bigint | null
    expiration: number | null
    voting_anchor_id: bigint | null
    type: $Enums.govactiontype | null
    param_proposal: bigint | null
    ratified_epoch: number | null
    enacted_epoch: number | null
    dropped_epoch: number | null
    expired_epoch: number | null
  }

  export type Gov_action_proposalCountAggregateOutputType = {
    id: number
    tx_id: number
    index: number
    prev_gov_action_proposal: number
    deposit: number
    return_address: number
    expiration: number
    voting_anchor_id: number
    type: number
    description: number
    param_proposal: number
    ratified_epoch: number
    enacted_epoch: number
    dropped_epoch: number
    expired_epoch: number
    _all: number
  }


  export type Gov_action_proposalAvgAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    prev_gov_action_proposal?: true
    deposit?: true
    return_address?: true
    expiration?: true
    voting_anchor_id?: true
    param_proposal?: true
    ratified_epoch?: true
    enacted_epoch?: true
    dropped_epoch?: true
    expired_epoch?: true
  }

  export type Gov_action_proposalSumAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    prev_gov_action_proposal?: true
    deposit?: true
    return_address?: true
    expiration?: true
    voting_anchor_id?: true
    param_proposal?: true
    ratified_epoch?: true
    enacted_epoch?: true
    dropped_epoch?: true
    expired_epoch?: true
  }

  export type Gov_action_proposalMinAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    prev_gov_action_proposal?: true
    deposit?: true
    return_address?: true
    expiration?: true
    voting_anchor_id?: true
    type?: true
    param_proposal?: true
    ratified_epoch?: true
    enacted_epoch?: true
    dropped_epoch?: true
    expired_epoch?: true
  }

  export type Gov_action_proposalMaxAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    prev_gov_action_proposal?: true
    deposit?: true
    return_address?: true
    expiration?: true
    voting_anchor_id?: true
    type?: true
    param_proposal?: true
    ratified_epoch?: true
    enacted_epoch?: true
    dropped_epoch?: true
    expired_epoch?: true
  }

  export type Gov_action_proposalCountAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    prev_gov_action_proposal?: true
    deposit?: true
    return_address?: true
    expiration?: true
    voting_anchor_id?: true
    type?: true
    description?: true
    param_proposal?: true
    ratified_epoch?: true
    enacted_epoch?: true
    dropped_epoch?: true
    expired_epoch?: true
    _all?: true
  }

  export type Gov_action_proposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gov_action_proposal to aggregate.
     */
    where?: gov_action_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gov_action_proposals to fetch.
     */
    orderBy?: gov_action_proposalOrderByWithRelationInput | gov_action_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gov_action_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gov_action_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gov_action_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gov_action_proposals
    **/
    _count?: true | Gov_action_proposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Gov_action_proposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Gov_action_proposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Gov_action_proposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Gov_action_proposalMaxAggregateInputType
  }

  export type GetGov_action_proposalAggregateType<T extends Gov_action_proposalAggregateArgs> = {
        [P in keyof T & keyof AggregateGov_action_proposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGov_action_proposal[P]>
      : GetScalarType<T[P], AggregateGov_action_proposal[P]>
  }




  export type gov_action_proposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gov_action_proposalWhereInput
    orderBy?: gov_action_proposalOrderByWithAggregationInput | gov_action_proposalOrderByWithAggregationInput[]
    by: Gov_action_proposalScalarFieldEnum[] | Gov_action_proposalScalarFieldEnum
    having?: gov_action_proposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Gov_action_proposalCountAggregateInputType | true
    _avg?: Gov_action_proposalAvgAggregateInputType
    _sum?: Gov_action_proposalSumAggregateInputType
    _min?: Gov_action_proposalMinAggregateInputType
    _max?: Gov_action_proposalMaxAggregateInputType
  }

  export type Gov_action_proposalGroupByOutputType = {
    id: bigint
    tx_id: bigint
    index: bigint
    prev_gov_action_proposal: bigint | null
    deposit: Decimal
    return_address: bigint
    expiration: number | null
    voting_anchor_id: bigint | null
    type: $Enums.govactiontype
    description: JsonValue
    param_proposal: bigint | null
    ratified_epoch: number | null
    enacted_epoch: number | null
    dropped_epoch: number | null
    expired_epoch: number | null
    _count: Gov_action_proposalCountAggregateOutputType | null
    _avg: Gov_action_proposalAvgAggregateOutputType | null
    _sum: Gov_action_proposalSumAggregateOutputType | null
    _min: Gov_action_proposalMinAggregateOutputType | null
    _max: Gov_action_proposalMaxAggregateOutputType | null
  }

  type GetGov_action_proposalGroupByPayload<T extends gov_action_proposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Gov_action_proposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Gov_action_proposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Gov_action_proposalGroupByOutputType[P]>
            : GetScalarType<T[P], Gov_action_proposalGroupByOutputType[P]>
        }
      >
    >


  export type gov_action_proposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    prev_gov_action_proposal?: boolean
    deposit?: boolean
    return_address?: boolean
    expiration?: boolean
    voting_anchor_id?: boolean
    type?: boolean
    description?: boolean
    param_proposal?: boolean
    ratified_epoch?: boolean
    enacted_epoch?: boolean
    dropped_epoch?: boolean
    expired_epoch?: boolean
  }, ExtArgs["result"]["gov_action_proposal"]>

  export type gov_action_proposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    prev_gov_action_proposal?: boolean
    deposit?: boolean
    return_address?: boolean
    expiration?: boolean
    voting_anchor_id?: boolean
    type?: boolean
    description?: boolean
    param_proposal?: boolean
    ratified_epoch?: boolean
    enacted_epoch?: boolean
    dropped_epoch?: boolean
    expired_epoch?: boolean
  }, ExtArgs["result"]["gov_action_proposal"]>

  export type gov_action_proposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    prev_gov_action_proposal?: boolean
    deposit?: boolean
    return_address?: boolean
    expiration?: boolean
    voting_anchor_id?: boolean
    type?: boolean
    description?: boolean
    param_proposal?: boolean
    ratified_epoch?: boolean
    enacted_epoch?: boolean
    dropped_epoch?: boolean
    expired_epoch?: boolean
  }, ExtArgs["result"]["gov_action_proposal"]>

  export type gov_action_proposalSelectScalar = {
    id?: boolean
    tx_id?: boolean
    index?: boolean
    prev_gov_action_proposal?: boolean
    deposit?: boolean
    return_address?: boolean
    expiration?: boolean
    voting_anchor_id?: boolean
    type?: boolean
    description?: boolean
    param_proposal?: boolean
    ratified_epoch?: boolean
    enacted_epoch?: boolean
    dropped_epoch?: boolean
    expired_epoch?: boolean
  }

  export type gov_action_proposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "index" | "prev_gov_action_proposal" | "deposit" | "return_address" | "expiration" | "voting_anchor_id" | "type" | "description" | "param_proposal" | "ratified_epoch" | "enacted_epoch" | "dropped_epoch" | "expired_epoch", ExtArgs["result"]["gov_action_proposal"]>

  export type $gov_action_proposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gov_action_proposal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      index: bigint
      prev_gov_action_proposal: bigint | null
      deposit: Prisma.Decimal
      return_address: bigint
      expiration: number | null
      voting_anchor_id: bigint | null
      type: $Enums.govactiontype
      description: Prisma.JsonValue
      param_proposal: bigint | null
      ratified_epoch: number | null
      enacted_epoch: number | null
      dropped_epoch: number | null
      expired_epoch: number | null
    }, ExtArgs["result"]["gov_action_proposal"]>
    composites: {}
  }

  type gov_action_proposalGetPayload<S extends boolean | null | undefined | gov_action_proposalDefaultArgs> = $Result.GetResult<Prisma.$gov_action_proposalPayload, S>

  type gov_action_proposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gov_action_proposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Gov_action_proposalCountAggregateInputType | true
    }

  export interface gov_action_proposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gov_action_proposal'], meta: { name: 'gov_action_proposal' } }
    /**
     * Find zero or one Gov_action_proposal that matches the filter.
     * @param {gov_action_proposalFindUniqueArgs} args - Arguments to find a Gov_action_proposal
     * @example
     * // Get one Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gov_action_proposalFindUniqueArgs>(args: SelectSubset<T, gov_action_proposalFindUniqueArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Gov_action_proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gov_action_proposalFindUniqueOrThrowArgs} args - Arguments to find a Gov_action_proposal
     * @example
     * // Get one Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gov_action_proposalFindUniqueOrThrowArgs>(args: SelectSubset<T, gov_action_proposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Gov_action_proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalFindFirstArgs} args - Arguments to find a Gov_action_proposal
     * @example
     * // Get one Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gov_action_proposalFindFirstArgs>(args?: SelectSubset<T, gov_action_proposalFindFirstArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Gov_action_proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalFindFirstOrThrowArgs} args - Arguments to find a Gov_action_proposal
     * @example
     * // Get one Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gov_action_proposalFindFirstOrThrowArgs>(args?: SelectSubset<T, gov_action_proposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Gov_action_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gov_action_proposals
     * const gov_action_proposals = await prisma.gov_action_proposal.findMany()
     * 
     * // Get first 10 Gov_action_proposals
     * const gov_action_proposals = await prisma.gov_action_proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gov_action_proposalWithIdOnly = await prisma.gov_action_proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gov_action_proposalFindManyArgs>(args?: SelectSubset<T, gov_action_proposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Gov_action_proposal.
     * @param {gov_action_proposalCreateArgs} args - Arguments to create a Gov_action_proposal.
     * @example
     * // Create one Gov_action_proposal
     * const Gov_action_proposal = await prisma.gov_action_proposal.create({
     *   data: {
     *     // ... data to create a Gov_action_proposal
     *   }
     * })
     * 
     */
    create<T extends gov_action_proposalCreateArgs>(args: SelectSubset<T, gov_action_proposalCreateArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Gov_action_proposals.
     * @param {gov_action_proposalCreateManyArgs} args - Arguments to create many Gov_action_proposals.
     * @example
     * // Create many Gov_action_proposals
     * const gov_action_proposal = await prisma.gov_action_proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gov_action_proposalCreateManyArgs>(args?: SelectSubset<T, gov_action_proposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gov_action_proposals and returns the data saved in the database.
     * @param {gov_action_proposalCreateManyAndReturnArgs} args - Arguments to create many Gov_action_proposals.
     * @example
     * // Create many Gov_action_proposals
     * const gov_action_proposal = await prisma.gov_action_proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gov_action_proposals and only return the `id`
     * const gov_action_proposalWithIdOnly = await prisma.gov_action_proposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gov_action_proposalCreateManyAndReturnArgs>(args?: SelectSubset<T, gov_action_proposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Gov_action_proposal.
     * @param {gov_action_proposalDeleteArgs} args - Arguments to delete one Gov_action_proposal.
     * @example
     * // Delete one Gov_action_proposal
     * const Gov_action_proposal = await prisma.gov_action_proposal.delete({
     *   where: {
     *     // ... filter to delete one Gov_action_proposal
     *   }
     * })
     * 
     */
    delete<T extends gov_action_proposalDeleteArgs>(args: SelectSubset<T, gov_action_proposalDeleteArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Gov_action_proposal.
     * @param {gov_action_proposalUpdateArgs} args - Arguments to update one Gov_action_proposal.
     * @example
     * // Update one Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gov_action_proposalUpdateArgs>(args: SelectSubset<T, gov_action_proposalUpdateArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Gov_action_proposals.
     * @param {gov_action_proposalDeleteManyArgs} args - Arguments to filter Gov_action_proposals to delete.
     * @example
     * // Delete a few Gov_action_proposals
     * const { count } = await prisma.gov_action_proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gov_action_proposalDeleteManyArgs>(args?: SelectSubset<T, gov_action_proposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gov_action_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gov_action_proposals
     * const gov_action_proposal = await prisma.gov_action_proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gov_action_proposalUpdateManyArgs>(args: SelectSubset<T, gov_action_proposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gov_action_proposals and returns the data updated in the database.
     * @param {gov_action_proposalUpdateManyAndReturnArgs} args - Arguments to update many Gov_action_proposals.
     * @example
     * // Update many Gov_action_proposals
     * const gov_action_proposal = await prisma.gov_action_proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gov_action_proposals and only return the `id`
     * const gov_action_proposalWithIdOnly = await prisma.gov_action_proposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gov_action_proposalUpdateManyAndReturnArgs>(args: SelectSubset<T, gov_action_proposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Gov_action_proposal.
     * @param {gov_action_proposalUpsertArgs} args - Arguments to update or create a Gov_action_proposal.
     * @example
     * // Update or create a Gov_action_proposal
     * const gov_action_proposal = await prisma.gov_action_proposal.upsert({
     *   create: {
     *     // ... data to create a Gov_action_proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gov_action_proposal we want to update
     *   }
     * })
     */
    upsert<T extends gov_action_proposalUpsertArgs>(args: SelectSubset<T, gov_action_proposalUpsertArgs<ExtArgs>>): Prisma__gov_action_proposalClient<$Result.GetResult<Prisma.$gov_action_proposalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Gov_action_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalCountArgs} args - Arguments to filter Gov_action_proposals to count.
     * @example
     * // Count the number of Gov_action_proposals
     * const count = await prisma.gov_action_proposal.count({
     *   where: {
     *     // ... the filter for the Gov_action_proposals we want to count
     *   }
     * })
    **/
    count<T extends gov_action_proposalCountArgs>(
      args?: Subset<T, gov_action_proposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Gov_action_proposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gov_action_proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Gov_action_proposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Gov_action_proposalAggregateArgs>(args: Subset<T, Gov_action_proposalAggregateArgs>): Prisma.PrismaPromise<GetGov_action_proposalAggregateType<T>>

    /**
     * Group by Gov_action_proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gov_action_proposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gov_action_proposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gov_action_proposalGroupByArgs['orderBy'] }
        : { orderBy?: gov_action_proposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gov_action_proposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGov_action_proposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gov_action_proposal model
   */
  readonly fields: gov_action_proposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gov_action_proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gov_action_proposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gov_action_proposal model
   */ 
  interface gov_action_proposalFieldRefs {
    readonly id: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly tx_id: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly index: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly prev_gov_action_proposal: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly deposit: FieldRef<"gov_action_proposal", 'Decimal'>
    readonly return_address: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly expiration: FieldRef<"gov_action_proposal", 'Int'>
    readonly voting_anchor_id: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly type: FieldRef<"gov_action_proposal", 'govactiontype'>
    readonly description: FieldRef<"gov_action_proposal", 'Json'>
    readonly param_proposal: FieldRef<"gov_action_proposal", 'BigInt'>
    readonly ratified_epoch: FieldRef<"gov_action_proposal", 'Int'>
    readonly enacted_epoch: FieldRef<"gov_action_proposal", 'Int'>
    readonly dropped_epoch: FieldRef<"gov_action_proposal", 'Int'>
    readonly expired_epoch: FieldRef<"gov_action_proposal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * gov_action_proposal findUnique
   */
  export type gov_action_proposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter, which gov_action_proposal to fetch.
     */
    where: gov_action_proposalWhereUniqueInput
  }

  /**
   * gov_action_proposal findUniqueOrThrow
   */
  export type gov_action_proposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter, which gov_action_proposal to fetch.
     */
    where: gov_action_proposalWhereUniqueInput
  }

  /**
   * gov_action_proposal findFirst
   */
  export type gov_action_proposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter, which gov_action_proposal to fetch.
     */
    where?: gov_action_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gov_action_proposals to fetch.
     */
    orderBy?: gov_action_proposalOrderByWithRelationInput | gov_action_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gov_action_proposals.
     */
    cursor?: gov_action_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gov_action_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gov_action_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gov_action_proposals.
     */
    distinct?: Gov_action_proposalScalarFieldEnum | Gov_action_proposalScalarFieldEnum[]
  }

  /**
   * gov_action_proposal findFirstOrThrow
   */
  export type gov_action_proposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter, which gov_action_proposal to fetch.
     */
    where?: gov_action_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gov_action_proposals to fetch.
     */
    orderBy?: gov_action_proposalOrderByWithRelationInput | gov_action_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gov_action_proposals.
     */
    cursor?: gov_action_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gov_action_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gov_action_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gov_action_proposals.
     */
    distinct?: Gov_action_proposalScalarFieldEnum | Gov_action_proposalScalarFieldEnum[]
  }

  /**
   * gov_action_proposal findMany
   */
  export type gov_action_proposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter, which gov_action_proposals to fetch.
     */
    where?: gov_action_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gov_action_proposals to fetch.
     */
    orderBy?: gov_action_proposalOrderByWithRelationInput | gov_action_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gov_action_proposals.
     */
    cursor?: gov_action_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gov_action_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gov_action_proposals.
     */
    skip?: number
    distinct?: Gov_action_proposalScalarFieldEnum | Gov_action_proposalScalarFieldEnum[]
  }

  /**
   * gov_action_proposal create
   */
  export type gov_action_proposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * The data needed to create a gov_action_proposal.
     */
    data: XOR<gov_action_proposalCreateInput, gov_action_proposalUncheckedCreateInput>
  }

  /**
   * gov_action_proposal createMany
   */
  export type gov_action_proposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gov_action_proposals.
     */
    data: gov_action_proposalCreateManyInput | gov_action_proposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gov_action_proposal createManyAndReturn
   */
  export type gov_action_proposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * The data used to create many gov_action_proposals.
     */
    data: gov_action_proposalCreateManyInput | gov_action_proposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gov_action_proposal update
   */
  export type gov_action_proposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * The data needed to update a gov_action_proposal.
     */
    data: XOR<gov_action_proposalUpdateInput, gov_action_proposalUncheckedUpdateInput>
    /**
     * Choose, which gov_action_proposal to update.
     */
    where: gov_action_proposalWhereUniqueInput
  }

  /**
   * gov_action_proposal updateMany
   */
  export type gov_action_proposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gov_action_proposals.
     */
    data: XOR<gov_action_proposalUpdateManyMutationInput, gov_action_proposalUncheckedUpdateManyInput>
    /**
     * Filter which gov_action_proposals to update
     */
    where?: gov_action_proposalWhereInput
    /**
     * Limit how many gov_action_proposals to update.
     */
    limit?: number
  }

  /**
   * gov_action_proposal updateManyAndReturn
   */
  export type gov_action_proposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * The data used to update gov_action_proposals.
     */
    data: XOR<gov_action_proposalUpdateManyMutationInput, gov_action_proposalUncheckedUpdateManyInput>
    /**
     * Filter which gov_action_proposals to update
     */
    where?: gov_action_proposalWhereInput
    /**
     * Limit how many gov_action_proposals to update.
     */
    limit?: number
  }

  /**
   * gov_action_proposal upsert
   */
  export type gov_action_proposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * The filter to search for the gov_action_proposal to update in case it exists.
     */
    where: gov_action_proposalWhereUniqueInput
    /**
     * In case the gov_action_proposal found by the `where` argument doesn't exist, create a new gov_action_proposal with this data.
     */
    create: XOR<gov_action_proposalCreateInput, gov_action_proposalUncheckedCreateInput>
    /**
     * In case the gov_action_proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gov_action_proposalUpdateInput, gov_action_proposalUncheckedUpdateInput>
  }

  /**
   * gov_action_proposal delete
   */
  export type gov_action_proposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
    /**
     * Filter which gov_action_proposal to delete.
     */
    where: gov_action_proposalWhereUniqueInput
  }

  /**
   * gov_action_proposal deleteMany
   */
  export type gov_action_proposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gov_action_proposals to delete
     */
    where?: gov_action_proposalWhereInput
    /**
     * Limit how many gov_action_proposals to delete.
     */
    limit?: number
  }

  /**
   * gov_action_proposal without action
   */
  export type gov_action_proposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gov_action_proposal
     */
    select?: gov_action_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gov_action_proposal
     */
    omit?: gov_action_proposalOmit<ExtArgs> | null
  }


  /**
   * Model ma_tx_mint
   */

  export type AggregateMa_tx_mint = {
    _count: Ma_tx_mintCountAggregateOutputType | null
    _avg: Ma_tx_mintAvgAggregateOutputType | null
    _sum: Ma_tx_mintSumAggregateOutputType | null
    _min: Ma_tx_mintMinAggregateOutputType | null
    _max: Ma_tx_mintMaxAggregateOutputType | null
  }

  export type Ma_tx_mintAvgAggregateOutputType = {
    id: number | null
    quantity: Decimal | null
    tx_id: number | null
    ident: number | null
  }

  export type Ma_tx_mintSumAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_mintMinAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_mintMaxAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_mintCountAggregateOutputType = {
    id: number
    quantity: number
    tx_id: number
    ident: number
    _all: number
  }


  export type Ma_tx_mintAvgAggregateInputType = {
    id?: true
    quantity?: true
    tx_id?: true
    ident?: true
  }

  export type Ma_tx_mintSumAggregateInputType = {
    id?: true
    quantity?: true
    tx_id?: true
    ident?: true
  }

  export type Ma_tx_mintMinAggregateInputType = {
    id?: true
    quantity?: true
    tx_id?: true
    ident?: true
  }

  export type Ma_tx_mintMaxAggregateInputType = {
    id?: true
    quantity?: true
    tx_id?: true
    ident?: true
  }

  export type Ma_tx_mintCountAggregateInputType = {
    id?: true
    quantity?: true
    tx_id?: true
    ident?: true
    _all?: true
  }

  export type Ma_tx_mintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ma_tx_mint to aggregate.
     */
    where?: ma_tx_mintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_mints to fetch.
     */
    orderBy?: ma_tx_mintOrderByWithRelationInput | ma_tx_mintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ma_tx_mintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_mints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_mints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ma_tx_mints
    **/
    _count?: true | Ma_tx_mintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ma_tx_mintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ma_tx_mintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ma_tx_mintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ma_tx_mintMaxAggregateInputType
  }

  export type GetMa_tx_mintAggregateType<T extends Ma_tx_mintAggregateArgs> = {
        [P in keyof T & keyof AggregateMa_tx_mint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMa_tx_mint[P]>
      : GetScalarType<T[P], AggregateMa_tx_mint[P]>
  }




  export type ma_tx_mintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ma_tx_mintWhereInput
    orderBy?: ma_tx_mintOrderByWithAggregationInput | ma_tx_mintOrderByWithAggregationInput[]
    by: Ma_tx_mintScalarFieldEnum[] | Ma_tx_mintScalarFieldEnum
    having?: ma_tx_mintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ma_tx_mintCountAggregateInputType | true
    _avg?: Ma_tx_mintAvgAggregateInputType
    _sum?: Ma_tx_mintSumAggregateInputType
    _min?: Ma_tx_mintMinAggregateInputType
    _max?: Ma_tx_mintMaxAggregateInputType
  }

  export type Ma_tx_mintGroupByOutputType = {
    id: bigint
    quantity: Decimal
    tx_id: bigint
    ident: bigint
    _count: Ma_tx_mintCountAggregateOutputType | null
    _avg: Ma_tx_mintAvgAggregateOutputType | null
    _sum: Ma_tx_mintSumAggregateOutputType | null
    _min: Ma_tx_mintMinAggregateOutputType | null
    _max: Ma_tx_mintMaxAggregateOutputType | null
  }

  type GetMa_tx_mintGroupByPayload<T extends ma_tx_mintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ma_tx_mintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ma_tx_mintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ma_tx_mintGroupByOutputType[P]>
            : GetScalarType<T[P], Ma_tx_mintGroupByOutputType[P]>
        }
      >
    >


  export type ma_tx_mintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_mint"]>

  export type ma_tx_mintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_mint"]>

  export type ma_tx_mintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_mint"]>

  export type ma_tx_mintSelectScalar = {
    id?: boolean
    quantity?: boolean
    tx_id?: boolean
    ident?: boolean
  }

  export type ma_tx_mintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "tx_id" | "ident", ExtArgs["result"]["ma_tx_mint"]>

  export type $ma_tx_mintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ma_tx_mint"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      quantity: Prisma.Decimal
      tx_id: bigint
      ident: bigint
    }, ExtArgs["result"]["ma_tx_mint"]>
    composites: {}
  }

  type ma_tx_mintGetPayload<S extends boolean | null | undefined | ma_tx_mintDefaultArgs> = $Result.GetResult<Prisma.$ma_tx_mintPayload, S>

  type ma_tx_mintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ma_tx_mintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ma_tx_mintCountAggregateInputType | true
    }

  export interface ma_tx_mintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ma_tx_mint'], meta: { name: 'ma_tx_mint' } }
    /**
     * Find zero or one Ma_tx_mint that matches the filter.
     * @param {ma_tx_mintFindUniqueArgs} args - Arguments to find a Ma_tx_mint
     * @example
     * // Get one Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ma_tx_mintFindUniqueArgs>(args: SelectSubset<T, ma_tx_mintFindUniqueArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ma_tx_mint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ma_tx_mintFindUniqueOrThrowArgs} args - Arguments to find a Ma_tx_mint
     * @example
     * // Get one Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ma_tx_mintFindUniqueOrThrowArgs>(args: SelectSubset<T, ma_tx_mintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ma_tx_mint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintFindFirstArgs} args - Arguments to find a Ma_tx_mint
     * @example
     * // Get one Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ma_tx_mintFindFirstArgs>(args?: SelectSubset<T, ma_tx_mintFindFirstArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ma_tx_mint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintFindFirstOrThrowArgs} args - Arguments to find a Ma_tx_mint
     * @example
     * // Get one Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ma_tx_mintFindFirstOrThrowArgs>(args?: SelectSubset<T, ma_tx_mintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ma_tx_mints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ma_tx_mints
     * const ma_tx_mints = await prisma.ma_tx_mint.findMany()
     * 
     * // Get first 10 Ma_tx_mints
     * const ma_tx_mints = await prisma.ma_tx_mint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ma_tx_mintWithIdOnly = await prisma.ma_tx_mint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ma_tx_mintFindManyArgs>(args?: SelectSubset<T, ma_tx_mintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ma_tx_mint.
     * @param {ma_tx_mintCreateArgs} args - Arguments to create a Ma_tx_mint.
     * @example
     * // Create one Ma_tx_mint
     * const Ma_tx_mint = await prisma.ma_tx_mint.create({
     *   data: {
     *     // ... data to create a Ma_tx_mint
     *   }
     * })
     * 
     */
    create<T extends ma_tx_mintCreateArgs>(args: SelectSubset<T, ma_tx_mintCreateArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ma_tx_mints.
     * @param {ma_tx_mintCreateManyArgs} args - Arguments to create many Ma_tx_mints.
     * @example
     * // Create many Ma_tx_mints
     * const ma_tx_mint = await prisma.ma_tx_mint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ma_tx_mintCreateManyArgs>(args?: SelectSubset<T, ma_tx_mintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ma_tx_mints and returns the data saved in the database.
     * @param {ma_tx_mintCreateManyAndReturnArgs} args - Arguments to create many Ma_tx_mints.
     * @example
     * // Create many Ma_tx_mints
     * const ma_tx_mint = await prisma.ma_tx_mint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ma_tx_mints and only return the `id`
     * const ma_tx_mintWithIdOnly = await prisma.ma_tx_mint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ma_tx_mintCreateManyAndReturnArgs>(args?: SelectSubset<T, ma_tx_mintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ma_tx_mint.
     * @param {ma_tx_mintDeleteArgs} args - Arguments to delete one Ma_tx_mint.
     * @example
     * // Delete one Ma_tx_mint
     * const Ma_tx_mint = await prisma.ma_tx_mint.delete({
     *   where: {
     *     // ... filter to delete one Ma_tx_mint
     *   }
     * })
     * 
     */
    delete<T extends ma_tx_mintDeleteArgs>(args: SelectSubset<T, ma_tx_mintDeleteArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ma_tx_mint.
     * @param {ma_tx_mintUpdateArgs} args - Arguments to update one Ma_tx_mint.
     * @example
     * // Update one Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ma_tx_mintUpdateArgs>(args: SelectSubset<T, ma_tx_mintUpdateArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ma_tx_mints.
     * @param {ma_tx_mintDeleteManyArgs} args - Arguments to filter Ma_tx_mints to delete.
     * @example
     * // Delete a few Ma_tx_mints
     * const { count } = await prisma.ma_tx_mint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ma_tx_mintDeleteManyArgs>(args?: SelectSubset<T, ma_tx_mintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ma_tx_mints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ma_tx_mints
     * const ma_tx_mint = await prisma.ma_tx_mint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ma_tx_mintUpdateManyArgs>(args: SelectSubset<T, ma_tx_mintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ma_tx_mints and returns the data updated in the database.
     * @param {ma_tx_mintUpdateManyAndReturnArgs} args - Arguments to update many Ma_tx_mints.
     * @example
     * // Update many Ma_tx_mints
     * const ma_tx_mint = await prisma.ma_tx_mint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ma_tx_mints and only return the `id`
     * const ma_tx_mintWithIdOnly = await prisma.ma_tx_mint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ma_tx_mintUpdateManyAndReturnArgs>(args: SelectSubset<T, ma_tx_mintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ma_tx_mint.
     * @param {ma_tx_mintUpsertArgs} args - Arguments to update or create a Ma_tx_mint.
     * @example
     * // Update or create a Ma_tx_mint
     * const ma_tx_mint = await prisma.ma_tx_mint.upsert({
     *   create: {
     *     // ... data to create a Ma_tx_mint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ma_tx_mint we want to update
     *   }
     * })
     */
    upsert<T extends ma_tx_mintUpsertArgs>(args: SelectSubset<T, ma_tx_mintUpsertArgs<ExtArgs>>): Prisma__ma_tx_mintClient<$Result.GetResult<Prisma.$ma_tx_mintPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ma_tx_mints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintCountArgs} args - Arguments to filter Ma_tx_mints to count.
     * @example
     * // Count the number of Ma_tx_mints
     * const count = await prisma.ma_tx_mint.count({
     *   where: {
     *     // ... the filter for the Ma_tx_mints we want to count
     *   }
     * })
    **/
    count<T extends ma_tx_mintCountArgs>(
      args?: Subset<T, ma_tx_mintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ma_tx_mintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ma_tx_mint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ma_tx_mintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ma_tx_mintAggregateArgs>(args: Subset<T, Ma_tx_mintAggregateArgs>): Prisma.PrismaPromise<GetMa_tx_mintAggregateType<T>>

    /**
     * Group by Ma_tx_mint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_mintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ma_tx_mintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ma_tx_mintGroupByArgs['orderBy'] }
        : { orderBy?: ma_tx_mintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ma_tx_mintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMa_tx_mintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ma_tx_mint model
   */
  readonly fields: ma_tx_mintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ma_tx_mint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ma_tx_mintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ma_tx_mint model
   */ 
  interface ma_tx_mintFieldRefs {
    readonly id: FieldRef<"ma_tx_mint", 'BigInt'>
    readonly quantity: FieldRef<"ma_tx_mint", 'Decimal'>
    readonly tx_id: FieldRef<"ma_tx_mint", 'BigInt'>
    readonly ident: FieldRef<"ma_tx_mint", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * ma_tx_mint findUnique
   */
  export type ma_tx_mintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_mint to fetch.
     */
    where: ma_tx_mintWhereUniqueInput
  }

  /**
   * ma_tx_mint findUniqueOrThrow
   */
  export type ma_tx_mintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_mint to fetch.
     */
    where: ma_tx_mintWhereUniqueInput
  }

  /**
   * ma_tx_mint findFirst
   */
  export type ma_tx_mintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_mint to fetch.
     */
    where?: ma_tx_mintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_mints to fetch.
     */
    orderBy?: ma_tx_mintOrderByWithRelationInput | ma_tx_mintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ma_tx_mints.
     */
    cursor?: ma_tx_mintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_mints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_mints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ma_tx_mints.
     */
    distinct?: Ma_tx_mintScalarFieldEnum | Ma_tx_mintScalarFieldEnum[]
  }

  /**
   * ma_tx_mint findFirstOrThrow
   */
  export type ma_tx_mintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_mint to fetch.
     */
    where?: ma_tx_mintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_mints to fetch.
     */
    orderBy?: ma_tx_mintOrderByWithRelationInput | ma_tx_mintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ma_tx_mints.
     */
    cursor?: ma_tx_mintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_mints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_mints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ma_tx_mints.
     */
    distinct?: Ma_tx_mintScalarFieldEnum | Ma_tx_mintScalarFieldEnum[]
  }

  /**
   * ma_tx_mint findMany
   */
  export type ma_tx_mintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_mints to fetch.
     */
    where?: ma_tx_mintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_mints to fetch.
     */
    orderBy?: ma_tx_mintOrderByWithRelationInput | ma_tx_mintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ma_tx_mints.
     */
    cursor?: ma_tx_mintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_mints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_mints.
     */
    skip?: number
    distinct?: Ma_tx_mintScalarFieldEnum | Ma_tx_mintScalarFieldEnum[]
  }

  /**
   * ma_tx_mint create
   */
  export type ma_tx_mintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * The data needed to create a ma_tx_mint.
     */
    data: XOR<ma_tx_mintCreateInput, ma_tx_mintUncheckedCreateInput>
  }

  /**
   * ma_tx_mint createMany
   */
  export type ma_tx_mintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ma_tx_mints.
     */
    data: ma_tx_mintCreateManyInput | ma_tx_mintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ma_tx_mint createManyAndReturn
   */
  export type ma_tx_mintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * The data used to create many ma_tx_mints.
     */
    data: ma_tx_mintCreateManyInput | ma_tx_mintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ma_tx_mint update
   */
  export type ma_tx_mintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * The data needed to update a ma_tx_mint.
     */
    data: XOR<ma_tx_mintUpdateInput, ma_tx_mintUncheckedUpdateInput>
    /**
     * Choose, which ma_tx_mint to update.
     */
    where: ma_tx_mintWhereUniqueInput
  }

  /**
   * ma_tx_mint updateMany
   */
  export type ma_tx_mintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ma_tx_mints.
     */
    data: XOR<ma_tx_mintUpdateManyMutationInput, ma_tx_mintUncheckedUpdateManyInput>
    /**
     * Filter which ma_tx_mints to update
     */
    where?: ma_tx_mintWhereInput
    /**
     * Limit how many ma_tx_mints to update.
     */
    limit?: number
  }

  /**
   * ma_tx_mint updateManyAndReturn
   */
  export type ma_tx_mintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * The data used to update ma_tx_mints.
     */
    data: XOR<ma_tx_mintUpdateManyMutationInput, ma_tx_mintUncheckedUpdateManyInput>
    /**
     * Filter which ma_tx_mints to update
     */
    where?: ma_tx_mintWhereInput
    /**
     * Limit how many ma_tx_mints to update.
     */
    limit?: number
  }

  /**
   * ma_tx_mint upsert
   */
  export type ma_tx_mintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * The filter to search for the ma_tx_mint to update in case it exists.
     */
    where: ma_tx_mintWhereUniqueInput
    /**
     * In case the ma_tx_mint found by the `where` argument doesn't exist, create a new ma_tx_mint with this data.
     */
    create: XOR<ma_tx_mintCreateInput, ma_tx_mintUncheckedCreateInput>
    /**
     * In case the ma_tx_mint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ma_tx_mintUpdateInput, ma_tx_mintUncheckedUpdateInput>
  }

  /**
   * ma_tx_mint delete
   */
  export type ma_tx_mintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
    /**
     * Filter which ma_tx_mint to delete.
     */
    where: ma_tx_mintWhereUniqueInput
  }

  /**
   * ma_tx_mint deleteMany
   */
  export type ma_tx_mintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ma_tx_mints to delete
     */
    where?: ma_tx_mintWhereInput
    /**
     * Limit how many ma_tx_mints to delete.
     */
    limit?: number
  }

  /**
   * ma_tx_mint without action
   */
  export type ma_tx_mintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_mint
     */
    select?: ma_tx_mintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_mint
     */
    omit?: ma_tx_mintOmit<ExtArgs> | null
  }


  /**
   * Model ma_tx_out
   */

  export type AggregateMa_tx_out = {
    _count: Ma_tx_outCountAggregateOutputType | null
    _avg: Ma_tx_outAvgAggregateOutputType | null
    _sum: Ma_tx_outSumAggregateOutputType | null
    _min: Ma_tx_outMinAggregateOutputType | null
    _max: Ma_tx_outMaxAggregateOutputType | null
  }

  export type Ma_tx_outAvgAggregateOutputType = {
    id: number | null
    quantity: Decimal | null
    tx_out_id: number | null
    ident: number | null
  }

  export type Ma_tx_outSumAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_out_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_outMinAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_out_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_outMaxAggregateOutputType = {
    id: bigint | null
    quantity: Decimal | null
    tx_out_id: bigint | null
    ident: bigint | null
  }

  export type Ma_tx_outCountAggregateOutputType = {
    id: number
    quantity: number
    tx_out_id: number
    ident: number
    _all: number
  }


  export type Ma_tx_outAvgAggregateInputType = {
    id?: true
    quantity?: true
    tx_out_id?: true
    ident?: true
  }

  export type Ma_tx_outSumAggregateInputType = {
    id?: true
    quantity?: true
    tx_out_id?: true
    ident?: true
  }

  export type Ma_tx_outMinAggregateInputType = {
    id?: true
    quantity?: true
    tx_out_id?: true
    ident?: true
  }

  export type Ma_tx_outMaxAggregateInputType = {
    id?: true
    quantity?: true
    tx_out_id?: true
    ident?: true
  }

  export type Ma_tx_outCountAggregateInputType = {
    id?: true
    quantity?: true
    tx_out_id?: true
    ident?: true
    _all?: true
  }

  export type Ma_tx_outAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ma_tx_out to aggregate.
     */
    where?: ma_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_outs to fetch.
     */
    orderBy?: ma_tx_outOrderByWithRelationInput | ma_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ma_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ma_tx_outs
    **/
    _count?: true | Ma_tx_outCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ma_tx_outAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ma_tx_outSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ma_tx_outMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ma_tx_outMaxAggregateInputType
  }

  export type GetMa_tx_outAggregateType<T extends Ma_tx_outAggregateArgs> = {
        [P in keyof T & keyof AggregateMa_tx_out]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMa_tx_out[P]>
      : GetScalarType<T[P], AggregateMa_tx_out[P]>
  }




  export type ma_tx_outGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ma_tx_outWhereInput
    orderBy?: ma_tx_outOrderByWithAggregationInput | ma_tx_outOrderByWithAggregationInput[]
    by: Ma_tx_outScalarFieldEnum[] | Ma_tx_outScalarFieldEnum
    having?: ma_tx_outScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ma_tx_outCountAggregateInputType | true
    _avg?: Ma_tx_outAvgAggregateInputType
    _sum?: Ma_tx_outSumAggregateInputType
    _min?: Ma_tx_outMinAggregateInputType
    _max?: Ma_tx_outMaxAggregateInputType
  }

  export type Ma_tx_outGroupByOutputType = {
    id: bigint
    quantity: Decimal
    tx_out_id: bigint
    ident: bigint
    _count: Ma_tx_outCountAggregateOutputType | null
    _avg: Ma_tx_outAvgAggregateOutputType | null
    _sum: Ma_tx_outSumAggregateOutputType | null
    _min: Ma_tx_outMinAggregateOutputType | null
    _max: Ma_tx_outMaxAggregateOutputType | null
  }

  type GetMa_tx_outGroupByPayload<T extends ma_tx_outGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ma_tx_outGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ma_tx_outGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ma_tx_outGroupByOutputType[P]>
            : GetScalarType<T[P], Ma_tx_outGroupByOutputType[P]>
        }
      >
    >


  export type ma_tx_outSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_out_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_out"]>

  export type ma_tx_outSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_out_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_out"]>

  export type ma_tx_outSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    tx_out_id?: boolean
    ident?: boolean
  }, ExtArgs["result"]["ma_tx_out"]>

  export type ma_tx_outSelectScalar = {
    id?: boolean
    quantity?: boolean
    tx_out_id?: boolean
    ident?: boolean
  }

  export type ma_tx_outOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "tx_out_id" | "ident", ExtArgs["result"]["ma_tx_out"]>

  export type $ma_tx_outPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ma_tx_out"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      quantity: Prisma.Decimal
      tx_out_id: bigint
      ident: bigint
    }, ExtArgs["result"]["ma_tx_out"]>
    composites: {}
  }

  type ma_tx_outGetPayload<S extends boolean | null | undefined | ma_tx_outDefaultArgs> = $Result.GetResult<Prisma.$ma_tx_outPayload, S>

  type ma_tx_outCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ma_tx_outFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ma_tx_outCountAggregateInputType | true
    }

  export interface ma_tx_outDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ma_tx_out'], meta: { name: 'ma_tx_out' } }
    /**
     * Find zero or one Ma_tx_out that matches the filter.
     * @param {ma_tx_outFindUniqueArgs} args - Arguments to find a Ma_tx_out
     * @example
     * // Get one Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ma_tx_outFindUniqueArgs>(args: SelectSubset<T, ma_tx_outFindUniqueArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Ma_tx_out that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ma_tx_outFindUniqueOrThrowArgs} args - Arguments to find a Ma_tx_out
     * @example
     * // Get one Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ma_tx_outFindUniqueOrThrowArgs>(args: SelectSubset<T, ma_tx_outFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Ma_tx_out that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outFindFirstArgs} args - Arguments to find a Ma_tx_out
     * @example
     * // Get one Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ma_tx_outFindFirstArgs>(args?: SelectSubset<T, ma_tx_outFindFirstArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Ma_tx_out that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outFindFirstOrThrowArgs} args - Arguments to find a Ma_tx_out
     * @example
     * // Get one Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ma_tx_outFindFirstOrThrowArgs>(args?: SelectSubset<T, ma_tx_outFindFirstOrThrowArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ma_tx_outs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ma_tx_outs
     * const ma_tx_outs = await prisma.ma_tx_out.findMany()
     * 
     * // Get first 10 Ma_tx_outs
     * const ma_tx_outs = await prisma.ma_tx_out.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ma_tx_outWithIdOnly = await prisma.ma_tx_out.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ma_tx_outFindManyArgs>(args?: SelectSubset<T, ma_tx_outFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Ma_tx_out.
     * @param {ma_tx_outCreateArgs} args - Arguments to create a Ma_tx_out.
     * @example
     * // Create one Ma_tx_out
     * const Ma_tx_out = await prisma.ma_tx_out.create({
     *   data: {
     *     // ... data to create a Ma_tx_out
     *   }
     * })
     * 
     */
    create<T extends ma_tx_outCreateArgs>(args: SelectSubset<T, ma_tx_outCreateArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ma_tx_outs.
     * @param {ma_tx_outCreateManyArgs} args - Arguments to create many Ma_tx_outs.
     * @example
     * // Create many Ma_tx_outs
     * const ma_tx_out = await prisma.ma_tx_out.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ma_tx_outCreateManyArgs>(args?: SelectSubset<T, ma_tx_outCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ma_tx_outs and returns the data saved in the database.
     * @param {ma_tx_outCreateManyAndReturnArgs} args - Arguments to create many Ma_tx_outs.
     * @example
     * // Create many Ma_tx_outs
     * const ma_tx_out = await prisma.ma_tx_out.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ma_tx_outs and only return the `id`
     * const ma_tx_outWithIdOnly = await prisma.ma_tx_out.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ma_tx_outCreateManyAndReturnArgs>(args?: SelectSubset<T, ma_tx_outCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Ma_tx_out.
     * @param {ma_tx_outDeleteArgs} args - Arguments to delete one Ma_tx_out.
     * @example
     * // Delete one Ma_tx_out
     * const Ma_tx_out = await prisma.ma_tx_out.delete({
     *   where: {
     *     // ... filter to delete one Ma_tx_out
     *   }
     * })
     * 
     */
    delete<T extends ma_tx_outDeleteArgs>(args: SelectSubset<T, ma_tx_outDeleteArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Ma_tx_out.
     * @param {ma_tx_outUpdateArgs} args - Arguments to update one Ma_tx_out.
     * @example
     * // Update one Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ma_tx_outUpdateArgs>(args: SelectSubset<T, ma_tx_outUpdateArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ma_tx_outs.
     * @param {ma_tx_outDeleteManyArgs} args - Arguments to filter Ma_tx_outs to delete.
     * @example
     * // Delete a few Ma_tx_outs
     * const { count } = await prisma.ma_tx_out.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ma_tx_outDeleteManyArgs>(args?: SelectSubset<T, ma_tx_outDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ma_tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ma_tx_outs
     * const ma_tx_out = await prisma.ma_tx_out.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ma_tx_outUpdateManyArgs>(args: SelectSubset<T, ma_tx_outUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ma_tx_outs and returns the data updated in the database.
     * @param {ma_tx_outUpdateManyAndReturnArgs} args - Arguments to update many Ma_tx_outs.
     * @example
     * // Update many Ma_tx_outs
     * const ma_tx_out = await prisma.ma_tx_out.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ma_tx_outs and only return the `id`
     * const ma_tx_outWithIdOnly = await prisma.ma_tx_out.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ma_tx_outUpdateManyAndReturnArgs>(args: SelectSubset<T, ma_tx_outUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Ma_tx_out.
     * @param {ma_tx_outUpsertArgs} args - Arguments to update or create a Ma_tx_out.
     * @example
     * // Update or create a Ma_tx_out
     * const ma_tx_out = await prisma.ma_tx_out.upsert({
     *   create: {
     *     // ... data to create a Ma_tx_out
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ma_tx_out we want to update
     *   }
     * })
     */
    upsert<T extends ma_tx_outUpsertArgs>(args: SelectSubset<T, ma_tx_outUpsertArgs<ExtArgs>>): Prisma__ma_tx_outClient<$Result.GetResult<Prisma.$ma_tx_outPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ma_tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outCountArgs} args - Arguments to filter Ma_tx_outs to count.
     * @example
     * // Count the number of Ma_tx_outs
     * const count = await prisma.ma_tx_out.count({
     *   where: {
     *     // ... the filter for the Ma_tx_outs we want to count
     *   }
     * })
    **/
    count<T extends ma_tx_outCountArgs>(
      args?: Subset<T, ma_tx_outCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ma_tx_outCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ma_tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ma_tx_outAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ma_tx_outAggregateArgs>(args: Subset<T, Ma_tx_outAggregateArgs>): Prisma.PrismaPromise<GetMa_tx_outAggregateType<T>>

    /**
     * Group by Ma_tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ma_tx_outGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ma_tx_outGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ma_tx_outGroupByArgs['orderBy'] }
        : { orderBy?: ma_tx_outGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ma_tx_outGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMa_tx_outGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ma_tx_out model
   */
  readonly fields: ma_tx_outFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ma_tx_out.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ma_tx_outClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ma_tx_out model
   */ 
  interface ma_tx_outFieldRefs {
    readonly id: FieldRef<"ma_tx_out", 'BigInt'>
    readonly quantity: FieldRef<"ma_tx_out", 'Decimal'>
    readonly tx_out_id: FieldRef<"ma_tx_out", 'BigInt'>
    readonly ident: FieldRef<"ma_tx_out", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * ma_tx_out findUnique
   */
  export type ma_tx_outFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_out to fetch.
     */
    where: ma_tx_outWhereUniqueInput
  }

  /**
   * ma_tx_out findUniqueOrThrow
   */
  export type ma_tx_outFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_out to fetch.
     */
    where: ma_tx_outWhereUniqueInput
  }

  /**
   * ma_tx_out findFirst
   */
  export type ma_tx_outFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_out to fetch.
     */
    where?: ma_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_outs to fetch.
     */
    orderBy?: ma_tx_outOrderByWithRelationInput | ma_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ma_tx_outs.
     */
    cursor?: ma_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ma_tx_outs.
     */
    distinct?: Ma_tx_outScalarFieldEnum | Ma_tx_outScalarFieldEnum[]
  }

  /**
   * ma_tx_out findFirstOrThrow
   */
  export type ma_tx_outFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_out to fetch.
     */
    where?: ma_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_outs to fetch.
     */
    orderBy?: ma_tx_outOrderByWithRelationInput | ma_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ma_tx_outs.
     */
    cursor?: ma_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ma_tx_outs.
     */
    distinct?: Ma_tx_outScalarFieldEnum | Ma_tx_outScalarFieldEnum[]
  }

  /**
   * ma_tx_out findMany
   */
  export type ma_tx_outFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter, which ma_tx_outs to fetch.
     */
    where?: ma_tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ma_tx_outs to fetch.
     */
    orderBy?: ma_tx_outOrderByWithRelationInput | ma_tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ma_tx_outs.
     */
    cursor?: ma_tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ma_tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ma_tx_outs.
     */
    skip?: number
    distinct?: Ma_tx_outScalarFieldEnum | Ma_tx_outScalarFieldEnum[]
  }

  /**
   * ma_tx_out create
   */
  export type ma_tx_outCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * The data needed to create a ma_tx_out.
     */
    data: XOR<ma_tx_outCreateInput, ma_tx_outUncheckedCreateInput>
  }

  /**
   * ma_tx_out createMany
   */
  export type ma_tx_outCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ma_tx_outs.
     */
    data: ma_tx_outCreateManyInput | ma_tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ma_tx_out createManyAndReturn
   */
  export type ma_tx_outCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * The data used to create many ma_tx_outs.
     */
    data: ma_tx_outCreateManyInput | ma_tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ma_tx_out update
   */
  export type ma_tx_outUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * The data needed to update a ma_tx_out.
     */
    data: XOR<ma_tx_outUpdateInput, ma_tx_outUncheckedUpdateInput>
    /**
     * Choose, which ma_tx_out to update.
     */
    where: ma_tx_outWhereUniqueInput
  }

  /**
   * ma_tx_out updateMany
   */
  export type ma_tx_outUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ma_tx_outs.
     */
    data: XOR<ma_tx_outUpdateManyMutationInput, ma_tx_outUncheckedUpdateManyInput>
    /**
     * Filter which ma_tx_outs to update
     */
    where?: ma_tx_outWhereInput
    /**
     * Limit how many ma_tx_outs to update.
     */
    limit?: number
  }

  /**
   * ma_tx_out updateManyAndReturn
   */
  export type ma_tx_outUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * The data used to update ma_tx_outs.
     */
    data: XOR<ma_tx_outUpdateManyMutationInput, ma_tx_outUncheckedUpdateManyInput>
    /**
     * Filter which ma_tx_outs to update
     */
    where?: ma_tx_outWhereInput
    /**
     * Limit how many ma_tx_outs to update.
     */
    limit?: number
  }

  /**
   * ma_tx_out upsert
   */
  export type ma_tx_outUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * The filter to search for the ma_tx_out to update in case it exists.
     */
    where: ma_tx_outWhereUniqueInput
    /**
     * In case the ma_tx_out found by the `where` argument doesn't exist, create a new ma_tx_out with this data.
     */
    create: XOR<ma_tx_outCreateInput, ma_tx_outUncheckedCreateInput>
    /**
     * In case the ma_tx_out was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ma_tx_outUpdateInput, ma_tx_outUncheckedUpdateInput>
  }

  /**
   * ma_tx_out delete
   */
  export type ma_tx_outDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
    /**
     * Filter which ma_tx_out to delete.
     */
    where: ma_tx_outWhereUniqueInput
  }

  /**
   * ma_tx_out deleteMany
   */
  export type ma_tx_outDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ma_tx_outs to delete
     */
    where?: ma_tx_outWhereInput
    /**
     * Limit how many ma_tx_outs to delete.
     */
    limit?: number
  }

  /**
   * ma_tx_out without action
   */
  export type ma_tx_outDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ma_tx_out
     */
    select?: ma_tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ma_tx_out
     */
    omit?: ma_tx_outOmit<ExtArgs> | null
  }


  /**
   * Model meta
   */

  export type AggregateMeta = {
    _count: MetaCountAggregateOutputType | null
    _avg: MetaAvgAggregateOutputType | null
    _sum: MetaSumAggregateOutputType | null
    _min: MetaMinAggregateOutputType | null
    _max: MetaMaxAggregateOutputType | null
  }

  export type MetaAvgAggregateOutputType = {
    id: number | null
  }

  export type MetaSumAggregateOutputType = {
    id: bigint | null
  }

  export type MetaMinAggregateOutputType = {
    id: bigint | null
    start_time: Date | null
    network_name: string | null
    version: string | null
  }

  export type MetaMaxAggregateOutputType = {
    id: bigint | null
    start_time: Date | null
    network_name: string | null
    version: string | null
  }

  export type MetaCountAggregateOutputType = {
    id: number
    start_time: number
    network_name: number
    version: number
    _all: number
  }


  export type MetaAvgAggregateInputType = {
    id?: true
  }

  export type MetaSumAggregateInputType = {
    id?: true
  }

  export type MetaMinAggregateInputType = {
    id?: true
    start_time?: true
    network_name?: true
    version?: true
  }

  export type MetaMaxAggregateInputType = {
    id?: true
    start_time?: true
    network_name?: true
    version?: true
  }

  export type MetaCountAggregateInputType = {
    id?: true
    start_time?: true
    network_name?: true
    version?: true
    _all?: true
  }

  export type MetaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meta to aggregate.
     */
    where?: metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned metas
    **/
    _count?: true | MetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaMaxAggregateInputType
  }

  export type GetMetaAggregateType<T extends MetaAggregateArgs> = {
        [P in keyof T & keyof AggregateMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeta[P]>
      : GetScalarType<T[P], AggregateMeta[P]>
  }




  export type metaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: metaWhereInput
    orderBy?: metaOrderByWithAggregationInput | metaOrderByWithAggregationInput[]
    by: MetaScalarFieldEnum[] | MetaScalarFieldEnum
    having?: metaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaCountAggregateInputType | true
    _avg?: MetaAvgAggregateInputType
    _sum?: MetaSumAggregateInputType
    _min?: MetaMinAggregateInputType
    _max?: MetaMaxAggregateInputType
  }

  export type MetaGroupByOutputType = {
    id: bigint
    start_time: Date
    network_name: string
    version: string
    _count: MetaCountAggregateOutputType | null
    _avg: MetaAvgAggregateOutputType | null
    _sum: MetaSumAggregateOutputType | null
    _min: MetaMinAggregateOutputType | null
    _max: MetaMaxAggregateOutputType | null
  }

  type GetMetaGroupByPayload<T extends metaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaGroupByOutputType[P]>
            : GetScalarType<T[P], MetaGroupByOutputType[P]>
        }
      >
    >


  export type metaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_time?: boolean
    network_name?: boolean
    version?: boolean
  }, ExtArgs["result"]["meta"]>

  export type metaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_time?: boolean
    network_name?: boolean
    version?: boolean
  }, ExtArgs["result"]["meta"]>

  export type metaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_time?: boolean
    network_name?: boolean
    version?: boolean
  }, ExtArgs["result"]["meta"]>

  export type metaSelectScalar = {
    id?: boolean
    start_time?: boolean
    network_name?: boolean
    version?: boolean
  }

  export type metaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start_time" | "network_name" | "version", ExtArgs["result"]["meta"]>

  export type $metaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meta"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      start_time: Date
      network_name: string
      version: string
    }, ExtArgs["result"]["meta"]>
    composites: {}
  }

  type metaGetPayload<S extends boolean | null | undefined | metaDefaultArgs> = $Result.GetResult<Prisma.$metaPayload, S>

  type metaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<metaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetaCountAggregateInputType | true
    }

  export interface metaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meta'], meta: { name: 'meta' } }
    /**
     * Find zero or one Meta that matches the filter.
     * @param {metaFindUniqueArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends metaFindUniqueArgs>(args: SelectSubset<T, metaFindUniqueArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Meta that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {metaFindUniqueOrThrowArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends metaFindUniqueOrThrowArgs>(args: SelectSubset<T, metaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Meta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindFirstArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends metaFindFirstArgs>(args?: SelectSubset<T, metaFindFirstArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Meta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindFirstOrThrowArgs} args - Arguments to find a Meta
     * @example
     * // Get one Meta
     * const meta = await prisma.meta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends metaFindFirstOrThrowArgs>(args?: SelectSubset<T, metaFindFirstOrThrowArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Metas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metas
     * const metas = await prisma.meta.findMany()
     * 
     * // Get first 10 Metas
     * const metas = await prisma.meta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaWithIdOnly = await prisma.meta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends metaFindManyArgs>(args?: SelectSubset<T, metaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Meta.
     * @param {metaCreateArgs} args - Arguments to create a Meta.
     * @example
     * // Create one Meta
     * const Meta = await prisma.meta.create({
     *   data: {
     *     // ... data to create a Meta
     *   }
     * })
     * 
     */
    create<T extends metaCreateArgs>(args: SelectSubset<T, metaCreateArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Metas.
     * @param {metaCreateManyArgs} args - Arguments to create many Metas.
     * @example
     * // Create many Metas
     * const meta = await prisma.meta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends metaCreateManyArgs>(args?: SelectSubset<T, metaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metas and returns the data saved in the database.
     * @param {metaCreateManyAndReturnArgs} args - Arguments to create many Metas.
     * @example
     * // Create many Metas
     * const meta = await prisma.meta.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metas and only return the `id`
     * const metaWithIdOnly = await prisma.meta.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends metaCreateManyAndReturnArgs>(args?: SelectSubset<T, metaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Meta.
     * @param {metaDeleteArgs} args - Arguments to delete one Meta.
     * @example
     * // Delete one Meta
     * const Meta = await prisma.meta.delete({
     *   where: {
     *     // ... filter to delete one Meta
     *   }
     * })
     * 
     */
    delete<T extends metaDeleteArgs>(args: SelectSubset<T, metaDeleteArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Meta.
     * @param {metaUpdateArgs} args - Arguments to update one Meta.
     * @example
     * // Update one Meta
     * const meta = await prisma.meta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends metaUpdateArgs>(args: SelectSubset<T, metaUpdateArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Metas.
     * @param {metaDeleteManyArgs} args - Arguments to filter Metas to delete.
     * @example
     * // Delete a few Metas
     * const { count } = await prisma.meta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends metaDeleteManyArgs>(args?: SelectSubset<T, metaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metas
     * const meta = await prisma.meta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends metaUpdateManyArgs>(args: SelectSubset<T, metaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metas and returns the data updated in the database.
     * @param {metaUpdateManyAndReturnArgs} args - Arguments to update many Metas.
     * @example
     * // Update many Metas
     * const meta = await prisma.meta.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Metas and only return the `id`
     * const metaWithIdOnly = await prisma.meta.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends metaUpdateManyAndReturnArgs>(args: SelectSubset<T, metaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Meta.
     * @param {metaUpsertArgs} args - Arguments to update or create a Meta.
     * @example
     * // Update or create a Meta
     * const meta = await prisma.meta.upsert({
     *   create: {
     *     // ... data to create a Meta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meta we want to update
     *   }
     * })
     */
    upsert<T extends metaUpsertArgs>(args: SelectSubset<T, metaUpsertArgs<ExtArgs>>): Prisma__metaClient<$Result.GetResult<Prisma.$metaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Metas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaCountArgs} args - Arguments to filter Metas to count.
     * @example
     * // Count the number of Metas
     * const count = await prisma.meta.count({
     *   where: {
     *     // ... the filter for the Metas we want to count
     *   }
     * })
    **/
    count<T extends metaCountArgs>(
      args?: Subset<T, metaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaAggregateArgs>(args: Subset<T, MetaAggregateArgs>): Prisma.PrismaPromise<GetMetaAggregateType<T>>

    /**
     * Group by Meta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {metaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends metaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: metaGroupByArgs['orderBy'] }
        : { orderBy?: metaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, metaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meta model
   */
  readonly fields: metaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__metaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meta model
   */ 
  interface metaFieldRefs {
    readonly id: FieldRef<"meta", 'BigInt'>
    readonly start_time: FieldRef<"meta", 'DateTime'>
    readonly network_name: FieldRef<"meta", 'String'>
    readonly version: FieldRef<"meta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * meta findUnique
   */
  export type metaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter, which meta to fetch.
     */
    where: metaWhereUniqueInput
  }

  /**
   * meta findUniqueOrThrow
   */
  export type metaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter, which meta to fetch.
     */
    where: metaWhereUniqueInput
  }

  /**
   * meta findFirst
   */
  export type metaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter, which meta to fetch.
     */
    where?: metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metas.
     */
    cursor?: metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metas.
     */
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[]
  }

  /**
   * meta findFirstOrThrow
   */
  export type metaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter, which meta to fetch.
     */
    where?: metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for metas.
     */
    cursor?: metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of metas.
     */
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[]
  }

  /**
   * meta findMany
   */
  export type metaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter, which metas to fetch.
     */
    where?: metaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of metas to fetch.
     */
    orderBy?: metaOrderByWithRelationInput | metaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing metas.
     */
    cursor?: metaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` metas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` metas.
     */
    skip?: number
    distinct?: MetaScalarFieldEnum | MetaScalarFieldEnum[]
  }

  /**
   * meta create
   */
  export type metaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * The data needed to create a meta.
     */
    data: XOR<metaCreateInput, metaUncheckedCreateInput>
  }

  /**
   * meta createMany
   */
  export type metaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many metas.
     */
    data: metaCreateManyInput | metaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meta createManyAndReturn
   */
  export type metaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * The data used to create many metas.
     */
    data: metaCreateManyInput | metaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meta update
   */
  export type metaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * The data needed to update a meta.
     */
    data: XOR<metaUpdateInput, metaUncheckedUpdateInput>
    /**
     * Choose, which meta to update.
     */
    where: metaWhereUniqueInput
  }

  /**
   * meta updateMany
   */
  export type metaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update metas.
     */
    data: XOR<metaUpdateManyMutationInput, metaUncheckedUpdateManyInput>
    /**
     * Filter which metas to update
     */
    where?: metaWhereInput
    /**
     * Limit how many metas to update.
     */
    limit?: number
  }

  /**
   * meta updateManyAndReturn
   */
  export type metaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * The data used to update metas.
     */
    data: XOR<metaUpdateManyMutationInput, metaUncheckedUpdateManyInput>
    /**
     * Filter which metas to update
     */
    where?: metaWhereInput
    /**
     * Limit how many metas to update.
     */
    limit?: number
  }

  /**
   * meta upsert
   */
  export type metaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * The filter to search for the meta to update in case it exists.
     */
    where: metaWhereUniqueInput
    /**
     * In case the meta found by the `where` argument doesn't exist, create a new meta with this data.
     */
    create: XOR<metaCreateInput, metaUncheckedCreateInput>
    /**
     * In case the meta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<metaUpdateInput, metaUncheckedUpdateInput>
  }

  /**
   * meta delete
   */
  export type metaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
    /**
     * Filter which meta to delete.
     */
    where: metaWhereUniqueInput
  }

  /**
   * meta deleteMany
   */
  export type metaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which metas to delete
     */
    where?: metaWhereInput
    /**
     * Limit how many metas to delete.
     */
    limit?: number
  }

  /**
   * meta without action
   */
  export type metaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meta
     */
    select?: metaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meta
     */
    omit?: metaOmit<ExtArgs> | null
  }


  /**
   * Model multi_asset
   */

  export type AggregateMulti_asset = {
    _count: Multi_assetCountAggregateOutputType | null
    _avg: Multi_assetAvgAggregateOutputType | null
    _sum: Multi_assetSumAggregateOutputType | null
    _min: Multi_assetMinAggregateOutputType | null
    _max: Multi_assetMaxAggregateOutputType | null
  }

  export type Multi_assetAvgAggregateOutputType = {
    id: number | null
  }

  export type Multi_assetSumAggregateOutputType = {
    id: bigint | null
  }

  export type Multi_assetMinAggregateOutputType = {
    id: bigint | null
    policy: Uint8Array | null
    name: Uint8Array | null
    fingerprint: string | null
  }

  export type Multi_assetMaxAggregateOutputType = {
    id: bigint | null
    policy: Uint8Array | null
    name: Uint8Array | null
    fingerprint: string | null
  }

  export type Multi_assetCountAggregateOutputType = {
    id: number
    policy: number
    name: number
    fingerprint: number
    _all: number
  }


  export type Multi_assetAvgAggregateInputType = {
    id?: true
  }

  export type Multi_assetSumAggregateInputType = {
    id?: true
  }

  export type Multi_assetMinAggregateInputType = {
    id?: true
    policy?: true
    name?: true
    fingerprint?: true
  }

  export type Multi_assetMaxAggregateInputType = {
    id?: true
    policy?: true
    name?: true
    fingerprint?: true
  }

  export type Multi_assetCountAggregateInputType = {
    id?: true
    policy?: true
    name?: true
    fingerprint?: true
    _all?: true
  }

  export type Multi_assetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which multi_asset to aggregate.
     */
    where?: multi_assetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multi_assets to fetch.
     */
    orderBy?: multi_assetOrderByWithRelationInput | multi_assetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: multi_assetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multi_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multi_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned multi_assets
    **/
    _count?: true | Multi_assetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Multi_assetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Multi_assetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Multi_assetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Multi_assetMaxAggregateInputType
  }

  export type GetMulti_assetAggregateType<T extends Multi_assetAggregateArgs> = {
        [P in keyof T & keyof AggregateMulti_asset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMulti_asset[P]>
      : GetScalarType<T[P], AggregateMulti_asset[P]>
  }




  export type multi_assetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: multi_assetWhereInput
    orderBy?: multi_assetOrderByWithAggregationInput | multi_assetOrderByWithAggregationInput[]
    by: Multi_assetScalarFieldEnum[] | Multi_assetScalarFieldEnum
    having?: multi_assetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Multi_assetCountAggregateInputType | true
    _avg?: Multi_assetAvgAggregateInputType
    _sum?: Multi_assetSumAggregateInputType
    _min?: Multi_assetMinAggregateInputType
    _max?: Multi_assetMaxAggregateInputType
  }

  export type Multi_assetGroupByOutputType = {
    id: bigint
    policy: Uint8Array
    name: Uint8Array
    fingerprint: string
    _count: Multi_assetCountAggregateOutputType | null
    _avg: Multi_assetAvgAggregateOutputType | null
    _sum: Multi_assetSumAggregateOutputType | null
    _min: Multi_assetMinAggregateOutputType | null
    _max: Multi_assetMaxAggregateOutputType | null
  }

  type GetMulti_assetGroupByPayload<T extends multi_assetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Multi_assetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Multi_assetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Multi_assetGroupByOutputType[P]>
            : GetScalarType<T[P], Multi_assetGroupByOutputType[P]>
        }
      >
    >


  export type multi_assetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policy?: boolean
    name?: boolean
    fingerprint?: boolean
  }, ExtArgs["result"]["multi_asset"]>

  export type multi_assetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policy?: boolean
    name?: boolean
    fingerprint?: boolean
  }, ExtArgs["result"]["multi_asset"]>

  export type multi_assetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    policy?: boolean
    name?: boolean
    fingerprint?: boolean
  }, ExtArgs["result"]["multi_asset"]>

  export type multi_assetSelectScalar = {
    id?: boolean
    policy?: boolean
    name?: boolean
    fingerprint?: boolean
  }

  export type multi_assetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "policy" | "name" | "fingerprint", ExtArgs["result"]["multi_asset"]>

  export type $multi_assetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "multi_asset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      policy: Uint8Array
      name: Uint8Array
      fingerprint: string
    }, ExtArgs["result"]["multi_asset"]>
    composites: {}
  }

  type multi_assetGetPayload<S extends boolean | null | undefined | multi_assetDefaultArgs> = $Result.GetResult<Prisma.$multi_assetPayload, S>

  type multi_assetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<multi_assetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Multi_assetCountAggregateInputType | true
    }

  export interface multi_assetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['multi_asset'], meta: { name: 'multi_asset' } }
    /**
     * Find zero or one Multi_asset that matches the filter.
     * @param {multi_assetFindUniqueArgs} args - Arguments to find a Multi_asset
     * @example
     * // Get one Multi_asset
     * const multi_asset = await prisma.multi_asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends multi_assetFindUniqueArgs>(args: SelectSubset<T, multi_assetFindUniqueArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Multi_asset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {multi_assetFindUniqueOrThrowArgs} args - Arguments to find a Multi_asset
     * @example
     * // Get one Multi_asset
     * const multi_asset = await prisma.multi_asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends multi_assetFindUniqueOrThrowArgs>(args: SelectSubset<T, multi_assetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Multi_asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetFindFirstArgs} args - Arguments to find a Multi_asset
     * @example
     * // Get one Multi_asset
     * const multi_asset = await prisma.multi_asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends multi_assetFindFirstArgs>(args?: SelectSubset<T, multi_assetFindFirstArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Multi_asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetFindFirstOrThrowArgs} args - Arguments to find a Multi_asset
     * @example
     * // Get one Multi_asset
     * const multi_asset = await prisma.multi_asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends multi_assetFindFirstOrThrowArgs>(args?: SelectSubset<T, multi_assetFindFirstOrThrowArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Multi_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Multi_assets
     * const multi_assets = await prisma.multi_asset.findMany()
     * 
     * // Get first 10 Multi_assets
     * const multi_assets = await prisma.multi_asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multi_assetWithIdOnly = await prisma.multi_asset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends multi_assetFindManyArgs>(args?: SelectSubset<T, multi_assetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Multi_asset.
     * @param {multi_assetCreateArgs} args - Arguments to create a Multi_asset.
     * @example
     * // Create one Multi_asset
     * const Multi_asset = await prisma.multi_asset.create({
     *   data: {
     *     // ... data to create a Multi_asset
     *   }
     * })
     * 
     */
    create<T extends multi_assetCreateArgs>(args: SelectSubset<T, multi_assetCreateArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Multi_assets.
     * @param {multi_assetCreateManyArgs} args - Arguments to create many Multi_assets.
     * @example
     * // Create many Multi_assets
     * const multi_asset = await prisma.multi_asset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends multi_assetCreateManyArgs>(args?: SelectSubset<T, multi_assetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Multi_assets and returns the data saved in the database.
     * @param {multi_assetCreateManyAndReturnArgs} args - Arguments to create many Multi_assets.
     * @example
     * // Create many Multi_assets
     * const multi_asset = await prisma.multi_asset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Multi_assets and only return the `id`
     * const multi_assetWithIdOnly = await prisma.multi_asset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends multi_assetCreateManyAndReturnArgs>(args?: SelectSubset<T, multi_assetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Multi_asset.
     * @param {multi_assetDeleteArgs} args - Arguments to delete one Multi_asset.
     * @example
     * // Delete one Multi_asset
     * const Multi_asset = await prisma.multi_asset.delete({
     *   where: {
     *     // ... filter to delete one Multi_asset
     *   }
     * })
     * 
     */
    delete<T extends multi_assetDeleteArgs>(args: SelectSubset<T, multi_assetDeleteArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Multi_asset.
     * @param {multi_assetUpdateArgs} args - Arguments to update one Multi_asset.
     * @example
     * // Update one Multi_asset
     * const multi_asset = await prisma.multi_asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends multi_assetUpdateArgs>(args: SelectSubset<T, multi_assetUpdateArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Multi_assets.
     * @param {multi_assetDeleteManyArgs} args - Arguments to filter Multi_assets to delete.
     * @example
     * // Delete a few Multi_assets
     * const { count } = await prisma.multi_asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends multi_assetDeleteManyArgs>(args?: SelectSubset<T, multi_assetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Multi_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Multi_assets
     * const multi_asset = await prisma.multi_asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends multi_assetUpdateManyArgs>(args: SelectSubset<T, multi_assetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Multi_assets and returns the data updated in the database.
     * @param {multi_assetUpdateManyAndReturnArgs} args - Arguments to update many Multi_assets.
     * @example
     * // Update many Multi_assets
     * const multi_asset = await prisma.multi_asset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Multi_assets and only return the `id`
     * const multi_assetWithIdOnly = await prisma.multi_asset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends multi_assetUpdateManyAndReturnArgs>(args: SelectSubset<T, multi_assetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Multi_asset.
     * @param {multi_assetUpsertArgs} args - Arguments to update or create a Multi_asset.
     * @example
     * // Update or create a Multi_asset
     * const multi_asset = await prisma.multi_asset.upsert({
     *   create: {
     *     // ... data to create a Multi_asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Multi_asset we want to update
     *   }
     * })
     */
    upsert<T extends multi_assetUpsertArgs>(args: SelectSubset<T, multi_assetUpsertArgs<ExtArgs>>): Prisma__multi_assetClient<$Result.GetResult<Prisma.$multi_assetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Multi_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetCountArgs} args - Arguments to filter Multi_assets to count.
     * @example
     * // Count the number of Multi_assets
     * const count = await prisma.multi_asset.count({
     *   where: {
     *     // ... the filter for the Multi_assets we want to count
     *   }
     * })
    **/
    count<T extends multi_assetCountArgs>(
      args?: Subset<T, multi_assetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Multi_assetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Multi_asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Multi_assetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Multi_assetAggregateArgs>(args: Subset<T, Multi_assetAggregateArgs>): Prisma.PrismaPromise<GetMulti_assetAggregateType<T>>

    /**
     * Group by Multi_asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multi_assetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends multi_assetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: multi_assetGroupByArgs['orderBy'] }
        : { orderBy?: multi_assetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, multi_assetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMulti_assetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the multi_asset model
   */
  readonly fields: multi_assetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for multi_asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__multi_assetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the multi_asset model
   */ 
  interface multi_assetFieldRefs {
    readonly id: FieldRef<"multi_asset", 'BigInt'>
    readonly policy: FieldRef<"multi_asset", 'Bytes'>
    readonly name: FieldRef<"multi_asset", 'Bytes'>
    readonly fingerprint: FieldRef<"multi_asset", 'String'>
  }
    

  // Custom InputTypes
  /**
   * multi_asset findUnique
   */
  export type multi_assetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter, which multi_asset to fetch.
     */
    where: multi_assetWhereUniqueInput
  }

  /**
   * multi_asset findUniqueOrThrow
   */
  export type multi_assetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter, which multi_asset to fetch.
     */
    where: multi_assetWhereUniqueInput
  }

  /**
   * multi_asset findFirst
   */
  export type multi_assetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter, which multi_asset to fetch.
     */
    where?: multi_assetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multi_assets to fetch.
     */
    orderBy?: multi_assetOrderByWithRelationInput | multi_assetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for multi_assets.
     */
    cursor?: multi_assetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multi_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multi_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of multi_assets.
     */
    distinct?: Multi_assetScalarFieldEnum | Multi_assetScalarFieldEnum[]
  }

  /**
   * multi_asset findFirstOrThrow
   */
  export type multi_assetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter, which multi_asset to fetch.
     */
    where?: multi_assetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multi_assets to fetch.
     */
    orderBy?: multi_assetOrderByWithRelationInput | multi_assetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for multi_assets.
     */
    cursor?: multi_assetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multi_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multi_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of multi_assets.
     */
    distinct?: Multi_assetScalarFieldEnum | Multi_assetScalarFieldEnum[]
  }

  /**
   * multi_asset findMany
   */
  export type multi_assetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter, which multi_assets to fetch.
     */
    where?: multi_assetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multi_assets to fetch.
     */
    orderBy?: multi_assetOrderByWithRelationInput | multi_assetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing multi_assets.
     */
    cursor?: multi_assetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multi_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multi_assets.
     */
    skip?: number
    distinct?: Multi_assetScalarFieldEnum | Multi_assetScalarFieldEnum[]
  }

  /**
   * multi_asset create
   */
  export type multi_assetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * The data needed to create a multi_asset.
     */
    data: XOR<multi_assetCreateInput, multi_assetUncheckedCreateInput>
  }

  /**
   * multi_asset createMany
   */
  export type multi_assetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many multi_assets.
     */
    data: multi_assetCreateManyInput | multi_assetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * multi_asset createManyAndReturn
   */
  export type multi_assetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * The data used to create many multi_assets.
     */
    data: multi_assetCreateManyInput | multi_assetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * multi_asset update
   */
  export type multi_assetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * The data needed to update a multi_asset.
     */
    data: XOR<multi_assetUpdateInput, multi_assetUncheckedUpdateInput>
    /**
     * Choose, which multi_asset to update.
     */
    where: multi_assetWhereUniqueInput
  }

  /**
   * multi_asset updateMany
   */
  export type multi_assetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update multi_assets.
     */
    data: XOR<multi_assetUpdateManyMutationInput, multi_assetUncheckedUpdateManyInput>
    /**
     * Filter which multi_assets to update
     */
    where?: multi_assetWhereInput
    /**
     * Limit how many multi_assets to update.
     */
    limit?: number
  }

  /**
   * multi_asset updateManyAndReturn
   */
  export type multi_assetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * The data used to update multi_assets.
     */
    data: XOR<multi_assetUpdateManyMutationInput, multi_assetUncheckedUpdateManyInput>
    /**
     * Filter which multi_assets to update
     */
    where?: multi_assetWhereInput
    /**
     * Limit how many multi_assets to update.
     */
    limit?: number
  }

  /**
   * multi_asset upsert
   */
  export type multi_assetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * The filter to search for the multi_asset to update in case it exists.
     */
    where: multi_assetWhereUniqueInput
    /**
     * In case the multi_asset found by the `where` argument doesn't exist, create a new multi_asset with this data.
     */
    create: XOR<multi_assetCreateInput, multi_assetUncheckedCreateInput>
    /**
     * In case the multi_asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<multi_assetUpdateInput, multi_assetUncheckedUpdateInput>
  }

  /**
   * multi_asset delete
   */
  export type multi_assetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
    /**
     * Filter which multi_asset to delete.
     */
    where: multi_assetWhereUniqueInput
  }

  /**
   * multi_asset deleteMany
   */
  export type multi_assetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which multi_assets to delete
     */
    where?: multi_assetWhereInput
    /**
     * Limit how many multi_assets to delete.
     */
    limit?: number
  }

  /**
   * multi_asset without action
   */
  export type multi_assetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multi_asset
     */
    select?: multi_assetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the multi_asset
     */
    omit?: multi_assetOmit<ExtArgs> | null
  }


  /**
   * Model new_committee
   */

  export type AggregateNew_committee = {
    _count: New_committeeCountAggregateOutputType | null
    _avg: New_committeeAvgAggregateOutputType | null
    _sum: New_committeeSumAggregateOutputType | null
    _min: New_committeeMinAggregateOutputType | null
    _max: New_committeeMaxAggregateOutputType | null
  }

  export type New_committeeAvgAggregateOutputType = {
    id: number | null
    gov_action_proposal_id: number | null
    quorum_numerator: number | null
    quorum_denominator: number | null
  }

  export type New_committeeSumAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type New_committeeMinAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    deleted_members: string | null
    added_members: string | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type New_committeeMaxAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    deleted_members: string | null
    added_members: string | null
    quorum_numerator: bigint | null
    quorum_denominator: bigint | null
  }

  export type New_committeeCountAggregateOutputType = {
    id: number
    gov_action_proposal_id: number
    deleted_members: number
    added_members: number
    quorum_numerator: number
    quorum_denominator: number
    _all: number
  }


  export type New_committeeAvgAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type New_committeeSumAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type New_committeeMinAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    deleted_members?: true
    added_members?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type New_committeeMaxAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    deleted_members?: true
    added_members?: true
    quorum_numerator?: true
    quorum_denominator?: true
  }

  export type New_committeeCountAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    deleted_members?: true
    added_members?: true
    quorum_numerator?: true
    quorum_denominator?: true
    _all?: true
  }

  export type New_committeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_committee to aggregate.
     */
    where?: new_committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_committees to fetch.
     */
    orderBy?: new_committeeOrderByWithRelationInput | new_committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: new_committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned new_committees
    **/
    _count?: true | New_committeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: New_committeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: New_committeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: New_committeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: New_committeeMaxAggregateInputType
  }

  export type GetNew_committeeAggregateType<T extends New_committeeAggregateArgs> = {
        [P in keyof T & keyof AggregateNew_committee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNew_committee[P]>
      : GetScalarType<T[P], AggregateNew_committee[P]>
  }




  export type new_committeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: new_committeeWhereInput
    orderBy?: new_committeeOrderByWithAggregationInput | new_committeeOrderByWithAggregationInput[]
    by: New_committeeScalarFieldEnum[] | New_committeeScalarFieldEnum
    having?: new_committeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: New_committeeCountAggregateInputType | true
    _avg?: New_committeeAvgAggregateInputType
    _sum?: New_committeeSumAggregateInputType
    _min?: New_committeeMinAggregateInputType
    _max?: New_committeeMaxAggregateInputType
  }

  export type New_committeeGroupByOutputType = {
    id: bigint
    gov_action_proposal_id: bigint
    deleted_members: string
    added_members: string
    quorum_numerator: bigint
    quorum_denominator: bigint
    _count: New_committeeCountAggregateOutputType | null
    _avg: New_committeeAvgAggregateOutputType | null
    _sum: New_committeeSumAggregateOutputType | null
    _min: New_committeeMinAggregateOutputType | null
    _max: New_committeeMaxAggregateOutputType | null
  }

  type GetNew_committeeGroupByPayload<T extends new_committeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<New_committeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof New_committeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], New_committeeGroupByOutputType[P]>
            : GetScalarType<T[P], New_committeeGroupByOutputType[P]>
        }
      >
    >


  export type new_committeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    deleted_members?: boolean
    added_members?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }, ExtArgs["result"]["new_committee"]>

  export type new_committeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    deleted_members?: boolean
    added_members?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }, ExtArgs["result"]["new_committee"]>

  export type new_committeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    deleted_members?: boolean
    added_members?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }, ExtArgs["result"]["new_committee"]>

  export type new_committeeSelectScalar = {
    id?: boolean
    gov_action_proposal_id?: boolean
    deleted_members?: boolean
    added_members?: boolean
    quorum_numerator?: boolean
    quorum_denominator?: boolean
  }

  export type new_committeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gov_action_proposal_id" | "deleted_members" | "added_members" | "quorum_numerator" | "quorum_denominator", ExtArgs["result"]["new_committee"]>

  export type $new_committeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "new_committee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      gov_action_proposal_id: bigint
      deleted_members: string
      added_members: string
      quorum_numerator: bigint
      quorum_denominator: bigint
    }, ExtArgs["result"]["new_committee"]>
    composites: {}
  }

  type new_committeeGetPayload<S extends boolean | null | undefined | new_committeeDefaultArgs> = $Result.GetResult<Prisma.$new_committeePayload, S>

  type new_committeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<new_committeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: New_committeeCountAggregateInputType | true
    }

  export interface new_committeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['new_committee'], meta: { name: 'new_committee' } }
    /**
     * Find zero or one New_committee that matches the filter.
     * @param {new_committeeFindUniqueArgs} args - Arguments to find a New_committee
     * @example
     * // Get one New_committee
     * const new_committee = await prisma.new_committee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends new_committeeFindUniqueArgs>(args: SelectSubset<T, new_committeeFindUniqueArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one New_committee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {new_committeeFindUniqueOrThrowArgs} args - Arguments to find a New_committee
     * @example
     * // Get one New_committee
     * const new_committee = await prisma.new_committee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends new_committeeFindUniqueOrThrowArgs>(args: SelectSubset<T, new_committeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first New_committee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeFindFirstArgs} args - Arguments to find a New_committee
     * @example
     * // Get one New_committee
     * const new_committee = await prisma.new_committee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends new_committeeFindFirstArgs>(args?: SelectSubset<T, new_committeeFindFirstArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first New_committee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeFindFirstOrThrowArgs} args - Arguments to find a New_committee
     * @example
     * // Get one New_committee
     * const new_committee = await prisma.new_committee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends new_committeeFindFirstOrThrowArgs>(args?: SelectSubset<T, new_committeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more New_committees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all New_committees
     * const new_committees = await prisma.new_committee.findMany()
     * 
     * // Get first 10 New_committees
     * const new_committees = await prisma.new_committee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const new_committeeWithIdOnly = await prisma.new_committee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends new_committeeFindManyArgs>(args?: SelectSubset<T, new_committeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a New_committee.
     * @param {new_committeeCreateArgs} args - Arguments to create a New_committee.
     * @example
     * // Create one New_committee
     * const New_committee = await prisma.new_committee.create({
     *   data: {
     *     // ... data to create a New_committee
     *   }
     * })
     * 
     */
    create<T extends new_committeeCreateArgs>(args: SelectSubset<T, new_committeeCreateArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many New_committees.
     * @param {new_committeeCreateManyArgs} args - Arguments to create many New_committees.
     * @example
     * // Create many New_committees
     * const new_committee = await prisma.new_committee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends new_committeeCreateManyArgs>(args?: SelectSubset<T, new_committeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many New_committees and returns the data saved in the database.
     * @param {new_committeeCreateManyAndReturnArgs} args - Arguments to create many New_committees.
     * @example
     * // Create many New_committees
     * const new_committee = await prisma.new_committee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many New_committees and only return the `id`
     * const new_committeeWithIdOnly = await prisma.new_committee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends new_committeeCreateManyAndReturnArgs>(args?: SelectSubset<T, new_committeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a New_committee.
     * @param {new_committeeDeleteArgs} args - Arguments to delete one New_committee.
     * @example
     * // Delete one New_committee
     * const New_committee = await prisma.new_committee.delete({
     *   where: {
     *     // ... filter to delete one New_committee
     *   }
     * })
     * 
     */
    delete<T extends new_committeeDeleteArgs>(args: SelectSubset<T, new_committeeDeleteArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one New_committee.
     * @param {new_committeeUpdateArgs} args - Arguments to update one New_committee.
     * @example
     * // Update one New_committee
     * const new_committee = await prisma.new_committee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends new_committeeUpdateArgs>(args: SelectSubset<T, new_committeeUpdateArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more New_committees.
     * @param {new_committeeDeleteManyArgs} args - Arguments to filter New_committees to delete.
     * @example
     * // Delete a few New_committees
     * const { count } = await prisma.new_committee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends new_committeeDeleteManyArgs>(args?: SelectSubset<T, new_committeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more New_committees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many New_committees
     * const new_committee = await prisma.new_committee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends new_committeeUpdateManyArgs>(args: SelectSubset<T, new_committeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more New_committees and returns the data updated in the database.
     * @param {new_committeeUpdateManyAndReturnArgs} args - Arguments to update many New_committees.
     * @example
     * // Update many New_committees
     * const new_committee = await prisma.new_committee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more New_committees and only return the `id`
     * const new_committeeWithIdOnly = await prisma.new_committee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends new_committeeUpdateManyAndReturnArgs>(args: SelectSubset<T, new_committeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one New_committee.
     * @param {new_committeeUpsertArgs} args - Arguments to update or create a New_committee.
     * @example
     * // Update or create a New_committee
     * const new_committee = await prisma.new_committee.upsert({
     *   create: {
     *     // ... data to create a New_committee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the New_committee we want to update
     *   }
     * })
     */
    upsert<T extends new_committeeUpsertArgs>(args: SelectSubset<T, new_committeeUpsertArgs<ExtArgs>>): Prisma__new_committeeClient<$Result.GetResult<Prisma.$new_committeePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of New_committees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeCountArgs} args - Arguments to filter New_committees to count.
     * @example
     * // Count the number of New_committees
     * const count = await prisma.new_committee.count({
     *   where: {
     *     // ... the filter for the New_committees we want to count
     *   }
     * })
    **/
    count<T extends new_committeeCountArgs>(
      args?: Subset<T, new_committeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], New_committeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a New_committee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {New_committeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends New_committeeAggregateArgs>(args: Subset<T, New_committeeAggregateArgs>): Prisma.PrismaPromise<GetNew_committeeAggregateType<T>>

    /**
     * Group by New_committee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_committeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends new_committeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: new_committeeGroupByArgs['orderBy'] }
        : { orderBy?: new_committeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, new_committeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNew_committeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the new_committee model
   */
  readonly fields: new_committeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for new_committee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__new_committeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the new_committee model
   */ 
  interface new_committeeFieldRefs {
    readonly id: FieldRef<"new_committee", 'BigInt'>
    readonly gov_action_proposal_id: FieldRef<"new_committee", 'BigInt'>
    readonly deleted_members: FieldRef<"new_committee", 'String'>
    readonly added_members: FieldRef<"new_committee", 'String'>
    readonly quorum_numerator: FieldRef<"new_committee", 'BigInt'>
    readonly quorum_denominator: FieldRef<"new_committee", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * new_committee findUnique
   */
  export type new_committeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter, which new_committee to fetch.
     */
    where: new_committeeWhereUniqueInput
  }

  /**
   * new_committee findUniqueOrThrow
   */
  export type new_committeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter, which new_committee to fetch.
     */
    where: new_committeeWhereUniqueInput
  }

  /**
   * new_committee findFirst
   */
  export type new_committeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter, which new_committee to fetch.
     */
    where?: new_committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_committees to fetch.
     */
    orderBy?: new_committeeOrderByWithRelationInput | new_committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_committees.
     */
    cursor?: new_committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_committees.
     */
    distinct?: New_committeeScalarFieldEnum | New_committeeScalarFieldEnum[]
  }

  /**
   * new_committee findFirstOrThrow
   */
  export type new_committeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter, which new_committee to fetch.
     */
    where?: new_committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_committees to fetch.
     */
    orderBy?: new_committeeOrderByWithRelationInput | new_committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_committees.
     */
    cursor?: new_committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_committees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_committees.
     */
    distinct?: New_committeeScalarFieldEnum | New_committeeScalarFieldEnum[]
  }

  /**
   * new_committee findMany
   */
  export type new_committeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter, which new_committees to fetch.
     */
    where?: new_committeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_committees to fetch.
     */
    orderBy?: new_committeeOrderByWithRelationInput | new_committeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing new_committees.
     */
    cursor?: new_committeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_committees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_committees.
     */
    skip?: number
    distinct?: New_committeeScalarFieldEnum | New_committeeScalarFieldEnum[]
  }

  /**
   * new_committee create
   */
  export type new_committeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * The data needed to create a new_committee.
     */
    data: XOR<new_committeeCreateInput, new_committeeUncheckedCreateInput>
  }

  /**
   * new_committee createMany
   */
  export type new_committeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many new_committees.
     */
    data: new_committeeCreateManyInput | new_committeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * new_committee createManyAndReturn
   */
  export type new_committeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * The data used to create many new_committees.
     */
    data: new_committeeCreateManyInput | new_committeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * new_committee update
   */
  export type new_committeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * The data needed to update a new_committee.
     */
    data: XOR<new_committeeUpdateInput, new_committeeUncheckedUpdateInput>
    /**
     * Choose, which new_committee to update.
     */
    where: new_committeeWhereUniqueInput
  }

  /**
   * new_committee updateMany
   */
  export type new_committeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update new_committees.
     */
    data: XOR<new_committeeUpdateManyMutationInput, new_committeeUncheckedUpdateManyInput>
    /**
     * Filter which new_committees to update
     */
    where?: new_committeeWhereInput
    /**
     * Limit how many new_committees to update.
     */
    limit?: number
  }

  /**
   * new_committee updateManyAndReturn
   */
  export type new_committeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * The data used to update new_committees.
     */
    data: XOR<new_committeeUpdateManyMutationInput, new_committeeUncheckedUpdateManyInput>
    /**
     * Filter which new_committees to update
     */
    where?: new_committeeWhereInput
    /**
     * Limit how many new_committees to update.
     */
    limit?: number
  }

  /**
   * new_committee upsert
   */
  export type new_committeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * The filter to search for the new_committee to update in case it exists.
     */
    where: new_committeeWhereUniqueInput
    /**
     * In case the new_committee found by the `where` argument doesn't exist, create a new new_committee with this data.
     */
    create: XOR<new_committeeCreateInput, new_committeeUncheckedCreateInput>
    /**
     * In case the new_committee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<new_committeeUpdateInput, new_committeeUncheckedUpdateInput>
  }

  /**
   * new_committee delete
   */
  export type new_committeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
    /**
     * Filter which new_committee to delete.
     */
    where: new_committeeWhereUniqueInput
  }

  /**
   * new_committee deleteMany
   */
  export type new_committeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_committees to delete
     */
    where?: new_committeeWhereInput
    /**
     * Limit how many new_committees to delete.
     */
    limit?: number
  }

  /**
   * new_committee without action
   */
  export type new_committeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_committee
     */
    select?: new_committeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_committee
     */
    omit?: new_committeeOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_pool_data
   */

  export type AggregateOff_chain_pool_data = {
    _count: Off_chain_pool_dataCountAggregateOutputType | null
    _avg: Off_chain_pool_dataAvgAggregateOutputType | null
    _sum: Off_chain_pool_dataSumAggregateOutputType | null
    _min: Off_chain_pool_dataMinAggregateOutputType | null
    _max: Off_chain_pool_dataMaxAggregateOutputType | null
  }

  export type Off_chain_pool_dataAvgAggregateOutputType = {
    id: number | null
    pool_id: number | null
    pmr_id: number | null
  }

  export type Off_chain_pool_dataSumAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    pmr_id: bigint | null
  }

  export type Off_chain_pool_dataMinAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    ticker_name: string | null
    hash: Uint8Array | null
    bytes: Uint8Array | null
    pmr_id: bigint | null
  }

  export type Off_chain_pool_dataMaxAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    ticker_name: string | null
    hash: Uint8Array | null
    bytes: Uint8Array | null
    pmr_id: bigint | null
  }

  export type Off_chain_pool_dataCountAggregateOutputType = {
    id: number
    pool_id: number
    ticker_name: number
    hash: number
    json: number
    bytes: number
    pmr_id: number
    _all: number
  }


  export type Off_chain_pool_dataAvgAggregateInputType = {
    id?: true
    pool_id?: true
    pmr_id?: true
  }

  export type Off_chain_pool_dataSumAggregateInputType = {
    id?: true
    pool_id?: true
    pmr_id?: true
  }

  export type Off_chain_pool_dataMinAggregateInputType = {
    id?: true
    pool_id?: true
    ticker_name?: true
    hash?: true
    bytes?: true
    pmr_id?: true
  }

  export type Off_chain_pool_dataMaxAggregateInputType = {
    id?: true
    pool_id?: true
    ticker_name?: true
    hash?: true
    bytes?: true
    pmr_id?: true
  }

  export type Off_chain_pool_dataCountAggregateInputType = {
    id?: true
    pool_id?: true
    ticker_name?: true
    hash?: true
    json?: true
    bytes?: true
    pmr_id?: true
    _all?: true
  }

  export type Off_chain_pool_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_pool_data to aggregate.
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_data to fetch.
     */
    orderBy?: off_chain_pool_dataOrderByWithRelationInput | off_chain_pool_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_pool_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_pool_data
    **/
    _count?: true | Off_chain_pool_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_pool_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_pool_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_pool_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_pool_dataMaxAggregateInputType
  }

  export type GetOff_chain_pool_dataAggregateType<T extends Off_chain_pool_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_pool_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_pool_data[P]>
      : GetScalarType<T[P], AggregateOff_chain_pool_data[P]>
  }




  export type off_chain_pool_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_pool_dataWhereInput
    orderBy?: off_chain_pool_dataOrderByWithAggregationInput | off_chain_pool_dataOrderByWithAggregationInput[]
    by: Off_chain_pool_dataScalarFieldEnum[] | Off_chain_pool_dataScalarFieldEnum
    having?: off_chain_pool_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_pool_dataCountAggregateInputType | true
    _avg?: Off_chain_pool_dataAvgAggregateInputType
    _sum?: Off_chain_pool_dataSumAggregateInputType
    _min?: Off_chain_pool_dataMinAggregateInputType
    _max?: Off_chain_pool_dataMaxAggregateInputType
  }

  export type Off_chain_pool_dataGroupByOutputType = {
    id: bigint
    pool_id: bigint
    ticker_name: string
    hash: Uint8Array
    json: JsonValue
    bytes: Uint8Array
    pmr_id: bigint
    _count: Off_chain_pool_dataCountAggregateOutputType | null
    _avg: Off_chain_pool_dataAvgAggregateOutputType | null
    _sum: Off_chain_pool_dataSumAggregateOutputType | null
    _min: Off_chain_pool_dataMinAggregateOutputType | null
    _max: Off_chain_pool_dataMaxAggregateOutputType | null
  }

  type GetOff_chain_pool_dataGroupByPayload<T extends off_chain_pool_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_pool_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_pool_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_pool_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_pool_dataGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_pool_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    ticker_name?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    pmr_id?: boolean
  }, ExtArgs["result"]["off_chain_pool_data"]>

  export type off_chain_pool_dataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    ticker_name?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    pmr_id?: boolean
  }, ExtArgs["result"]["off_chain_pool_data"]>

  export type off_chain_pool_dataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    ticker_name?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    pmr_id?: boolean
  }, ExtArgs["result"]["off_chain_pool_data"]>

  export type off_chain_pool_dataSelectScalar = {
    id?: boolean
    pool_id?: boolean
    ticker_name?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    pmr_id?: boolean
  }

  export type off_chain_pool_dataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pool_id" | "ticker_name" | "hash" | "json" | "bytes" | "pmr_id", ExtArgs["result"]["off_chain_pool_data"]>

  export type $off_chain_pool_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_pool_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      pool_id: bigint
      ticker_name: string
      hash: Uint8Array
      json: Prisma.JsonValue
      bytes: Uint8Array
      pmr_id: bigint
    }, ExtArgs["result"]["off_chain_pool_data"]>
    composites: {}
  }

  type off_chain_pool_dataGetPayload<S extends boolean | null | undefined | off_chain_pool_dataDefaultArgs> = $Result.GetResult<Prisma.$off_chain_pool_dataPayload, S>

  type off_chain_pool_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_pool_dataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_pool_dataCountAggregateInputType | true
    }

  export interface off_chain_pool_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_pool_data'], meta: { name: 'off_chain_pool_data' } }
    /**
     * Find zero or one Off_chain_pool_data that matches the filter.
     * @param {off_chain_pool_dataFindUniqueArgs} args - Arguments to find a Off_chain_pool_data
     * @example
     * // Get one Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_pool_dataFindUniqueArgs>(args: SelectSubset<T, off_chain_pool_dataFindUniqueArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_pool_data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_pool_dataFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_pool_data
     * @example
     * // Get one Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_pool_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_pool_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_pool_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataFindFirstArgs} args - Arguments to find a Off_chain_pool_data
     * @example
     * // Get one Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_pool_dataFindFirstArgs>(args?: SelectSubset<T, off_chain_pool_dataFindFirstArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_pool_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataFindFirstOrThrowArgs} args - Arguments to find a Off_chain_pool_data
     * @example
     * // Get one Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_pool_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_pool_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_pool_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findMany()
     * 
     * // Get first 10 Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_pool_dataWithIdOnly = await prisma.off_chain_pool_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_pool_dataFindManyArgs>(args?: SelectSubset<T, off_chain_pool_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_pool_data.
     * @param {off_chain_pool_dataCreateArgs} args - Arguments to create a Off_chain_pool_data.
     * @example
     * // Create one Off_chain_pool_data
     * const Off_chain_pool_data = await prisma.off_chain_pool_data.create({
     *   data: {
     *     // ... data to create a Off_chain_pool_data
     *   }
     * })
     * 
     */
    create<T extends off_chain_pool_dataCreateArgs>(args: SelectSubset<T, off_chain_pool_dataCreateArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_pool_data.
     * @param {off_chain_pool_dataCreateManyArgs} args - Arguments to create many Off_chain_pool_data.
     * @example
     * // Create many Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_pool_dataCreateManyArgs>(args?: SelectSubset<T, off_chain_pool_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_pool_data and returns the data saved in the database.
     * @param {off_chain_pool_dataCreateManyAndReturnArgs} args - Arguments to create many Off_chain_pool_data.
     * @example
     * // Create many Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_pool_data and only return the `id`
     * const off_chain_pool_dataWithIdOnly = await prisma.off_chain_pool_data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_pool_dataCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_pool_dataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_pool_data.
     * @param {off_chain_pool_dataDeleteArgs} args - Arguments to delete one Off_chain_pool_data.
     * @example
     * // Delete one Off_chain_pool_data
     * const Off_chain_pool_data = await prisma.off_chain_pool_data.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_pool_data
     *   }
     * })
     * 
     */
    delete<T extends off_chain_pool_dataDeleteArgs>(args: SelectSubset<T, off_chain_pool_dataDeleteArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_pool_data.
     * @param {off_chain_pool_dataUpdateArgs} args - Arguments to update one Off_chain_pool_data.
     * @example
     * // Update one Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_pool_dataUpdateArgs>(args: SelectSubset<T, off_chain_pool_dataUpdateArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_pool_data.
     * @param {off_chain_pool_dataDeleteManyArgs} args - Arguments to filter Off_chain_pool_data to delete.
     * @example
     * // Delete a few Off_chain_pool_data
     * const { count } = await prisma.off_chain_pool_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_pool_dataDeleteManyArgs>(args?: SelectSubset<T, off_chain_pool_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_pool_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_pool_dataUpdateManyArgs>(args: SelectSubset<T, off_chain_pool_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_pool_data and returns the data updated in the database.
     * @param {off_chain_pool_dataUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_pool_data.
     * @example
     * // Update many Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_pool_data and only return the `id`
     * const off_chain_pool_dataWithIdOnly = await prisma.off_chain_pool_data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_pool_dataUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_pool_dataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_pool_data.
     * @param {off_chain_pool_dataUpsertArgs} args - Arguments to update or create a Off_chain_pool_data.
     * @example
     * // Update or create a Off_chain_pool_data
     * const off_chain_pool_data = await prisma.off_chain_pool_data.upsert({
     *   create: {
     *     // ... data to create a Off_chain_pool_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_pool_data we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_pool_dataUpsertArgs>(args: SelectSubset<T, off_chain_pool_dataUpsertArgs<ExtArgs>>): Prisma__off_chain_pool_dataClient<$Result.GetResult<Prisma.$off_chain_pool_dataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_pool_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataCountArgs} args - Arguments to filter Off_chain_pool_data to count.
     * @example
     * // Count the number of Off_chain_pool_data
     * const count = await prisma.off_chain_pool_data.count({
     *   where: {
     *     // ... the filter for the Off_chain_pool_data we want to count
     *   }
     * })
    **/
    count<T extends off_chain_pool_dataCountArgs>(
      args?: Subset<T, off_chain_pool_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_pool_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_pool_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_pool_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_pool_dataAggregateArgs>(args: Subset<T, Off_chain_pool_dataAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_pool_dataAggregateType<T>>

    /**
     * Group by Off_chain_pool_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_pool_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_pool_dataGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_pool_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_pool_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_pool_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_pool_data model
   */
  readonly fields: off_chain_pool_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_pool_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_pool_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_pool_data model
   */ 
  interface off_chain_pool_dataFieldRefs {
    readonly id: FieldRef<"off_chain_pool_data", 'BigInt'>
    readonly pool_id: FieldRef<"off_chain_pool_data", 'BigInt'>
    readonly ticker_name: FieldRef<"off_chain_pool_data", 'String'>
    readonly hash: FieldRef<"off_chain_pool_data", 'Bytes'>
    readonly json: FieldRef<"off_chain_pool_data", 'Json'>
    readonly bytes: FieldRef<"off_chain_pool_data", 'Bytes'>
    readonly pmr_id: FieldRef<"off_chain_pool_data", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_pool_data findUnique
   */
  export type off_chain_pool_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_data to fetch.
     */
    where: off_chain_pool_dataWhereUniqueInput
  }

  /**
   * off_chain_pool_data findUniqueOrThrow
   */
  export type off_chain_pool_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_data to fetch.
     */
    where: off_chain_pool_dataWhereUniqueInput
  }

  /**
   * off_chain_pool_data findFirst
   */
  export type off_chain_pool_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_data to fetch.
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_data to fetch.
     */
    orderBy?: off_chain_pool_dataOrderByWithRelationInput | off_chain_pool_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_pool_data.
     */
    cursor?: off_chain_pool_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_pool_data.
     */
    distinct?: Off_chain_pool_dataScalarFieldEnum | Off_chain_pool_dataScalarFieldEnum[]
  }

  /**
   * off_chain_pool_data findFirstOrThrow
   */
  export type off_chain_pool_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_data to fetch.
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_data to fetch.
     */
    orderBy?: off_chain_pool_dataOrderByWithRelationInput | off_chain_pool_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_pool_data.
     */
    cursor?: off_chain_pool_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_pool_data.
     */
    distinct?: Off_chain_pool_dataScalarFieldEnum | Off_chain_pool_dataScalarFieldEnum[]
  }

  /**
   * off_chain_pool_data findMany
   */
  export type off_chain_pool_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_data to fetch.
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_data to fetch.
     */
    orderBy?: off_chain_pool_dataOrderByWithRelationInput | off_chain_pool_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_pool_data.
     */
    cursor?: off_chain_pool_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_data.
     */
    skip?: number
    distinct?: Off_chain_pool_dataScalarFieldEnum | Off_chain_pool_dataScalarFieldEnum[]
  }

  /**
   * off_chain_pool_data create
   */
  export type off_chain_pool_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_pool_data.
     */
    data: XOR<off_chain_pool_dataCreateInput, off_chain_pool_dataUncheckedCreateInput>
  }

  /**
   * off_chain_pool_data createMany
   */
  export type off_chain_pool_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_pool_data.
     */
    data: off_chain_pool_dataCreateManyInput | off_chain_pool_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_pool_data createManyAndReturn
   */
  export type off_chain_pool_dataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_pool_data.
     */
    data: off_chain_pool_dataCreateManyInput | off_chain_pool_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_pool_data update
   */
  export type off_chain_pool_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_pool_data.
     */
    data: XOR<off_chain_pool_dataUpdateInput, off_chain_pool_dataUncheckedUpdateInput>
    /**
     * Choose, which off_chain_pool_data to update.
     */
    where: off_chain_pool_dataWhereUniqueInput
  }

  /**
   * off_chain_pool_data updateMany
   */
  export type off_chain_pool_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_pool_data.
     */
    data: XOR<off_chain_pool_dataUpdateManyMutationInput, off_chain_pool_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_pool_data to update
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * Limit how many off_chain_pool_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_pool_data updateManyAndReturn
   */
  export type off_chain_pool_dataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_pool_data.
     */
    data: XOR<off_chain_pool_dataUpdateManyMutationInput, off_chain_pool_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_pool_data to update
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * Limit how many off_chain_pool_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_pool_data upsert
   */
  export type off_chain_pool_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_pool_data to update in case it exists.
     */
    where: off_chain_pool_dataWhereUniqueInput
    /**
     * In case the off_chain_pool_data found by the `where` argument doesn't exist, create a new off_chain_pool_data with this data.
     */
    create: XOR<off_chain_pool_dataCreateInput, off_chain_pool_dataUncheckedCreateInput>
    /**
     * In case the off_chain_pool_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_pool_dataUpdateInput, off_chain_pool_dataUncheckedUpdateInput>
  }

  /**
   * off_chain_pool_data delete
   */
  export type off_chain_pool_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
    /**
     * Filter which off_chain_pool_data to delete.
     */
    where: off_chain_pool_dataWhereUniqueInput
  }

  /**
   * off_chain_pool_data deleteMany
   */
  export type off_chain_pool_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_pool_data to delete
     */
    where?: off_chain_pool_dataWhereInput
    /**
     * Limit how many off_chain_pool_data to delete.
     */
    limit?: number
  }

  /**
   * off_chain_pool_data without action
   */
  export type off_chain_pool_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_data
     */
    select?: off_chain_pool_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_data
     */
    omit?: off_chain_pool_dataOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_pool_fetch_error
   */

  export type AggregateOff_chain_pool_fetch_error = {
    _count: Off_chain_pool_fetch_errorCountAggregateOutputType | null
    _avg: Off_chain_pool_fetch_errorAvgAggregateOutputType | null
    _sum: Off_chain_pool_fetch_errorSumAggregateOutputType | null
    _min: Off_chain_pool_fetch_errorMinAggregateOutputType | null
    _max: Off_chain_pool_fetch_errorMaxAggregateOutputType | null
  }

  export type Off_chain_pool_fetch_errorAvgAggregateOutputType = {
    id: number | null
    pool_id: number | null
    pmr_id: number | null
    retry_count: number | null
  }

  export type Off_chain_pool_fetch_errorSumAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    pmr_id: bigint | null
    retry_count: number | null
  }

  export type Off_chain_pool_fetch_errorMinAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    fetch_time: Date | null
    pmr_id: bigint | null
    fetch_error: string | null
    retry_count: number | null
  }

  export type Off_chain_pool_fetch_errorMaxAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    fetch_time: Date | null
    pmr_id: bigint | null
    fetch_error: string | null
    retry_count: number | null
  }

  export type Off_chain_pool_fetch_errorCountAggregateOutputType = {
    id: number
    pool_id: number
    fetch_time: number
    pmr_id: number
    fetch_error: number
    retry_count: number
    _all: number
  }


  export type Off_chain_pool_fetch_errorAvgAggregateInputType = {
    id?: true
    pool_id?: true
    pmr_id?: true
    retry_count?: true
  }

  export type Off_chain_pool_fetch_errorSumAggregateInputType = {
    id?: true
    pool_id?: true
    pmr_id?: true
    retry_count?: true
  }

  export type Off_chain_pool_fetch_errorMinAggregateInputType = {
    id?: true
    pool_id?: true
    fetch_time?: true
    pmr_id?: true
    fetch_error?: true
    retry_count?: true
  }

  export type Off_chain_pool_fetch_errorMaxAggregateInputType = {
    id?: true
    pool_id?: true
    fetch_time?: true
    pmr_id?: true
    fetch_error?: true
    retry_count?: true
  }

  export type Off_chain_pool_fetch_errorCountAggregateInputType = {
    id?: true
    pool_id?: true
    fetch_time?: true
    pmr_id?: true
    fetch_error?: true
    retry_count?: true
    _all?: true
  }

  export type Off_chain_pool_fetch_errorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_pool_fetch_error to aggregate.
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_fetch_errors to fetch.
     */
    orderBy?: off_chain_pool_fetch_errorOrderByWithRelationInput | off_chain_pool_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_pool_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_pool_fetch_errors
    **/
    _count?: true | Off_chain_pool_fetch_errorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_pool_fetch_errorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_pool_fetch_errorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_pool_fetch_errorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_pool_fetch_errorMaxAggregateInputType
  }

  export type GetOff_chain_pool_fetch_errorAggregateType<T extends Off_chain_pool_fetch_errorAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_pool_fetch_error]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_pool_fetch_error[P]>
      : GetScalarType<T[P], AggregateOff_chain_pool_fetch_error[P]>
  }




  export type off_chain_pool_fetch_errorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_pool_fetch_errorWhereInput
    orderBy?: off_chain_pool_fetch_errorOrderByWithAggregationInput | off_chain_pool_fetch_errorOrderByWithAggregationInput[]
    by: Off_chain_pool_fetch_errorScalarFieldEnum[] | Off_chain_pool_fetch_errorScalarFieldEnum
    having?: off_chain_pool_fetch_errorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_pool_fetch_errorCountAggregateInputType | true
    _avg?: Off_chain_pool_fetch_errorAvgAggregateInputType
    _sum?: Off_chain_pool_fetch_errorSumAggregateInputType
    _min?: Off_chain_pool_fetch_errorMinAggregateInputType
    _max?: Off_chain_pool_fetch_errorMaxAggregateInputType
  }

  export type Off_chain_pool_fetch_errorGroupByOutputType = {
    id: bigint
    pool_id: bigint
    fetch_time: Date
    pmr_id: bigint
    fetch_error: string
    retry_count: number
    _count: Off_chain_pool_fetch_errorCountAggregateOutputType | null
    _avg: Off_chain_pool_fetch_errorAvgAggregateOutputType | null
    _sum: Off_chain_pool_fetch_errorSumAggregateOutputType | null
    _min: Off_chain_pool_fetch_errorMinAggregateOutputType | null
    _max: Off_chain_pool_fetch_errorMaxAggregateOutputType | null
  }

  type GetOff_chain_pool_fetch_errorGroupByPayload<T extends off_chain_pool_fetch_errorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_pool_fetch_errorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_pool_fetch_errorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_pool_fetch_errorGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_pool_fetch_errorGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_pool_fetch_errorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    fetch_time?: boolean
    pmr_id?: boolean
    fetch_error?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_pool_fetch_error"]>

  export type off_chain_pool_fetch_errorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    fetch_time?: boolean
    pmr_id?: boolean
    fetch_error?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_pool_fetch_error"]>

  export type off_chain_pool_fetch_errorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    fetch_time?: boolean
    pmr_id?: boolean
    fetch_error?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_pool_fetch_error"]>

  export type off_chain_pool_fetch_errorSelectScalar = {
    id?: boolean
    pool_id?: boolean
    fetch_time?: boolean
    pmr_id?: boolean
    fetch_error?: boolean
    retry_count?: boolean
  }

  export type off_chain_pool_fetch_errorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pool_id" | "fetch_time" | "pmr_id" | "fetch_error" | "retry_count", ExtArgs["result"]["off_chain_pool_fetch_error"]>

  export type $off_chain_pool_fetch_errorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_pool_fetch_error"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      pool_id: bigint
      fetch_time: Date
      pmr_id: bigint
      fetch_error: string
      retry_count: number
    }, ExtArgs["result"]["off_chain_pool_fetch_error"]>
    composites: {}
  }

  type off_chain_pool_fetch_errorGetPayload<S extends boolean | null | undefined | off_chain_pool_fetch_errorDefaultArgs> = $Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload, S>

  type off_chain_pool_fetch_errorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_pool_fetch_errorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_pool_fetch_errorCountAggregateInputType | true
    }

  export interface off_chain_pool_fetch_errorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_pool_fetch_error'], meta: { name: 'off_chain_pool_fetch_error' } }
    /**
     * Find zero or one Off_chain_pool_fetch_error that matches the filter.
     * @param {off_chain_pool_fetch_errorFindUniqueArgs} args - Arguments to find a Off_chain_pool_fetch_error
     * @example
     * // Get one Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_pool_fetch_errorFindUniqueArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorFindUniqueArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_pool_fetch_error that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_pool_fetch_errorFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_pool_fetch_error
     * @example
     * // Get one Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_pool_fetch_errorFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_pool_fetch_error that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorFindFirstArgs} args - Arguments to find a Off_chain_pool_fetch_error
     * @example
     * // Get one Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_pool_fetch_errorFindFirstArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorFindFirstArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_pool_fetch_error that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorFindFirstOrThrowArgs} args - Arguments to find a Off_chain_pool_fetch_error
     * @example
     * // Get one Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_pool_fetch_errorFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_pool_fetch_errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_errors = await prisma.off_chain_pool_fetch_error.findMany()
     * 
     * // Get first 10 Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_errors = await prisma.off_chain_pool_fetch_error.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_pool_fetch_errorWithIdOnly = await prisma.off_chain_pool_fetch_error.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_pool_fetch_errorFindManyArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_pool_fetch_error.
     * @param {off_chain_pool_fetch_errorCreateArgs} args - Arguments to create a Off_chain_pool_fetch_error.
     * @example
     * // Create one Off_chain_pool_fetch_error
     * const Off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.create({
     *   data: {
     *     // ... data to create a Off_chain_pool_fetch_error
     *   }
     * })
     * 
     */
    create<T extends off_chain_pool_fetch_errorCreateArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorCreateArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_pool_fetch_errors.
     * @param {off_chain_pool_fetch_errorCreateManyArgs} args - Arguments to create many Off_chain_pool_fetch_errors.
     * @example
     * // Create many Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_pool_fetch_errorCreateManyArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_pool_fetch_errors and returns the data saved in the database.
     * @param {off_chain_pool_fetch_errorCreateManyAndReturnArgs} args - Arguments to create many Off_chain_pool_fetch_errors.
     * @example
     * // Create many Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_pool_fetch_errors and only return the `id`
     * const off_chain_pool_fetch_errorWithIdOnly = await prisma.off_chain_pool_fetch_error.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_pool_fetch_errorCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_pool_fetch_error.
     * @param {off_chain_pool_fetch_errorDeleteArgs} args - Arguments to delete one Off_chain_pool_fetch_error.
     * @example
     * // Delete one Off_chain_pool_fetch_error
     * const Off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_pool_fetch_error
     *   }
     * })
     * 
     */
    delete<T extends off_chain_pool_fetch_errorDeleteArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorDeleteArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_pool_fetch_error.
     * @param {off_chain_pool_fetch_errorUpdateArgs} args - Arguments to update one Off_chain_pool_fetch_error.
     * @example
     * // Update one Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_pool_fetch_errorUpdateArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorUpdateArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_pool_fetch_errors.
     * @param {off_chain_pool_fetch_errorDeleteManyArgs} args - Arguments to filter Off_chain_pool_fetch_errors to delete.
     * @example
     * // Delete a few Off_chain_pool_fetch_errors
     * const { count } = await prisma.off_chain_pool_fetch_error.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_pool_fetch_errorDeleteManyArgs>(args?: SelectSubset<T, off_chain_pool_fetch_errorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_pool_fetch_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_pool_fetch_errorUpdateManyArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_pool_fetch_errors and returns the data updated in the database.
     * @param {off_chain_pool_fetch_errorUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_pool_fetch_errors.
     * @example
     * // Update many Off_chain_pool_fetch_errors
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_pool_fetch_errors and only return the `id`
     * const off_chain_pool_fetch_errorWithIdOnly = await prisma.off_chain_pool_fetch_error.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_pool_fetch_errorUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_pool_fetch_error.
     * @param {off_chain_pool_fetch_errorUpsertArgs} args - Arguments to update or create a Off_chain_pool_fetch_error.
     * @example
     * // Update or create a Off_chain_pool_fetch_error
     * const off_chain_pool_fetch_error = await prisma.off_chain_pool_fetch_error.upsert({
     *   create: {
     *     // ... data to create a Off_chain_pool_fetch_error
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_pool_fetch_error we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_pool_fetch_errorUpsertArgs>(args: SelectSubset<T, off_chain_pool_fetch_errorUpsertArgs<ExtArgs>>): Prisma__off_chain_pool_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_pool_fetch_errorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_pool_fetch_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorCountArgs} args - Arguments to filter Off_chain_pool_fetch_errors to count.
     * @example
     * // Count the number of Off_chain_pool_fetch_errors
     * const count = await prisma.off_chain_pool_fetch_error.count({
     *   where: {
     *     // ... the filter for the Off_chain_pool_fetch_errors we want to count
     *   }
     * })
    **/
    count<T extends off_chain_pool_fetch_errorCountArgs>(
      args?: Subset<T, off_chain_pool_fetch_errorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_pool_fetch_errorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_pool_fetch_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_pool_fetch_errorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_pool_fetch_errorAggregateArgs>(args: Subset<T, Off_chain_pool_fetch_errorAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_pool_fetch_errorAggregateType<T>>

    /**
     * Group by Off_chain_pool_fetch_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_pool_fetch_errorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_pool_fetch_errorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_pool_fetch_errorGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_pool_fetch_errorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_pool_fetch_errorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_pool_fetch_errorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_pool_fetch_error model
   */
  readonly fields: off_chain_pool_fetch_errorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_pool_fetch_error.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_pool_fetch_errorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_pool_fetch_error model
   */ 
  interface off_chain_pool_fetch_errorFieldRefs {
    readonly id: FieldRef<"off_chain_pool_fetch_error", 'BigInt'>
    readonly pool_id: FieldRef<"off_chain_pool_fetch_error", 'BigInt'>
    readonly fetch_time: FieldRef<"off_chain_pool_fetch_error", 'DateTime'>
    readonly pmr_id: FieldRef<"off_chain_pool_fetch_error", 'BigInt'>
    readonly fetch_error: FieldRef<"off_chain_pool_fetch_error", 'String'>
    readonly retry_count: FieldRef<"off_chain_pool_fetch_error", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_pool_fetch_error findUnique
   */
  export type off_chain_pool_fetch_errorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_fetch_error to fetch.
     */
    where: off_chain_pool_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_pool_fetch_error findUniqueOrThrow
   */
  export type off_chain_pool_fetch_errorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_fetch_error to fetch.
     */
    where: off_chain_pool_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_pool_fetch_error findFirst
   */
  export type off_chain_pool_fetch_errorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_fetch_error to fetch.
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_fetch_errors to fetch.
     */
    orderBy?: off_chain_pool_fetch_errorOrderByWithRelationInput | off_chain_pool_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_pool_fetch_errors.
     */
    cursor?: off_chain_pool_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_pool_fetch_errors.
     */
    distinct?: Off_chain_pool_fetch_errorScalarFieldEnum | Off_chain_pool_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_pool_fetch_error findFirstOrThrow
   */
  export type off_chain_pool_fetch_errorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_fetch_error to fetch.
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_fetch_errors to fetch.
     */
    orderBy?: off_chain_pool_fetch_errorOrderByWithRelationInput | off_chain_pool_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_pool_fetch_errors.
     */
    cursor?: off_chain_pool_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_pool_fetch_errors.
     */
    distinct?: Off_chain_pool_fetch_errorScalarFieldEnum | Off_chain_pool_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_pool_fetch_error findMany
   */
  export type off_chain_pool_fetch_errorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_pool_fetch_errors to fetch.
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_pool_fetch_errors to fetch.
     */
    orderBy?: off_chain_pool_fetch_errorOrderByWithRelationInput | off_chain_pool_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_pool_fetch_errors.
     */
    cursor?: off_chain_pool_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_pool_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_pool_fetch_errors.
     */
    skip?: number
    distinct?: Off_chain_pool_fetch_errorScalarFieldEnum | Off_chain_pool_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_pool_fetch_error create
   */
  export type off_chain_pool_fetch_errorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_pool_fetch_error.
     */
    data: XOR<off_chain_pool_fetch_errorCreateInput, off_chain_pool_fetch_errorUncheckedCreateInput>
  }

  /**
   * off_chain_pool_fetch_error createMany
   */
  export type off_chain_pool_fetch_errorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_pool_fetch_errors.
     */
    data: off_chain_pool_fetch_errorCreateManyInput | off_chain_pool_fetch_errorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_pool_fetch_error createManyAndReturn
   */
  export type off_chain_pool_fetch_errorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_pool_fetch_errors.
     */
    data: off_chain_pool_fetch_errorCreateManyInput | off_chain_pool_fetch_errorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_pool_fetch_error update
   */
  export type off_chain_pool_fetch_errorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_pool_fetch_error.
     */
    data: XOR<off_chain_pool_fetch_errorUpdateInput, off_chain_pool_fetch_errorUncheckedUpdateInput>
    /**
     * Choose, which off_chain_pool_fetch_error to update.
     */
    where: off_chain_pool_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_pool_fetch_error updateMany
   */
  export type off_chain_pool_fetch_errorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_pool_fetch_errors.
     */
    data: XOR<off_chain_pool_fetch_errorUpdateManyMutationInput, off_chain_pool_fetch_errorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_pool_fetch_errors to update
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * Limit how many off_chain_pool_fetch_errors to update.
     */
    limit?: number
  }

  /**
   * off_chain_pool_fetch_error updateManyAndReturn
   */
  export type off_chain_pool_fetch_errorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_pool_fetch_errors.
     */
    data: XOR<off_chain_pool_fetch_errorUpdateManyMutationInput, off_chain_pool_fetch_errorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_pool_fetch_errors to update
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * Limit how many off_chain_pool_fetch_errors to update.
     */
    limit?: number
  }

  /**
   * off_chain_pool_fetch_error upsert
   */
  export type off_chain_pool_fetch_errorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_pool_fetch_error to update in case it exists.
     */
    where: off_chain_pool_fetch_errorWhereUniqueInput
    /**
     * In case the off_chain_pool_fetch_error found by the `where` argument doesn't exist, create a new off_chain_pool_fetch_error with this data.
     */
    create: XOR<off_chain_pool_fetch_errorCreateInput, off_chain_pool_fetch_errorUncheckedCreateInput>
    /**
     * In case the off_chain_pool_fetch_error was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_pool_fetch_errorUpdateInput, off_chain_pool_fetch_errorUncheckedUpdateInput>
  }

  /**
   * off_chain_pool_fetch_error delete
   */
  export type off_chain_pool_fetch_errorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter which off_chain_pool_fetch_error to delete.
     */
    where: off_chain_pool_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_pool_fetch_error deleteMany
   */
  export type off_chain_pool_fetch_errorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_pool_fetch_errors to delete
     */
    where?: off_chain_pool_fetch_errorWhereInput
    /**
     * Limit how many off_chain_pool_fetch_errors to delete.
     */
    limit?: number
  }

  /**
   * off_chain_pool_fetch_error without action
   */
  export type off_chain_pool_fetch_errorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_pool_fetch_error
     */
    select?: off_chain_pool_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_pool_fetch_error
     */
    omit?: off_chain_pool_fetch_errorOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_author
   */

  export type AggregateOff_chain_vote_author = {
    _count: Off_chain_vote_authorCountAggregateOutputType | null
    _avg: Off_chain_vote_authorAvgAggregateOutputType | null
    _sum: Off_chain_vote_authorSumAggregateOutputType | null
    _min: Off_chain_vote_authorMinAggregateOutputType | null
    _max: Off_chain_vote_authorMaxAggregateOutputType | null
  }

  export type Off_chain_vote_authorAvgAggregateOutputType = {
    id: number | null
    off_chain_vote_data_id: number | null
  }

  export type Off_chain_vote_authorSumAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
  }

  export type Off_chain_vote_authorMinAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    name: string | null
    witness_algorithm: string | null
    public_key: string | null
    signature: string | null
    warning: string | null
  }

  export type Off_chain_vote_authorMaxAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    name: string | null
    witness_algorithm: string | null
    public_key: string | null
    signature: string | null
    warning: string | null
  }

  export type Off_chain_vote_authorCountAggregateOutputType = {
    id: number
    off_chain_vote_data_id: number
    name: number
    witness_algorithm: number
    public_key: number
    signature: number
    warning: number
    _all: number
  }


  export type Off_chain_vote_authorAvgAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_authorSumAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_authorMinAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    name?: true
    witness_algorithm?: true
    public_key?: true
    signature?: true
    warning?: true
  }

  export type Off_chain_vote_authorMaxAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    name?: true
    witness_algorithm?: true
    public_key?: true
    signature?: true
    warning?: true
  }

  export type Off_chain_vote_authorCountAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    name?: true
    witness_algorithm?: true
    public_key?: true
    signature?: true
    warning?: true
    _all?: true
  }

  export type Off_chain_vote_authorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_author to aggregate.
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_authors to fetch.
     */
    orderBy?: off_chain_vote_authorOrderByWithRelationInput | off_chain_vote_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_authors
    **/
    _count?: true | Off_chain_vote_authorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_authorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_authorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_authorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_authorMaxAggregateInputType
  }

  export type GetOff_chain_vote_authorAggregateType<T extends Off_chain_vote_authorAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_author]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_author[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_author[P]>
  }




  export type off_chain_vote_authorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_authorWhereInput
    orderBy?: off_chain_vote_authorOrderByWithAggregationInput | off_chain_vote_authorOrderByWithAggregationInput[]
    by: Off_chain_vote_authorScalarFieldEnum[] | Off_chain_vote_authorScalarFieldEnum
    having?: off_chain_vote_authorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_authorCountAggregateInputType | true
    _avg?: Off_chain_vote_authorAvgAggregateInputType
    _sum?: Off_chain_vote_authorSumAggregateInputType
    _min?: Off_chain_vote_authorMinAggregateInputType
    _max?: Off_chain_vote_authorMaxAggregateInputType
  }

  export type Off_chain_vote_authorGroupByOutputType = {
    id: bigint
    off_chain_vote_data_id: bigint
    name: string | null
    witness_algorithm: string
    public_key: string
    signature: string
    warning: string | null
    _count: Off_chain_vote_authorCountAggregateOutputType | null
    _avg: Off_chain_vote_authorAvgAggregateOutputType | null
    _sum: Off_chain_vote_authorSumAggregateOutputType | null
    _min: Off_chain_vote_authorMinAggregateOutputType | null
    _max: Off_chain_vote_authorMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_authorGroupByPayload<T extends off_chain_vote_authorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_authorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_authorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_authorGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_authorGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_authorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    name?: boolean
    witness_algorithm?: boolean
    public_key?: boolean
    signature?: boolean
    warning?: boolean
  }, ExtArgs["result"]["off_chain_vote_author"]>

  export type off_chain_vote_authorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    name?: boolean
    witness_algorithm?: boolean
    public_key?: boolean
    signature?: boolean
    warning?: boolean
  }, ExtArgs["result"]["off_chain_vote_author"]>

  export type off_chain_vote_authorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    name?: boolean
    witness_algorithm?: boolean
    public_key?: boolean
    signature?: boolean
    warning?: boolean
  }, ExtArgs["result"]["off_chain_vote_author"]>

  export type off_chain_vote_authorSelectScalar = {
    id?: boolean
    off_chain_vote_data_id?: boolean
    name?: boolean
    witness_algorithm?: boolean
    public_key?: boolean
    signature?: boolean
    warning?: boolean
  }

  export type off_chain_vote_authorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "off_chain_vote_data_id" | "name" | "witness_algorithm" | "public_key" | "signature" | "warning", ExtArgs["result"]["off_chain_vote_author"]>

  export type $off_chain_vote_authorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_author"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      off_chain_vote_data_id: bigint
      name: string | null
      witness_algorithm: string
      public_key: string
      signature: string
      warning: string | null
    }, ExtArgs["result"]["off_chain_vote_author"]>
    composites: {}
  }

  type off_chain_vote_authorGetPayload<S extends boolean | null | undefined | off_chain_vote_authorDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_authorPayload, S>

  type off_chain_vote_authorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_authorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_authorCountAggregateInputType | true
    }

  export interface off_chain_vote_authorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_author'], meta: { name: 'off_chain_vote_author' } }
    /**
     * Find zero or one Off_chain_vote_author that matches the filter.
     * @param {off_chain_vote_authorFindUniqueArgs} args - Arguments to find a Off_chain_vote_author
     * @example
     * // Get one Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_authorFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_authorFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_authorFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_author
     * @example
     * // Get one Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_authorFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_authorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorFindFirstArgs} args - Arguments to find a Off_chain_vote_author
     * @example
     * // Get one Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_authorFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_authorFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_author
     * @example
     * // Get one Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_authorFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_authorFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_authors
     * const off_chain_vote_authors = await prisma.off_chain_vote_author.findMany()
     * 
     * // Get first 10 Off_chain_vote_authors
     * const off_chain_vote_authors = await prisma.off_chain_vote_author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_authorWithIdOnly = await prisma.off_chain_vote_author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_authorFindManyArgs>(args?: SelectSubset<T, off_chain_vote_authorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_author.
     * @param {off_chain_vote_authorCreateArgs} args - Arguments to create a Off_chain_vote_author.
     * @example
     * // Create one Off_chain_vote_author
     * const Off_chain_vote_author = await prisma.off_chain_vote_author.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_author
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_authorCreateArgs>(args: SelectSubset<T, off_chain_vote_authorCreateArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_authors.
     * @param {off_chain_vote_authorCreateManyArgs} args - Arguments to create many Off_chain_vote_authors.
     * @example
     * // Create many Off_chain_vote_authors
     * const off_chain_vote_author = await prisma.off_chain_vote_author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_authorCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_authorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_authors and returns the data saved in the database.
     * @param {off_chain_vote_authorCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_authors.
     * @example
     * // Create many Off_chain_vote_authors
     * const off_chain_vote_author = await prisma.off_chain_vote_author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_authors and only return the `id`
     * const off_chain_vote_authorWithIdOnly = await prisma.off_chain_vote_author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_authorCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_authorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_author.
     * @param {off_chain_vote_authorDeleteArgs} args - Arguments to delete one Off_chain_vote_author.
     * @example
     * // Delete one Off_chain_vote_author
     * const Off_chain_vote_author = await prisma.off_chain_vote_author.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_author
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_authorDeleteArgs>(args: SelectSubset<T, off_chain_vote_authorDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_author.
     * @param {off_chain_vote_authorUpdateArgs} args - Arguments to update one Off_chain_vote_author.
     * @example
     * // Update one Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_authorUpdateArgs>(args: SelectSubset<T, off_chain_vote_authorUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_authors.
     * @param {off_chain_vote_authorDeleteManyArgs} args - Arguments to filter Off_chain_vote_authors to delete.
     * @example
     * // Delete a few Off_chain_vote_authors
     * const { count } = await prisma.off_chain_vote_author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_authorDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_authorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_authors
     * const off_chain_vote_author = await prisma.off_chain_vote_author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_authorUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_authorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_authors and returns the data updated in the database.
     * @param {off_chain_vote_authorUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_authors.
     * @example
     * // Update many Off_chain_vote_authors
     * const off_chain_vote_author = await prisma.off_chain_vote_author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_authors and only return the `id`
     * const off_chain_vote_authorWithIdOnly = await prisma.off_chain_vote_author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_authorUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_authorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_author.
     * @param {off_chain_vote_authorUpsertArgs} args - Arguments to update or create a Off_chain_vote_author.
     * @example
     * // Update or create a Off_chain_vote_author
     * const off_chain_vote_author = await prisma.off_chain_vote_author.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_author we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_authorUpsertArgs>(args: SelectSubset<T, off_chain_vote_authorUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_authorClient<$Result.GetResult<Prisma.$off_chain_vote_authorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorCountArgs} args - Arguments to filter Off_chain_vote_authors to count.
     * @example
     * // Count the number of Off_chain_vote_authors
     * const count = await prisma.off_chain_vote_author.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_authors we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_authorCountArgs>(
      args?: Subset<T, off_chain_vote_authorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_authorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_authorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_authorAggregateArgs>(args: Subset<T, Off_chain_vote_authorAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_authorAggregateType<T>>

    /**
     * Group by Off_chain_vote_author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_authorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_authorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_authorGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_authorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_authorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_authorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_author model
   */
  readonly fields: off_chain_vote_authorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_authorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_author model
   */ 
  interface off_chain_vote_authorFieldRefs {
    readonly id: FieldRef<"off_chain_vote_author", 'BigInt'>
    readonly off_chain_vote_data_id: FieldRef<"off_chain_vote_author", 'BigInt'>
    readonly name: FieldRef<"off_chain_vote_author", 'String'>
    readonly witness_algorithm: FieldRef<"off_chain_vote_author", 'String'>
    readonly public_key: FieldRef<"off_chain_vote_author", 'String'>
    readonly signature: FieldRef<"off_chain_vote_author", 'String'>
    readonly warning: FieldRef<"off_chain_vote_author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_author findUnique
   */
  export type off_chain_vote_authorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_author to fetch.
     */
    where: off_chain_vote_authorWhereUniqueInput
  }

  /**
   * off_chain_vote_author findUniqueOrThrow
   */
  export type off_chain_vote_authorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_author to fetch.
     */
    where: off_chain_vote_authorWhereUniqueInput
  }

  /**
   * off_chain_vote_author findFirst
   */
  export type off_chain_vote_authorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_author to fetch.
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_authors to fetch.
     */
    orderBy?: off_chain_vote_authorOrderByWithRelationInput | off_chain_vote_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_authors.
     */
    cursor?: off_chain_vote_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_authors.
     */
    distinct?: Off_chain_vote_authorScalarFieldEnum | Off_chain_vote_authorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_author findFirstOrThrow
   */
  export type off_chain_vote_authorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_author to fetch.
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_authors to fetch.
     */
    orderBy?: off_chain_vote_authorOrderByWithRelationInput | off_chain_vote_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_authors.
     */
    cursor?: off_chain_vote_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_authors.
     */
    distinct?: Off_chain_vote_authorScalarFieldEnum | Off_chain_vote_authorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_author findMany
   */
  export type off_chain_vote_authorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_authors to fetch.
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_authors to fetch.
     */
    orderBy?: off_chain_vote_authorOrderByWithRelationInput | off_chain_vote_authorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_authors.
     */
    cursor?: off_chain_vote_authorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_authors.
     */
    skip?: number
    distinct?: Off_chain_vote_authorScalarFieldEnum | Off_chain_vote_authorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_author create
   */
  export type off_chain_vote_authorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_author.
     */
    data: XOR<off_chain_vote_authorCreateInput, off_chain_vote_authorUncheckedCreateInput>
  }

  /**
   * off_chain_vote_author createMany
   */
  export type off_chain_vote_authorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_authors.
     */
    data: off_chain_vote_authorCreateManyInput | off_chain_vote_authorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_author createManyAndReturn
   */
  export type off_chain_vote_authorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_authors.
     */
    data: off_chain_vote_authorCreateManyInput | off_chain_vote_authorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_author update
   */
  export type off_chain_vote_authorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_author.
     */
    data: XOR<off_chain_vote_authorUpdateInput, off_chain_vote_authorUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_author to update.
     */
    where: off_chain_vote_authorWhereUniqueInput
  }

  /**
   * off_chain_vote_author updateMany
   */
  export type off_chain_vote_authorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_authors.
     */
    data: XOR<off_chain_vote_authorUpdateManyMutationInput, off_chain_vote_authorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_authors to update
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * Limit how many off_chain_vote_authors to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_author updateManyAndReturn
   */
  export type off_chain_vote_authorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_authors.
     */
    data: XOR<off_chain_vote_authorUpdateManyMutationInput, off_chain_vote_authorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_authors to update
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * Limit how many off_chain_vote_authors to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_author upsert
   */
  export type off_chain_vote_authorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_author to update in case it exists.
     */
    where: off_chain_vote_authorWhereUniqueInput
    /**
     * In case the off_chain_vote_author found by the `where` argument doesn't exist, create a new off_chain_vote_author with this data.
     */
    create: XOR<off_chain_vote_authorCreateInput, off_chain_vote_authorUncheckedCreateInput>
    /**
     * In case the off_chain_vote_author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_authorUpdateInput, off_chain_vote_authorUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_author delete
   */
  export type off_chain_vote_authorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_author to delete.
     */
    where: off_chain_vote_authorWhereUniqueInput
  }

  /**
   * off_chain_vote_author deleteMany
   */
  export type off_chain_vote_authorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_authors to delete
     */
    where?: off_chain_vote_authorWhereInput
    /**
     * Limit how many off_chain_vote_authors to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_author without action
   */
  export type off_chain_vote_authorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_author
     */
    select?: off_chain_vote_authorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_author
     */
    omit?: off_chain_vote_authorOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_data
   */

  export type AggregateOff_chain_vote_data = {
    _count: Off_chain_vote_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_dataSumAggregateOutputType | null
    _min: Off_chain_vote_dataMinAggregateOutputType | null
    _max: Off_chain_vote_dataMaxAggregateOutputType | null
  }

  export type Off_chain_vote_dataAvgAggregateOutputType = {
    id: number | null
    voting_anchor_id: number | null
  }

  export type Off_chain_vote_dataSumAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
  }

  export type Off_chain_vote_dataMinAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
    hash: Uint8Array | null
    bytes: Uint8Array | null
    warning: string | null
    language: string | null
    comment: string | null
    is_valid: boolean | null
  }

  export type Off_chain_vote_dataMaxAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
    hash: Uint8Array | null
    bytes: Uint8Array | null
    warning: string | null
    language: string | null
    comment: string | null
    is_valid: boolean | null
  }

  export type Off_chain_vote_dataCountAggregateOutputType = {
    id: number
    voting_anchor_id: number
    hash: number
    json: number
    bytes: number
    warning: number
    language: number
    comment: number
    is_valid: number
    _all: number
  }


  export type Off_chain_vote_dataAvgAggregateInputType = {
    id?: true
    voting_anchor_id?: true
  }

  export type Off_chain_vote_dataSumAggregateInputType = {
    id?: true
    voting_anchor_id?: true
  }

  export type Off_chain_vote_dataMinAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    hash?: true
    bytes?: true
    warning?: true
    language?: true
    comment?: true
    is_valid?: true
  }

  export type Off_chain_vote_dataMaxAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    hash?: true
    bytes?: true
    warning?: true
    language?: true
    comment?: true
    is_valid?: true
  }

  export type Off_chain_vote_dataCountAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    hash?: true
    json?: true
    bytes?: true
    warning?: true
    language?: true
    comment?: true
    is_valid?: true
    _all?: true
  }

  export type Off_chain_vote_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_data to aggregate.
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_data to fetch.
     */
    orderBy?: off_chain_vote_dataOrderByWithRelationInput | off_chain_vote_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_data
    **/
    _count?: true | Off_chain_vote_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_dataMaxAggregateInputType
  }

  export type GetOff_chain_vote_dataAggregateType<T extends Off_chain_vote_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_data[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_data[P]>
  }




  export type off_chain_vote_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_dataWhereInput
    orderBy?: off_chain_vote_dataOrderByWithAggregationInput | off_chain_vote_dataOrderByWithAggregationInput[]
    by: Off_chain_vote_dataScalarFieldEnum[] | Off_chain_vote_dataScalarFieldEnum
    having?: off_chain_vote_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_dataCountAggregateInputType | true
    _avg?: Off_chain_vote_dataAvgAggregateInputType
    _sum?: Off_chain_vote_dataSumAggregateInputType
    _min?: Off_chain_vote_dataMinAggregateInputType
    _max?: Off_chain_vote_dataMaxAggregateInputType
  }

  export type Off_chain_vote_dataGroupByOutputType = {
    id: bigint
    voting_anchor_id: bigint
    hash: Uint8Array
    json: JsonValue
    bytes: Uint8Array
    warning: string | null
    language: string
    comment: string | null
    is_valid: boolean | null
    _count: Off_chain_vote_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_dataSumAggregateOutputType | null
    _min: Off_chain_vote_dataMinAggregateOutputType | null
    _max: Off_chain_vote_dataMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_dataGroupByPayload<T extends off_chain_vote_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_dataGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    warning?: boolean
    language?: boolean
    comment?: boolean
    is_valid?: boolean
  }, ExtArgs["result"]["off_chain_vote_data"]>

  export type off_chain_vote_dataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    warning?: boolean
    language?: boolean
    comment?: boolean
    is_valid?: boolean
  }, ExtArgs["result"]["off_chain_vote_data"]>

  export type off_chain_vote_dataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    warning?: boolean
    language?: boolean
    comment?: boolean
    is_valid?: boolean
  }, ExtArgs["result"]["off_chain_vote_data"]>

  export type off_chain_vote_dataSelectScalar = {
    id?: boolean
    voting_anchor_id?: boolean
    hash?: boolean
    json?: boolean
    bytes?: boolean
    warning?: boolean
    language?: boolean
    comment?: boolean
    is_valid?: boolean
  }

  export type off_chain_vote_dataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voting_anchor_id" | "hash" | "json" | "bytes" | "warning" | "language" | "comment" | "is_valid", ExtArgs["result"]["off_chain_vote_data"]>

  export type $off_chain_vote_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      voting_anchor_id: bigint
      hash: Uint8Array
      json: Prisma.JsonValue
      bytes: Uint8Array
      warning: string | null
      language: string
      comment: string | null
      is_valid: boolean | null
    }, ExtArgs["result"]["off_chain_vote_data"]>
    composites: {}
  }

  type off_chain_vote_dataGetPayload<S extends boolean | null | undefined | off_chain_vote_dataDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_dataPayload, S>

  type off_chain_vote_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_dataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_dataCountAggregateInputType | true
    }

  export interface off_chain_vote_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_data'], meta: { name: 'off_chain_vote_data' } }
    /**
     * Find zero or one Off_chain_vote_data that matches the filter.
     * @param {off_chain_vote_dataFindUniqueArgs} args - Arguments to find a Off_chain_vote_data
     * @example
     * // Get one Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_dataFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_dataFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_dataFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_data
     * @example
     * // Get one Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataFindFirstArgs} args - Arguments to find a Off_chain_vote_data
     * @example
     * // Get one Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_dataFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_dataFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_data
     * @example
     * // Get one Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findMany()
     * 
     * // Get first 10 Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_dataWithIdOnly = await prisma.off_chain_vote_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_dataFindManyArgs>(args?: SelectSubset<T, off_chain_vote_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_data.
     * @param {off_chain_vote_dataCreateArgs} args - Arguments to create a Off_chain_vote_data.
     * @example
     * // Create one Off_chain_vote_data
     * const Off_chain_vote_data = await prisma.off_chain_vote_data.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_data
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_dataCreateArgs>(args: SelectSubset<T, off_chain_vote_dataCreateArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_data.
     * @param {off_chain_vote_dataCreateManyArgs} args - Arguments to create many Off_chain_vote_data.
     * @example
     * // Create many Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_dataCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_data and returns the data saved in the database.
     * @param {off_chain_vote_dataCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_data.
     * @example
     * // Create many Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_data and only return the `id`
     * const off_chain_vote_dataWithIdOnly = await prisma.off_chain_vote_data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_dataCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_dataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_data.
     * @param {off_chain_vote_dataDeleteArgs} args - Arguments to delete one Off_chain_vote_data.
     * @example
     * // Delete one Off_chain_vote_data
     * const Off_chain_vote_data = await prisma.off_chain_vote_data.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_data
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_dataDeleteArgs>(args: SelectSubset<T, off_chain_vote_dataDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_data.
     * @param {off_chain_vote_dataUpdateArgs} args - Arguments to update one Off_chain_vote_data.
     * @example
     * // Update one Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_dataUpdateArgs>(args: SelectSubset<T, off_chain_vote_dataUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_data.
     * @param {off_chain_vote_dataDeleteManyArgs} args - Arguments to filter Off_chain_vote_data to delete.
     * @example
     * // Delete a few Off_chain_vote_data
     * const { count } = await prisma.off_chain_vote_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_dataDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_dataUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_data and returns the data updated in the database.
     * @param {off_chain_vote_dataUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_data.
     * @example
     * // Update many Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_data and only return the `id`
     * const off_chain_vote_dataWithIdOnly = await prisma.off_chain_vote_data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_dataUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_dataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_data.
     * @param {off_chain_vote_dataUpsertArgs} args - Arguments to update or create a Off_chain_vote_data.
     * @example
     * // Update or create a Off_chain_vote_data
     * const off_chain_vote_data = await prisma.off_chain_vote_data.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_data we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_dataUpsertArgs>(args: SelectSubset<T, off_chain_vote_dataUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_dataClient<$Result.GetResult<Prisma.$off_chain_vote_dataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataCountArgs} args - Arguments to filter Off_chain_vote_data to count.
     * @example
     * // Count the number of Off_chain_vote_data
     * const count = await prisma.off_chain_vote_data.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_data we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_dataCountArgs>(
      args?: Subset<T, off_chain_vote_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_dataAggregateArgs>(args: Subset<T, Off_chain_vote_dataAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_dataAggregateType<T>>

    /**
     * Group by Off_chain_vote_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_dataGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_data model
   */
  readonly fields: off_chain_vote_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_data model
   */ 
  interface off_chain_vote_dataFieldRefs {
    readonly id: FieldRef<"off_chain_vote_data", 'BigInt'>
    readonly voting_anchor_id: FieldRef<"off_chain_vote_data", 'BigInt'>
    readonly hash: FieldRef<"off_chain_vote_data", 'Bytes'>
    readonly json: FieldRef<"off_chain_vote_data", 'Json'>
    readonly bytes: FieldRef<"off_chain_vote_data", 'Bytes'>
    readonly warning: FieldRef<"off_chain_vote_data", 'String'>
    readonly language: FieldRef<"off_chain_vote_data", 'String'>
    readonly comment: FieldRef<"off_chain_vote_data", 'String'>
    readonly is_valid: FieldRef<"off_chain_vote_data", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_data findUnique
   */
  export type off_chain_vote_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_data to fetch.
     */
    where: off_chain_vote_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_data findUniqueOrThrow
   */
  export type off_chain_vote_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_data to fetch.
     */
    where: off_chain_vote_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_data findFirst
   */
  export type off_chain_vote_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_data to fetch.
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_data to fetch.
     */
    orderBy?: off_chain_vote_dataOrderByWithRelationInput | off_chain_vote_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_data.
     */
    cursor?: off_chain_vote_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_data.
     */
    distinct?: Off_chain_vote_dataScalarFieldEnum | Off_chain_vote_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_data findFirstOrThrow
   */
  export type off_chain_vote_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_data to fetch.
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_data to fetch.
     */
    orderBy?: off_chain_vote_dataOrderByWithRelationInput | off_chain_vote_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_data.
     */
    cursor?: off_chain_vote_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_data.
     */
    distinct?: Off_chain_vote_dataScalarFieldEnum | Off_chain_vote_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_data findMany
   */
  export type off_chain_vote_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_data to fetch.
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_data to fetch.
     */
    orderBy?: off_chain_vote_dataOrderByWithRelationInput | off_chain_vote_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_data.
     */
    cursor?: off_chain_vote_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_data.
     */
    skip?: number
    distinct?: Off_chain_vote_dataScalarFieldEnum | Off_chain_vote_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_data create
   */
  export type off_chain_vote_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_data.
     */
    data: XOR<off_chain_vote_dataCreateInput, off_chain_vote_dataUncheckedCreateInput>
  }

  /**
   * off_chain_vote_data createMany
   */
  export type off_chain_vote_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_data.
     */
    data: off_chain_vote_dataCreateManyInput | off_chain_vote_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_data createManyAndReturn
   */
  export type off_chain_vote_dataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_data.
     */
    data: off_chain_vote_dataCreateManyInput | off_chain_vote_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_data update
   */
  export type off_chain_vote_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_data.
     */
    data: XOR<off_chain_vote_dataUpdateInput, off_chain_vote_dataUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_data to update.
     */
    where: off_chain_vote_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_data updateMany
   */
  export type off_chain_vote_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_data.
     */
    data: XOR<off_chain_vote_dataUpdateManyMutationInput, off_chain_vote_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_data to update
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * Limit how many off_chain_vote_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_data updateManyAndReturn
   */
  export type off_chain_vote_dataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_data.
     */
    data: XOR<off_chain_vote_dataUpdateManyMutationInput, off_chain_vote_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_data to update
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * Limit how many off_chain_vote_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_data upsert
   */
  export type off_chain_vote_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_data to update in case it exists.
     */
    where: off_chain_vote_dataWhereUniqueInput
    /**
     * In case the off_chain_vote_data found by the `where` argument doesn't exist, create a new off_chain_vote_data with this data.
     */
    create: XOR<off_chain_vote_dataCreateInput, off_chain_vote_dataUncheckedCreateInput>
    /**
     * In case the off_chain_vote_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_dataUpdateInput, off_chain_vote_dataUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_data delete
   */
  export type off_chain_vote_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_data to delete.
     */
    where: off_chain_vote_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_data deleteMany
   */
  export type off_chain_vote_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_data to delete
     */
    where?: off_chain_vote_dataWhereInput
    /**
     * Limit how many off_chain_vote_data to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_data without action
   */
  export type off_chain_vote_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_data
     */
    select?: off_chain_vote_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_data
     */
    omit?: off_chain_vote_dataOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_drep_data
   */

  export type AggregateOff_chain_vote_drep_data = {
    _count: Off_chain_vote_drep_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_drep_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_drep_dataSumAggregateOutputType | null
    _min: Off_chain_vote_drep_dataMinAggregateOutputType | null
    _max: Off_chain_vote_drep_dataMaxAggregateOutputType | null
  }

  export type Off_chain_vote_drep_dataAvgAggregateOutputType = {
    id: number | null
    off_chain_vote_data_id: number | null
  }

  export type Off_chain_vote_drep_dataSumAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
  }

  export type Off_chain_vote_drep_dataMinAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    payment_address: string | null
    given_name: string | null
    objectives: string | null
    motivations: string | null
    qualifications: string | null
    image_url: string | null
    image_hash: string | null
  }

  export type Off_chain_vote_drep_dataMaxAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    payment_address: string | null
    given_name: string | null
    objectives: string | null
    motivations: string | null
    qualifications: string | null
    image_url: string | null
    image_hash: string | null
  }

  export type Off_chain_vote_drep_dataCountAggregateOutputType = {
    id: number
    off_chain_vote_data_id: number
    payment_address: number
    given_name: number
    objectives: number
    motivations: number
    qualifications: number
    image_url: number
    image_hash: number
    _all: number
  }


  export type Off_chain_vote_drep_dataAvgAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_drep_dataSumAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_drep_dataMinAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    payment_address?: true
    given_name?: true
    objectives?: true
    motivations?: true
    qualifications?: true
    image_url?: true
    image_hash?: true
  }

  export type Off_chain_vote_drep_dataMaxAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    payment_address?: true
    given_name?: true
    objectives?: true
    motivations?: true
    qualifications?: true
    image_url?: true
    image_hash?: true
  }

  export type Off_chain_vote_drep_dataCountAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    payment_address?: true
    given_name?: true
    objectives?: true
    motivations?: true
    qualifications?: true
    image_url?: true
    image_hash?: true
    _all?: true
  }

  export type Off_chain_vote_drep_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_drep_data to aggregate.
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_drep_data to fetch.
     */
    orderBy?: off_chain_vote_drep_dataOrderByWithRelationInput | off_chain_vote_drep_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_drep_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_drep_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_drep_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_drep_data
    **/
    _count?: true | Off_chain_vote_drep_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_drep_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_drep_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_drep_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_drep_dataMaxAggregateInputType
  }

  export type GetOff_chain_vote_drep_dataAggregateType<T extends Off_chain_vote_drep_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_drep_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_drep_data[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_drep_data[P]>
  }




  export type off_chain_vote_drep_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_drep_dataWhereInput
    orderBy?: off_chain_vote_drep_dataOrderByWithAggregationInput | off_chain_vote_drep_dataOrderByWithAggregationInput[]
    by: Off_chain_vote_drep_dataScalarFieldEnum[] | Off_chain_vote_drep_dataScalarFieldEnum
    having?: off_chain_vote_drep_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_drep_dataCountAggregateInputType | true
    _avg?: Off_chain_vote_drep_dataAvgAggregateInputType
    _sum?: Off_chain_vote_drep_dataSumAggregateInputType
    _min?: Off_chain_vote_drep_dataMinAggregateInputType
    _max?: Off_chain_vote_drep_dataMaxAggregateInputType
  }

  export type Off_chain_vote_drep_dataGroupByOutputType = {
    id: bigint
    off_chain_vote_data_id: bigint
    payment_address: string | null
    given_name: string
    objectives: string | null
    motivations: string | null
    qualifications: string | null
    image_url: string | null
    image_hash: string | null
    _count: Off_chain_vote_drep_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_drep_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_drep_dataSumAggregateOutputType | null
    _min: Off_chain_vote_drep_dataMinAggregateOutputType | null
    _max: Off_chain_vote_drep_dataMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_drep_dataGroupByPayload<T extends off_chain_vote_drep_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_drep_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_drep_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_drep_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_drep_dataGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_drep_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    payment_address?: boolean
    given_name?: boolean
    objectives?: boolean
    motivations?: boolean
    qualifications?: boolean
    image_url?: boolean
    image_hash?: boolean
  }, ExtArgs["result"]["off_chain_vote_drep_data"]>

  export type off_chain_vote_drep_dataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    payment_address?: boolean
    given_name?: boolean
    objectives?: boolean
    motivations?: boolean
    qualifications?: boolean
    image_url?: boolean
    image_hash?: boolean
  }, ExtArgs["result"]["off_chain_vote_drep_data"]>

  export type off_chain_vote_drep_dataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    payment_address?: boolean
    given_name?: boolean
    objectives?: boolean
    motivations?: boolean
    qualifications?: boolean
    image_url?: boolean
    image_hash?: boolean
  }, ExtArgs["result"]["off_chain_vote_drep_data"]>

  export type off_chain_vote_drep_dataSelectScalar = {
    id?: boolean
    off_chain_vote_data_id?: boolean
    payment_address?: boolean
    given_name?: boolean
    objectives?: boolean
    motivations?: boolean
    qualifications?: boolean
    image_url?: boolean
    image_hash?: boolean
  }

  export type off_chain_vote_drep_dataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "off_chain_vote_data_id" | "payment_address" | "given_name" | "objectives" | "motivations" | "qualifications" | "image_url" | "image_hash", ExtArgs["result"]["off_chain_vote_drep_data"]>

  export type $off_chain_vote_drep_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_drep_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      off_chain_vote_data_id: bigint
      payment_address: string | null
      given_name: string
      objectives: string | null
      motivations: string | null
      qualifications: string | null
      image_url: string | null
      image_hash: string | null
    }, ExtArgs["result"]["off_chain_vote_drep_data"]>
    composites: {}
  }

  type off_chain_vote_drep_dataGetPayload<S extends boolean | null | undefined | off_chain_vote_drep_dataDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload, S>

  type off_chain_vote_drep_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_drep_dataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_drep_dataCountAggregateInputType | true
    }

  export interface off_chain_vote_drep_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_drep_data'], meta: { name: 'off_chain_vote_drep_data' } }
    /**
     * Find zero or one Off_chain_vote_drep_data that matches the filter.
     * @param {off_chain_vote_drep_dataFindUniqueArgs} args - Arguments to find a Off_chain_vote_drep_data
     * @example
     * // Get one Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_drep_dataFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_drep_dataFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_drep_data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_drep_dataFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_drep_data
     * @example
     * // Get one Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_drep_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_drep_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_drep_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataFindFirstArgs} args - Arguments to find a Off_chain_vote_drep_data
     * @example
     * // Get one Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_drep_dataFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_drep_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_drep_data
     * @example
     * // Get one Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_drep_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_drep_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findMany()
     * 
     * // Get first 10 Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_drep_dataWithIdOnly = await prisma.off_chain_vote_drep_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_drep_dataFindManyArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataCreateArgs} args - Arguments to create a Off_chain_vote_drep_data.
     * @example
     * // Create one Off_chain_vote_drep_data
     * const Off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_drep_data
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_drep_dataCreateArgs>(args: SelectSubset<T, off_chain_vote_drep_dataCreateArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataCreateManyArgs} args - Arguments to create many Off_chain_vote_drep_data.
     * @example
     * // Create many Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_drep_dataCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_drep_data and returns the data saved in the database.
     * @param {off_chain_vote_drep_dataCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_drep_data.
     * @example
     * // Create many Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_drep_data and only return the `id`
     * const off_chain_vote_drep_dataWithIdOnly = await prisma.off_chain_vote_drep_data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_drep_dataCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataDeleteArgs} args - Arguments to delete one Off_chain_vote_drep_data.
     * @example
     * // Delete one Off_chain_vote_drep_data
     * const Off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_drep_data
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_drep_dataDeleteArgs>(args: SelectSubset<T, off_chain_vote_drep_dataDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataUpdateArgs} args - Arguments to update one Off_chain_vote_drep_data.
     * @example
     * // Update one Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_drep_dataUpdateArgs>(args: SelectSubset<T, off_chain_vote_drep_dataUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataDeleteManyArgs} args - Arguments to filter Off_chain_vote_drep_data to delete.
     * @example
     * // Delete a few Off_chain_vote_drep_data
     * const { count } = await prisma.off_chain_vote_drep_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_drep_dataDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_drep_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_drep_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_drep_dataUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_drep_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_drep_data and returns the data updated in the database.
     * @param {off_chain_vote_drep_dataUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_drep_data.
     * @example
     * // Update many Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_drep_data and only return the `id`
     * const off_chain_vote_drep_dataWithIdOnly = await prisma.off_chain_vote_drep_data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_drep_dataUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_drep_dataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_drep_data.
     * @param {off_chain_vote_drep_dataUpsertArgs} args - Arguments to update or create a Off_chain_vote_drep_data.
     * @example
     * // Update or create a Off_chain_vote_drep_data
     * const off_chain_vote_drep_data = await prisma.off_chain_vote_drep_data.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_drep_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_drep_data we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_drep_dataUpsertArgs>(args: SelectSubset<T, off_chain_vote_drep_dataUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_drep_dataClient<$Result.GetResult<Prisma.$off_chain_vote_drep_dataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_drep_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataCountArgs} args - Arguments to filter Off_chain_vote_drep_data to count.
     * @example
     * // Count the number of Off_chain_vote_drep_data
     * const count = await prisma.off_chain_vote_drep_data.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_drep_data we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_drep_dataCountArgs>(
      args?: Subset<T, off_chain_vote_drep_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_drep_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_drep_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_drep_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_drep_dataAggregateArgs>(args: Subset<T, Off_chain_vote_drep_dataAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_drep_dataAggregateType<T>>

    /**
     * Group by Off_chain_vote_drep_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_drep_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_drep_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_drep_dataGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_drep_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_drep_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_drep_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_drep_data model
   */
  readonly fields: off_chain_vote_drep_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_drep_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_drep_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_drep_data model
   */ 
  interface off_chain_vote_drep_dataFieldRefs {
    readonly id: FieldRef<"off_chain_vote_drep_data", 'BigInt'>
    readonly off_chain_vote_data_id: FieldRef<"off_chain_vote_drep_data", 'BigInt'>
    readonly payment_address: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly given_name: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly objectives: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly motivations: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly qualifications: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly image_url: FieldRef<"off_chain_vote_drep_data", 'String'>
    readonly image_hash: FieldRef<"off_chain_vote_drep_data", 'String'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_drep_data findUnique
   */
  export type off_chain_vote_drep_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_drep_data to fetch.
     */
    where: off_chain_vote_drep_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_drep_data findUniqueOrThrow
   */
  export type off_chain_vote_drep_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_drep_data to fetch.
     */
    where: off_chain_vote_drep_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_drep_data findFirst
   */
  export type off_chain_vote_drep_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_drep_data to fetch.
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_drep_data to fetch.
     */
    orderBy?: off_chain_vote_drep_dataOrderByWithRelationInput | off_chain_vote_drep_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_drep_data.
     */
    cursor?: off_chain_vote_drep_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_drep_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_drep_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_drep_data.
     */
    distinct?: Off_chain_vote_drep_dataScalarFieldEnum | Off_chain_vote_drep_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_drep_data findFirstOrThrow
   */
  export type off_chain_vote_drep_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_drep_data to fetch.
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_drep_data to fetch.
     */
    orderBy?: off_chain_vote_drep_dataOrderByWithRelationInput | off_chain_vote_drep_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_drep_data.
     */
    cursor?: off_chain_vote_drep_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_drep_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_drep_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_drep_data.
     */
    distinct?: Off_chain_vote_drep_dataScalarFieldEnum | Off_chain_vote_drep_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_drep_data findMany
   */
  export type off_chain_vote_drep_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_drep_data to fetch.
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_drep_data to fetch.
     */
    orderBy?: off_chain_vote_drep_dataOrderByWithRelationInput | off_chain_vote_drep_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_drep_data.
     */
    cursor?: off_chain_vote_drep_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_drep_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_drep_data.
     */
    skip?: number
    distinct?: Off_chain_vote_drep_dataScalarFieldEnum | Off_chain_vote_drep_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_drep_data create
   */
  export type off_chain_vote_drep_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_drep_data.
     */
    data: XOR<off_chain_vote_drep_dataCreateInput, off_chain_vote_drep_dataUncheckedCreateInput>
  }

  /**
   * off_chain_vote_drep_data createMany
   */
  export type off_chain_vote_drep_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_drep_data.
     */
    data: off_chain_vote_drep_dataCreateManyInput | off_chain_vote_drep_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_drep_data createManyAndReturn
   */
  export type off_chain_vote_drep_dataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_drep_data.
     */
    data: off_chain_vote_drep_dataCreateManyInput | off_chain_vote_drep_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_drep_data update
   */
  export type off_chain_vote_drep_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_drep_data.
     */
    data: XOR<off_chain_vote_drep_dataUpdateInput, off_chain_vote_drep_dataUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_drep_data to update.
     */
    where: off_chain_vote_drep_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_drep_data updateMany
   */
  export type off_chain_vote_drep_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_drep_data.
     */
    data: XOR<off_chain_vote_drep_dataUpdateManyMutationInput, off_chain_vote_drep_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_drep_data to update
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * Limit how many off_chain_vote_drep_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_drep_data updateManyAndReturn
   */
  export type off_chain_vote_drep_dataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_drep_data.
     */
    data: XOR<off_chain_vote_drep_dataUpdateManyMutationInput, off_chain_vote_drep_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_drep_data to update
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * Limit how many off_chain_vote_drep_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_drep_data upsert
   */
  export type off_chain_vote_drep_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_drep_data to update in case it exists.
     */
    where: off_chain_vote_drep_dataWhereUniqueInput
    /**
     * In case the off_chain_vote_drep_data found by the `where` argument doesn't exist, create a new off_chain_vote_drep_data with this data.
     */
    create: XOR<off_chain_vote_drep_dataCreateInput, off_chain_vote_drep_dataUncheckedCreateInput>
    /**
     * In case the off_chain_vote_drep_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_drep_dataUpdateInput, off_chain_vote_drep_dataUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_drep_data delete
   */
  export type off_chain_vote_drep_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_drep_data to delete.
     */
    where: off_chain_vote_drep_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_drep_data deleteMany
   */
  export type off_chain_vote_drep_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_drep_data to delete
     */
    where?: off_chain_vote_drep_dataWhereInput
    /**
     * Limit how many off_chain_vote_drep_data to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_drep_data without action
   */
  export type off_chain_vote_drep_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_drep_data
     */
    select?: off_chain_vote_drep_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_drep_data
     */
    omit?: off_chain_vote_drep_dataOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_external_update
   */

  export type AggregateOff_chain_vote_external_update = {
    _count: Off_chain_vote_external_updateCountAggregateOutputType | null
    _avg: Off_chain_vote_external_updateAvgAggregateOutputType | null
    _sum: Off_chain_vote_external_updateSumAggregateOutputType | null
    _min: Off_chain_vote_external_updateMinAggregateOutputType | null
    _max: Off_chain_vote_external_updateMaxAggregateOutputType | null
  }

  export type Off_chain_vote_external_updateAvgAggregateOutputType = {
    id: number | null
    off_chain_vote_data_id: number | null
  }

  export type Off_chain_vote_external_updateSumAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
  }

  export type Off_chain_vote_external_updateMinAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    title: string | null
    uri: string | null
  }

  export type Off_chain_vote_external_updateMaxAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    title: string | null
    uri: string | null
  }

  export type Off_chain_vote_external_updateCountAggregateOutputType = {
    id: number
    off_chain_vote_data_id: number
    title: number
    uri: number
    _all: number
  }


  export type Off_chain_vote_external_updateAvgAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_external_updateSumAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_external_updateMinAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    uri?: true
  }

  export type Off_chain_vote_external_updateMaxAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    uri?: true
  }

  export type Off_chain_vote_external_updateCountAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    uri?: true
    _all?: true
  }

  export type Off_chain_vote_external_updateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_external_update to aggregate.
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_external_updates to fetch.
     */
    orderBy?: off_chain_vote_external_updateOrderByWithRelationInput | off_chain_vote_external_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_external_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_external_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_external_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_external_updates
    **/
    _count?: true | Off_chain_vote_external_updateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_external_updateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_external_updateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_external_updateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_external_updateMaxAggregateInputType
  }

  export type GetOff_chain_vote_external_updateAggregateType<T extends Off_chain_vote_external_updateAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_external_update]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_external_update[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_external_update[P]>
  }




  export type off_chain_vote_external_updateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_external_updateWhereInput
    orderBy?: off_chain_vote_external_updateOrderByWithAggregationInput | off_chain_vote_external_updateOrderByWithAggregationInput[]
    by: Off_chain_vote_external_updateScalarFieldEnum[] | Off_chain_vote_external_updateScalarFieldEnum
    having?: off_chain_vote_external_updateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_external_updateCountAggregateInputType | true
    _avg?: Off_chain_vote_external_updateAvgAggregateInputType
    _sum?: Off_chain_vote_external_updateSumAggregateInputType
    _min?: Off_chain_vote_external_updateMinAggregateInputType
    _max?: Off_chain_vote_external_updateMaxAggregateInputType
  }

  export type Off_chain_vote_external_updateGroupByOutputType = {
    id: bigint
    off_chain_vote_data_id: bigint
    title: string
    uri: string
    _count: Off_chain_vote_external_updateCountAggregateOutputType | null
    _avg: Off_chain_vote_external_updateAvgAggregateOutputType | null
    _sum: Off_chain_vote_external_updateSumAggregateOutputType | null
    _min: Off_chain_vote_external_updateMinAggregateOutputType | null
    _max: Off_chain_vote_external_updateMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_external_updateGroupByPayload<T extends off_chain_vote_external_updateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_external_updateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_external_updateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_external_updateGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_external_updateGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_external_updateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    uri?: boolean
  }, ExtArgs["result"]["off_chain_vote_external_update"]>

  export type off_chain_vote_external_updateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    uri?: boolean
  }, ExtArgs["result"]["off_chain_vote_external_update"]>

  export type off_chain_vote_external_updateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    uri?: boolean
  }, ExtArgs["result"]["off_chain_vote_external_update"]>

  export type off_chain_vote_external_updateSelectScalar = {
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    uri?: boolean
  }

  export type off_chain_vote_external_updateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "off_chain_vote_data_id" | "title" | "uri", ExtArgs["result"]["off_chain_vote_external_update"]>

  export type $off_chain_vote_external_updatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_external_update"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      off_chain_vote_data_id: bigint
      title: string
      uri: string
    }, ExtArgs["result"]["off_chain_vote_external_update"]>
    composites: {}
  }

  type off_chain_vote_external_updateGetPayload<S extends boolean | null | undefined | off_chain_vote_external_updateDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_external_updatePayload, S>

  type off_chain_vote_external_updateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_external_updateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_external_updateCountAggregateInputType | true
    }

  export interface off_chain_vote_external_updateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_external_update'], meta: { name: 'off_chain_vote_external_update' } }
    /**
     * Find zero or one Off_chain_vote_external_update that matches the filter.
     * @param {off_chain_vote_external_updateFindUniqueArgs} args - Arguments to find a Off_chain_vote_external_update
     * @example
     * // Get one Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_external_updateFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_external_updateFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_external_update that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_external_updateFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_external_update
     * @example
     * // Get one Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_external_updateFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_external_updateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_external_update that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateFindFirstArgs} args - Arguments to find a Off_chain_vote_external_update
     * @example
     * // Get one Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_external_updateFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_external_updateFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_external_update that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_external_update
     * @example
     * // Get one Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_external_updateFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_external_updateFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_external_updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_external_updates
     * const off_chain_vote_external_updates = await prisma.off_chain_vote_external_update.findMany()
     * 
     * // Get first 10 Off_chain_vote_external_updates
     * const off_chain_vote_external_updates = await prisma.off_chain_vote_external_update.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_external_updateWithIdOnly = await prisma.off_chain_vote_external_update.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_external_updateFindManyArgs>(args?: SelectSubset<T, off_chain_vote_external_updateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_external_update.
     * @param {off_chain_vote_external_updateCreateArgs} args - Arguments to create a Off_chain_vote_external_update.
     * @example
     * // Create one Off_chain_vote_external_update
     * const Off_chain_vote_external_update = await prisma.off_chain_vote_external_update.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_external_update
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_external_updateCreateArgs>(args: SelectSubset<T, off_chain_vote_external_updateCreateArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_external_updates.
     * @param {off_chain_vote_external_updateCreateManyArgs} args - Arguments to create many Off_chain_vote_external_updates.
     * @example
     * // Create many Off_chain_vote_external_updates
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_external_updateCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_external_updateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_external_updates and returns the data saved in the database.
     * @param {off_chain_vote_external_updateCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_external_updates.
     * @example
     * // Create many Off_chain_vote_external_updates
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_external_updates and only return the `id`
     * const off_chain_vote_external_updateWithIdOnly = await prisma.off_chain_vote_external_update.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_external_updateCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_external_updateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_external_update.
     * @param {off_chain_vote_external_updateDeleteArgs} args - Arguments to delete one Off_chain_vote_external_update.
     * @example
     * // Delete one Off_chain_vote_external_update
     * const Off_chain_vote_external_update = await prisma.off_chain_vote_external_update.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_external_update
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_external_updateDeleteArgs>(args: SelectSubset<T, off_chain_vote_external_updateDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_external_update.
     * @param {off_chain_vote_external_updateUpdateArgs} args - Arguments to update one Off_chain_vote_external_update.
     * @example
     * // Update one Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_external_updateUpdateArgs>(args: SelectSubset<T, off_chain_vote_external_updateUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_external_updates.
     * @param {off_chain_vote_external_updateDeleteManyArgs} args - Arguments to filter Off_chain_vote_external_updates to delete.
     * @example
     * // Delete a few Off_chain_vote_external_updates
     * const { count } = await prisma.off_chain_vote_external_update.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_external_updateDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_external_updateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_external_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_external_updates
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_external_updateUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_external_updateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_external_updates and returns the data updated in the database.
     * @param {off_chain_vote_external_updateUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_external_updates.
     * @example
     * // Update many Off_chain_vote_external_updates
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_external_updates and only return the `id`
     * const off_chain_vote_external_updateWithIdOnly = await prisma.off_chain_vote_external_update.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_external_updateUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_external_updateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_external_update.
     * @param {off_chain_vote_external_updateUpsertArgs} args - Arguments to update or create a Off_chain_vote_external_update.
     * @example
     * // Update or create a Off_chain_vote_external_update
     * const off_chain_vote_external_update = await prisma.off_chain_vote_external_update.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_external_update
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_external_update we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_external_updateUpsertArgs>(args: SelectSubset<T, off_chain_vote_external_updateUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_external_updateClient<$Result.GetResult<Prisma.$off_chain_vote_external_updatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_external_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateCountArgs} args - Arguments to filter Off_chain_vote_external_updates to count.
     * @example
     * // Count the number of Off_chain_vote_external_updates
     * const count = await prisma.off_chain_vote_external_update.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_external_updates we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_external_updateCountArgs>(
      args?: Subset<T, off_chain_vote_external_updateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_external_updateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_external_update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_external_updateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_external_updateAggregateArgs>(args: Subset<T, Off_chain_vote_external_updateAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_external_updateAggregateType<T>>

    /**
     * Group by Off_chain_vote_external_update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_external_updateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_external_updateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_external_updateGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_external_updateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_external_updateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_external_updateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_external_update model
   */
  readonly fields: off_chain_vote_external_updateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_external_update.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_external_updateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_external_update model
   */ 
  interface off_chain_vote_external_updateFieldRefs {
    readonly id: FieldRef<"off_chain_vote_external_update", 'BigInt'>
    readonly off_chain_vote_data_id: FieldRef<"off_chain_vote_external_update", 'BigInt'>
    readonly title: FieldRef<"off_chain_vote_external_update", 'String'>
    readonly uri: FieldRef<"off_chain_vote_external_update", 'String'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_external_update findUnique
   */
  export type off_chain_vote_external_updateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_external_update to fetch.
     */
    where: off_chain_vote_external_updateWhereUniqueInput
  }

  /**
   * off_chain_vote_external_update findUniqueOrThrow
   */
  export type off_chain_vote_external_updateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_external_update to fetch.
     */
    where: off_chain_vote_external_updateWhereUniqueInput
  }

  /**
   * off_chain_vote_external_update findFirst
   */
  export type off_chain_vote_external_updateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_external_update to fetch.
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_external_updates to fetch.
     */
    orderBy?: off_chain_vote_external_updateOrderByWithRelationInput | off_chain_vote_external_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_external_updates.
     */
    cursor?: off_chain_vote_external_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_external_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_external_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_external_updates.
     */
    distinct?: Off_chain_vote_external_updateScalarFieldEnum | Off_chain_vote_external_updateScalarFieldEnum[]
  }

  /**
   * off_chain_vote_external_update findFirstOrThrow
   */
  export type off_chain_vote_external_updateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_external_update to fetch.
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_external_updates to fetch.
     */
    orderBy?: off_chain_vote_external_updateOrderByWithRelationInput | off_chain_vote_external_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_external_updates.
     */
    cursor?: off_chain_vote_external_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_external_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_external_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_external_updates.
     */
    distinct?: Off_chain_vote_external_updateScalarFieldEnum | Off_chain_vote_external_updateScalarFieldEnum[]
  }

  /**
   * off_chain_vote_external_update findMany
   */
  export type off_chain_vote_external_updateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_external_updates to fetch.
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_external_updates to fetch.
     */
    orderBy?: off_chain_vote_external_updateOrderByWithRelationInput | off_chain_vote_external_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_external_updates.
     */
    cursor?: off_chain_vote_external_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_external_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_external_updates.
     */
    skip?: number
    distinct?: Off_chain_vote_external_updateScalarFieldEnum | Off_chain_vote_external_updateScalarFieldEnum[]
  }

  /**
   * off_chain_vote_external_update create
   */
  export type off_chain_vote_external_updateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_external_update.
     */
    data: XOR<off_chain_vote_external_updateCreateInput, off_chain_vote_external_updateUncheckedCreateInput>
  }

  /**
   * off_chain_vote_external_update createMany
   */
  export type off_chain_vote_external_updateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_external_updates.
     */
    data: off_chain_vote_external_updateCreateManyInput | off_chain_vote_external_updateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_external_update createManyAndReturn
   */
  export type off_chain_vote_external_updateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_external_updates.
     */
    data: off_chain_vote_external_updateCreateManyInput | off_chain_vote_external_updateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_external_update update
   */
  export type off_chain_vote_external_updateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_external_update.
     */
    data: XOR<off_chain_vote_external_updateUpdateInput, off_chain_vote_external_updateUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_external_update to update.
     */
    where: off_chain_vote_external_updateWhereUniqueInput
  }

  /**
   * off_chain_vote_external_update updateMany
   */
  export type off_chain_vote_external_updateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_external_updates.
     */
    data: XOR<off_chain_vote_external_updateUpdateManyMutationInput, off_chain_vote_external_updateUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_external_updates to update
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * Limit how many off_chain_vote_external_updates to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_external_update updateManyAndReturn
   */
  export type off_chain_vote_external_updateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_external_updates.
     */
    data: XOR<off_chain_vote_external_updateUpdateManyMutationInput, off_chain_vote_external_updateUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_external_updates to update
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * Limit how many off_chain_vote_external_updates to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_external_update upsert
   */
  export type off_chain_vote_external_updateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_external_update to update in case it exists.
     */
    where: off_chain_vote_external_updateWhereUniqueInput
    /**
     * In case the off_chain_vote_external_update found by the `where` argument doesn't exist, create a new off_chain_vote_external_update with this data.
     */
    create: XOR<off_chain_vote_external_updateCreateInput, off_chain_vote_external_updateUncheckedCreateInput>
    /**
     * In case the off_chain_vote_external_update was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_external_updateUpdateInput, off_chain_vote_external_updateUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_external_update delete
   */
  export type off_chain_vote_external_updateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_external_update to delete.
     */
    where: off_chain_vote_external_updateWhereUniqueInput
  }

  /**
   * off_chain_vote_external_update deleteMany
   */
  export type off_chain_vote_external_updateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_external_updates to delete
     */
    where?: off_chain_vote_external_updateWhereInput
    /**
     * Limit how many off_chain_vote_external_updates to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_external_update without action
   */
  export type off_chain_vote_external_updateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_external_update
     */
    select?: off_chain_vote_external_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_external_update
     */
    omit?: off_chain_vote_external_updateOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_fetch_error
   */

  export type AggregateOff_chain_vote_fetch_error = {
    _count: Off_chain_vote_fetch_errorCountAggregateOutputType | null
    _avg: Off_chain_vote_fetch_errorAvgAggregateOutputType | null
    _sum: Off_chain_vote_fetch_errorSumAggregateOutputType | null
    _min: Off_chain_vote_fetch_errorMinAggregateOutputType | null
    _max: Off_chain_vote_fetch_errorMaxAggregateOutputType | null
  }

  export type Off_chain_vote_fetch_errorAvgAggregateOutputType = {
    id: number | null
    voting_anchor_id: number | null
    retry_count: number | null
  }

  export type Off_chain_vote_fetch_errorSumAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
    retry_count: number | null
  }

  export type Off_chain_vote_fetch_errorMinAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
    fetch_error: string | null
    fetch_time: Date | null
    retry_count: number | null
  }

  export type Off_chain_vote_fetch_errorMaxAggregateOutputType = {
    id: bigint | null
    voting_anchor_id: bigint | null
    fetch_error: string | null
    fetch_time: Date | null
    retry_count: number | null
  }

  export type Off_chain_vote_fetch_errorCountAggregateOutputType = {
    id: number
    voting_anchor_id: number
    fetch_error: number
    fetch_time: number
    retry_count: number
    _all: number
  }


  export type Off_chain_vote_fetch_errorAvgAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    retry_count?: true
  }

  export type Off_chain_vote_fetch_errorSumAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    retry_count?: true
  }

  export type Off_chain_vote_fetch_errorMinAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    fetch_error?: true
    fetch_time?: true
    retry_count?: true
  }

  export type Off_chain_vote_fetch_errorMaxAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    fetch_error?: true
    fetch_time?: true
    retry_count?: true
  }

  export type Off_chain_vote_fetch_errorCountAggregateInputType = {
    id?: true
    voting_anchor_id?: true
    fetch_error?: true
    fetch_time?: true
    retry_count?: true
    _all?: true
  }

  export type Off_chain_vote_fetch_errorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_fetch_error to aggregate.
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_fetch_errors to fetch.
     */
    orderBy?: off_chain_vote_fetch_errorOrderByWithRelationInput | off_chain_vote_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_fetch_errors
    **/
    _count?: true | Off_chain_vote_fetch_errorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_fetch_errorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_fetch_errorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_fetch_errorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_fetch_errorMaxAggregateInputType
  }

  export type GetOff_chain_vote_fetch_errorAggregateType<T extends Off_chain_vote_fetch_errorAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_fetch_error]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_fetch_error[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_fetch_error[P]>
  }




  export type off_chain_vote_fetch_errorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_fetch_errorWhereInput
    orderBy?: off_chain_vote_fetch_errorOrderByWithAggregationInput | off_chain_vote_fetch_errorOrderByWithAggregationInput[]
    by: Off_chain_vote_fetch_errorScalarFieldEnum[] | Off_chain_vote_fetch_errorScalarFieldEnum
    having?: off_chain_vote_fetch_errorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_fetch_errorCountAggregateInputType | true
    _avg?: Off_chain_vote_fetch_errorAvgAggregateInputType
    _sum?: Off_chain_vote_fetch_errorSumAggregateInputType
    _min?: Off_chain_vote_fetch_errorMinAggregateInputType
    _max?: Off_chain_vote_fetch_errorMaxAggregateInputType
  }

  export type Off_chain_vote_fetch_errorGroupByOutputType = {
    id: bigint
    voting_anchor_id: bigint
    fetch_error: string
    fetch_time: Date
    retry_count: number
    _count: Off_chain_vote_fetch_errorCountAggregateOutputType | null
    _avg: Off_chain_vote_fetch_errorAvgAggregateOutputType | null
    _sum: Off_chain_vote_fetch_errorSumAggregateOutputType | null
    _min: Off_chain_vote_fetch_errorMinAggregateOutputType | null
    _max: Off_chain_vote_fetch_errorMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_fetch_errorGroupByPayload<T extends off_chain_vote_fetch_errorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_fetch_errorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_fetch_errorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_fetch_errorGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_fetch_errorGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_fetch_errorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    fetch_error?: boolean
    fetch_time?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_vote_fetch_error"]>

  export type off_chain_vote_fetch_errorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    fetch_error?: boolean
    fetch_time?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_vote_fetch_error"]>

  export type off_chain_vote_fetch_errorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voting_anchor_id?: boolean
    fetch_error?: boolean
    fetch_time?: boolean
    retry_count?: boolean
  }, ExtArgs["result"]["off_chain_vote_fetch_error"]>

  export type off_chain_vote_fetch_errorSelectScalar = {
    id?: boolean
    voting_anchor_id?: boolean
    fetch_error?: boolean
    fetch_time?: boolean
    retry_count?: boolean
  }

  export type off_chain_vote_fetch_errorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voting_anchor_id" | "fetch_error" | "fetch_time" | "retry_count", ExtArgs["result"]["off_chain_vote_fetch_error"]>

  export type $off_chain_vote_fetch_errorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_fetch_error"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      voting_anchor_id: bigint
      fetch_error: string
      fetch_time: Date
      retry_count: number
    }, ExtArgs["result"]["off_chain_vote_fetch_error"]>
    composites: {}
  }

  type off_chain_vote_fetch_errorGetPayload<S extends boolean | null | undefined | off_chain_vote_fetch_errorDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload, S>

  type off_chain_vote_fetch_errorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_fetch_errorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_fetch_errorCountAggregateInputType | true
    }

  export interface off_chain_vote_fetch_errorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_fetch_error'], meta: { name: 'off_chain_vote_fetch_error' } }
    /**
     * Find zero or one Off_chain_vote_fetch_error that matches the filter.
     * @param {off_chain_vote_fetch_errorFindUniqueArgs} args - Arguments to find a Off_chain_vote_fetch_error
     * @example
     * // Get one Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_fetch_errorFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_fetch_error that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_fetch_errorFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_fetch_error
     * @example
     * // Get one Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_fetch_errorFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_fetch_error that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorFindFirstArgs} args - Arguments to find a Off_chain_vote_fetch_error
     * @example
     * // Get one Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_fetch_errorFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_fetch_error that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_fetch_error
     * @example
     * // Get one Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_fetch_errorFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_fetch_errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_errors = await prisma.off_chain_vote_fetch_error.findMany()
     * 
     * // Get first 10 Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_errors = await prisma.off_chain_vote_fetch_error.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_fetch_errorWithIdOnly = await prisma.off_chain_vote_fetch_error.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_fetch_errorFindManyArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_fetch_error.
     * @param {off_chain_vote_fetch_errorCreateArgs} args - Arguments to create a Off_chain_vote_fetch_error.
     * @example
     * // Create one Off_chain_vote_fetch_error
     * const Off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_fetch_error
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_fetch_errorCreateArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorCreateArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_fetch_errors.
     * @param {off_chain_vote_fetch_errorCreateManyArgs} args - Arguments to create many Off_chain_vote_fetch_errors.
     * @example
     * // Create many Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_fetch_errorCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_fetch_errors and returns the data saved in the database.
     * @param {off_chain_vote_fetch_errorCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_fetch_errors.
     * @example
     * // Create many Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_fetch_errors and only return the `id`
     * const off_chain_vote_fetch_errorWithIdOnly = await prisma.off_chain_vote_fetch_error.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_fetch_errorCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_fetch_error.
     * @param {off_chain_vote_fetch_errorDeleteArgs} args - Arguments to delete one Off_chain_vote_fetch_error.
     * @example
     * // Delete one Off_chain_vote_fetch_error
     * const Off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_fetch_error
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_fetch_errorDeleteArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_fetch_error.
     * @param {off_chain_vote_fetch_errorUpdateArgs} args - Arguments to update one Off_chain_vote_fetch_error.
     * @example
     * // Update one Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_fetch_errorUpdateArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_fetch_errors.
     * @param {off_chain_vote_fetch_errorDeleteManyArgs} args - Arguments to filter Off_chain_vote_fetch_errors to delete.
     * @example
     * // Delete a few Off_chain_vote_fetch_errors
     * const { count } = await prisma.off_chain_vote_fetch_error.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_fetch_errorDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_fetch_errorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_fetch_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_fetch_errorUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_fetch_errors and returns the data updated in the database.
     * @param {off_chain_vote_fetch_errorUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_fetch_errors.
     * @example
     * // Update many Off_chain_vote_fetch_errors
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_fetch_errors and only return the `id`
     * const off_chain_vote_fetch_errorWithIdOnly = await prisma.off_chain_vote_fetch_error.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_fetch_errorUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_fetch_error.
     * @param {off_chain_vote_fetch_errorUpsertArgs} args - Arguments to update or create a Off_chain_vote_fetch_error.
     * @example
     * // Update or create a Off_chain_vote_fetch_error
     * const off_chain_vote_fetch_error = await prisma.off_chain_vote_fetch_error.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_fetch_error
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_fetch_error we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_fetch_errorUpsertArgs>(args: SelectSubset<T, off_chain_vote_fetch_errorUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_fetch_errorClient<$Result.GetResult<Prisma.$off_chain_vote_fetch_errorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_fetch_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorCountArgs} args - Arguments to filter Off_chain_vote_fetch_errors to count.
     * @example
     * // Count the number of Off_chain_vote_fetch_errors
     * const count = await prisma.off_chain_vote_fetch_error.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_fetch_errors we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_fetch_errorCountArgs>(
      args?: Subset<T, off_chain_vote_fetch_errorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_fetch_errorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_fetch_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_fetch_errorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_fetch_errorAggregateArgs>(args: Subset<T, Off_chain_vote_fetch_errorAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_fetch_errorAggregateType<T>>

    /**
     * Group by Off_chain_vote_fetch_error.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_fetch_errorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_fetch_errorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_fetch_errorGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_fetch_errorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_fetch_errorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_fetch_errorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_fetch_error model
   */
  readonly fields: off_chain_vote_fetch_errorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_fetch_error.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_fetch_errorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_fetch_error model
   */ 
  interface off_chain_vote_fetch_errorFieldRefs {
    readonly id: FieldRef<"off_chain_vote_fetch_error", 'BigInt'>
    readonly voting_anchor_id: FieldRef<"off_chain_vote_fetch_error", 'BigInt'>
    readonly fetch_error: FieldRef<"off_chain_vote_fetch_error", 'String'>
    readonly fetch_time: FieldRef<"off_chain_vote_fetch_error", 'DateTime'>
    readonly retry_count: FieldRef<"off_chain_vote_fetch_error", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_fetch_error findUnique
   */
  export type off_chain_vote_fetch_errorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_fetch_error to fetch.
     */
    where: off_chain_vote_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_vote_fetch_error findUniqueOrThrow
   */
  export type off_chain_vote_fetch_errorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_fetch_error to fetch.
     */
    where: off_chain_vote_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_vote_fetch_error findFirst
   */
  export type off_chain_vote_fetch_errorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_fetch_error to fetch.
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_fetch_errors to fetch.
     */
    orderBy?: off_chain_vote_fetch_errorOrderByWithRelationInput | off_chain_vote_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_fetch_errors.
     */
    cursor?: off_chain_vote_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_fetch_errors.
     */
    distinct?: Off_chain_vote_fetch_errorScalarFieldEnum | Off_chain_vote_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_fetch_error findFirstOrThrow
   */
  export type off_chain_vote_fetch_errorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_fetch_error to fetch.
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_fetch_errors to fetch.
     */
    orderBy?: off_chain_vote_fetch_errorOrderByWithRelationInput | off_chain_vote_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_fetch_errors.
     */
    cursor?: off_chain_vote_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_fetch_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_fetch_errors.
     */
    distinct?: Off_chain_vote_fetch_errorScalarFieldEnum | Off_chain_vote_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_fetch_error findMany
   */
  export type off_chain_vote_fetch_errorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_fetch_errors to fetch.
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_fetch_errors to fetch.
     */
    orderBy?: off_chain_vote_fetch_errorOrderByWithRelationInput | off_chain_vote_fetch_errorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_fetch_errors.
     */
    cursor?: off_chain_vote_fetch_errorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_fetch_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_fetch_errors.
     */
    skip?: number
    distinct?: Off_chain_vote_fetch_errorScalarFieldEnum | Off_chain_vote_fetch_errorScalarFieldEnum[]
  }

  /**
   * off_chain_vote_fetch_error create
   */
  export type off_chain_vote_fetch_errorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_fetch_error.
     */
    data: XOR<off_chain_vote_fetch_errorCreateInput, off_chain_vote_fetch_errorUncheckedCreateInput>
  }

  /**
   * off_chain_vote_fetch_error createMany
   */
  export type off_chain_vote_fetch_errorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_fetch_errors.
     */
    data: off_chain_vote_fetch_errorCreateManyInput | off_chain_vote_fetch_errorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_fetch_error createManyAndReturn
   */
  export type off_chain_vote_fetch_errorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_fetch_errors.
     */
    data: off_chain_vote_fetch_errorCreateManyInput | off_chain_vote_fetch_errorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_fetch_error update
   */
  export type off_chain_vote_fetch_errorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_fetch_error.
     */
    data: XOR<off_chain_vote_fetch_errorUpdateInput, off_chain_vote_fetch_errorUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_fetch_error to update.
     */
    where: off_chain_vote_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_vote_fetch_error updateMany
   */
  export type off_chain_vote_fetch_errorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_fetch_errors.
     */
    data: XOR<off_chain_vote_fetch_errorUpdateManyMutationInput, off_chain_vote_fetch_errorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_fetch_errors to update
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * Limit how many off_chain_vote_fetch_errors to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_fetch_error updateManyAndReturn
   */
  export type off_chain_vote_fetch_errorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_fetch_errors.
     */
    data: XOR<off_chain_vote_fetch_errorUpdateManyMutationInput, off_chain_vote_fetch_errorUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_fetch_errors to update
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * Limit how many off_chain_vote_fetch_errors to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_fetch_error upsert
   */
  export type off_chain_vote_fetch_errorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_fetch_error to update in case it exists.
     */
    where: off_chain_vote_fetch_errorWhereUniqueInput
    /**
     * In case the off_chain_vote_fetch_error found by the `where` argument doesn't exist, create a new off_chain_vote_fetch_error with this data.
     */
    create: XOR<off_chain_vote_fetch_errorCreateInput, off_chain_vote_fetch_errorUncheckedCreateInput>
    /**
     * In case the off_chain_vote_fetch_error was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_fetch_errorUpdateInput, off_chain_vote_fetch_errorUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_fetch_error delete
   */
  export type off_chain_vote_fetch_errorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_fetch_error to delete.
     */
    where: off_chain_vote_fetch_errorWhereUniqueInput
  }

  /**
   * off_chain_vote_fetch_error deleteMany
   */
  export type off_chain_vote_fetch_errorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_fetch_errors to delete
     */
    where?: off_chain_vote_fetch_errorWhereInput
    /**
     * Limit how many off_chain_vote_fetch_errors to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_fetch_error without action
   */
  export type off_chain_vote_fetch_errorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_fetch_error
     */
    select?: off_chain_vote_fetch_errorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_fetch_error
     */
    omit?: off_chain_vote_fetch_errorOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_gov_action_data
   */

  export type AggregateOff_chain_vote_gov_action_data = {
    _count: Off_chain_vote_gov_action_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_gov_action_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_gov_action_dataSumAggregateOutputType | null
    _min: Off_chain_vote_gov_action_dataMinAggregateOutputType | null
    _max: Off_chain_vote_gov_action_dataMaxAggregateOutputType | null
  }

  export type Off_chain_vote_gov_action_dataAvgAggregateOutputType = {
    id: number | null
    off_chain_vote_data_id: number | null
  }

  export type Off_chain_vote_gov_action_dataSumAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
  }

  export type Off_chain_vote_gov_action_dataMinAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    title: string | null
    abstract: string | null
    motivation: string | null
    rationale: string | null
  }

  export type Off_chain_vote_gov_action_dataMaxAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    title: string | null
    abstract: string | null
    motivation: string | null
    rationale: string | null
  }

  export type Off_chain_vote_gov_action_dataCountAggregateOutputType = {
    id: number
    off_chain_vote_data_id: number
    title: number
    abstract: number
    motivation: number
    rationale: number
    _all: number
  }


  export type Off_chain_vote_gov_action_dataAvgAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_gov_action_dataSumAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_gov_action_dataMinAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    abstract?: true
    motivation?: true
    rationale?: true
  }

  export type Off_chain_vote_gov_action_dataMaxAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    abstract?: true
    motivation?: true
    rationale?: true
  }

  export type Off_chain_vote_gov_action_dataCountAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    title?: true
    abstract?: true
    motivation?: true
    rationale?: true
    _all?: true
  }

  export type Off_chain_vote_gov_action_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_gov_action_data to aggregate.
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_gov_action_data to fetch.
     */
    orderBy?: off_chain_vote_gov_action_dataOrderByWithRelationInput | off_chain_vote_gov_action_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_gov_action_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_gov_action_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_gov_action_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_gov_action_data
    **/
    _count?: true | Off_chain_vote_gov_action_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_gov_action_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_gov_action_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_gov_action_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_gov_action_dataMaxAggregateInputType
  }

  export type GetOff_chain_vote_gov_action_dataAggregateType<T extends Off_chain_vote_gov_action_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_gov_action_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_gov_action_data[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_gov_action_data[P]>
  }




  export type off_chain_vote_gov_action_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_gov_action_dataWhereInput
    orderBy?: off_chain_vote_gov_action_dataOrderByWithAggregationInput | off_chain_vote_gov_action_dataOrderByWithAggregationInput[]
    by: Off_chain_vote_gov_action_dataScalarFieldEnum[] | Off_chain_vote_gov_action_dataScalarFieldEnum
    having?: off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_gov_action_dataCountAggregateInputType | true
    _avg?: Off_chain_vote_gov_action_dataAvgAggregateInputType
    _sum?: Off_chain_vote_gov_action_dataSumAggregateInputType
    _min?: Off_chain_vote_gov_action_dataMinAggregateInputType
    _max?: Off_chain_vote_gov_action_dataMaxAggregateInputType
  }

  export type Off_chain_vote_gov_action_dataGroupByOutputType = {
    id: bigint
    off_chain_vote_data_id: bigint
    title: string
    abstract: string
    motivation: string
    rationale: string
    _count: Off_chain_vote_gov_action_dataCountAggregateOutputType | null
    _avg: Off_chain_vote_gov_action_dataAvgAggregateOutputType | null
    _sum: Off_chain_vote_gov_action_dataSumAggregateOutputType | null
    _min: Off_chain_vote_gov_action_dataMinAggregateOutputType | null
    _max: Off_chain_vote_gov_action_dataMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_gov_action_dataGroupByPayload<T extends off_chain_vote_gov_action_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_gov_action_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_gov_action_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_gov_action_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_gov_action_dataGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_gov_action_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    abstract?: boolean
    motivation?: boolean
    rationale?: boolean
  }, ExtArgs["result"]["off_chain_vote_gov_action_data"]>

  export type off_chain_vote_gov_action_dataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    abstract?: boolean
    motivation?: boolean
    rationale?: boolean
  }, ExtArgs["result"]["off_chain_vote_gov_action_data"]>

  export type off_chain_vote_gov_action_dataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    abstract?: boolean
    motivation?: boolean
    rationale?: boolean
  }, ExtArgs["result"]["off_chain_vote_gov_action_data"]>

  export type off_chain_vote_gov_action_dataSelectScalar = {
    id?: boolean
    off_chain_vote_data_id?: boolean
    title?: boolean
    abstract?: boolean
    motivation?: boolean
    rationale?: boolean
  }

  export type off_chain_vote_gov_action_dataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "off_chain_vote_data_id" | "title" | "abstract" | "motivation" | "rationale", ExtArgs["result"]["off_chain_vote_gov_action_data"]>

  export type $off_chain_vote_gov_action_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_gov_action_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      off_chain_vote_data_id: bigint
      title: string
      abstract: string
      motivation: string
      rationale: string
    }, ExtArgs["result"]["off_chain_vote_gov_action_data"]>
    composites: {}
  }

  type off_chain_vote_gov_action_dataGetPayload<S extends boolean | null | undefined | off_chain_vote_gov_action_dataDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload, S>

  type off_chain_vote_gov_action_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_gov_action_dataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_gov_action_dataCountAggregateInputType | true
    }

  export interface off_chain_vote_gov_action_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_gov_action_data'], meta: { name: 'off_chain_vote_gov_action_data' } }
    /**
     * Find zero or one Off_chain_vote_gov_action_data that matches the filter.
     * @param {off_chain_vote_gov_action_dataFindUniqueArgs} args - Arguments to find a Off_chain_vote_gov_action_data
     * @example
     * // Get one Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_gov_action_dataFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_gov_action_data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_gov_action_dataFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_gov_action_data
     * @example
     * // Get one Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_gov_action_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_gov_action_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataFindFirstArgs} args - Arguments to find a Off_chain_vote_gov_action_data
     * @example
     * // Get one Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_gov_action_dataFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_gov_action_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_gov_action_data
     * @example
     * // Get one Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_gov_action_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_gov_action_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findMany()
     * 
     * // Get first 10 Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_gov_action_dataWithIdOnly = await prisma.off_chain_vote_gov_action_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_gov_action_dataFindManyArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataCreateArgs} args - Arguments to create a Off_chain_vote_gov_action_data.
     * @example
     * // Create one Off_chain_vote_gov_action_data
     * const Off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_gov_action_data
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_gov_action_dataCreateArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataCreateArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataCreateManyArgs} args - Arguments to create many Off_chain_vote_gov_action_data.
     * @example
     * // Create many Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_gov_action_dataCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_gov_action_data and returns the data saved in the database.
     * @param {off_chain_vote_gov_action_dataCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_gov_action_data.
     * @example
     * // Create many Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_gov_action_data and only return the `id`
     * const off_chain_vote_gov_action_dataWithIdOnly = await prisma.off_chain_vote_gov_action_data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_gov_action_dataCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataDeleteArgs} args - Arguments to delete one Off_chain_vote_gov_action_data.
     * @example
     * // Delete one Off_chain_vote_gov_action_data
     * const Off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_gov_action_data
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_gov_action_dataDeleteArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataUpdateArgs} args - Arguments to update one Off_chain_vote_gov_action_data.
     * @example
     * // Update one Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_gov_action_dataUpdateArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataDeleteManyArgs} args - Arguments to filter Off_chain_vote_gov_action_data to delete.
     * @example
     * // Delete a few Off_chain_vote_gov_action_data
     * const { count } = await prisma.off_chain_vote_gov_action_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_gov_action_dataDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_gov_action_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_gov_action_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_gov_action_dataUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_gov_action_data and returns the data updated in the database.
     * @param {off_chain_vote_gov_action_dataUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_gov_action_data.
     * @example
     * // Update many Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_gov_action_data and only return the `id`
     * const off_chain_vote_gov_action_dataWithIdOnly = await prisma.off_chain_vote_gov_action_data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_gov_action_dataUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_gov_action_data.
     * @param {off_chain_vote_gov_action_dataUpsertArgs} args - Arguments to update or create a Off_chain_vote_gov_action_data.
     * @example
     * // Update or create a Off_chain_vote_gov_action_data
     * const off_chain_vote_gov_action_data = await prisma.off_chain_vote_gov_action_data.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_gov_action_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_gov_action_data we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_gov_action_dataUpsertArgs>(args: SelectSubset<T, off_chain_vote_gov_action_dataUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_gov_action_dataClient<$Result.GetResult<Prisma.$off_chain_vote_gov_action_dataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_gov_action_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataCountArgs} args - Arguments to filter Off_chain_vote_gov_action_data to count.
     * @example
     * // Count the number of Off_chain_vote_gov_action_data
     * const count = await prisma.off_chain_vote_gov_action_data.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_gov_action_data we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_gov_action_dataCountArgs>(
      args?: Subset<T, off_chain_vote_gov_action_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_gov_action_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_gov_action_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_gov_action_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_gov_action_dataAggregateArgs>(args: Subset<T, Off_chain_vote_gov_action_dataAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_gov_action_dataAggregateType<T>>

    /**
     * Group by Off_chain_vote_gov_action_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_gov_action_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_gov_action_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_gov_action_dataGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_gov_action_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_gov_action_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_gov_action_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_gov_action_data model
   */
  readonly fields: off_chain_vote_gov_action_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_gov_action_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_gov_action_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_gov_action_data model
   */ 
  interface off_chain_vote_gov_action_dataFieldRefs {
    readonly id: FieldRef<"off_chain_vote_gov_action_data", 'BigInt'>
    readonly off_chain_vote_data_id: FieldRef<"off_chain_vote_gov_action_data", 'BigInt'>
    readonly title: FieldRef<"off_chain_vote_gov_action_data", 'String'>
    readonly abstract: FieldRef<"off_chain_vote_gov_action_data", 'String'>
    readonly motivation: FieldRef<"off_chain_vote_gov_action_data", 'String'>
    readonly rationale: FieldRef<"off_chain_vote_gov_action_data", 'String'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_gov_action_data findUnique
   */
  export type off_chain_vote_gov_action_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_gov_action_data to fetch.
     */
    where: off_chain_vote_gov_action_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_gov_action_data findUniqueOrThrow
   */
  export type off_chain_vote_gov_action_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_gov_action_data to fetch.
     */
    where: off_chain_vote_gov_action_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_gov_action_data findFirst
   */
  export type off_chain_vote_gov_action_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_gov_action_data to fetch.
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_gov_action_data to fetch.
     */
    orderBy?: off_chain_vote_gov_action_dataOrderByWithRelationInput | off_chain_vote_gov_action_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_gov_action_data.
     */
    cursor?: off_chain_vote_gov_action_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_gov_action_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_gov_action_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_gov_action_data.
     */
    distinct?: Off_chain_vote_gov_action_dataScalarFieldEnum | Off_chain_vote_gov_action_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_gov_action_data findFirstOrThrow
   */
  export type off_chain_vote_gov_action_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_gov_action_data to fetch.
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_gov_action_data to fetch.
     */
    orderBy?: off_chain_vote_gov_action_dataOrderByWithRelationInput | off_chain_vote_gov_action_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_gov_action_data.
     */
    cursor?: off_chain_vote_gov_action_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_gov_action_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_gov_action_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_gov_action_data.
     */
    distinct?: Off_chain_vote_gov_action_dataScalarFieldEnum | Off_chain_vote_gov_action_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_gov_action_data findMany
   */
  export type off_chain_vote_gov_action_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_gov_action_data to fetch.
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_gov_action_data to fetch.
     */
    orderBy?: off_chain_vote_gov_action_dataOrderByWithRelationInput | off_chain_vote_gov_action_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_gov_action_data.
     */
    cursor?: off_chain_vote_gov_action_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_gov_action_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_gov_action_data.
     */
    skip?: number
    distinct?: Off_chain_vote_gov_action_dataScalarFieldEnum | Off_chain_vote_gov_action_dataScalarFieldEnum[]
  }

  /**
   * off_chain_vote_gov_action_data create
   */
  export type off_chain_vote_gov_action_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_gov_action_data.
     */
    data: XOR<off_chain_vote_gov_action_dataCreateInput, off_chain_vote_gov_action_dataUncheckedCreateInput>
  }

  /**
   * off_chain_vote_gov_action_data createMany
   */
  export type off_chain_vote_gov_action_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_gov_action_data.
     */
    data: off_chain_vote_gov_action_dataCreateManyInput | off_chain_vote_gov_action_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_gov_action_data createManyAndReturn
   */
  export type off_chain_vote_gov_action_dataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_gov_action_data.
     */
    data: off_chain_vote_gov_action_dataCreateManyInput | off_chain_vote_gov_action_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_gov_action_data update
   */
  export type off_chain_vote_gov_action_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_gov_action_data.
     */
    data: XOR<off_chain_vote_gov_action_dataUpdateInput, off_chain_vote_gov_action_dataUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_gov_action_data to update.
     */
    where: off_chain_vote_gov_action_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_gov_action_data updateMany
   */
  export type off_chain_vote_gov_action_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_gov_action_data.
     */
    data: XOR<off_chain_vote_gov_action_dataUpdateManyMutationInput, off_chain_vote_gov_action_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_gov_action_data to update
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * Limit how many off_chain_vote_gov_action_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_gov_action_data updateManyAndReturn
   */
  export type off_chain_vote_gov_action_dataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_gov_action_data.
     */
    data: XOR<off_chain_vote_gov_action_dataUpdateManyMutationInput, off_chain_vote_gov_action_dataUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_gov_action_data to update
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * Limit how many off_chain_vote_gov_action_data to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_gov_action_data upsert
   */
  export type off_chain_vote_gov_action_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_gov_action_data to update in case it exists.
     */
    where: off_chain_vote_gov_action_dataWhereUniqueInput
    /**
     * In case the off_chain_vote_gov_action_data found by the `where` argument doesn't exist, create a new off_chain_vote_gov_action_data with this data.
     */
    create: XOR<off_chain_vote_gov_action_dataCreateInput, off_chain_vote_gov_action_dataUncheckedCreateInput>
    /**
     * In case the off_chain_vote_gov_action_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_gov_action_dataUpdateInput, off_chain_vote_gov_action_dataUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_gov_action_data delete
   */
  export type off_chain_vote_gov_action_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_gov_action_data to delete.
     */
    where: off_chain_vote_gov_action_dataWhereUniqueInput
  }

  /**
   * off_chain_vote_gov_action_data deleteMany
   */
  export type off_chain_vote_gov_action_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_gov_action_data to delete
     */
    where?: off_chain_vote_gov_action_dataWhereInput
    /**
     * Limit how many off_chain_vote_gov_action_data to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_gov_action_data without action
   */
  export type off_chain_vote_gov_action_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_gov_action_data
     */
    select?: off_chain_vote_gov_action_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_gov_action_data
     */
    omit?: off_chain_vote_gov_action_dataOmit<ExtArgs> | null
  }


  /**
   * Model off_chain_vote_reference
   */

  export type AggregateOff_chain_vote_reference = {
    _count: Off_chain_vote_referenceCountAggregateOutputType | null
    _avg: Off_chain_vote_referenceAvgAggregateOutputType | null
    _sum: Off_chain_vote_referenceSumAggregateOutputType | null
    _min: Off_chain_vote_referenceMinAggregateOutputType | null
    _max: Off_chain_vote_referenceMaxAggregateOutputType | null
  }

  export type Off_chain_vote_referenceAvgAggregateOutputType = {
    id: number | null
    off_chain_vote_data_id: number | null
  }

  export type Off_chain_vote_referenceSumAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
  }

  export type Off_chain_vote_referenceMinAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    label: string | null
    uri: string | null
    hash_digest: string | null
    hash_algorithm: string | null
  }

  export type Off_chain_vote_referenceMaxAggregateOutputType = {
    id: bigint | null
    off_chain_vote_data_id: bigint | null
    label: string | null
    uri: string | null
    hash_digest: string | null
    hash_algorithm: string | null
  }

  export type Off_chain_vote_referenceCountAggregateOutputType = {
    id: number
    off_chain_vote_data_id: number
    label: number
    uri: number
    hash_digest: number
    hash_algorithm: number
    _all: number
  }


  export type Off_chain_vote_referenceAvgAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_referenceSumAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
  }

  export type Off_chain_vote_referenceMinAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    label?: true
    uri?: true
    hash_digest?: true
    hash_algorithm?: true
  }

  export type Off_chain_vote_referenceMaxAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    label?: true
    uri?: true
    hash_digest?: true
    hash_algorithm?: true
  }

  export type Off_chain_vote_referenceCountAggregateInputType = {
    id?: true
    off_chain_vote_data_id?: true
    label?: true
    uri?: true
    hash_digest?: true
    hash_algorithm?: true
    _all?: true
  }

  export type Off_chain_vote_referenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_reference to aggregate.
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_references to fetch.
     */
    orderBy?: off_chain_vote_referenceOrderByWithRelationInput | off_chain_vote_referenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: off_chain_vote_referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned off_chain_vote_references
    **/
    _count?: true | Off_chain_vote_referenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Off_chain_vote_referenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Off_chain_vote_referenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Off_chain_vote_referenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Off_chain_vote_referenceMaxAggregateInputType
  }

  export type GetOff_chain_vote_referenceAggregateType<T extends Off_chain_vote_referenceAggregateArgs> = {
        [P in keyof T & keyof AggregateOff_chain_vote_reference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOff_chain_vote_reference[P]>
      : GetScalarType<T[P], AggregateOff_chain_vote_reference[P]>
  }




  export type off_chain_vote_referenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: off_chain_vote_referenceWhereInput
    orderBy?: off_chain_vote_referenceOrderByWithAggregationInput | off_chain_vote_referenceOrderByWithAggregationInput[]
    by: Off_chain_vote_referenceScalarFieldEnum[] | Off_chain_vote_referenceScalarFieldEnum
    having?: off_chain_vote_referenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Off_chain_vote_referenceCountAggregateInputType | true
    _avg?: Off_chain_vote_referenceAvgAggregateInputType
    _sum?: Off_chain_vote_referenceSumAggregateInputType
    _min?: Off_chain_vote_referenceMinAggregateInputType
    _max?: Off_chain_vote_referenceMaxAggregateInputType
  }

  export type Off_chain_vote_referenceGroupByOutputType = {
    id: bigint
    off_chain_vote_data_id: bigint
    label: string
    uri: string
    hash_digest: string | null
    hash_algorithm: string | null
    _count: Off_chain_vote_referenceCountAggregateOutputType | null
    _avg: Off_chain_vote_referenceAvgAggregateOutputType | null
    _sum: Off_chain_vote_referenceSumAggregateOutputType | null
    _min: Off_chain_vote_referenceMinAggregateOutputType | null
    _max: Off_chain_vote_referenceMaxAggregateOutputType | null
  }

  type GetOff_chain_vote_referenceGroupByPayload<T extends off_chain_vote_referenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Off_chain_vote_referenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Off_chain_vote_referenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Off_chain_vote_referenceGroupByOutputType[P]>
            : GetScalarType<T[P], Off_chain_vote_referenceGroupByOutputType[P]>
        }
      >
    >


  export type off_chain_vote_referenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    label?: boolean
    uri?: boolean
    hash_digest?: boolean
    hash_algorithm?: boolean
  }, ExtArgs["result"]["off_chain_vote_reference"]>

  export type off_chain_vote_referenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    label?: boolean
    uri?: boolean
    hash_digest?: boolean
    hash_algorithm?: boolean
  }, ExtArgs["result"]["off_chain_vote_reference"]>

  export type off_chain_vote_referenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    off_chain_vote_data_id?: boolean
    label?: boolean
    uri?: boolean
    hash_digest?: boolean
    hash_algorithm?: boolean
  }, ExtArgs["result"]["off_chain_vote_reference"]>

  export type off_chain_vote_referenceSelectScalar = {
    id?: boolean
    off_chain_vote_data_id?: boolean
    label?: boolean
    uri?: boolean
    hash_digest?: boolean
    hash_algorithm?: boolean
  }

  export type off_chain_vote_referenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "off_chain_vote_data_id" | "label" | "uri" | "hash_digest" | "hash_algorithm", ExtArgs["result"]["off_chain_vote_reference"]>

  export type $off_chain_vote_referencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "off_chain_vote_reference"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      off_chain_vote_data_id: bigint
      label: string
      uri: string
      hash_digest: string | null
      hash_algorithm: string | null
    }, ExtArgs["result"]["off_chain_vote_reference"]>
    composites: {}
  }

  type off_chain_vote_referenceGetPayload<S extends boolean | null | undefined | off_chain_vote_referenceDefaultArgs> = $Result.GetResult<Prisma.$off_chain_vote_referencePayload, S>

  type off_chain_vote_referenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<off_chain_vote_referenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Off_chain_vote_referenceCountAggregateInputType | true
    }

  export interface off_chain_vote_referenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['off_chain_vote_reference'], meta: { name: 'off_chain_vote_reference' } }
    /**
     * Find zero or one Off_chain_vote_reference that matches the filter.
     * @param {off_chain_vote_referenceFindUniqueArgs} args - Arguments to find a Off_chain_vote_reference
     * @example
     * // Get one Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends off_chain_vote_referenceFindUniqueArgs>(args: SelectSubset<T, off_chain_vote_referenceFindUniqueArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Off_chain_vote_reference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {off_chain_vote_referenceFindUniqueOrThrowArgs} args - Arguments to find a Off_chain_vote_reference
     * @example
     * // Get one Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends off_chain_vote_referenceFindUniqueOrThrowArgs>(args: SelectSubset<T, off_chain_vote_referenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_reference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceFindFirstArgs} args - Arguments to find a Off_chain_vote_reference
     * @example
     * // Get one Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends off_chain_vote_referenceFindFirstArgs>(args?: SelectSubset<T, off_chain_vote_referenceFindFirstArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Off_chain_vote_reference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceFindFirstOrThrowArgs} args - Arguments to find a Off_chain_vote_reference
     * @example
     * // Get one Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends off_chain_vote_referenceFindFirstOrThrowArgs>(args?: SelectSubset<T, off_chain_vote_referenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Off_chain_vote_references that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Off_chain_vote_references
     * const off_chain_vote_references = await prisma.off_chain_vote_reference.findMany()
     * 
     * // Get first 10 Off_chain_vote_references
     * const off_chain_vote_references = await prisma.off_chain_vote_reference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const off_chain_vote_referenceWithIdOnly = await prisma.off_chain_vote_reference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends off_chain_vote_referenceFindManyArgs>(args?: SelectSubset<T, off_chain_vote_referenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Off_chain_vote_reference.
     * @param {off_chain_vote_referenceCreateArgs} args - Arguments to create a Off_chain_vote_reference.
     * @example
     * // Create one Off_chain_vote_reference
     * const Off_chain_vote_reference = await prisma.off_chain_vote_reference.create({
     *   data: {
     *     // ... data to create a Off_chain_vote_reference
     *   }
     * })
     * 
     */
    create<T extends off_chain_vote_referenceCreateArgs>(args: SelectSubset<T, off_chain_vote_referenceCreateArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Off_chain_vote_references.
     * @param {off_chain_vote_referenceCreateManyArgs} args - Arguments to create many Off_chain_vote_references.
     * @example
     * // Create many Off_chain_vote_references
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends off_chain_vote_referenceCreateManyArgs>(args?: SelectSubset<T, off_chain_vote_referenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Off_chain_vote_references and returns the data saved in the database.
     * @param {off_chain_vote_referenceCreateManyAndReturnArgs} args - Arguments to create many Off_chain_vote_references.
     * @example
     * // Create many Off_chain_vote_references
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Off_chain_vote_references and only return the `id`
     * const off_chain_vote_referenceWithIdOnly = await prisma.off_chain_vote_reference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends off_chain_vote_referenceCreateManyAndReturnArgs>(args?: SelectSubset<T, off_chain_vote_referenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Off_chain_vote_reference.
     * @param {off_chain_vote_referenceDeleteArgs} args - Arguments to delete one Off_chain_vote_reference.
     * @example
     * // Delete one Off_chain_vote_reference
     * const Off_chain_vote_reference = await prisma.off_chain_vote_reference.delete({
     *   where: {
     *     // ... filter to delete one Off_chain_vote_reference
     *   }
     * })
     * 
     */
    delete<T extends off_chain_vote_referenceDeleteArgs>(args: SelectSubset<T, off_chain_vote_referenceDeleteArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Off_chain_vote_reference.
     * @param {off_chain_vote_referenceUpdateArgs} args - Arguments to update one Off_chain_vote_reference.
     * @example
     * // Update one Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends off_chain_vote_referenceUpdateArgs>(args: SelectSubset<T, off_chain_vote_referenceUpdateArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Off_chain_vote_references.
     * @param {off_chain_vote_referenceDeleteManyArgs} args - Arguments to filter Off_chain_vote_references to delete.
     * @example
     * // Delete a few Off_chain_vote_references
     * const { count } = await prisma.off_chain_vote_reference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends off_chain_vote_referenceDeleteManyArgs>(args?: SelectSubset<T, off_chain_vote_referenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Off_chain_vote_references
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends off_chain_vote_referenceUpdateManyArgs>(args: SelectSubset<T, off_chain_vote_referenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Off_chain_vote_references and returns the data updated in the database.
     * @param {off_chain_vote_referenceUpdateManyAndReturnArgs} args - Arguments to update many Off_chain_vote_references.
     * @example
     * // Update many Off_chain_vote_references
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Off_chain_vote_references and only return the `id`
     * const off_chain_vote_referenceWithIdOnly = await prisma.off_chain_vote_reference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends off_chain_vote_referenceUpdateManyAndReturnArgs>(args: SelectSubset<T, off_chain_vote_referenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Off_chain_vote_reference.
     * @param {off_chain_vote_referenceUpsertArgs} args - Arguments to update or create a Off_chain_vote_reference.
     * @example
     * // Update or create a Off_chain_vote_reference
     * const off_chain_vote_reference = await prisma.off_chain_vote_reference.upsert({
     *   create: {
     *     // ... data to create a Off_chain_vote_reference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Off_chain_vote_reference we want to update
     *   }
     * })
     */
    upsert<T extends off_chain_vote_referenceUpsertArgs>(args: SelectSubset<T, off_chain_vote_referenceUpsertArgs<ExtArgs>>): Prisma__off_chain_vote_referenceClient<$Result.GetResult<Prisma.$off_chain_vote_referencePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Off_chain_vote_references.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceCountArgs} args - Arguments to filter Off_chain_vote_references to count.
     * @example
     * // Count the number of Off_chain_vote_references
     * const count = await prisma.off_chain_vote_reference.count({
     *   where: {
     *     // ... the filter for the Off_chain_vote_references we want to count
     *   }
     * })
    **/
    count<T extends off_chain_vote_referenceCountArgs>(
      args?: Subset<T, off_chain_vote_referenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Off_chain_vote_referenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Off_chain_vote_reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Off_chain_vote_referenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Off_chain_vote_referenceAggregateArgs>(args: Subset<T, Off_chain_vote_referenceAggregateArgs>): Prisma.PrismaPromise<GetOff_chain_vote_referenceAggregateType<T>>

    /**
     * Group by Off_chain_vote_reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {off_chain_vote_referenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends off_chain_vote_referenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: off_chain_vote_referenceGroupByArgs['orderBy'] }
        : { orderBy?: off_chain_vote_referenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, off_chain_vote_referenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOff_chain_vote_referenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the off_chain_vote_reference model
   */
  readonly fields: off_chain_vote_referenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for off_chain_vote_reference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__off_chain_vote_referenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the off_chain_vote_reference model
   */ 
  interface off_chain_vote_referenceFieldRefs {
    readonly id: FieldRef<"off_chain_vote_reference", 'BigInt'>
    readonly off_chain_vote_data_id: FieldRef<"off_chain_vote_reference", 'BigInt'>
    readonly label: FieldRef<"off_chain_vote_reference", 'String'>
    readonly uri: FieldRef<"off_chain_vote_reference", 'String'>
    readonly hash_digest: FieldRef<"off_chain_vote_reference", 'String'>
    readonly hash_algorithm: FieldRef<"off_chain_vote_reference", 'String'>
  }
    

  // Custom InputTypes
  /**
   * off_chain_vote_reference findUnique
   */
  export type off_chain_vote_referenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_reference to fetch.
     */
    where: off_chain_vote_referenceWhereUniqueInput
  }

  /**
   * off_chain_vote_reference findUniqueOrThrow
   */
  export type off_chain_vote_referenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_reference to fetch.
     */
    where: off_chain_vote_referenceWhereUniqueInput
  }

  /**
   * off_chain_vote_reference findFirst
   */
  export type off_chain_vote_referenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_reference to fetch.
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_references to fetch.
     */
    orderBy?: off_chain_vote_referenceOrderByWithRelationInput | off_chain_vote_referenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_references.
     */
    cursor?: off_chain_vote_referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_references.
     */
    distinct?: Off_chain_vote_referenceScalarFieldEnum | Off_chain_vote_referenceScalarFieldEnum[]
  }

  /**
   * off_chain_vote_reference findFirstOrThrow
   */
  export type off_chain_vote_referenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_reference to fetch.
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_references to fetch.
     */
    orderBy?: off_chain_vote_referenceOrderByWithRelationInput | off_chain_vote_referenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for off_chain_vote_references.
     */
    cursor?: off_chain_vote_referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of off_chain_vote_references.
     */
    distinct?: Off_chain_vote_referenceScalarFieldEnum | Off_chain_vote_referenceScalarFieldEnum[]
  }

  /**
   * off_chain_vote_reference findMany
   */
  export type off_chain_vote_referenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter, which off_chain_vote_references to fetch.
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of off_chain_vote_references to fetch.
     */
    orderBy?: off_chain_vote_referenceOrderByWithRelationInput | off_chain_vote_referenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing off_chain_vote_references.
     */
    cursor?: off_chain_vote_referenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` off_chain_vote_references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` off_chain_vote_references.
     */
    skip?: number
    distinct?: Off_chain_vote_referenceScalarFieldEnum | Off_chain_vote_referenceScalarFieldEnum[]
  }

  /**
   * off_chain_vote_reference create
   */
  export type off_chain_vote_referenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * The data needed to create a off_chain_vote_reference.
     */
    data: XOR<off_chain_vote_referenceCreateInput, off_chain_vote_referenceUncheckedCreateInput>
  }

  /**
   * off_chain_vote_reference createMany
   */
  export type off_chain_vote_referenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many off_chain_vote_references.
     */
    data: off_chain_vote_referenceCreateManyInput | off_chain_vote_referenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_reference createManyAndReturn
   */
  export type off_chain_vote_referenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * The data used to create many off_chain_vote_references.
     */
    data: off_chain_vote_referenceCreateManyInput | off_chain_vote_referenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * off_chain_vote_reference update
   */
  export type off_chain_vote_referenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * The data needed to update a off_chain_vote_reference.
     */
    data: XOR<off_chain_vote_referenceUpdateInput, off_chain_vote_referenceUncheckedUpdateInput>
    /**
     * Choose, which off_chain_vote_reference to update.
     */
    where: off_chain_vote_referenceWhereUniqueInput
  }

  /**
   * off_chain_vote_reference updateMany
   */
  export type off_chain_vote_referenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update off_chain_vote_references.
     */
    data: XOR<off_chain_vote_referenceUpdateManyMutationInput, off_chain_vote_referenceUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_references to update
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * Limit how many off_chain_vote_references to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_reference updateManyAndReturn
   */
  export type off_chain_vote_referenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * The data used to update off_chain_vote_references.
     */
    data: XOR<off_chain_vote_referenceUpdateManyMutationInput, off_chain_vote_referenceUncheckedUpdateManyInput>
    /**
     * Filter which off_chain_vote_references to update
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * Limit how many off_chain_vote_references to update.
     */
    limit?: number
  }

  /**
   * off_chain_vote_reference upsert
   */
  export type off_chain_vote_referenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * The filter to search for the off_chain_vote_reference to update in case it exists.
     */
    where: off_chain_vote_referenceWhereUniqueInput
    /**
     * In case the off_chain_vote_reference found by the `where` argument doesn't exist, create a new off_chain_vote_reference with this data.
     */
    create: XOR<off_chain_vote_referenceCreateInput, off_chain_vote_referenceUncheckedCreateInput>
    /**
     * In case the off_chain_vote_reference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<off_chain_vote_referenceUpdateInput, off_chain_vote_referenceUncheckedUpdateInput>
  }

  /**
   * off_chain_vote_reference delete
   */
  export type off_chain_vote_referenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
    /**
     * Filter which off_chain_vote_reference to delete.
     */
    where: off_chain_vote_referenceWhereUniqueInput
  }

  /**
   * off_chain_vote_reference deleteMany
   */
  export type off_chain_vote_referenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which off_chain_vote_references to delete
     */
    where?: off_chain_vote_referenceWhereInput
    /**
     * Limit how many off_chain_vote_references to delete.
     */
    limit?: number
  }

  /**
   * off_chain_vote_reference without action
   */
  export type off_chain_vote_referenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the off_chain_vote_reference
     */
    select?: off_chain_vote_referenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the off_chain_vote_reference
     */
    omit?: off_chain_vote_referenceOmit<ExtArgs> | null
  }


  /**
   * Model param_proposal
   */

  export type AggregateParam_proposal = {
    _count: Param_proposalCountAggregateOutputType | null
    _avg: Param_proposalAvgAggregateOutputType | null
    _sum: Param_proposalSumAggregateOutputType | null
    _min: Param_proposalMinAggregateOutputType | null
    _max: Param_proposalMaxAggregateOutputType | null
  }

  export type Param_proposalAvgAggregateOutputType = {
    id: number | null
    epoch_no: number | null
    min_fee_a: Decimal | null
    min_fee_b: Decimal | null
    max_block_size: Decimal | null
    max_tx_size: Decimal | null
    max_bh_size: Decimal | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: Decimal | null
    optimal_pool_count: Decimal | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: number | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    registered_tx_id: number | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Param_proposalSumAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    min_fee_a: Decimal | null
    min_fee_b: Decimal | null
    max_block_size: Decimal | null
    max_tx_size: Decimal | null
    max_bh_size: Decimal | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: Decimal | null
    optimal_pool_count: Decimal | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    registered_tx_id: bigint | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Param_proposalMinAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    key: Uint8Array | null
    min_fee_a: Decimal | null
    min_fee_b: Decimal | null
    max_block_size: Decimal | null
    max_tx_size: Decimal | null
    max_bh_size: Decimal | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: Decimal | null
    optimal_pool_count: Decimal | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    entropy: Uint8Array | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    registered_tx_id: bigint | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Param_proposalMaxAggregateOutputType = {
    id: bigint | null
    epoch_no: number | null
    key: Uint8Array | null
    min_fee_a: Decimal | null
    min_fee_b: Decimal | null
    max_block_size: Decimal | null
    max_tx_size: Decimal | null
    max_bh_size: Decimal | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: Decimal | null
    optimal_pool_count: Decimal | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    entropy: Uint8Array | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    registered_tx_id: bigint | null
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
  }

  export type Param_proposalCountAggregateOutputType = {
    id: number
    epoch_no: number
    key: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: number
    pool_deposit: number
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    entropy: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: number
    min_pool_cost: number
    cost_model_id: number
    price_mem: number
    price_step: number
    max_tx_ex_mem: number
    max_tx_ex_steps: number
    max_block_ex_mem: number
    max_block_ex_steps: number
    max_val_size: number
    collateral_percent: number
    max_collateral_inputs: number
    registered_tx_id: number
    coins_per_utxo_size: number
    pvt_motion_no_confidence: number
    pvt_committee_normal: number
    pvt_committee_no_confidence: number
    pvt_hard_fork_initiation: number
    dvt_motion_no_confidence: number
    dvt_committee_normal: number
    dvt_committee_no_confidence: number
    dvt_update_to_constitution: number
    dvt_hard_fork_initiation: number
    dvt_p_p_network_group: number
    dvt_p_p_economic_group: number
    dvt_p_p_technical_group: number
    dvt_p_p_gov_group: number
    dvt_treasury_withdrawal: number
    committee_min_size: number
    committee_max_term_length: number
    gov_action_lifetime: number
    gov_action_deposit: number
    drep_deposit: number
    drep_activity: number
    pvtpp_security_group: number
    min_fee_ref_script_cost_per_byte: number
    _all: number
  }


  export type Param_proposalAvgAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    registered_tx_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Param_proposalSumAggregateInputType = {
    id?: true
    epoch_no?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    registered_tx_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Param_proposalMinAggregateInputType = {
    id?: true
    epoch_no?: true
    key?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    entropy?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    registered_tx_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Param_proposalMaxAggregateInputType = {
    id?: true
    epoch_no?: true
    key?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    entropy?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    registered_tx_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
  }

  export type Param_proposalCountAggregateInputType = {
    id?: true
    epoch_no?: true
    key?: true
    min_fee_a?: true
    min_fee_b?: true
    max_block_size?: true
    max_tx_size?: true
    max_bh_size?: true
    key_deposit?: true
    pool_deposit?: true
    max_epoch?: true
    optimal_pool_count?: true
    influence?: true
    monetary_expand_rate?: true
    treasury_growth_rate?: true
    decentralisation?: true
    entropy?: true
    protocol_major?: true
    protocol_minor?: true
    min_utxo_value?: true
    min_pool_cost?: true
    cost_model_id?: true
    price_mem?: true
    price_step?: true
    max_tx_ex_mem?: true
    max_tx_ex_steps?: true
    max_block_ex_mem?: true
    max_block_ex_steps?: true
    max_val_size?: true
    collateral_percent?: true
    max_collateral_inputs?: true
    registered_tx_id?: true
    coins_per_utxo_size?: true
    pvt_motion_no_confidence?: true
    pvt_committee_normal?: true
    pvt_committee_no_confidence?: true
    pvt_hard_fork_initiation?: true
    dvt_motion_no_confidence?: true
    dvt_committee_normal?: true
    dvt_committee_no_confidence?: true
    dvt_update_to_constitution?: true
    dvt_hard_fork_initiation?: true
    dvt_p_p_network_group?: true
    dvt_p_p_economic_group?: true
    dvt_p_p_technical_group?: true
    dvt_p_p_gov_group?: true
    dvt_treasury_withdrawal?: true
    committee_min_size?: true
    committee_max_term_length?: true
    gov_action_lifetime?: true
    gov_action_deposit?: true
    drep_deposit?: true
    drep_activity?: true
    pvtpp_security_group?: true
    min_fee_ref_script_cost_per_byte?: true
    _all?: true
  }

  export type Param_proposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which param_proposal to aggregate.
     */
    where?: param_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of param_proposals to fetch.
     */
    orderBy?: param_proposalOrderByWithRelationInput | param_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: param_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` param_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` param_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned param_proposals
    **/
    _count?: true | Param_proposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Param_proposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Param_proposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Param_proposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Param_proposalMaxAggregateInputType
  }

  export type GetParam_proposalAggregateType<T extends Param_proposalAggregateArgs> = {
        [P in keyof T & keyof AggregateParam_proposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParam_proposal[P]>
      : GetScalarType<T[P], AggregateParam_proposal[P]>
  }




  export type param_proposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: param_proposalWhereInput
    orderBy?: param_proposalOrderByWithAggregationInput | param_proposalOrderByWithAggregationInput[]
    by: Param_proposalScalarFieldEnum[] | Param_proposalScalarFieldEnum
    having?: param_proposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Param_proposalCountAggregateInputType | true
    _avg?: Param_proposalAvgAggregateInputType
    _sum?: Param_proposalSumAggregateInputType
    _min?: Param_proposalMinAggregateInputType
    _max?: Param_proposalMaxAggregateInputType
  }

  export type Param_proposalGroupByOutputType = {
    id: bigint
    epoch_no: number | null
    key: Uint8Array | null
    min_fee_a: Decimal | null
    min_fee_b: Decimal | null
    max_block_size: Decimal | null
    max_tx_size: Decimal | null
    max_bh_size: Decimal | null
    key_deposit: Decimal | null
    pool_deposit: Decimal | null
    max_epoch: Decimal | null
    optimal_pool_count: Decimal | null
    influence: number | null
    monetary_expand_rate: number | null
    treasury_growth_rate: number | null
    decentralisation: number | null
    entropy: Uint8Array | null
    protocol_major: number | null
    protocol_minor: number | null
    min_utxo_value: Decimal | null
    min_pool_cost: Decimal | null
    cost_model_id: bigint | null
    price_mem: number | null
    price_step: number | null
    max_tx_ex_mem: Decimal | null
    max_tx_ex_steps: Decimal | null
    max_block_ex_mem: Decimal | null
    max_block_ex_steps: Decimal | null
    max_val_size: Decimal | null
    collateral_percent: number | null
    max_collateral_inputs: number | null
    registered_tx_id: bigint
    coins_per_utxo_size: Decimal | null
    pvt_motion_no_confidence: number | null
    pvt_committee_normal: number | null
    pvt_committee_no_confidence: number | null
    pvt_hard_fork_initiation: number | null
    dvt_motion_no_confidence: number | null
    dvt_committee_normal: number | null
    dvt_committee_no_confidence: number | null
    dvt_update_to_constitution: number | null
    dvt_hard_fork_initiation: number | null
    dvt_p_p_network_group: number | null
    dvt_p_p_economic_group: number | null
    dvt_p_p_technical_group: number | null
    dvt_p_p_gov_group: number | null
    dvt_treasury_withdrawal: number | null
    committee_min_size: Decimal | null
    committee_max_term_length: Decimal | null
    gov_action_lifetime: Decimal | null
    gov_action_deposit: Decimal | null
    drep_deposit: Decimal | null
    drep_activity: Decimal | null
    pvtpp_security_group: number | null
    min_fee_ref_script_cost_per_byte: number | null
    _count: Param_proposalCountAggregateOutputType | null
    _avg: Param_proposalAvgAggregateOutputType | null
    _sum: Param_proposalSumAggregateOutputType | null
    _min: Param_proposalMinAggregateOutputType | null
    _max: Param_proposalMaxAggregateOutputType | null
  }

  type GetParam_proposalGroupByPayload<T extends param_proposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Param_proposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Param_proposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Param_proposalGroupByOutputType[P]>
            : GetScalarType<T[P], Param_proposalGroupByOutputType[P]>
        }
      >
    >


  export type param_proposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    key?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    entropy?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    registered_tx_id?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["param_proposal"]>

  export type param_proposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    key?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    entropy?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    registered_tx_id?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["param_proposal"]>

  export type param_proposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    epoch_no?: boolean
    key?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    entropy?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    registered_tx_id?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }, ExtArgs["result"]["param_proposal"]>

  export type param_proposalSelectScalar = {
    id?: boolean
    epoch_no?: boolean
    key?: boolean
    min_fee_a?: boolean
    min_fee_b?: boolean
    max_block_size?: boolean
    max_tx_size?: boolean
    max_bh_size?: boolean
    key_deposit?: boolean
    pool_deposit?: boolean
    max_epoch?: boolean
    optimal_pool_count?: boolean
    influence?: boolean
    monetary_expand_rate?: boolean
    treasury_growth_rate?: boolean
    decentralisation?: boolean
    entropy?: boolean
    protocol_major?: boolean
    protocol_minor?: boolean
    min_utxo_value?: boolean
    min_pool_cost?: boolean
    cost_model_id?: boolean
    price_mem?: boolean
    price_step?: boolean
    max_tx_ex_mem?: boolean
    max_tx_ex_steps?: boolean
    max_block_ex_mem?: boolean
    max_block_ex_steps?: boolean
    max_val_size?: boolean
    collateral_percent?: boolean
    max_collateral_inputs?: boolean
    registered_tx_id?: boolean
    coins_per_utxo_size?: boolean
    pvt_motion_no_confidence?: boolean
    pvt_committee_normal?: boolean
    pvt_committee_no_confidence?: boolean
    pvt_hard_fork_initiation?: boolean
    dvt_motion_no_confidence?: boolean
    dvt_committee_normal?: boolean
    dvt_committee_no_confidence?: boolean
    dvt_update_to_constitution?: boolean
    dvt_hard_fork_initiation?: boolean
    dvt_p_p_network_group?: boolean
    dvt_p_p_economic_group?: boolean
    dvt_p_p_technical_group?: boolean
    dvt_p_p_gov_group?: boolean
    dvt_treasury_withdrawal?: boolean
    committee_min_size?: boolean
    committee_max_term_length?: boolean
    gov_action_lifetime?: boolean
    gov_action_deposit?: boolean
    drep_deposit?: boolean
    drep_activity?: boolean
    pvtpp_security_group?: boolean
    min_fee_ref_script_cost_per_byte?: boolean
  }

  export type param_proposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "epoch_no" | "key" | "min_fee_a" | "min_fee_b" | "max_block_size" | "max_tx_size" | "max_bh_size" | "key_deposit" | "pool_deposit" | "max_epoch" | "optimal_pool_count" | "influence" | "monetary_expand_rate" | "treasury_growth_rate" | "decentralisation" | "entropy" | "protocol_major" | "protocol_minor" | "min_utxo_value" | "min_pool_cost" | "cost_model_id" | "price_mem" | "price_step" | "max_tx_ex_mem" | "max_tx_ex_steps" | "max_block_ex_mem" | "max_block_ex_steps" | "max_val_size" | "collateral_percent" | "max_collateral_inputs" | "registered_tx_id" | "coins_per_utxo_size" | "pvt_motion_no_confidence" | "pvt_committee_normal" | "pvt_committee_no_confidence" | "pvt_hard_fork_initiation" | "dvt_motion_no_confidence" | "dvt_committee_normal" | "dvt_committee_no_confidence" | "dvt_update_to_constitution" | "dvt_hard_fork_initiation" | "dvt_p_p_network_group" | "dvt_p_p_economic_group" | "dvt_p_p_technical_group" | "dvt_p_p_gov_group" | "dvt_treasury_withdrawal" | "committee_min_size" | "committee_max_term_length" | "gov_action_lifetime" | "gov_action_deposit" | "drep_deposit" | "drep_activity" | "pvtpp_security_group" | "min_fee_ref_script_cost_per_byte", ExtArgs["result"]["param_proposal"]>

  export type $param_proposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "param_proposal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      epoch_no: number | null
      key: Uint8Array | null
      min_fee_a: Prisma.Decimal | null
      min_fee_b: Prisma.Decimal | null
      max_block_size: Prisma.Decimal | null
      max_tx_size: Prisma.Decimal | null
      max_bh_size: Prisma.Decimal | null
      key_deposit: Prisma.Decimal | null
      pool_deposit: Prisma.Decimal | null
      max_epoch: Prisma.Decimal | null
      optimal_pool_count: Prisma.Decimal | null
      influence: number | null
      monetary_expand_rate: number | null
      treasury_growth_rate: number | null
      decentralisation: number | null
      entropy: Uint8Array | null
      protocol_major: number | null
      protocol_minor: number | null
      min_utxo_value: Prisma.Decimal | null
      min_pool_cost: Prisma.Decimal | null
      cost_model_id: bigint | null
      price_mem: number | null
      price_step: number | null
      max_tx_ex_mem: Prisma.Decimal | null
      max_tx_ex_steps: Prisma.Decimal | null
      max_block_ex_mem: Prisma.Decimal | null
      max_block_ex_steps: Prisma.Decimal | null
      max_val_size: Prisma.Decimal | null
      collateral_percent: number | null
      max_collateral_inputs: number | null
      registered_tx_id: bigint
      coins_per_utxo_size: Prisma.Decimal | null
      pvt_motion_no_confidence: number | null
      pvt_committee_normal: number | null
      pvt_committee_no_confidence: number | null
      pvt_hard_fork_initiation: number | null
      dvt_motion_no_confidence: number | null
      dvt_committee_normal: number | null
      dvt_committee_no_confidence: number | null
      dvt_update_to_constitution: number | null
      dvt_hard_fork_initiation: number | null
      dvt_p_p_network_group: number | null
      dvt_p_p_economic_group: number | null
      dvt_p_p_technical_group: number | null
      dvt_p_p_gov_group: number | null
      dvt_treasury_withdrawal: number | null
      committee_min_size: Prisma.Decimal | null
      committee_max_term_length: Prisma.Decimal | null
      gov_action_lifetime: Prisma.Decimal | null
      gov_action_deposit: Prisma.Decimal | null
      drep_deposit: Prisma.Decimal | null
      drep_activity: Prisma.Decimal | null
      pvtpp_security_group: number | null
      min_fee_ref_script_cost_per_byte: number | null
    }, ExtArgs["result"]["param_proposal"]>
    composites: {}
  }

  type param_proposalGetPayload<S extends boolean | null | undefined | param_proposalDefaultArgs> = $Result.GetResult<Prisma.$param_proposalPayload, S>

  type param_proposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<param_proposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Param_proposalCountAggregateInputType | true
    }

  export interface param_proposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['param_proposal'], meta: { name: 'param_proposal' } }
    /**
     * Find zero or one Param_proposal that matches the filter.
     * @param {param_proposalFindUniqueArgs} args - Arguments to find a Param_proposal
     * @example
     * // Get one Param_proposal
     * const param_proposal = await prisma.param_proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends param_proposalFindUniqueArgs>(args: SelectSubset<T, param_proposalFindUniqueArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Param_proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {param_proposalFindUniqueOrThrowArgs} args - Arguments to find a Param_proposal
     * @example
     * // Get one Param_proposal
     * const param_proposal = await prisma.param_proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends param_proposalFindUniqueOrThrowArgs>(args: SelectSubset<T, param_proposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Param_proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalFindFirstArgs} args - Arguments to find a Param_proposal
     * @example
     * // Get one Param_proposal
     * const param_proposal = await prisma.param_proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends param_proposalFindFirstArgs>(args?: SelectSubset<T, param_proposalFindFirstArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Param_proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalFindFirstOrThrowArgs} args - Arguments to find a Param_proposal
     * @example
     * // Get one Param_proposal
     * const param_proposal = await prisma.param_proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends param_proposalFindFirstOrThrowArgs>(args?: SelectSubset<T, param_proposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Param_proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Param_proposals
     * const param_proposals = await prisma.param_proposal.findMany()
     * 
     * // Get first 10 Param_proposals
     * const param_proposals = await prisma.param_proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const param_proposalWithIdOnly = await prisma.param_proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends param_proposalFindManyArgs>(args?: SelectSubset<T, param_proposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Param_proposal.
     * @param {param_proposalCreateArgs} args - Arguments to create a Param_proposal.
     * @example
     * // Create one Param_proposal
     * const Param_proposal = await prisma.param_proposal.create({
     *   data: {
     *     // ... data to create a Param_proposal
     *   }
     * })
     * 
     */
    create<T extends param_proposalCreateArgs>(args: SelectSubset<T, param_proposalCreateArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Param_proposals.
     * @param {param_proposalCreateManyArgs} args - Arguments to create many Param_proposals.
     * @example
     * // Create many Param_proposals
     * const param_proposal = await prisma.param_proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends param_proposalCreateManyArgs>(args?: SelectSubset<T, param_proposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Param_proposals and returns the data saved in the database.
     * @param {param_proposalCreateManyAndReturnArgs} args - Arguments to create many Param_proposals.
     * @example
     * // Create many Param_proposals
     * const param_proposal = await prisma.param_proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Param_proposals and only return the `id`
     * const param_proposalWithIdOnly = await prisma.param_proposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends param_proposalCreateManyAndReturnArgs>(args?: SelectSubset<T, param_proposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Param_proposal.
     * @param {param_proposalDeleteArgs} args - Arguments to delete one Param_proposal.
     * @example
     * // Delete one Param_proposal
     * const Param_proposal = await prisma.param_proposal.delete({
     *   where: {
     *     // ... filter to delete one Param_proposal
     *   }
     * })
     * 
     */
    delete<T extends param_proposalDeleteArgs>(args: SelectSubset<T, param_proposalDeleteArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Param_proposal.
     * @param {param_proposalUpdateArgs} args - Arguments to update one Param_proposal.
     * @example
     * // Update one Param_proposal
     * const param_proposal = await prisma.param_proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends param_proposalUpdateArgs>(args: SelectSubset<T, param_proposalUpdateArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Param_proposals.
     * @param {param_proposalDeleteManyArgs} args - Arguments to filter Param_proposals to delete.
     * @example
     * // Delete a few Param_proposals
     * const { count } = await prisma.param_proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends param_proposalDeleteManyArgs>(args?: SelectSubset<T, param_proposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Param_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Param_proposals
     * const param_proposal = await prisma.param_proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends param_proposalUpdateManyArgs>(args: SelectSubset<T, param_proposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Param_proposals and returns the data updated in the database.
     * @param {param_proposalUpdateManyAndReturnArgs} args - Arguments to update many Param_proposals.
     * @example
     * // Update many Param_proposals
     * const param_proposal = await prisma.param_proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Param_proposals and only return the `id`
     * const param_proposalWithIdOnly = await prisma.param_proposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends param_proposalUpdateManyAndReturnArgs>(args: SelectSubset<T, param_proposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Param_proposal.
     * @param {param_proposalUpsertArgs} args - Arguments to update or create a Param_proposal.
     * @example
     * // Update or create a Param_proposal
     * const param_proposal = await prisma.param_proposal.upsert({
     *   create: {
     *     // ... data to create a Param_proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Param_proposal we want to update
     *   }
     * })
     */
    upsert<T extends param_proposalUpsertArgs>(args: SelectSubset<T, param_proposalUpsertArgs<ExtArgs>>): Prisma__param_proposalClient<$Result.GetResult<Prisma.$param_proposalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Param_proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalCountArgs} args - Arguments to filter Param_proposals to count.
     * @example
     * // Count the number of Param_proposals
     * const count = await prisma.param_proposal.count({
     *   where: {
     *     // ... the filter for the Param_proposals we want to count
     *   }
     * })
    **/
    count<T extends param_proposalCountArgs>(
      args?: Subset<T, param_proposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Param_proposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Param_proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Param_proposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Param_proposalAggregateArgs>(args: Subset<T, Param_proposalAggregateArgs>): Prisma.PrismaPromise<GetParam_proposalAggregateType<T>>

    /**
     * Group by Param_proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {param_proposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends param_proposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: param_proposalGroupByArgs['orderBy'] }
        : { orderBy?: param_proposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, param_proposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParam_proposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the param_proposal model
   */
  readonly fields: param_proposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for param_proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__param_proposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the param_proposal model
   */ 
  interface param_proposalFieldRefs {
    readonly id: FieldRef<"param_proposal", 'BigInt'>
    readonly epoch_no: FieldRef<"param_proposal", 'Int'>
    readonly key: FieldRef<"param_proposal", 'Bytes'>
    readonly min_fee_a: FieldRef<"param_proposal", 'Decimal'>
    readonly min_fee_b: FieldRef<"param_proposal", 'Decimal'>
    readonly max_block_size: FieldRef<"param_proposal", 'Decimal'>
    readonly max_tx_size: FieldRef<"param_proposal", 'Decimal'>
    readonly max_bh_size: FieldRef<"param_proposal", 'Decimal'>
    readonly key_deposit: FieldRef<"param_proposal", 'Decimal'>
    readonly pool_deposit: FieldRef<"param_proposal", 'Decimal'>
    readonly max_epoch: FieldRef<"param_proposal", 'Decimal'>
    readonly optimal_pool_count: FieldRef<"param_proposal", 'Decimal'>
    readonly influence: FieldRef<"param_proposal", 'Float'>
    readonly monetary_expand_rate: FieldRef<"param_proposal", 'Float'>
    readonly treasury_growth_rate: FieldRef<"param_proposal", 'Float'>
    readonly decentralisation: FieldRef<"param_proposal", 'Float'>
    readonly entropy: FieldRef<"param_proposal", 'Bytes'>
    readonly protocol_major: FieldRef<"param_proposal", 'Int'>
    readonly protocol_minor: FieldRef<"param_proposal", 'Int'>
    readonly min_utxo_value: FieldRef<"param_proposal", 'Decimal'>
    readonly min_pool_cost: FieldRef<"param_proposal", 'Decimal'>
    readonly cost_model_id: FieldRef<"param_proposal", 'BigInt'>
    readonly price_mem: FieldRef<"param_proposal", 'Float'>
    readonly price_step: FieldRef<"param_proposal", 'Float'>
    readonly max_tx_ex_mem: FieldRef<"param_proposal", 'Decimal'>
    readonly max_tx_ex_steps: FieldRef<"param_proposal", 'Decimal'>
    readonly max_block_ex_mem: FieldRef<"param_proposal", 'Decimal'>
    readonly max_block_ex_steps: FieldRef<"param_proposal", 'Decimal'>
    readonly max_val_size: FieldRef<"param_proposal", 'Decimal'>
    readonly collateral_percent: FieldRef<"param_proposal", 'Int'>
    readonly max_collateral_inputs: FieldRef<"param_proposal", 'Int'>
    readonly registered_tx_id: FieldRef<"param_proposal", 'BigInt'>
    readonly coins_per_utxo_size: FieldRef<"param_proposal", 'Decimal'>
    readonly pvt_motion_no_confidence: FieldRef<"param_proposal", 'Float'>
    readonly pvt_committee_normal: FieldRef<"param_proposal", 'Float'>
    readonly pvt_committee_no_confidence: FieldRef<"param_proposal", 'Float'>
    readonly pvt_hard_fork_initiation: FieldRef<"param_proposal", 'Float'>
    readonly dvt_motion_no_confidence: FieldRef<"param_proposal", 'Float'>
    readonly dvt_committee_normal: FieldRef<"param_proposal", 'Float'>
    readonly dvt_committee_no_confidence: FieldRef<"param_proposal", 'Float'>
    readonly dvt_update_to_constitution: FieldRef<"param_proposal", 'Float'>
    readonly dvt_hard_fork_initiation: FieldRef<"param_proposal", 'Float'>
    readonly dvt_p_p_network_group: FieldRef<"param_proposal", 'Float'>
    readonly dvt_p_p_economic_group: FieldRef<"param_proposal", 'Float'>
    readonly dvt_p_p_technical_group: FieldRef<"param_proposal", 'Float'>
    readonly dvt_p_p_gov_group: FieldRef<"param_proposal", 'Float'>
    readonly dvt_treasury_withdrawal: FieldRef<"param_proposal", 'Float'>
    readonly committee_min_size: FieldRef<"param_proposal", 'Decimal'>
    readonly committee_max_term_length: FieldRef<"param_proposal", 'Decimal'>
    readonly gov_action_lifetime: FieldRef<"param_proposal", 'Decimal'>
    readonly gov_action_deposit: FieldRef<"param_proposal", 'Decimal'>
    readonly drep_deposit: FieldRef<"param_proposal", 'Decimal'>
    readonly drep_activity: FieldRef<"param_proposal", 'Decimal'>
    readonly pvtpp_security_group: FieldRef<"param_proposal", 'Float'>
    readonly min_fee_ref_script_cost_per_byte: FieldRef<"param_proposal", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * param_proposal findUnique
   */
  export type param_proposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter, which param_proposal to fetch.
     */
    where: param_proposalWhereUniqueInput
  }

  /**
   * param_proposal findUniqueOrThrow
   */
  export type param_proposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter, which param_proposal to fetch.
     */
    where: param_proposalWhereUniqueInput
  }

  /**
   * param_proposal findFirst
   */
  export type param_proposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter, which param_proposal to fetch.
     */
    where?: param_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of param_proposals to fetch.
     */
    orderBy?: param_proposalOrderByWithRelationInput | param_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for param_proposals.
     */
    cursor?: param_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` param_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` param_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of param_proposals.
     */
    distinct?: Param_proposalScalarFieldEnum | Param_proposalScalarFieldEnum[]
  }

  /**
   * param_proposal findFirstOrThrow
   */
  export type param_proposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter, which param_proposal to fetch.
     */
    where?: param_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of param_proposals to fetch.
     */
    orderBy?: param_proposalOrderByWithRelationInput | param_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for param_proposals.
     */
    cursor?: param_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` param_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` param_proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of param_proposals.
     */
    distinct?: Param_proposalScalarFieldEnum | Param_proposalScalarFieldEnum[]
  }

  /**
   * param_proposal findMany
   */
  export type param_proposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter, which param_proposals to fetch.
     */
    where?: param_proposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of param_proposals to fetch.
     */
    orderBy?: param_proposalOrderByWithRelationInput | param_proposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing param_proposals.
     */
    cursor?: param_proposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` param_proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` param_proposals.
     */
    skip?: number
    distinct?: Param_proposalScalarFieldEnum | Param_proposalScalarFieldEnum[]
  }

  /**
   * param_proposal create
   */
  export type param_proposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * The data needed to create a param_proposal.
     */
    data: XOR<param_proposalCreateInput, param_proposalUncheckedCreateInput>
  }

  /**
   * param_proposal createMany
   */
  export type param_proposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many param_proposals.
     */
    data: param_proposalCreateManyInput | param_proposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * param_proposal createManyAndReturn
   */
  export type param_proposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * The data used to create many param_proposals.
     */
    data: param_proposalCreateManyInput | param_proposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * param_proposal update
   */
  export type param_proposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * The data needed to update a param_proposal.
     */
    data: XOR<param_proposalUpdateInput, param_proposalUncheckedUpdateInput>
    /**
     * Choose, which param_proposal to update.
     */
    where: param_proposalWhereUniqueInput
  }

  /**
   * param_proposal updateMany
   */
  export type param_proposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update param_proposals.
     */
    data: XOR<param_proposalUpdateManyMutationInput, param_proposalUncheckedUpdateManyInput>
    /**
     * Filter which param_proposals to update
     */
    where?: param_proposalWhereInput
    /**
     * Limit how many param_proposals to update.
     */
    limit?: number
  }

  /**
   * param_proposal updateManyAndReturn
   */
  export type param_proposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * The data used to update param_proposals.
     */
    data: XOR<param_proposalUpdateManyMutationInput, param_proposalUncheckedUpdateManyInput>
    /**
     * Filter which param_proposals to update
     */
    where?: param_proposalWhereInput
    /**
     * Limit how many param_proposals to update.
     */
    limit?: number
  }

  /**
   * param_proposal upsert
   */
  export type param_proposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * The filter to search for the param_proposal to update in case it exists.
     */
    where: param_proposalWhereUniqueInput
    /**
     * In case the param_proposal found by the `where` argument doesn't exist, create a new param_proposal with this data.
     */
    create: XOR<param_proposalCreateInput, param_proposalUncheckedCreateInput>
    /**
     * In case the param_proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<param_proposalUpdateInput, param_proposalUncheckedUpdateInput>
  }

  /**
   * param_proposal delete
   */
  export type param_proposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
    /**
     * Filter which param_proposal to delete.
     */
    where: param_proposalWhereUniqueInput
  }

  /**
   * param_proposal deleteMany
   */
  export type param_proposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which param_proposals to delete
     */
    where?: param_proposalWhereInput
    /**
     * Limit how many param_proposals to delete.
     */
    limit?: number
  }

  /**
   * param_proposal without action
   */
  export type param_proposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the param_proposal
     */
    select?: param_proposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the param_proposal
     */
    omit?: param_proposalOmit<ExtArgs> | null
  }


  /**
   * Model pool_hash
   */

  export type AggregatePool_hash = {
    _count: Pool_hashCountAggregateOutputType | null
    _avg: Pool_hashAvgAggregateOutputType | null
    _sum: Pool_hashSumAggregateOutputType | null
    _min: Pool_hashMinAggregateOutputType | null
    _max: Pool_hashMaxAggregateOutputType | null
  }

  export type Pool_hashAvgAggregateOutputType = {
    id: number | null
  }

  export type Pool_hashSumAggregateOutputType = {
    id: bigint | null
  }

  export type Pool_hashMinAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
    view: string | null
  }

  export type Pool_hashMaxAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
    view: string | null
  }

  export type Pool_hashCountAggregateOutputType = {
    id: number
    hash_raw: number
    view: number
    _all: number
  }


  export type Pool_hashAvgAggregateInputType = {
    id?: true
  }

  export type Pool_hashSumAggregateInputType = {
    id?: true
  }

  export type Pool_hashMinAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
  }

  export type Pool_hashMaxAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
  }

  export type Pool_hashCountAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
    _all?: true
  }

  export type Pool_hashAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_hash to aggregate.
     */
    where?: pool_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_hashes to fetch.
     */
    orderBy?: pool_hashOrderByWithRelationInput | pool_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_hashes
    **/
    _count?: true | Pool_hashCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_hashAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_hashSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_hashMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_hashMaxAggregateInputType
  }

  export type GetPool_hashAggregateType<T extends Pool_hashAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_hash]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_hash[P]>
      : GetScalarType<T[P], AggregatePool_hash[P]>
  }




  export type pool_hashGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_hashWhereInput
    orderBy?: pool_hashOrderByWithAggregationInput | pool_hashOrderByWithAggregationInput[]
    by: Pool_hashScalarFieldEnum[] | Pool_hashScalarFieldEnum
    having?: pool_hashScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_hashCountAggregateInputType | true
    _avg?: Pool_hashAvgAggregateInputType
    _sum?: Pool_hashSumAggregateInputType
    _min?: Pool_hashMinAggregateInputType
    _max?: Pool_hashMaxAggregateInputType
  }

  export type Pool_hashGroupByOutputType = {
    id: bigint
    hash_raw: Uint8Array
    view: string
    _count: Pool_hashCountAggregateOutputType | null
    _avg: Pool_hashAvgAggregateOutputType | null
    _sum: Pool_hashSumAggregateOutputType | null
    _min: Pool_hashMinAggregateOutputType | null
    _max: Pool_hashMaxAggregateOutputType | null
  }

  type GetPool_hashGroupByPayload<T extends pool_hashGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_hashGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_hashGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_hashGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_hashGroupByOutputType[P]>
        }
      >
    >


  export type pool_hashSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
  }, ExtArgs["result"]["pool_hash"]>

  export type pool_hashSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
  }, ExtArgs["result"]["pool_hash"]>

  export type pool_hashSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
  }, ExtArgs["result"]["pool_hash"]>

  export type pool_hashSelectScalar = {
    id?: boolean
    hash_raw?: boolean
    view?: boolean
  }

  export type pool_hashOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_raw" | "view", ExtArgs["result"]["pool_hash"]>

  export type $pool_hashPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_hash"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_raw: Uint8Array
      view: string
    }, ExtArgs["result"]["pool_hash"]>
    composites: {}
  }

  type pool_hashGetPayload<S extends boolean | null | undefined | pool_hashDefaultArgs> = $Result.GetResult<Prisma.$pool_hashPayload, S>

  type pool_hashCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_hashFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_hashCountAggregateInputType | true
    }

  export interface pool_hashDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_hash'], meta: { name: 'pool_hash' } }
    /**
     * Find zero or one Pool_hash that matches the filter.
     * @param {pool_hashFindUniqueArgs} args - Arguments to find a Pool_hash
     * @example
     * // Get one Pool_hash
     * const pool_hash = await prisma.pool_hash.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_hashFindUniqueArgs>(args: SelectSubset<T, pool_hashFindUniqueArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_hash that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_hashFindUniqueOrThrowArgs} args - Arguments to find a Pool_hash
     * @example
     * // Get one Pool_hash
     * const pool_hash = await prisma.pool_hash.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_hashFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_hashFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_hash that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashFindFirstArgs} args - Arguments to find a Pool_hash
     * @example
     * // Get one Pool_hash
     * const pool_hash = await prisma.pool_hash.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_hashFindFirstArgs>(args?: SelectSubset<T, pool_hashFindFirstArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_hash that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashFindFirstOrThrowArgs} args - Arguments to find a Pool_hash
     * @example
     * // Get one Pool_hash
     * const pool_hash = await prisma.pool_hash.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_hashFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_hashFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_hashes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_hashes
     * const pool_hashes = await prisma.pool_hash.findMany()
     * 
     * // Get first 10 Pool_hashes
     * const pool_hashes = await prisma.pool_hash.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_hashWithIdOnly = await prisma.pool_hash.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_hashFindManyArgs>(args?: SelectSubset<T, pool_hashFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_hash.
     * @param {pool_hashCreateArgs} args - Arguments to create a Pool_hash.
     * @example
     * // Create one Pool_hash
     * const Pool_hash = await prisma.pool_hash.create({
     *   data: {
     *     // ... data to create a Pool_hash
     *   }
     * })
     * 
     */
    create<T extends pool_hashCreateArgs>(args: SelectSubset<T, pool_hashCreateArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_hashes.
     * @param {pool_hashCreateManyArgs} args - Arguments to create many Pool_hashes.
     * @example
     * // Create many Pool_hashes
     * const pool_hash = await prisma.pool_hash.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_hashCreateManyArgs>(args?: SelectSubset<T, pool_hashCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_hashes and returns the data saved in the database.
     * @param {pool_hashCreateManyAndReturnArgs} args - Arguments to create many Pool_hashes.
     * @example
     * // Create many Pool_hashes
     * const pool_hash = await prisma.pool_hash.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_hashes and only return the `id`
     * const pool_hashWithIdOnly = await prisma.pool_hash.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_hashCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_hashCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_hash.
     * @param {pool_hashDeleteArgs} args - Arguments to delete one Pool_hash.
     * @example
     * // Delete one Pool_hash
     * const Pool_hash = await prisma.pool_hash.delete({
     *   where: {
     *     // ... filter to delete one Pool_hash
     *   }
     * })
     * 
     */
    delete<T extends pool_hashDeleteArgs>(args: SelectSubset<T, pool_hashDeleteArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_hash.
     * @param {pool_hashUpdateArgs} args - Arguments to update one Pool_hash.
     * @example
     * // Update one Pool_hash
     * const pool_hash = await prisma.pool_hash.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_hashUpdateArgs>(args: SelectSubset<T, pool_hashUpdateArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_hashes.
     * @param {pool_hashDeleteManyArgs} args - Arguments to filter Pool_hashes to delete.
     * @example
     * // Delete a few Pool_hashes
     * const { count } = await prisma.pool_hash.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_hashDeleteManyArgs>(args?: SelectSubset<T, pool_hashDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_hashes
     * const pool_hash = await prisma.pool_hash.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_hashUpdateManyArgs>(args: SelectSubset<T, pool_hashUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_hashes and returns the data updated in the database.
     * @param {pool_hashUpdateManyAndReturnArgs} args - Arguments to update many Pool_hashes.
     * @example
     * // Update many Pool_hashes
     * const pool_hash = await prisma.pool_hash.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_hashes and only return the `id`
     * const pool_hashWithIdOnly = await prisma.pool_hash.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_hashUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_hashUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_hash.
     * @param {pool_hashUpsertArgs} args - Arguments to update or create a Pool_hash.
     * @example
     * // Update or create a Pool_hash
     * const pool_hash = await prisma.pool_hash.upsert({
     *   create: {
     *     // ... data to create a Pool_hash
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_hash we want to update
     *   }
     * })
     */
    upsert<T extends pool_hashUpsertArgs>(args: SelectSubset<T, pool_hashUpsertArgs<ExtArgs>>): Prisma__pool_hashClient<$Result.GetResult<Prisma.$pool_hashPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_hashes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashCountArgs} args - Arguments to filter Pool_hashes to count.
     * @example
     * // Count the number of Pool_hashes
     * const count = await prisma.pool_hash.count({
     *   where: {
     *     // ... the filter for the Pool_hashes we want to count
     *   }
     * })
    **/
    count<T extends pool_hashCountArgs>(
      args?: Subset<T, pool_hashCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_hashCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_hashAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_hashAggregateArgs>(args: Subset<T, Pool_hashAggregateArgs>): Prisma.PrismaPromise<GetPool_hashAggregateType<T>>

    /**
     * Group by Pool_hash.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_hashGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_hashGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_hashGroupByArgs['orderBy'] }
        : { orderBy?: pool_hashGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_hashGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_hashGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_hash model
   */
  readonly fields: pool_hashFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_hash.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_hashClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_hash model
   */ 
  interface pool_hashFieldRefs {
    readonly id: FieldRef<"pool_hash", 'BigInt'>
    readonly hash_raw: FieldRef<"pool_hash", 'Bytes'>
    readonly view: FieldRef<"pool_hash", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pool_hash findUnique
   */
  export type pool_hashFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter, which pool_hash to fetch.
     */
    where: pool_hashWhereUniqueInput
  }

  /**
   * pool_hash findUniqueOrThrow
   */
  export type pool_hashFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter, which pool_hash to fetch.
     */
    where: pool_hashWhereUniqueInput
  }

  /**
   * pool_hash findFirst
   */
  export type pool_hashFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter, which pool_hash to fetch.
     */
    where?: pool_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_hashes to fetch.
     */
    orderBy?: pool_hashOrderByWithRelationInput | pool_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_hashes.
     */
    cursor?: pool_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_hashes.
     */
    distinct?: Pool_hashScalarFieldEnum | Pool_hashScalarFieldEnum[]
  }

  /**
   * pool_hash findFirstOrThrow
   */
  export type pool_hashFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter, which pool_hash to fetch.
     */
    where?: pool_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_hashes to fetch.
     */
    orderBy?: pool_hashOrderByWithRelationInput | pool_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_hashes.
     */
    cursor?: pool_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_hashes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_hashes.
     */
    distinct?: Pool_hashScalarFieldEnum | Pool_hashScalarFieldEnum[]
  }

  /**
   * pool_hash findMany
   */
  export type pool_hashFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter, which pool_hashes to fetch.
     */
    where?: pool_hashWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_hashes to fetch.
     */
    orderBy?: pool_hashOrderByWithRelationInput | pool_hashOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_hashes.
     */
    cursor?: pool_hashWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_hashes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_hashes.
     */
    skip?: number
    distinct?: Pool_hashScalarFieldEnum | Pool_hashScalarFieldEnum[]
  }

  /**
   * pool_hash create
   */
  export type pool_hashCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_hash.
     */
    data: XOR<pool_hashCreateInput, pool_hashUncheckedCreateInput>
  }

  /**
   * pool_hash createMany
   */
  export type pool_hashCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_hashes.
     */
    data: pool_hashCreateManyInput | pool_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_hash createManyAndReturn
   */
  export type pool_hashCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * The data used to create many pool_hashes.
     */
    data: pool_hashCreateManyInput | pool_hashCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_hash update
   */
  export type pool_hashUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_hash.
     */
    data: XOR<pool_hashUpdateInput, pool_hashUncheckedUpdateInput>
    /**
     * Choose, which pool_hash to update.
     */
    where: pool_hashWhereUniqueInput
  }

  /**
   * pool_hash updateMany
   */
  export type pool_hashUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_hashes.
     */
    data: XOR<pool_hashUpdateManyMutationInput, pool_hashUncheckedUpdateManyInput>
    /**
     * Filter which pool_hashes to update
     */
    where?: pool_hashWhereInput
    /**
     * Limit how many pool_hashes to update.
     */
    limit?: number
  }

  /**
   * pool_hash updateManyAndReturn
   */
  export type pool_hashUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * The data used to update pool_hashes.
     */
    data: XOR<pool_hashUpdateManyMutationInput, pool_hashUncheckedUpdateManyInput>
    /**
     * Filter which pool_hashes to update
     */
    where?: pool_hashWhereInput
    /**
     * Limit how many pool_hashes to update.
     */
    limit?: number
  }

  /**
   * pool_hash upsert
   */
  export type pool_hashUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_hash to update in case it exists.
     */
    where: pool_hashWhereUniqueInput
    /**
     * In case the pool_hash found by the `where` argument doesn't exist, create a new pool_hash with this data.
     */
    create: XOR<pool_hashCreateInput, pool_hashUncheckedCreateInput>
    /**
     * In case the pool_hash was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_hashUpdateInput, pool_hashUncheckedUpdateInput>
  }

  /**
   * pool_hash delete
   */
  export type pool_hashDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
    /**
     * Filter which pool_hash to delete.
     */
    where: pool_hashWhereUniqueInput
  }

  /**
   * pool_hash deleteMany
   */
  export type pool_hashDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_hashes to delete
     */
    where?: pool_hashWhereInput
    /**
     * Limit how many pool_hashes to delete.
     */
    limit?: number
  }

  /**
   * pool_hash without action
   */
  export type pool_hashDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_hash
     */
    select?: pool_hashSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_hash
     */
    omit?: pool_hashOmit<ExtArgs> | null
  }


  /**
   * Model pool_metadata_ref
   */

  export type AggregatePool_metadata_ref = {
    _count: Pool_metadata_refCountAggregateOutputType | null
    _avg: Pool_metadata_refAvgAggregateOutputType | null
    _sum: Pool_metadata_refSumAggregateOutputType | null
    _min: Pool_metadata_refMinAggregateOutputType | null
    _max: Pool_metadata_refMaxAggregateOutputType | null
  }

  export type Pool_metadata_refAvgAggregateOutputType = {
    id: number | null
    pool_id: number | null
    registered_tx_id: number | null
  }

  export type Pool_metadata_refSumAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    registered_tx_id: bigint | null
  }

  export type Pool_metadata_refMinAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    url: string | null
    hash: Uint8Array | null
    registered_tx_id: bigint | null
  }

  export type Pool_metadata_refMaxAggregateOutputType = {
    id: bigint | null
    pool_id: bigint | null
    url: string | null
    hash: Uint8Array | null
    registered_tx_id: bigint | null
  }

  export type Pool_metadata_refCountAggregateOutputType = {
    id: number
    pool_id: number
    url: number
    hash: number
    registered_tx_id: number
    _all: number
  }


  export type Pool_metadata_refAvgAggregateInputType = {
    id?: true
    pool_id?: true
    registered_tx_id?: true
  }

  export type Pool_metadata_refSumAggregateInputType = {
    id?: true
    pool_id?: true
    registered_tx_id?: true
  }

  export type Pool_metadata_refMinAggregateInputType = {
    id?: true
    pool_id?: true
    url?: true
    hash?: true
    registered_tx_id?: true
  }

  export type Pool_metadata_refMaxAggregateInputType = {
    id?: true
    pool_id?: true
    url?: true
    hash?: true
    registered_tx_id?: true
  }

  export type Pool_metadata_refCountAggregateInputType = {
    id?: true
    pool_id?: true
    url?: true
    hash?: true
    registered_tx_id?: true
    _all?: true
  }

  export type Pool_metadata_refAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_metadata_ref to aggregate.
     */
    where?: pool_metadata_refWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_metadata_refs to fetch.
     */
    orderBy?: pool_metadata_refOrderByWithRelationInput | pool_metadata_refOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_metadata_refWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_metadata_refs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_metadata_refs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_metadata_refs
    **/
    _count?: true | Pool_metadata_refCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_metadata_refAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_metadata_refSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_metadata_refMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_metadata_refMaxAggregateInputType
  }

  export type GetPool_metadata_refAggregateType<T extends Pool_metadata_refAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_metadata_ref]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_metadata_ref[P]>
      : GetScalarType<T[P], AggregatePool_metadata_ref[P]>
  }




  export type pool_metadata_refGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_metadata_refWhereInput
    orderBy?: pool_metadata_refOrderByWithAggregationInput | pool_metadata_refOrderByWithAggregationInput[]
    by: Pool_metadata_refScalarFieldEnum[] | Pool_metadata_refScalarFieldEnum
    having?: pool_metadata_refScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_metadata_refCountAggregateInputType | true
    _avg?: Pool_metadata_refAvgAggregateInputType
    _sum?: Pool_metadata_refSumAggregateInputType
    _min?: Pool_metadata_refMinAggregateInputType
    _max?: Pool_metadata_refMaxAggregateInputType
  }

  export type Pool_metadata_refGroupByOutputType = {
    id: bigint
    pool_id: bigint
    url: string
    hash: Uint8Array
    registered_tx_id: bigint
    _count: Pool_metadata_refCountAggregateOutputType | null
    _avg: Pool_metadata_refAvgAggregateOutputType | null
    _sum: Pool_metadata_refSumAggregateOutputType | null
    _min: Pool_metadata_refMinAggregateOutputType | null
    _max: Pool_metadata_refMaxAggregateOutputType | null
  }

  type GetPool_metadata_refGroupByPayload<T extends pool_metadata_refGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_metadata_refGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_metadata_refGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_metadata_refGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_metadata_refGroupByOutputType[P]>
        }
      >
    >


  export type pool_metadata_refSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    url?: boolean
    hash?: boolean
    registered_tx_id?: boolean
  }, ExtArgs["result"]["pool_metadata_ref"]>

  export type pool_metadata_refSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    url?: boolean
    hash?: boolean
    registered_tx_id?: boolean
  }, ExtArgs["result"]["pool_metadata_ref"]>

  export type pool_metadata_refSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_id?: boolean
    url?: boolean
    hash?: boolean
    registered_tx_id?: boolean
  }, ExtArgs["result"]["pool_metadata_ref"]>

  export type pool_metadata_refSelectScalar = {
    id?: boolean
    pool_id?: boolean
    url?: boolean
    hash?: boolean
    registered_tx_id?: boolean
  }

  export type pool_metadata_refOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pool_id" | "url" | "hash" | "registered_tx_id", ExtArgs["result"]["pool_metadata_ref"]>

  export type $pool_metadata_refPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_metadata_ref"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      pool_id: bigint
      url: string
      hash: Uint8Array
      registered_tx_id: bigint
    }, ExtArgs["result"]["pool_metadata_ref"]>
    composites: {}
  }

  type pool_metadata_refGetPayload<S extends boolean | null | undefined | pool_metadata_refDefaultArgs> = $Result.GetResult<Prisma.$pool_metadata_refPayload, S>

  type pool_metadata_refCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_metadata_refFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_metadata_refCountAggregateInputType | true
    }

  export interface pool_metadata_refDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_metadata_ref'], meta: { name: 'pool_metadata_ref' } }
    /**
     * Find zero or one Pool_metadata_ref that matches the filter.
     * @param {pool_metadata_refFindUniqueArgs} args - Arguments to find a Pool_metadata_ref
     * @example
     * // Get one Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_metadata_refFindUniqueArgs>(args: SelectSubset<T, pool_metadata_refFindUniqueArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_metadata_ref that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_metadata_refFindUniqueOrThrowArgs} args - Arguments to find a Pool_metadata_ref
     * @example
     * // Get one Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_metadata_refFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_metadata_refFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_metadata_ref that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refFindFirstArgs} args - Arguments to find a Pool_metadata_ref
     * @example
     * // Get one Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_metadata_refFindFirstArgs>(args?: SelectSubset<T, pool_metadata_refFindFirstArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_metadata_ref that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refFindFirstOrThrowArgs} args - Arguments to find a Pool_metadata_ref
     * @example
     * // Get one Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_metadata_refFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_metadata_refFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_metadata_refs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_metadata_refs
     * const pool_metadata_refs = await prisma.pool_metadata_ref.findMany()
     * 
     * // Get first 10 Pool_metadata_refs
     * const pool_metadata_refs = await prisma.pool_metadata_ref.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_metadata_refWithIdOnly = await prisma.pool_metadata_ref.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_metadata_refFindManyArgs>(args?: SelectSubset<T, pool_metadata_refFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_metadata_ref.
     * @param {pool_metadata_refCreateArgs} args - Arguments to create a Pool_metadata_ref.
     * @example
     * // Create one Pool_metadata_ref
     * const Pool_metadata_ref = await prisma.pool_metadata_ref.create({
     *   data: {
     *     // ... data to create a Pool_metadata_ref
     *   }
     * })
     * 
     */
    create<T extends pool_metadata_refCreateArgs>(args: SelectSubset<T, pool_metadata_refCreateArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_metadata_refs.
     * @param {pool_metadata_refCreateManyArgs} args - Arguments to create many Pool_metadata_refs.
     * @example
     * // Create many Pool_metadata_refs
     * const pool_metadata_ref = await prisma.pool_metadata_ref.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_metadata_refCreateManyArgs>(args?: SelectSubset<T, pool_metadata_refCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_metadata_refs and returns the data saved in the database.
     * @param {pool_metadata_refCreateManyAndReturnArgs} args - Arguments to create many Pool_metadata_refs.
     * @example
     * // Create many Pool_metadata_refs
     * const pool_metadata_ref = await prisma.pool_metadata_ref.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_metadata_refs and only return the `id`
     * const pool_metadata_refWithIdOnly = await prisma.pool_metadata_ref.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_metadata_refCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_metadata_refCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_metadata_ref.
     * @param {pool_metadata_refDeleteArgs} args - Arguments to delete one Pool_metadata_ref.
     * @example
     * // Delete one Pool_metadata_ref
     * const Pool_metadata_ref = await prisma.pool_metadata_ref.delete({
     *   where: {
     *     // ... filter to delete one Pool_metadata_ref
     *   }
     * })
     * 
     */
    delete<T extends pool_metadata_refDeleteArgs>(args: SelectSubset<T, pool_metadata_refDeleteArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_metadata_ref.
     * @param {pool_metadata_refUpdateArgs} args - Arguments to update one Pool_metadata_ref.
     * @example
     * // Update one Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_metadata_refUpdateArgs>(args: SelectSubset<T, pool_metadata_refUpdateArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_metadata_refs.
     * @param {pool_metadata_refDeleteManyArgs} args - Arguments to filter Pool_metadata_refs to delete.
     * @example
     * // Delete a few Pool_metadata_refs
     * const { count } = await prisma.pool_metadata_ref.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_metadata_refDeleteManyArgs>(args?: SelectSubset<T, pool_metadata_refDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_metadata_refs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_metadata_refs
     * const pool_metadata_ref = await prisma.pool_metadata_ref.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_metadata_refUpdateManyArgs>(args: SelectSubset<T, pool_metadata_refUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_metadata_refs and returns the data updated in the database.
     * @param {pool_metadata_refUpdateManyAndReturnArgs} args - Arguments to update many Pool_metadata_refs.
     * @example
     * // Update many Pool_metadata_refs
     * const pool_metadata_ref = await prisma.pool_metadata_ref.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_metadata_refs and only return the `id`
     * const pool_metadata_refWithIdOnly = await prisma.pool_metadata_ref.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_metadata_refUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_metadata_refUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_metadata_ref.
     * @param {pool_metadata_refUpsertArgs} args - Arguments to update or create a Pool_metadata_ref.
     * @example
     * // Update or create a Pool_metadata_ref
     * const pool_metadata_ref = await prisma.pool_metadata_ref.upsert({
     *   create: {
     *     // ... data to create a Pool_metadata_ref
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_metadata_ref we want to update
     *   }
     * })
     */
    upsert<T extends pool_metadata_refUpsertArgs>(args: SelectSubset<T, pool_metadata_refUpsertArgs<ExtArgs>>): Prisma__pool_metadata_refClient<$Result.GetResult<Prisma.$pool_metadata_refPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_metadata_refs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refCountArgs} args - Arguments to filter Pool_metadata_refs to count.
     * @example
     * // Count the number of Pool_metadata_refs
     * const count = await prisma.pool_metadata_ref.count({
     *   where: {
     *     // ... the filter for the Pool_metadata_refs we want to count
     *   }
     * })
    **/
    count<T extends pool_metadata_refCountArgs>(
      args?: Subset<T, pool_metadata_refCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_metadata_refCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_metadata_ref.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_metadata_refAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_metadata_refAggregateArgs>(args: Subset<T, Pool_metadata_refAggregateArgs>): Prisma.PrismaPromise<GetPool_metadata_refAggregateType<T>>

    /**
     * Group by Pool_metadata_ref.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_metadata_refGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_metadata_refGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_metadata_refGroupByArgs['orderBy'] }
        : { orderBy?: pool_metadata_refGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_metadata_refGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_metadata_refGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_metadata_ref model
   */
  readonly fields: pool_metadata_refFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_metadata_ref.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_metadata_refClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_metadata_ref model
   */ 
  interface pool_metadata_refFieldRefs {
    readonly id: FieldRef<"pool_metadata_ref", 'BigInt'>
    readonly pool_id: FieldRef<"pool_metadata_ref", 'BigInt'>
    readonly url: FieldRef<"pool_metadata_ref", 'String'>
    readonly hash: FieldRef<"pool_metadata_ref", 'Bytes'>
    readonly registered_tx_id: FieldRef<"pool_metadata_ref", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * pool_metadata_ref findUnique
   */
  export type pool_metadata_refFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter, which pool_metadata_ref to fetch.
     */
    where: pool_metadata_refWhereUniqueInput
  }

  /**
   * pool_metadata_ref findUniqueOrThrow
   */
  export type pool_metadata_refFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter, which pool_metadata_ref to fetch.
     */
    where: pool_metadata_refWhereUniqueInput
  }

  /**
   * pool_metadata_ref findFirst
   */
  export type pool_metadata_refFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter, which pool_metadata_ref to fetch.
     */
    where?: pool_metadata_refWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_metadata_refs to fetch.
     */
    orderBy?: pool_metadata_refOrderByWithRelationInput | pool_metadata_refOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_metadata_refs.
     */
    cursor?: pool_metadata_refWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_metadata_refs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_metadata_refs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_metadata_refs.
     */
    distinct?: Pool_metadata_refScalarFieldEnum | Pool_metadata_refScalarFieldEnum[]
  }

  /**
   * pool_metadata_ref findFirstOrThrow
   */
  export type pool_metadata_refFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter, which pool_metadata_ref to fetch.
     */
    where?: pool_metadata_refWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_metadata_refs to fetch.
     */
    orderBy?: pool_metadata_refOrderByWithRelationInput | pool_metadata_refOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_metadata_refs.
     */
    cursor?: pool_metadata_refWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_metadata_refs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_metadata_refs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_metadata_refs.
     */
    distinct?: Pool_metadata_refScalarFieldEnum | Pool_metadata_refScalarFieldEnum[]
  }

  /**
   * pool_metadata_ref findMany
   */
  export type pool_metadata_refFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter, which pool_metadata_refs to fetch.
     */
    where?: pool_metadata_refWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_metadata_refs to fetch.
     */
    orderBy?: pool_metadata_refOrderByWithRelationInput | pool_metadata_refOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_metadata_refs.
     */
    cursor?: pool_metadata_refWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_metadata_refs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_metadata_refs.
     */
    skip?: number
    distinct?: Pool_metadata_refScalarFieldEnum | Pool_metadata_refScalarFieldEnum[]
  }

  /**
   * pool_metadata_ref create
   */
  export type pool_metadata_refCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_metadata_ref.
     */
    data: XOR<pool_metadata_refCreateInput, pool_metadata_refUncheckedCreateInput>
  }

  /**
   * pool_metadata_ref createMany
   */
  export type pool_metadata_refCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_metadata_refs.
     */
    data: pool_metadata_refCreateManyInput | pool_metadata_refCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_metadata_ref createManyAndReturn
   */
  export type pool_metadata_refCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * The data used to create many pool_metadata_refs.
     */
    data: pool_metadata_refCreateManyInput | pool_metadata_refCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_metadata_ref update
   */
  export type pool_metadata_refUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_metadata_ref.
     */
    data: XOR<pool_metadata_refUpdateInput, pool_metadata_refUncheckedUpdateInput>
    /**
     * Choose, which pool_metadata_ref to update.
     */
    where: pool_metadata_refWhereUniqueInput
  }

  /**
   * pool_metadata_ref updateMany
   */
  export type pool_metadata_refUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_metadata_refs.
     */
    data: XOR<pool_metadata_refUpdateManyMutationInput, pool_metadata_refUncheckedUpdateManyInput>
    /**
     * Filter which pool_metadata_refs to update
     */
    where?: pool_metadata_refWhereInput
    /**
     * Limit how many pool_metadata_refs to update.
     */
    limit?: number
  }

  /**
   * pool_metadata_ref updateManyAndReturn
   */
  export type pool_metadata_refUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * The data used to update pool_metadata_refs.
     */
    data: XOR<pool_metadata_refUpdateManyMutationInput, pool_metadata_refUncheckedUpdateManyInput>
    /**
     * Filter which pool_metadata_refs to update
     */
    where?: pool_metadata_refWhereInput
    /**
     * Limit how many pool_metadata_refs to update.
     */
    limit?: number
  }

  /**
   * pool_metadata_ref upsert
   */
  export type pool_metadata_refUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_metadata_ref to update in case it exists.
     */
    where: pool_metadata_refWhereUniqueInput
    /**
     * In case the pool_metadata_ref found by the `where` argument doesn't exist, create a new pool_metadata_ref with this data.
     */
    create: XOR<pool_metadata_refCreateInput, pool_metadata_refUncheckedCreateInput>
    /**
     * In case the pool_metadata_ref was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_metadata_refUpdateInput, pool_metadata_refUncheckedUpdateInput>
  }

  /**
   * pool_metadata_ref delete
   */
  export type pool_metadata_refDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
    /**
     * Filter which pool_metadata_ref to delete.
     */
    where: pool_metadata_refWhereUniqueInput
  }

  /**
   * pool_metadata_ref deleteMany
   */
  export type pool_metadata_refDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_metadata_refs to delete
     */
    where?: pool_metadata_refWhereInput
    /**
     * Limit how many pool_metadata_refs to delete.
     */
    limit?: number
  }

  /**
   * pool_metadata_ref without action
   */
  export type pool_metadata_refDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_metadata_ref
     */
    select?: pool_metadata_refSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_metadata_ref
     */
    omit?: pool_metadata_refOmit<ExtArgs> | null
  }


  /**
   * Model pool_owner
   */

  export type AggregatePool_owner = {
    _count: Pool_ownerCountAggregateOutputType | null
    _avg: Pool_ownerAvgAggregateOutputType | null
    _sum: Pool_ownerSumAggregateOutputType | null
    _min: Pool_ownerMinAggregateOutputType | null
    _max: Pool_ownerMaxAggregateOutputType | null
  }

  export type Pool_ownerAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    pool_update_id: number | null
  }

  export type Pool_ownerSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_update_id: bigint | null
  }

  export type Pool_ownerMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_update_id: bigint | null
  }

  export type Pool_ownerMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    pool_update_id: bigint | null
  }

  export type Pool_ownerCountAggregateOutputType = {
    id: number
    addr_id: number
    pool_update_id: number
    _all: number
  }


  export type Pool_ownerAvgAggregateInputType = {
    id?: true
    addr_id?: true
    pool_update_id?: true
  }

  export type Pool_ownerSumAggregateInputType = {
    id?: true
    addr_id?: true
    pool_update_id?: true
  }

  export type Pool_ownerMinAggregateInputType = {
    id?: true
    addr_id?: true
    pool_update_id?: true
  }

  export type Pool_ownerMaxAggregateInputType = {
    id?: true
    addr_id?: true
    pool_update_id?: true
  }

  export type Pool_ownerCountAggregateInputType = {
    id?: true
    addr_id?: true
    pool_update_id?: true
    _all?: true
  }

  export type Pool_ownerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_owner to aggregate.
     */
    where?: pool_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_owners to fetch.
     */
    orderBy?: pool_ownerOrderByWithRelationInput | pool_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_owners
    **/
    _count?: true | Pool_ownerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_ownerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_ownerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_ownerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_ownerMaxAggregateInputType
  }

  export type GetPool_ownerAggregateType<T extends Pool_ownerAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_owner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_owner[P]>
      : GetScalarType<T[P], AggregatePool_owner[P]>
  }




  export type pool_ownerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_ownerWhereInput
    orderBy?: pool_ownerOrderByWithAggregationInput | pool_ownerOrderByWithAggregationInput[]
    by: Pool_ownerScalarFieldEnum[] | Pool_ownerScalarFieldEnum
    having?: pool_ownerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_ownerCountAggregateInputType | true
    _avg?: Pool_ownerAvgAggregateInputType
    _sum?: Pool_ownerSumAggregateInputType
    _min?: Pool_ownerMinAggregateInputType
    _max?: Pool_ownerMaxAggregateInputType
  }

  export type Pool_ownerGroupByOutputType = {
    id: bigint
    addr_id: bigint
    pool_update_id: bigint
    _count: Pool_ownerCountAggregateOutputType | null
    _avg: Pool_ownerAvgAggregateOutputType | null
    _sum: Pool_ownerSumAggregateOutputType | null
    _min: Pool_ownerMinAggregateOutputType | null
    _max: Pool_ownerMaxAggregateOutputType | null
  }

  type GetPool_ownerGroupByPayload<T extends pool_ownerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_ownerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_ownerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_ownerGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_ownerGroupByOutputType[P]>
        }
      >
    >


  export type pool_ownerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_update_id?: boolean
  }, ExtArgs["result"]["pool_owner"]>

  export type pool_ownerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_update_id?: boolean
  }, ExtArgs["result"]["pool_owner"]>

  export type pool_ownerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    pool_update_id?: boolean
  }, ExtArgs["result"]["pool_owner"]>

  export type pool_ownerSelectScalar = {
    id?: boolean
    addr_id?: boolean
    pool_update_id?: boolean
  }

  export type pool_ownerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "pool_update_id", ExtArgs["result"]["pool_owner"]>

  export type $pool_ownerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_owner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      pool_update_id: bigint
    }, ExtArgs["result"]["pool_owner"]>
    composites: {}
  }

  type pool_ownerGetPayload<S extends boolean | null | undefined | pool_ownerDefaultArgs> = $Result.GetResult<Prisma.$pool_ownerPayload, S>

  type pool_ownerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_ownerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_ownerCountAggregateInputType | true
    }

  export interface pool_ownerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_owner'], meta: { name: 'pool_owner' } }
    /**
     * Find zero or one Pool_owner that matches the filter.
     * @param {pool_ownerFindUniqueArgs} args - Arguments to find a Pool_owner
     * @example
     * // Get one Pool_owner
     * const pool_owner = await prisma.pool_owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_ownerFindUniqueArgs>(args: SelectSubset<T, pool_ownerFindUniqueArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_owner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_ownerFindUniqueOrThrowArgs} args - Arguments to find a Pool_owner
     * @example
     * // Get one Pool_owner
     * const pool_owner = await prisma.pool_owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_ownerFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_ownerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerFindFirstArgs} args - Arguments to find a Pool_owner
     * @example
     * // Get one Pool_owner
     * const pool_owner = await prisma.pool_owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_ownerFindFirstArgs>(args?: SelectSubset<T, pool_ownerFindFirstArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerFindFirstOrThrowArgs} args - Arguments to find a Pool_owner
     * @example
     * // Get one Pool_owner
     * const pool_owner = await prisma.pool_owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_ownerFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_ownerFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_owners
     * const pool_owners = await prisma.pool_owner.findMany()
     * 
     * // Get first 10 Pool_owners
     * const pool_owners = await prisma.pool_owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_ownerWithIdOnly = await prisma.pool_owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_ownerFindManyArgs>(args?: SelectSubset<T, pool_ownerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_owner.
     * @param {pool_ownerCreateArgs} args - Arguments to create a Pool_owner.
     * @example
     * // Create one Pool_owner
     * const Pool_owner = await prisma.pool_owner.create({
     *   data: {
     *     // ... data to create a Pool_owner
     *   }
     * })
     * 
     */
    create<T extends pool_ownerCreateArgs>(args: SelectSubset<T, pool_ownerCreateArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_owners.
     * @param {pool_ownerCreateManyArgs} args - Arguments to create many Pool_owners.
     * @example
     * // Create many Pool_owners
     * const pool_owner = await prisma.pool_owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_ownerCreateManyArgs>(args?: SelectSubset<T, pool_ownerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_owners and returns the data saved in the database.
     * @param {pool_ownerCreateManyAndReturnArgs} args - Arguments to create many Pool_owners.
     * @example
     * // Create many Pool_owners
     * const pool_owner = await prisma.pool_owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_owners and only return the `id`
     * const pool_ownerWithIdOnly = await prisma.pool_owner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_ownerCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_ownerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_owner.
     * @param {pool_ownerDeleteArgs} args - Arguments to delete one Pool_owner.
     * @example
     * // Delete one Pool_owner
     * const Pool_owner = await prisma.pool_owner.delete({
     *   where: {
     *     // ... filter to delete one Pool_owner
     *   }
     * })
     * 
     */
    delete<T extends pool_ownerDeleteArgs>(args: SelectSubset<T, pool_ownerDeleteArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_owner.
     * @param {pool_ownerUpdateArgs} args - Arguments to update one Pool_owner.
     * @example
     * // Update one Pool_owner
     * const pool_owner = await prisma.pool_owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_ownerUpdateArgs>(args: SelectSubset<T, pool_ownerUpdateArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_owners.
     * @param {pool_ownerDeleteManyArgs} args - Arguments to filter Pool_owners to delete.
     * @example
     * // Delete a few Pool_owners
     * const { count } = await prisma.pool_owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_ownerDeleteManyArgs>(args?: SelectSubset<T, pool_ownerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_owners
     * const pool_owner = await prisma.pool_owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_ownerUpdateManyArgs>(args: SelectSubset<T, pool_ownerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_owners and returns the data updated in the database.
     * @param {pool_ownerUpdateManyAndReturnArgs} args - Arguments to update many Pool_owners.
     * @example
     * // Update many Pool_owners
     * const pool_owner = await prisma.pool_owner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_owners and only return the `id`
     * const pool_ownerWithIdOnly = await prisma.pool_owner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_ownerUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_ownerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_owner.
     * @param {pool_ownerUpsertArgs} args - Arguments to update or create a Pool_owner.
     * @example
     * // Update or create a Pool_owner
     * const pool_owner = await prisma.pool_owner.upsert({
     *   create: {
     *     // ... data to create a Pool_owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_owner we want to update
     *   }
     * })
     */
    upsert<T extends pool_ownerUpsertArgs>(args: SelectSubset<T, pool_ownerUpsertArgs<ExtArgs>>): Prisma__pool_ownerClient<$Result.GetResult<Prisma.$pool_ownerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerCountArgs} args - Arguments to filter Pool_owners to count.
     * @example
     * // Count the number of Pool_owners
     * const count = await prisma.pool_owner.count({
     *   where: {
     *     // ... the filter for the Pool_owners we want to count
     *   }
     * })
    **/
    count<T extends pool_ownerCountArgs>(
      args?: Subset<T, pool_ownerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_ownerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_ownerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_ownerAggregateArgs>(args: Subset<T, Pool_ownerAggregateArgs>): Prisma.PrismaPromise<GetPool_ownerAggregateType<T>>

    /**
     * Group by Pool_owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_ownerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_ownerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_ownerGroupByArgs['orderBy'] }
        : { orderBy?: pool_ownerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_ownerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_ownerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_owner model
   */
  readonly fields: pool_ownerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_ownerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_owner model
   */ 
  interface pool_ownerFieldRefs {
    readonly id: FieldRef<"pool_owner", 'BigInt'>
    readonly addr_id: FieldRef<"pool_owner", 'BigInt'>
    readonly pool_update_id: FieldRef<"pool_owner", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * pool_owner findUnique
   */
  export type pool_ownerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter, which pool_owner to fetch.
     */
    where: pool_ownerWhereUniqueInput
  }

  /**
   * pool_owner findUniqueOrThrow
   */
  export type pool_ownerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter, which pool_owner to fetch.
     */
    where: pool_ownerWhereUniqueInput
  }

  /**
   * pool_owner findFirst
   */
  export type pool_ownerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter, which pool_owner to fetch.
     */
    where?: pool_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_owners to fetch.
     */
    orderBy?: pool_ownerOrderByWithRelationInput | pool_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_owners.
     */
    cursor?: pool_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_owners.
     */
    distinct?: Pool_ownerScalarFieldEnum | Pool_ownerScalarFieldEnum[]
  }

  /**
   * pool_owner findFirstOrThrow
   */
  export type pool_ownerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter, which pool_owner to fetch.
     */
    where?: pool_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_owners to fetch.
     */
    orderBy?: pool_ownerOrderByWithRelationInput | pool_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_owners.
     */
    cursor?: pool_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_owners.
     */
    distinct?: Pool_ownerScalarFieldEnum | Pool_ownerScalarFieldEnum[]
  }

  /**
   * pool_owner findMany
   */
  export type pool_ownerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter, which pool_owners to fetch.
     */
    where?: pool_ownerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_owners to fetch.
     */
    orderBy?: pool_ownerOrderByWithRelationInput | pool_ownerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_owners.
     */
    cursor?: pool_ownerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_owners.
     */
    skip?: number
    distinct?: Pool_ownerScalarFieldEnum | Pool_ownerScalarFieldEnum[]
  }

  /**
   * pool_owner create
   */
  export type pool_ownerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_owner.
     */
    data: XOR<pool_ownerCreateInput, pool_ownerUncheckedCreateInput>
  }

  /**
   * pool_owner createMany
   */
  export type pool_ownerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_owners.
     */
    data: pool_ownerCreateManyInput | pool_ownerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_owner createManyAndReturn
   */
  export type pool_ownerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * The data used to create many pool_owners.
     */
    data: pool_ownerCreateManyInput | pool_ownerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_owner update
   */
  export type pool_ownerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_owner.
     */
    data: XOR<pool_ownerUpdateInput, pool_ownerUncheckedUpdateInput>
    /**
     * Choose, which pool_owner to update.
     */
    where: pool_ownerWhereUniqueInput
  }

  /**
   * pool_owner updateMany
   */
  export type pool_ownerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_owners.
     */
    data: XOR<pool_ownerUpdateManyMutationInput, pool_ownerUncheckedUpdateManyInput>
    /**
     * Filter which pool_owners to update
     */
    where?: pool_ownerWhereInput
    /**
     * Limit how many pool_owners to update.
     */
    limit?: number
  }

  /**
   * pool_owner updateManyAndReturn
   */
  export type pool_ownerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * The data used to update pool_owners.
     */
    data: XOR<pool_ownerUpdateManyMutationInput, pool_ownerUncheckedUpdateManyInput>
    /**
     * Filter which pool_owners to update
     */
    where?: pool_ownerWhereInput
    /**
     * Limit how many pool_owners to update.
     */
    limit?: number
  }

  /**
   * pool_owner upsert
   */
  export type pool_ownerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_owner to update in case it exists.
     */
    where: pool_ownerWhereUniqueInput
    /**
     * In case the pool_owner found by the `where` argument doesn't exist, create a new pool_owner with this data.
     */
    create: XOR<pool_ownerCreateInput, pool_ownerUncheckedCreateInput>
    /**
     * In case the pool_owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_ownerUpdateInput, pool_ownerUncheckedUpdateInput>
  }

  /**
   * pool_owner delete
   */
  export type pool_ownerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
    /**
     * Filter which pool_owner to delete.
     */
    where: pool_ownerWhereUniqueInput
  }

  /**
   * pool_owner deleteMany
   */
  export type pool_ownerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_owners to delete
     */
    where?: pool_ownerWhereInput
    /**
     * Limit how many pool_owners to delete.
     */
    limit?: number
  }

  /**
   * pool_owner without action
   */
  export type pool_ownerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_owner
     */
    select?: pool_ownerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_owner
     */
    omit?: pool_ownerOmit<ExtArgs> | null
  }


  /**
   * Model pool_relay
   */

  export type AggregatePool_relay = {
    _count: Pool_relayCountAggregateOutputType | null
    _avg: Pool_relayAvgAggregateOutputType | null
    _sum: Pool_relaySumAggregateOutputType | null
    _min: Pool_relayMinAggregateOutputType | null
    _max: Pool_relayMaxAggregateOutputType | null
  }

  export type Pool_relayAvgAggregateOutputType = {
    id: number | null
    update_id: number | null
    port: number | null
  }

  export type Pool_relaySumAggregateOutputType = {
    id: bigint | null
    update_id: bigint | null
    port: number | null
  }

  export type Pool_relayMinAggregateOutputType = {
    id: bigint | null
    update_id: bigint | null
    ipv4: string | null
    ipv6: string | null
    dns_name: string | null
    dns_srv_name: string | null
    port: number | null
  }

  export type Pool_relayMaxAggregateOutputType = {
    id: bigint | null
    update_id: bigint | null
    ipv4: string | null
    ipv6: string | null
    dns_name: string | null
    dns_srv_name: string | null
    port: number | null
  }

  export type Pool_relayCountAggregateOutputType = {
    id: number
    update_id: number
    ipv4: number
    ipv6: number
    dns_name: number
    dns_srv_name: number
    port: number
    _all: number
  }


  export type Pool_relayAvgAggregateInputType = {
    id?: true
    update_id?: true
    port?: true
  }

  export type Pool_relaySumAggregateInputType = {
    id?: true
    update_id?: true
    port?: true
  }

  export type Pool_relayMinAggregateInputType = {
    id?: true
    update_id?: true
    ipv4?: true
    ipv6?: true
    dns_name?: true
    dns_srv_name?: true
    port?: true
  }

  export type Pool_relayMaxAggregateInputType = {
    id?: true
    update_id?: true
    ipv4?: true
    ipv6?: true
    dns_name?: true
    dns_srv_name?: true
    port?: true
  }

  export type Pool_relayCountAggregateInputType = {
    id?: true
    update_id?: true
    ipv4?: true
    ipv6?: true
    dns_name?: true
    dns_srv_name?: true
    port?: true
    _all?: true
  }

  export type Pool_relayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_relay to aggregate.
     */
    where?: pool_relayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_relays to fetch.
     */
    orderBy?: pool_relayOrderByWithRelationInput | pool_relayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_relayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_relays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_relays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_relays
    **/
    _count?: true | Pool_relayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_relayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_relaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_relayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_relayMaxAggregateInputType
  }

  export type GetPool_relayAggregateType<T extends Pool_relayAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_relay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_relay[P]>
      : GetScalarType<T[P], AggregatePool_relay[P]>
  }




  export type pool_relayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_relayWhereInput
    orderBy?: pool_relayOrderByWithAggregationInput | pool_relayOrderByWithAggregationInput[]
    by: Pool_relayScalarFieldEnum[] | Pool_relayScalarFieldEnum
    having?: pool_relayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_relayCountAggregateInputType | true
    _avg?: Pool_relayAvgAggregateInputType
    _sum?: Pool_relaySumAggregateInputType
    _min?: Pool_relayMinAggregateInputType
    _max?: Pool_relayMaxAggregateInputType
  }

  export type Pool_relayGroupByOutputType = {
    id: bigint
    update_id: bigint
    ipv4: string | null
    ipv6: string | null
    dns_name: string | null
    dns_srv_name: string | null
    port: number | null
    _count: Pool_relayCountAggregateOutputType | null
    _avg: Pool_relayAvgAggregateOutputType | null
    _sum: Pool_relaySumAggregateOutputType | null
    _min: Pool_relayMinAggregateOutputType | null
    _max: Pool_relayMaxAggregateOutputType | null
  }

  type GetPool_relayGroupByPayload<T extends pool_relayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_relayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_relayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_relayGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_relayGroupByOutputType[P]>
        }
      >
    >


  export type pool_relaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    update_id?: boolean
    ipv4?: boolean
    ipv6?: boolean
    dns_name?: boolean
    dns_srv_name?: boolean
    port?: boolean
  }, ExtArgs["result"]["pool_relay"]>

  export type pool_relaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    update_id?: boolean
    ipv4?: boolean
    ipv6?: boolean
    dns_name?: boolean
    dns_srv_name?: boolean
    port?: boolean
  }, ExtArgs["result"]["pool_relay"]>

  export type pool_relaySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    update_id?: boolean
    ipv4?: boolean
    ipv6?: boolean
    dns_name?: boolean
    dns_srv_name?: boolean
    port?: boolean
  }, ExtArgs["result"]["pool_relay"]>

  export type pool_relaySelectScalar = {
    id?: boolean
    update_id?: boolean
    ipv4?: boolean
    ipv6?: boolean
    dns_name?: boolean
    dns_srv_name?: boolean
    port?: boolean
  }

  export type pool_relayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "update_id" | "ipv4" | "ipv6" | "dns_name" | "dns_srv_name" | "port", ExtArgs["result"]["pool_relay"]>

  export type $pool_relayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_relay"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      update_id: bigint
      ipv4: string | null
      ipv6: string | null
      dns_name: string | null
      dns_srv_name: string | null
      port: number | null
    }, ExtArgs["result"]["pool_relay"]>
    composites: {}
  }

  type pool_relayGetPayload<S extends boolean | null | undefined | pool_relayDefaultArgs> = $Result.GetResult<Prisma.$pool_relayPayload, S>

  type pool_relayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_relayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_relayCountAggregateInputType | true
    }

  export interface pool_relayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_relay'], meta: { name: 'pool_relay' } }
    /**
     * Find zero or one Pool_relay that matches the filter.
     * @param {pool_relayFindUniqueArgs} args - Arguments to find a Pool_relay
     * @example
     * // Get one Pool_relay
     * const pool_relay = await prisma.pool_relay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_relayFindUniqueArgs>(args: SelectSubset<T, pool_relayFindUniqueArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_relay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_relayFindUniqueOrThrowArgs} args - Arguments to find a Pool_relay
     * @example
     * // Get one Pool_relay
     * const pool_relay = await prisma.pool_relay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_relayFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_relayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_relay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayFindFirstArgs} args - Arguments to find a Pool_relay
     * @example
     * // Get one Pool_relay
     * const pool_relay = await prisma.pool_relay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_relayFindFirstArgs>(args?: SelectSubset<T, pool_relayFindFirstArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_relay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayFindFirstOrThrowArgs} args - Arguments to find a Pool_relay
     * @example
     * // Get one Pool_relay
     * const pool_relay = await prisma.pool_relay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_relayFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_relayFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_relays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_relays
     * const pool_relays = await prisma.pool_relay.findMany()
     * 
     * // Get first 10 Pool_relays
     * const pool_relays = await prisma.pool_relay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_relayWithIdOnly = await prisma.pool_relay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_relayFindManyArgs>(args?: SelectSubset<T, pool_relayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_relay.
     * @param {pool_relayCreateArgs} args - Arguments to create a Pool_relay.
     * @example
     * // Create one Pool_relay
     * const Pool_relay = await prisma.pool_relay.create({
     *   data: {
     *     // ... data to create a Pool_relay
     *   }
     * })
     * 
     */
    create<T extends pool_relayCreateArgs>(args: SelectSubset<T, pool_relayCreateArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_relays.
     * @param {pool_relayCreateManyArgs} args - Arguments to create many Pool_relays.
     * @example
     * // Create many Pool_relays
     * const pool_relay = await prisma.pool_relay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_relayCreateManyArgs>(args?: SelectSubset<T, pool_relayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_relays and returns the data saved in the database.
     * @param {pool_relayCreateManyAndReturnArgs} args - Arguments to create many Pool_relays.
     * @example
     * // Create many Pool_relays
     * const pool_relay = await prisma.pool_relay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_relays and only return the `id`
     * const pool_relayWithIdOnly = await prisma.pool_relay.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_relayCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_relayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_relay.
     * @param {pool_relayDeleteArgs} args - Arguments to delete one Pool_relay.
     * @example
     * // Delete one Pool_relay
     * const Pool_relay = await prisma.pool_relay.delete({
     *   where: {
     *     // ... filter to delete one Pool_relay
     *   }
     * })
     * 
     */
    delete<T extends pool_relayDeleteArgs>(args: SelectSubset<T, pool_relayDeleteArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_relay.
     * @param {pool_relayUpdateArgs} args - Arguments to update one Pool_relay.
     * @example
     * // Update one Pool_relay
     * const pool_relay = await prisma.pool_relay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_relayUpdateArgs>(args: SelectSubset<T, pool_relayUpdateArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_relays.
     * @param {pool_relayDeleteManyArgs} args - Arguments to filter Pool_relays to delete.
     * @example
     * // Delete a few Pool_relays
     * const { count } = await prisma.pool_relay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_relayDeleteManyArgs>(args?: SelectSubset<T, pool_relayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_relays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_relays
     * const pool_relay = await prisma.pool_relay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_relayUpdateManyArgs>(args: SelectSubset<T, pool_relayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_relays and returns the data updated in the database.
     * @param {pool_relayUpdateManyAndReturnArgs} args - Arguments to update many Pool_relays.
     * @example
     * // Update many Pool_relays
     * const pool_relay = await prisma.pool_relay.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_relays and only return the `id`
     * const pool_relayWithIdOnly = await prisma.pool_relay.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_relayUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_relayUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_relay.
     * @param {pool_relayUpsertArgs} args - Arguments to update or create a Pool_relay.
     * @example
     * // Update or create a Pool_relay
     * const pool_relay = await prisma.pool_relay.upsert({
     *   create: {
     *     // ... data to create a Pool_relay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_relay we want to update
     *   }
     * })
     */
    upsert<T extends pool_relayUpsertArgs>(args: SelectSubset<T, pool_relayUpsertArgs<ExtArgs>>): Prisma__pool_relayClient<$Result.GetResult<Prisma.$pool_relayPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_relays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayCountArgs} args - Arguments to filter Pool_relays to count.
     * @example
     * // Count the number of Pool_relays
     * const count = await prisma.pool_relay.count({
     *   where: {
     *     // ... the filter for the Pool_relays we want to count
     *   }
     * })
    **/
    count<T extends pool_relayCountArgs>(
      args?: Subset<T, pool_relayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_relayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_relay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_relayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_relayAggregateArgs>(args: Subset<T, Pool_relayAggregateArgs>): Prisma.PrismaPromise<GetPool_relayAggregateType<T>>

    /**
     * Group by Pool_relay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_relayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_relayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_relayGroupByArgs['orderBy'] }
        : { orderBy?: pool_relayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_relayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_relayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_relay model
   */
  readonly fields: pool_relayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_relay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_relayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_relay model
   */ 
  interface pool_relayFieldRefs {
    readonly id: FieldRef<"pool_relay", 'BigInt'>
    readonly update_id: FieldRef<"pool_relay", 'BigInt'>
    readonly ipv4: FieldRef<"pool_relay", 'String'>
    readonly ipv6: FieldRef<"pool_relay", 'String'>
    readonly dns_name: FieldRef<"pool_relay", 'String'>
    readonly dns_srv_name: FieldRef<"pool_relay", 'String'>
    readonly port: FieldRef<"pool_relay", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pool_relay findUnique
   */
  export type pool_relayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter, which pool_relay to fetch.
     */
    where: pool_relayWhereUniqueInput
  }

  /**
   * pool_relay findUniqueOrThrow
   */
  export type pool_relayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter, which pool_relay to fetch.
     */
    where: pool_relayWhereUniqueInput
  }

  /**
   * pool_relay findFirst
   */
  export type pool_relayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter, which pool_relay to fetch.
     */
    where?: pool_relayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_relays to fetch.
     */
    orderBy?: pool_relayOrderByWithRelationInput | pool_relayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_relays.
     */
    cursor?: pool_relayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_relays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_relays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_relays.
     */
    distinct?: Pool_relayScalarFieldEnum | Pool_relayScalarFieldEnum[]
  }

  /**
   * pool_relay findFirstOrThrow
   */
  export type pool_relayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter, which pool_relay to fetch.
     */
    where?: pool_relayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_relays to fetch.
     */
    orderBy?: pool_relayOrderByWithRelationInput | pool_relayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_relays.
     */
    cursor?: pool_relayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_relays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_relays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_relays.
     */
    distinct?: Pool_relayScalarFieldEnum | Pool_relayScalarFieldEnum[]
  }

  /**
   * pool_relay findMany
   */
  export type pool_relayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter, which pool_relays to fetch.
     */
    where?: pool_relayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_relays to fetch.
     */
    orderBy?: pool_relayOrderByWithRelationInput | pool_relayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_relays.
     */
    cursor?: pool_relayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_relays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_relays.
     */
    skip?: number
    distinct?: Pool_relayScalarFieldEnum | Pool_relayScalarFieldEnum[]
  }

  /**
   * pool_relay create
   */
  export type pool_relayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_relay.
     */
    data: XOR<pool_relayCreateInput, pool_relayUncheckedCreateInput>
  }

  /**
   * pool_relay createMany
   */
  export type pool_relayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_relays.
     */
    data: pool_relayCreateManyInput | pool_relayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_relay createManyAndReturn
   */
  export type pool_relayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * The data used to create many pool_relays.
     */
    data: pool_relayCreateManyInput | pool_relayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_relay update
   */
  export type pool_relayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_relay.
     */
    data: XOR<pool_relayUpdateInput, pool_relayUncheckedUpdateInput>
    /**
     * Choose, which pool_relay to update.
     */
    where: pool_relayWhereUniqueInput
  }

  /**
   * pool_relay updateMany
   */
  export type pool_relayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_relays.
     */
    data: XOR<pool_relayUpdateManyMutationInput, pool_relayUncheckedUpdateManyInput>
    /**
     * Filter which pool_relays to update
     */
    where?: pool_relayWhereInput
    /**
     * Limit how many pool_relays to update.
     */
    limit?: number
  }

  /**
   * pool_relay updateManyAndReturn
   */
  export type pool_relayUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * The data used to update pool_relays.
     */
    data: XOR<pool_relayUpdateManyMutationInput, pool_relayUncheckedUpdateManyInput>
    /**
     * Filter which pool_relays to update
     */
    where?: pool_relayWhereInput
    /**
     * Limit how many pool_relays to update.
     */
    limit?: number
  }

  /**
   * pool_relay upsert
   */
  export type pool_relayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_relay to update in case it exists.
     */
    where: pool_relayWhereUniqueInput
    /**
     * In case the pool_relay found by the `where` argument doesn't exist, create a new pool_relay with this data.
     */
    create: XOR<pool_relayCreateInput, pool_relayUncheckedCreateInput>
    /**
     * In case the pool_relay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_relayUpdateInput, pool_relayUncheckedUpdateInput>
  }

  /**
   * pool_relay delete
   */
  export type pool_relayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
    /**
     * Filter which pool_relay to delete.
     */
    where: pool_relayWhereUniqueInput
  }

  /**
   * pool_relay deleteMany
   */
  export type pool_relayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_relays to delete
     */
    where?: pool_relayWhereInput
    /**
     * Limit how many pool_relays to delete.
     */
    limit?: number
  }

  /**
   * pool_relay without action
   */
  export type pool_relayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_relay
     */
    select?: pool_relaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_relay
     */
    omit?: pool_relayOmit<ExtArgs> | null
  }


  /**
   * Model pool_retire
   */

  export type AggregatePool_retire = {
    _count: Pool_retireCountAggregateOutputType | null
    _avg: Pool_retireAvgAggregateOutputType | null
    _sum: Pool_retireSumAggregateOutputType | null
    _min: Pool_retireMinAggregateOutputType | null
    _max: Pool_retireMaxAggregateOutputType | null
  }

  export type Pool_retireAvgAggregateOutputType = {
    id: number | null
    hash_id: number | null
    cert_index: number | null
    announced_tx_id: number | null
    retiring_epoch: number | null
  }

  export type Pool_retireSumAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    announced_tx_id: bigint | null
    retiring_epoch: number | null
  }

  export type Pool_retireMinAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    announced_tx_id: bigint | null
    retiring_epoch: number | null
  }

  export type Pool_retireMaxAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    announced_tx_id: bigint | null
    retiring_epoch: number | null
  }

  export type Pool_retireCountAggregateOutputType = {
    id: number
    hash_id: number
    cert_index: number
    announced_tx_id: number
    retiring_epoch: number
    _all: number
  }


  export type Pool_retireAvgAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    announced_tx_id?: true
    retiring_epoch?: true
  }

  export type Pool_retireSumAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    announced_tx_id?: true
    retiring_epoch?: true
  }

  export type Pool_retireMinAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    announced_tx_id?: true
    retiring_epoch?: true
  }

  export type Pool_retireMaxAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    announced_tx_id?: true
    retiring_epoch?: true
  }

  export type Pool_retireCountAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    announced_tx_id?: true
    retiring_epoch?: true
    _all?: true
  }

  export type Pool_retireAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_retire to aggregate.
     */
    where?: pool_retireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_retires to fetch.
     */
    orderBy?: pool_retireOrderByWithRelationInput | pool_retireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_retireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_retires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_retires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_retires
    **/
    _count?: true | Pool_retireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_retireAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_retireSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_retireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_retireMaxAggregateInputType
  }

  export type GetPool_retireAggregateType<T extends Pool_retireAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_retire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_retire[P]>
      : GetScalarType<T[P], AggregatePool_retire[P]>
  }




  export type pool_retireGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_retireWhereInput
    orderBy?: pool_retireOrderByWithAggregationInput | pool_retireOrderByWithAggregationInput[]
    by: Pool_retireScalarFieldEnum[] | Pool_retireScalarFieldEnum
    having?: pool_retireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_retireCountAggregateInputType | true
    _avg?: Pool_retireAvgAggregateInputType
    _sum?: Pool_retireSumAggregateInputType
    _min?: Pool_retireMinAggregateInputType
    _max?: Pool_retireMaxAggregateInputType
  }

  export type Pool_retireGroupByOutputType = {
    id: bigint
    hash_id: bigint
    cert_index: number
    announced_tx_id: bigint
    retiring_epoch: number
    _count: Pool_retireCountAggregateOutputType | null
    _avg: Pool_retireAvgAggregateOutputType | null
    _sum: Pool_retireSumAggregateOutputType | null
    _min: Pool_retireMinAggregateOutputType | null
    _max: Pool_retireMaxAggregateOutputType | null
  }

  type GetPool_retireGroupByPayload<T extends pool_retireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_retireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_retireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_retireGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_retireGroupByOutputType[P]>
        }
      >
    >


  export type pool_retireSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    announced_tx_id?: boolean
    retiring_epoch?: boolean
  }, ExtArgs["result"]["pool_retire"]>

  export type pool_retireSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    announced_tx_id?: boolean
    retiring_epoch?: boolean
  }, ExtArgs["result"]["pool_retire"]>

  export type pool_retireSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    announced_tx_id?: boolean
    retiring_epoch?: boolean
  }, ExtArgs["result"]["pool_retire"]>

  export type pool_retireSelectScalar = {
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    announced_tx_id?: boolean
    retiring_epoch?: boolean
  }

  export type pool_retireOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_id" | "cert_index" | "announced_tx_id" | "retiring_epoch", ExtArgs["result"]["pool_retire"]>

  export type $pool_retirePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_retire"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_id: bigint
      cert_index: number
      announced_tx_id: bigint
      retiring_epoch: number
    }, ExtArgs["result"]["pool_retire"]>
    composites: {}
  }

  type pool_retireGetPayload<S extends boolean | null | undefined | pool_retireDefaultArgs> = $Result.GetResult<Prisma.$pool_retirePayload, S>

  type pool_retireCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_retireFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_retireCountAggregateInputType | true
    }

  export interface pool_retireDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_retire'], meta: { name: 'pool_retire' } }
    /**
     * Find zero or one Pool_retire that matches the filter.
     * @param {pool_retireFindUniqueArgs} args - Arguments to find a Pool_retire
     * @example
     * // Get one Pool_retire
     * const pool_retire = await prisma.pool_retire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_retireFindUniqueArgs>(args: SelectSubset<T, pool_retireFindUniqueArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_retire that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_retireFindUniqueOrThrowArgs} args - Arguments to find a Pool_retire
     * @example
     * // Get one Pool_retire
     * const pool_retire = await prisma.pool_retire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_retireFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_retireFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_retire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireFindFirstArgs} args - Arguments to find a Pool_retire
     * @example
     * // Get one Pool_retire
     * const pool_retire = await prisma.pool_retire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_retireFindFirstArgs>(args?: SelectSubset<T, pool_retireFindFirstArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_retire that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireFindFirstOrThrowArgs} args - Arguments to find a Pool_retire
     * @example
     * // Get one Pool_retire
     * const pool_retire = await prisma.pool_retire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_retireFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_retireFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_retires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_retires
     * const pool_retires = await prisma.pool_retire.findMany()
     * 
     * // Get first 10 Pool_retires
     * const pool_retires = await prisma.pool_retire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_retireWithIdOnly = await prisma.pool_retire.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_retireFindManyArgs>(args?: SelectSubset<T, pool_retireFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_retire.
     * @param {pool_retireCreateArgs} args - Arguments to create a Pool_retire.
     * @example
     * // Create one Pool_retire
     * const Pool_retire = await prisma.pool_retire.create({
     *   data: {
     *     // ... data to create a Pool_retire
     *   }
     * })
     * 
     */
    create<T extends pool_retireCreateArgs>(args: SelectSubset<T, pool_retireCreateArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_retires.
     * @param {pool_retireCreateManyArgs} args - Arguments to create many Pool_retires.
     * @example
     * // Create many Pool_retires
     * const pool_retire = await prisma.pool_retire.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_retireCreateManyArgs>(args?: SelectSubset<T, pool_retireCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_retires and returns the data saved in the database.
     * @param {pool_retireCreateManyAndReturnArgs} args - Arguments to create many Pool_retires.
     * @example
     * // Create many Pool_retires
     * const pool_retire = await prisma.pool_retire.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_retires and only return the `id`
     * const pool_retireWithIdOnly = await prisma.pool_retire.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_retireCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_retireCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_retire.
     * @param {pool_retireDeleteArgs} args - Arguments to delete one Pool_retire.
     * @example
     * // Delete one Pool_retire
     * const Pool_retire = await prisma.pool_retire.delete({
     *   where: {
     *     // ... filter to delete one Pool_retire
     *   }
     * })
     * 
     */
    delete<T extends pool_retireDeleteArgs>(args: SelectSubset<T, pool_retireDeleteArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_retire.
     * @param {pool_retireUpdateArgs} args - Arguments to update one Pool_retire.
     * @example
     * // Update one Pool_retire
     * const pool_retire = await prisma.pool_retire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_retireUpdateArgs>(args: SelectSubset<T, pool_retireUpdateArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_retires.
     * @param {pool_retireDeleteManyArgs} args - Arguments to filter Pool_retires to delete.
     * @example
     * // Delete a few Pool_retires
     * const { count } = await prisma.pool_retire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_retireDeleteManyArgs>(args?: SelectSubset<T, pool_retireDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_retires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_retires
     * const pool_retire = await prisma.pool_retire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_retireUpdateManyArgs>(args: SelectSubset<T, pool_retireUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_retires and returns the data updated in the database.
     * @param {pool_retireUpdateManyAndReturnArgs} args - Arguments to update many Pool_retires.
     * @example
     * // Update many Pool_retires
     * const pool_retire = await prisma.pool_retire.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_retires and only return the `id`
     * const pool_retireWithIdOnly = await prisma.pool_retire.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_retireUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_retireUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_retire.
     * @param {pool_retireUpsertArgs} args - Arguments to update or create a Pool_retire.
     * @example
     * // Update or create a Pool_retire
     * const pool_retire = await prisma.pool_retire.upsert({
     *   create: {
     *     // ... data to create a Pool_retire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_retire we want to update
     *   }
     * })
     */
    upsert<T extends pool_retireUpsertArgs>(args: SelectSubset<T, pool_retireUpsertArgs<ExtArgs>>): Prisma__pool_retireClient<$Result.GetResult<Prisma.$pool_retirePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_retires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireCountArgs} args - Arguments to filter Pool_retires to count.
     * @example
     * // Count the number of Pool_retires
     * const count = await prisma.pool_retire.count({
     *   where: {
     *     // ... the filter for the Pool_retires we want to count
     *   }
     * })
    **/
    count<T extends pool_retireCountArgs>(
      args?: Subset<T, pool_retireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_retireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_retire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_retireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_retireAggregateArgs>(args: Subset<T, Pool_retireAggregateArgs>): Prisma.PrismaPromise<GetPool_retireAggregateType<T>>

    /**
     * Group by Pool_retire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_retireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_retireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_retireGroupByArgs['orderBy'] }
        : { orderBy?: pool_retireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_retireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_retireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_retire model
   */
  readonly fields: pool_retireFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_retire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_retireClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_retire model
   */ 
  interface pool_retireFieldRefs {
    readonly id: FieldRef<"pool_retire", 'BigInt'>
    readonly hash_id: FieldRef<"pool_retire", 'BigInt'>
    readonly cert_index: FieldRef<"pool_retire", 'Int'>
    readonly announced_tx_id: FieldRef<"pool_retire", 'BigInt'>
    readonly retiring_epoch: FieldRef<"pool_retire", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pool_retire findUnique
   */
  export type pool_retireFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter, which pool_retire to fetch.
     */
    where: pool_retireWhereUniqueInput
  }

  /**
   * pool_retire findUniqueOrThrow
   */
  export type pool_retireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter, which pool_retire to fetch.
     */
    where: pool_retireWhereUniqueInput
  }

  /**
   * pool_retire findFirst
   */
  export type pool_retireFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter, which pool_retire to fetch.
     */
    where?: pool_retireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_retires to fetch.
     */
    orderBy?: pool_retireOrderByWithRelationInput | pool_retireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_retires.
     */
    cursor?: pool_retireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_retires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_retires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_retires.
     */
    distinct?: Pool_retireScalarFieldEnum | Pool_retireScalarFieldEnum[]
  }

  /**
   * pool_retire findFirstOrThrow
   */
  export type pool_retireFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter, which pool_retire to fetch.
     */
    where?: pool_retireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_retires to fetch.
     */
    orderBy?: pool_retireOrderByWithRelationInput | pool_retireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_retires.
     */
    cursor?: pool_retireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_retires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_retires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_retires.
     */
    distinct?: Pool_retireScalarFieldEnum | Pool_retireScalarFieldEnum[]
  }

  /**
   * pool_retire findMany
   */
  export type pool_retireFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter, which pool_retires to fetch.
     */
    where?: pool_retireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_retires to fetch.
     */
    orderBy?: pool_retireOrderByWithRelationInput | pool_retireOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_retires.
     */
    cursor?: pool_retireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_retires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_retires.
     */
    skip?: number
    distinct?: Pool_retireScalarFieldEnum | Pool_retireScalarFieldEnum[]
  }

  /**
   * pool_retire create
   */
  export type pool_retireCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_retire.
     */
    data: XOR<pool_retireCreateInput, pool_retireUncheckedCreateInput>
  }

  /**
   * pool_retire createMany
   */
  export type pool_retireCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_retires.
     */
    data: pool_retireCreateManyInput | pool_retireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_retire createManyAndReturn
   */
  export type pool_retireCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * The data used to create many pool_retires.
     */
    data: pool_retireCreateManyInput | pool_retireCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_retire update
   */
  export type pool_retireUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_retire.
     */
    data: XOR<pool_retireUpdateInput, pool_retireUncheckedUpdateInput>
    /**
     * Choose, which pool_retire to update.
     */
    where: pool_retireWhereUniqueInput
  }

  /**
   * pool_retire updateMany
   */
  export type pool_retireUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_retires.
     */
    data: XOR<pool_retireUpdateManyMutationInput, pool_retireUncheckedUpdateManyInput>
    /**
     * Filter which pool_retires to update
     */
    where?: pool_retireWhereInput
    /**
     * Limit how many pool_retires to update.
     */
    limit?: number
  }

  /**
   * pool_retire updateManyAndReturn
   */
  export type pool_retireUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * The data used to update pool_retires.
     */
    data: XOR<pool_retireUpdateManyMutationInput, pool_retireUncheckedUpdateManyInput>
    /**
     * Filter which pool_retires to update
     */
    where?: pool_retireWhereInput
    /**
     * Limit how many pool_retires to update.
     */
    limit?: number
  }

  /**
   * pool_retire upsert
   */
  export type pool_retireUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_retire to update in case it exists.
     */
    where: pool_retireWhereUniqueInput
    /**
     * In case the pool_retire found by the `where` argument doesn't exist, create a new pool_retire with this data.
     */
    create: XOR<pool_retireCreateInput, pool_retireUncheckedCreateInput>
    /**
     * In case the pool_retire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_retireUpdateInput, pool_retireUncheckedUpdateInput>
  }

  /**
   * pool_retire delete
   */
  export type pool_retireDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
    /**
     * Filter which pool_retire to delete.
     */
    where: pool_retireWhereUniqueInput
  }

  /**
   * pool_retire deleteMany
   */
  export type pool_retireDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_retires to delete
     */
    where?: pool_retireWhereInput
    /**
     * Limit how many pool_retires to delete.
     */
    limit?: number
  }

  /**
   * pool_retire without action
   */
  export type pool_retireDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_retire
     */
    select?: pool_retireSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_retire
     */
    omit?: pool_retireOmit<ExtArgs> | null
  }


  /**
   * Model pool_stat
   */

  export type AggregatePool_stat = {
    _count: Pool_statCountAggregateOutputType | null
    _avg: Pool_statAvgAggregateOutputType | null
    _sum: Pool_statSumAggregateOutputType | null
    _min: Pool_statMinAggregateOutputType | null
    _max: Pool_statMaxAggregateOutputType | null
  }

  export type Pool_statAvgAggregateOutputType = {
    id: number | null
    pool_hash_id: number | null
    epoch_no: number | null
    number_of_blocks: Decimal | null
    number_of_delegators: Decimal | null
    stake: Decimal | null
    voting_power: Decimal | null
  }

  export type Pool_statSumAggregateOutputType = {
    id: bigint | null
    pool_hash_id: bigint | null
    epoch_no: number | null
    number_of_blocks: Decimal | null
    number_of_delegators: Decimal | null
    stake: Decimal | null
    voting_power: Decimal | null
  }

  export type Pool_statMinAggregateOutputType = {
    id: bigint | null
    pool_hash_id: bigint | null
    epoch_no: number | null
    number_of_blocks: Decimal | null
    number_of_delegators: Decimal | null
    stake: Decimal | null
    voting_power: Decimal | null
  }

  export type Pool_statMaxAggregateOutputType = {
    id: bigint | null
    pool_hash_id: bigint | null
    epoch_no: number | null
    number_of_blocks: Decimal | null
    number_of_delegators: Decimal | null
    stake: Decimal | null
    voting_power: Decimal | null
  }

  export type Pool_statCountAggregateOutputType = {
    id: number
    pool_hash_id: number
    epoch_no: number
    number_of_blocks: number
    number_of_delegators: number
    stake: number
    voting_power: number
    _all: number
  }


  export type Pool_statAvgAggregateInputType = {
    id?: true
    pool_hash_id?: true
    epoch_no?: true
    number_of_blocks?: true
    number_of_delegators?: true
    stake?: true
    voting_power?: true
  }

  export type Pool_statSumAggregateInputType = {
    id?: true
    pool_hash_id?: true
    epoch_no?: true
    number_of_blocks?: true
    number_of_delegators?: true
    stake?: true
    voting_power?: true
  }

  export type Pool_statMinAggregateInputType = {
    id?: true
    pool_hash_id?: true
    epoch_no?: true
    number_of_blocks?: true
    number_of_delegators?: true
    stake?: true
    voting_power?: true
  }

  export type Pool_statMaxAggregateInputType = {
    id?: true
    pool_hash_id?: true
    epoch_no?: true
    number_of_blocks?: true
    number_of_delegators?: true
    stake?: true
    voting_power?: true
  }

  export type Pool_statCountAggregateInputType = {
    id?: true
    pool_hash_id?: true
    epoch_no?: true
    number_of_blocks?: true
    number_of_delegators?: true
    stake?: true
    voting_power?: true
    _all?: true
  }

  export type Pool_statAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_stat to aggregate.
     */
    where?: pool_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_stats to fetch.
     */
    orderBy?: pool_statOrderByWithRelationInput | pool_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_stats
    **/
    _count?: true | Pool_statCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_statAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_statSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_statMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_statMaxAggregateInputType
  }

  export type GetPool_statAggregateType<T extends Pool_statAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_stat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_stat[P]>
      : GetScalarType<T[P], AggregatePool_stat[P]>
  }




  export type pool_statGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_statWhereInput
    orderBy?: pool_statOrderByWithAggregationInput | pool_statOrderByWithAggregationInput[]
    by: Pool_statScalarFieldEnum[] | Pool_statScalarFieldEnum
    having?: pool_statScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_statCountAggregateInputType | true
    _avg?: Pool_statAvgAggregateInputType
    _sum?: Pool_statSumAggregateInputType
    _min?: Pool_statMinAggregateInputType
    _max?: Pool_statMaxAggregateInputType
  }

  export type Pool_statGroupByOutputType = {
    id: bigint
    pool_hash_id: bigint
    epoch_no: number
    number_of_blocks: Decimal
    number_of_delegators: Decimal
    stake: Decimal
    voting_power: Decimal | null
    _count: Pool_statCountAggregateOutputType | null
    _avg: Pool_statAvgAggregateOutputType | null
    _sum: Pool_statSumAggregateOutputType | null
    _min: Pool_statMinAggregateOutputType | null
    _max: Pool_statMaxAggregateOutputType | null
  }

  type GetPool_statGroupByPayload<T extends pool_statGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_statGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_statGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_statGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_statGroupByOutputType[P]>
        }
      >
    >


  export type pool_statSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_hash_id?: boolean
    epoch_no?: boolean
    number_of_blocks?: boolean
    number_of_delegators?: boolean
    stake?: boolean
    voting_power?: boolean
  }, ExtArgs["result"]["pool_stat"]>

  export type pool_statSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_hash_id?: boolean
    epoch_no?: boolean
    number_of_blocks?: boolean
    number_of_delegators?: boolean
    stake?: boolean
    voting_power?: boolean
  }, ExtArgs["result"]["pool_stat"]>

  export type pool_statSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pool_hash_id?: boolean
    epoch_no?: boolean
    number_of_blocks?: boolean
    number_of_delegators?: boolean
    stake?: boolean
    voting_power?: boolean
  }, ExtArgs["result"]["pool_stat"]>

  export type pool_statSelectScalar = {
    id?: boolean
    pool_hash_id?: boolean
    epoch_no?: boolean
    number_of_blocks?: boolean
    number_of_delegators?: boolean
    stake?: boolean
    voting_power?: boolean
  }

  export type pool_statOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pool_hash_id" | "epoch_no" | "number_of_blocks" | "number_of_delegators" | "stake" | "voting_power", ExtArgs["result"]["pool_stat"]>

  export type $pool_statPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_stat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      pool_hash_id: bigint
      epoch_no: number
      number_of_blocks: Prisma.Decimal
      number_of_delegators: Prisma.Decimal
      stake: Prisma.Decimal
      voting_power: Prisma.Decimal | null
    }, ExtArgs["result"]["pool_stat"]>
    composites: {}
  }

  type pool_statGetPayload<S extends boolean | null | undefined | pool_statDefaultArgs> = $Result.GetResult<Prisma.$pool_statPayload, S>

  type pool_statCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_statFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_statCountAggregateInputType | true
    }

  export interface pool_statDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_stat'], meta: { name: 'pool_stat' } }
    /**
     * Find zero or one Pool_stat that matches the filter.
     * @param {pool_statFindUniqueArgs} args - Arguments to find a Pool_stat
     * @example
     * // Get one Pool_stat
     * const pool_stat = await prisma.pool_stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_statFindUniqueArgs>(args: SelectSubset<T, pool_statFindUniqueArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_stat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_statFindUniqueOrThrowArgs} args - Arguments to find a Pool_stat
     * @example
     * // Get one Pool_stat
     * const pool_stat = await prisma.pool_stat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_statFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_statFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statFindFirstArgs} args - Arguments to find a Pool_stat
     * @example
     * // Get one Pool_stat
     * const pool_stat = await prisma.pool_stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_statFindFirstArgs>(args?: SelectSubset<T, pool_statFindFirstArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_stat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statFindFirstOrThrowArgs} args - Arguments to find a Pool_stat
     * @example
     * // Get one Pool_stat
     * const pool_stat = await prisma.pool_stat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_statFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_statFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_stats
     * const pool_stats = await prisma.pool_stat.findMany()
     * 
     * // Get first 10 Pool_stats
     * const pool_stats = await prisma.pool_stat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_statWithIdOnly = await prisma.pool_stat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_statFindManyArgs>(args?: SelectSubset<T, pool_statFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_stat.
     * @param {pool_statCreateArgs} args - Arguments to create a Pool_stat.
     * @example
     * // Create one Pool_stat
     * const Pool_stat = await prisma.pool_stat.create({
     *   data: {
     *     // ... data to create a Pool_stat
     *   }
     * })
     * 
     */
    create<T extends pool_statCreateArgs>(args: SelectSubset<T, pool_statCreateArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_stats.
     * @param {pool_statCreateManyArgs} args - Arguments to create many Pool_stats.
     * @example
     * // Create many Pool_stats
     * const pool_stat = await prisma.pool_stat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_statCreateManyArgs>(args?: SelectSubset<T, pool_statCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_stats and returns the data saved in the database.
     * @param {pool_statCreateManyAndReturnArgs} args - Arguments to create many Pool_stats.
     * @example
     * // Create many Pool_stats
     * const pool_stat = await prisma.pool_stat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_stats and only return the `id`
     * const pool_statWithIdOnly = await prisma.pool_stat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_statCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_statCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_stat.
     * @param {pool_statDeleteArgs} args - Arguments to delete one Pool_stat.
     * @example
     * // Delete one Pool_stat
     * const Pool_stat = await prisma.pool_stat.delete({
     *   where: {
     *     // ... filter to delete one Pool_stat
     *   }
     * })
     * 
     */
    delete<T extends pool_statDeleteArgs>(args: SelectSubset<T, pool_statDeleteArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_stat.
     * @param {pool_statUpdateArgs} args - Arguments to update one Pool_stat.
     * @example
     * // Update one Pool_stat
     * const pool_stat = await prisma.pool_stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_statUpdateArgs>(args: SelectSubset<T, pool_statUpdateArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_stats.
     * @param {pool_statDeleteManyArgs} args - Arguments to filter Pool_stats to delete.
     * @example
     * // Delete a few Pool_stats
     * const { count } = await prisma.pool_stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_statDeleteManyArgs>(args?: SelectSubset<T, pool_statDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_stats
     * const pool_stat = await prisma.pool_stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_statUpdateManyArgs>(args: SelectSubset<T, pool_statUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_stats and returns the data updated in the database.
     * @param {pool_statUpdateManyAndReturnArgs} args - Arguments to update many Pool_stats.
     * @example
     * // Update many Pool_stats
     * const pool_stat = await prisma.pool_stat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_stats and only return the `id`
     * const pool_statWithIdOnly = await prisma.pool_stat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_statUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_statUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_stat.
     * @param {pool_statUpsertArgs} args - Arguments to update or create a Pool_stat.
     * @example
     * // Update or create a Pool_stat
     * const pool_stat = await prisma.pool_stat.upsert({
     *   create: {
     *     // ... data to create a Pool_stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_stat we want to update
     *   }
     * })
     */
    upsert<T extends pool_statUpsertArgs>(args: SelectSubset<T, pool_statUpsertArgs<ExtArgs>>): Prisma__pool_statClient<$Result.GetResult<Prisma.$pool_statPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statCountArgs} args - Arguments to filter Pool_stats to count.
     * @example
     * // Count the number of Pool_stats
     * const count = await prisma.pool_stat.count({
     *   where: {
     *     // ... the filter for the Pool_stats we want to count
     *   }
     * })
    **/
    count<T extends pool_statCountArgs>(
      args?: Subset<T, pool_statCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_statCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_statAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_statAggregateArgs>(args: Subset<T, Pool_statAggregateArgs>): Prisma.PrismaPromise<GetPool_statAggregateType<T>>

    /**
     * Group by Pool_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_statGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_statGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_statGroupByArgs['orderBy'] }
        : { orderBy?: pool_statGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_statGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_statGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_stat model
   */
  readonly fields: pool_statFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_statClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_stat model
   */ 
  interface pool_statFieldRefs {
    readonly id: FieldRef<"pool_stat", 'BigInt'>
    readonly pool_hash_id: FieldRef<"pool_stat", 'BigInt'>
    readonly epoch_no: FieldRef<"pool_stat", 'Int'>
    readonly number_of_blocks: FieldRef<"pool_stat", 'Decimal'>
    readonly number_of_delegators: FieldRef<"pool_stat", 'Decimal'>
    readonly stake: FieldRef<"pool_stat", 'Decimal'>
    readonly voting_power: FieldRef<"pool_stat", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * pool_stat findUnique
   */
  export type pool_statFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter, which pool_stat to fetch.
     */
    where: pool_statWhereUniqueInput
  }

  /**
   * pool_stat findUniqueOrThrow
   */
  export type pool_statFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter, which pool_stat to fetch.
     */
    where: pool_statWhereUniqueInput
  }

  /**
   * pool_stat findFirst
   */
  export type pool_statFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter, which pool_stat to fetch.
     */
    where?: pool_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_stats to fetch.
     */
    orderBy?: pool_statOrderByWithRelationInput | pool_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_stats.
     */
    cursor?: pool_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_stats.
     */
    distinct?: Pool_statScalarFieldEnum | Pool_statScalarFieldEnum[]
  }

  /**
   * pool_stat findFirstOrThrow
   */
  export type pool_statFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter, which pool_stat to fetch.
     */
    where?: pool_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_stats to fetch.
     */
    orderBy?: pool_statOrderByWithRelationInput | pool_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_stats.
     */
    cursor?: pool_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_stats.
     */
    distinct?: Pool_statScalarFieldEnum | Pool_statScalarFieldEnum[]
  }

  /**
   * pool_stat findMany
   */
  export type pool_statFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter, which pool_stats to fetch.
     */
    where?: pool_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_stats to fetch.
     */
    orderBy?: pool_statOrderByWithRelationInput | pool_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_stats.
     */
    cursor?: pool_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_stats.
     */
    skip?: number
    distinct?: Pool_statScalarFieldEnum | Pool_statScalarFieldEnum[]
  }

  /**
   * pool_stat create
   */
  export type pool_statCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_stat.
     */
    data: XOR<pool_statCreateInput, pool_statUncheckedCreateInput>
  }

  /**
   * pool_stat createMany
   */
  export type pool_statCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_stats.
     */
    data: pool_statCreateManyInput | pool_statCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_stat createManyAndReturn
   */
  export type pool_statCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * The data used to create many pool_stats.
     */
    data: pool_statCreateManyInput | pool_statCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_stat update
   */
  export type pool_statUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_stat.
     */
    data: XOR<pool_statUpdateInput, pool_statUncheckedUpdateInput>
    /**
     * Choose, which pool_stat to update.
     */
    where: pool_statWhereUniqueInput
  }

  /**
   * pool_stat updateMany
   */
  export type pool_statUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_stats.
     */
    data: XOR<pool_statUpdateManyMutationInput, pool_statUncheckedUpdateManyInput>
    /**
     * Filter which pool_stats to update
     */
    where?: pool_statWhereInput
    /**
     * Limit how many pool_stats to update.
     */
    limit?: number
  }

  /**
   * pool_stat updateManyAndReturn
   */
  export type pool_statUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * The data used to update pool_stats.
     */
    data: XOR<pool_statUpdateManyMutationInput, pool_statUncheckedUpdateManyInput>
    /**
     * Filter which pool_stats to update
     */
    where?: pool_statWhereInput
    /**
     * Limit how many pool_stats to update.
     */
    limit?: number
  }

  /**
   * pool_stat upsert
   */
  export type pool_statUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_stat to update in case it exists.
     */
    where: pool_statWhereUniqueInput
    /**
     * In case the pool_stat found by the `where` argument doesn't exist, create a new pool_stat with this data.
     */
    create: XOR<pool_statCreateInput, pool_statUncheckedCreateInput>
    /**
     * In case the pool_stat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_statUpdateInput, pool_statUncheckedUpdateInput>
  }

  /**
   * pool_stat delete
   */
  export type pool_statDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
    /**
     * Filter which pool_stat to delete.
     */
    where: pool_statWhereUniqueInput
  }

  /**
   * pool_stat deleteMany
   */
  export type pool_statDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_stats to delete
     */
    where?: pool_statWhereInput
    /**
     * Limit how many pool_stats to delete.
     */
    limit?: number
  }

  /**
   * pool_stat without action
   */
  export type pool_statDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_stat
     */
    select?: pool_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_stat
     */
    omit?: pool_statOmit<ExtArgs> | null
  }


  /**
   * Model pool_update
   */

  export type AggregatePool_update = {
    _count: Pool_updateCountAggregateOutputType | null
    _avg: Pool_updateAvgAggregateOutputType | null
    _sum: Pool_updateSumAggregateOutputType | null
    _min: Pool_updateMinAggregateOutputType | null
    _max: Pool_updateMaxAggregateOutputType | null
  }

  export type Pool_updateAvgAggregateOutputType = {
    id: number | null
    hash_id: number | null
    cert_index: number | null
    pledge: Decimal | null
    active_epoch_no: number | null
    meta_id: number | null
    margin: number | null
    fixed_cost: Decimal | null
    registered_tx_id: number | null
    reward_addr_id: number | null
    deposit: Decimal | null
  }

  export type Pool_updateSumAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    pledge: Decimal | null
    active_epoch_no: bigint | null
    meta_id: bigint | null
    margin: number | null
    fixed_cost: Decimal | null
    registered_tx_id: bigint | null
    reward_addr_id: bigint | null
    deposit: Decimal | null
  }

  export type Pool_updateMinAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    vrf_key_hash: Uint8Array | null
    pledge: Decimal | null
    active_epoch_no: bigint | null
    meta_id: bigint | null
    margin: number | null
    fixed_cost: Decimal | null
    registered_tx_id: bigint | null
    reward_addr_id: bigint | null
    deposit: Decimal | null
  }

  export type Pool_updateMaxAggregateOutputType = {
    id: bigint | null
    hash_id: bigint | null
    cert_index: number | null
    vrf_key_hash: Uint8Array | null
    pledge: Decimal | null
    active_epoch_no: bigint | null
    meta_id: bigint | null
    margin: number | null
    fixed_cost: Decimal | null
    registered_tx_id: bigint | null
    reward_addr_id: bigint | null
    deposit: Decimal | null
  }

  export type Pool_updateCountAggregateOutputType = {
    id: number
    hash_id: number
    cert_index: number
    vrf_key_hash: number
    pledge: number
    active_epoch_no: number
    meta_id: number
    margin: number
    fixed_cost: number
    registered_tx_id: number
    reward_addr_id: number
    deposit: number
    _all: number
  }


  export type Pool_updateAvgAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    pledge?: true
    active_epoch_no?: true
    meta_id?: true
    margin?: true
    fixed_cost?: true
    registered_tx_id?: true
    reward_addr_id?: true
    deposit?: true
  }

  export type Pool_updateSumAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    pledge?: true
    active_epoch_no?: true
    meta_id?: true
    margin?: true
    fixed_cost?: true
    registered_tx_id?: true
    reward_addr_id?: true
    deposit?: true
  }

  export type Pool_updateMinAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    vrf_key_hash?: true
    pledge?: true
    active_epoch_no?: true
    meta_id?: true
    margin?: true
    fixed_cost?: true
    registered_tx_id?: true
    reward_addr_id?: true
    deposit?: true
  }

  export type Pool_updateMaxAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    vrf_key_hash?: true
    pledge?: true
    active_epoch_no?: true
    meta_id?: true
    margin?: true
    fixed_cost?: true
    registered_tx_id?: true
    reward_addr_id?: true
    deposit?: true
  }

  export type Pool_updateCountAggregateInputType = {
    id?: true
    hash_id?: true
    cert_index?: true
    vrf_key_hash?: true
    pledge?: true
    active_epoch_no?: true
    meta_id?: true
    margin?: true
    fixed_cost?: true
    registered_tx_id?: true
    reward_addr_id?: true
    deposit?: true
    _all?: true
  }

  export type Pool_updateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_update to aggregate.
     */
    where?: pool_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_updates to fetch.
     */
    orderBy?: pool_updateOrderByWithRelationInput | pool_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pool_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pool_updates
    **/
    _count?: true | Pool_updateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pool_updateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pool_updateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pool_updateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pool_updateMaxAggregateInputType
  }

  export type GetPool_updateAggregateType<T extends Pool_updateAggregateArgs> = {
        [P in keyof T & keyof AggregatePool_update]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePool_update[P]>
      : GetScalarType<T[P], AggregatePool_update[P]>
  }




  export type pool_updateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pool_updateWhereInput
    orderBy?: pool_updateOrderByWithAggregationInput | pool_updateOrderByWithAggregationInput[]
    by: Pool_updateScalarFieldEnum[] | Pool_updateScalarFieldEnum
    having?: pool_updateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pool_updateCountAggregateInputType | true
    _avg?: Pool_updateAvgAggregateInputType
    _sum?: Pool_updateSumAggregateInputType
    _min?: Pool_updateMinAggregateInputType
    _max?: Pool_updateMaxAggregateInputType
  }

  export type Pool_updateGroupByOutputType = {
    id: bigint
    hash_id: bigint
    cert_index: number
    vrf_key_hash: Uint8Array
    pledge: Decimal
    active_epoch_no: bigint
    meta_id: bigint | null
    margin: number
    fixed_cost: Decimal
    registered_tx_id: bigint
    reward_addr_id: bigint
    deposit: Decimal | null
    _count: Pool_updateCountAggregateOutputType | null
    _avg: Pool_updateAvgAggregateOutputType | null
    _sum: Pool_updateSumAggregateOutputType | null
    _min: Pool_updateMinAggregateOutputType | null
    _max: Pool_updateMaxAggregateOutputType | null
  }

  type GetPool_updateGroupByPayload<T extends pool_updateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pool_updateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pool_updateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pool_updateGroupByOutputType[P]>
            : GetScalarType<T[P], Pool_updateGroupByOutputType[P]>
        }
      >
    >


  export type pool_updateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    vrf_key_hash?: boolean
    pledge?: boolean
    active_epoch_no?: boolean
    meta_id?: boolean
    margin?: boolean
    fixed_cost?: boolean
    registered_tx_id?: boolean
    reward_addr_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["pool_update"]>

  export type pool_updateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    vrf_key_hash?: boolean
    pledge?: boolean
    active_epoch_no?: boolean
    meta_id?: boolean
    margin?: boolean
    fixed_cost?: boolean
    registered_tx_id?: boolean
    reward_addr_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["pool_update"]>

  export type pool_updateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    vrf_key_hash?: boolean
    pledge?: boolean
    active_epoch_no?: boolean
    meta_id?: boolean
    margin?: boolean
    fixed_cost?: boolean
    registered_tx_id?: boolean
    reward_addr_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["pool_update"]>

  export type pool_updateSelectScalar = {
    id?: boolean
    hash_id?: boolean
    cert_index?: boolean
    vrf_key_hash?: boolean
    pledge?: boolean
    active_epoch_no?: boolean
    meta_id?: boolean
    margin?: boolean
    fixed_cost?: boolean
    registered_tx_id?: boolean
    reward_addr_id?: boolean
    deposit?: boolean
  }

  export type pool_updateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_id" | "cert_index" | "vrf_key_hash" | "pledge" | "active_epoch_no" | "meta_id" | "margin" | "fixed_cost" | "registered_tx_id" | "reward_addr_id" | "deposit", ExtArgs["result"]["pool_update"]>

  export type $pool_updatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pool_update"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_id: bigint
      cert_index: number
      vrf_key_hash: Uint8Array
      pledge: Prisma.Decimal
      active_epoch_no: bigint
      meta_id: bigint | null
      margin: number
      fixed_cost: Prisma.Decimal
      registered_tx_id: bigint
      reward_addr_id: bigint
      deposit: Prisma.Decimal | null
    }, ExtArgs["result"]["pool_update"]>
    composites: {}
  }

  type pool_updateGetPayload<S extends boolean | null | undefined | pool_updateDefaultArgs> = $Result.GetResult<Prisma.$pool_updatePayload, S>

  type pool_updateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pool_updateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pool_updateCountAggregateInputType | true
    }

  export interface pool_updateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pool_update'], meta: { name: 'pool_update' } }
    /**
     * Find zero or one Pool_update that matches the filter.
     * @param {pool_updateFindUniqueArgs} args - Arguments to find a Pool_update
     * @example
     * // Get one Pool_update
     * const pool_update = await prisma.pool_update.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pool_updateFindUniqueArgs>(args: SelectSubset<T, pool_updateFindUniqueArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pool_update that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pool_updateFindUniqueOrThrowArgs} args - Arguments to find a Pool_update
     * @example
     * // Get one Pool_update
     * const pool_update = await prisma.pool_update.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pool_updateFindUniqueOrThrowArgs>(args: SelectSubset<T, pool_updateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_update that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateFindFirstArgs} args - Arguments to find a Pool_update
     * @example
     * // Get one Pool_update
     * const pool_update = await prisma.pool_update.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pool_updateFindFirstArgs>(args?: SelectSubset<T, pool_updateFindFirstArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pool_update that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateFindFirstOrThrowArgs} args - Arguments to find a Pool_update
     * @example
     * // Get one Pool_update
     * const pool_update = await prisma.pool_update.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pool_updateFindFirstOrThrowArgs>(args?: SelectSubset<T, pool_updateFindFirstOrThrowArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pool_updates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pool_updates
     * const pool_updates = await prisma.pool_update.findMany()
     * 
     * // Get first 10 Pool_updates
     * const pool_updates = await prisma.pool_update.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pool_updateWithIdOnly = await prisma.pool_update.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pool_updateFindManyArgs>(args?: SelectSubset<T, pool_updateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pool_update.
     * @param {pool_updateCreateArgs} args - Arguments to create a Pool_update.
     * @example
     * // Create one Pool_update
     * const Pool_update = await prisma.pool_update.create({
     *   data: {
     *     // ... data to create a Pool_update
     *   }
     * })
     * 
     */
    create<T extends pool_updateCreateArgs>(args: SelectSubset<T, pool_updateCreateArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pool_updates.
     * @param {pool_updateCreateManyArgs} args - Arguments to create many Pool_updates.
     * @example
     * // Create many Pool_updates
     * const pool_update = await prisma.pool_update.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pool_updateCreateManyArgs>(args?: SelectSubset<T, pool_updateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pool_updates and returns the data saved in the database.
     * @param {pool_updateCreateManyAndReturnArgs} args - Arguments to create many Pool_updates.
     * @example
     * // Create many Pool_updates
     * const pool_update = await prisma.pool_update.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pool_updates and only return the `id`
     * const pool_updateWithIdOnly = await prisma.pool_update.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pool_updateCreateManyAndReturnArgs>(args?: SelectSubset<T, pool_updateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pool_update.
     * @param {pool_updateDeleteArgs} args - Arguments to delete one Pool_update.
     * @example
     * // Delete one Pool_update
     * const Pool_update = await prisma.pool_update.delete({
     *   where: {
     *     // ... filter to delete one Pool_update
     *   }
     * })
     * 
     */
    delete<T extends pool_updateDeleteArgs>(args: SelectSubset<T, pool_updateDeleteArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pool_update.
     * @param {pool_updateUpdateArgs} args - Arguments to update one Pool_update.
     * @example
     * // Update one Pool_update
     * const pool_update = await prisma.pool_update.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pool_updateUpdateArgs>(args: SelectSubset<T, pool_updateUpdateArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pool_updates.
     * @param {pool_updateDeleteManyArgs} args - Arguments to filter Pool_updates to delete.
     * @example
     * // Delete a few Pool_updates
     * const { count } = await prisma.pool_update.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pool_updateDeleteManyArgs>(args?: SelectSubset<T, pool_updateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pool_updates
     * const pool_update = await prisma.pool_update.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pool_updateUpdateManyArgs>(args: SelectSubset<T, pool_updateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pool_updates and returns the data updated in the database.
     * @param {pool_updateUpdateManyAndReturnArgs} args - Arguments to update many Pool_updates.
     * @example
     * // Update many Pool_updates
     * const pool_update = await prisma.pool_update.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pool_updates and only return the `id`
     * const pool_updateWithIdOnly = await prisma.pool_update.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pool_updateUpdateManyAndReturnArgs>(args: SelectSubset<T, pool_updateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pool_update.
     * @param {pool_updateUpsertArgs} args - Arguments to update or create a Pool_update.
     * @example
     * // Update or create a Pool_update
     * const pool_update = await prisma.pool_update.upsert({
     *   create: {
     *     // ... data to create a Pool_update
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pool_update we want to update
     *   }
     * })
     */
    upsert<T extends pool_updateUpsertArgs>(args: SelectSubset<T, pool_updateUpsertArgs<ExtArgs>>): Prisma__pool_updateClient<$Result.GetResult<Prisma.$pool_updatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pool_updates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateCountArgs} args - Arguments to filter Pool_updates to count.
     * @example
     * // Count the number of Pool_updates
     * const count = await prisma.pool_update.count({
     *   where: {
     *     // ... the filter for the Pool_updates we want to count
     *   }
     * })
    **/
    count<T extends pool_updateCountArgs>(
      args?: Subset<T, pool_updateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pool_updateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pool_update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pool_updateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pool_updateAggregateArgs>(args: Subset<T, Pool_updateAggregateArgs>): Prisma.PrismaPromise<GetPool_updateAggregateType<T>>

    /**
     * Group by Pool_update.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pool_updateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pool_updateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pool_updateGroupByArgs['orderBy'] }
        : { orderBy?: pool_updateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pool_updateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPool_updateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pool_update model
   */
  readonly fields: pool_updateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pool_update.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pool_updateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pool_update model
   */ 
  interface pool_updateFieldRefs {
    readonly id: FieldRef<"pool_update", 'BigInt'>
    readonly hash_id: FieldRef<"pool_update", 'BigInt'>
    readonly cert_index: FieldRef<"pool_update", 'Int'>
    readonly vrf_key_hash: FieldRef<"pool_update", 'Bytes'>
    readonly pledge: FieldRef<"pool_update", 'Decimal'>
    readonly active_epoch_no: FieldRef<"pool_update", 'BigInt'>
    readonly meta_id: FieldRef<"pool_update", 'BigInt'>
    readonly margin: FieldRef<"pool_update", 'Float'>
    readonly fixed_cost: FieldRef<"pool_update", 'Decimal'>
    readonly registered_tx_id: FieldRef<"pool_update", 'BigInt'>
    readonly reward_addr_id: FieldRef<"pool_update", 'BigInt'>
    readonly deposit: FieldRef<"pool_update", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * pool_update findUnique
   */
  export type pool_updateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter, which pool_update to fetch.
     */
    where: pool_updateWhereUniqueInput
  }

  /**
   * pool_update findUniqueOrThrow
   */
  export type pool_updateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter, which pool_update to fetch.
     */
    where: pool_updateWhereUniqueInput
  }

  /**
   * pool_update findFirst
   */
  export type pool_updateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter, which pool_update to fetch.
     */
    where?: pool_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_updates to fetch.
     */
    orderBy?: pool_updateOrderByWithRelationInput | pool_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_updates.
     */
    cursor?: pool_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_updates.
     */
    distinct?: Pool_updateScalarFieldEnum | Pool_updateScalarFieldEnum[]
  }

  /**
   * pool_update findFirstOrThrow
   */
  export type pool_updateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter, which pool_update to fetch.
     */
    where?: pool_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_updates to fetch.
     */
    orderBy?: pool_updateOrderByWithRelationInput | pool_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pool_updates.
     */
    cursor?: pool_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_updates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pool_updates.
     */
    distinct?: Pool_updateScalarFieldEnum | Pool_updateScalarFieldEnum[]
  }

  /**
   * pool_update findMany
   */
  export type pool_updateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter, which pool_updates to fetch.
     */
    where?: pool_updateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pool_updates to fetch.
     */
    orderBy?: pool_updateOrderByWithRelationInput | pool_updateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pool_updates.
     */
    cursor?: pool_updateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pool_updates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pool_updates.
     */
    skip?: number
    distinct?: Pool_updateScalarFieldEnum | Pool_updateScalarFieldEnum[]
  }

  /**
   * pool_update create
   */
  export type pool_updateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * The data needed to create a pool_update.
     */
    data: XOR<pool_updateCreateInput, pool_updateUncheckedCreateInput>
  }

  /**
   * pool_update createMany
   */
  export type pool_updateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pool_updates.
     */
    data: pool_updateCreateManyInput | pool_updateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_update createManyAndReturn
   */
  export type pool_updateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * The data used to create many pool_updates.
     */
    data: pool_updateCreateManyInput | pool_updateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pool_update update
   */
  export type pool_updateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * The data needed to update a pool_update.
     */
    data: XOR<pool_updateUpdateInput, pool_updateUncheckedUpdateInput>
    /**
     * Choose, which pool_update to update.
     */
    where: pool_updateWhereUniqueInput
  }

  /**
   * pool_update updateMany
   */
  export type pool_updateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pool_updates.
     */
    data: XOR<pool_updateUpdateManyMutationInput, pool_updateUncheckedUpdateManyInput>
    /**
     * Filter which pool_updates to update
     */
    where?: pool_updateWhereInput
    /**
     * Limit how many pool_updates to update.
     */
    limit?: number
  }

  /**
   * pool_update updateManyAndReturn
   */
  export type pool_updateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * The data used to update pool_updates.
     */
    data: XOR<pool_updateUpdateManyMutationInput, pool_updateUncheckedUpdateManyInput>
    /**
     * Filter which pool_updates to update
     */
    where?: pool_updateWhereInput
    /**
     * Limit how many pool_updates to update.
     */
    limit?: number
  }

  /**
   * pool_update upsert
   */
  export type pool_updateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * The filter to search for the pool_update to update in case it exists.
     */
    where: pool_updateWhereUniqueInput
    /**
     * In case the pool_update found by the `where` argument doesn't exist, create a new pool_update with this data.
     */
    create: XOR<pool_updateCreateInput, pool_updateUncheckedCreateInput>
    /**
     * In case the pool_update was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pool_updateUpdateInput, pool_updateUncheckedUpdateInput>
  }

  /**
   * pool_update delete
   */
  export type pool_updateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
    /**
     * Filter which pool_update to delete.
     */
    where: pool_updateWhereUniqueInput
  }

  /**
   * pool_update deleteMany
   */
  export type pool_updateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pool_updates to delete
     */
    where?: pool_updateWhereInput
    /**
     * Limit how many pool_updates to delete.
     */
    limit?: number
  }

  /**
   * pool_update without action
   */
  export type pool_updateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pool_update
     */
    select?: pool_updateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pool_update
     */
    omit?: pool_updateOmit<ExtArgs> | null
  }


  /**
   * Model pot_transfer
   */

  export type AggregatePot_transfer = {
    _count: Pot_transferCountAggregateOutputType | null
    _avg: Pot_transferAvgAggregateOutputType | null
    _sum: Pot_transferSumAggregateOutputType | null
    _min: Pot_transferMinAggregateOutputType | null
    _max: Pot_transferMaxAggregateOutputType | null
  }

  export type Pot_transferAvgAggregateOutputType = {
    id: number | null
    cert_index: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    tx_id: number | null
  }

  export type Pot_transferSumAggregateOutputType = {
    id: bigint | null
    cert_index: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    tx_id: bigint | null
  }

  export type Pot_transferMinAggregateOutputType = {
    id: bigint | null
    cert_index: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    tx_id: bigint | null
  }

  export type Pot_transferMaxAggregateOutputType = {
    id: bigint | null
    cert_index: number | null
    treasury: Decimal | null
    reserves: Decimal | null
    tx_id: bigint | null
  }

  export type Pot_transferCountAggregateOutputType = {
    id: number
    cert_index: number
    treasury: number
    reserves: number
    tx_id: number
    _all: number
  }


  export type Pot_transferAvgAggregateInputType = {
    id?: true
    cert_index?: true
    treasury?: true
    reserves?: true
    tx_id?: true
  }

  export type Pot_transferSumAggregateInputType = {
    id?: true
    cert_index?: true
    treasury?: true
    reserves?: true
    tx_id?: true
  }

  export type Pot_transferMinAggregateInputType = {
    id?: true
    cert_index?: true
    treasury?: true
    reserves?: true
    tx_id?: true
  }

  export type Pot_transferMaxAggregateInputType = {
    id?: true
    cert_index?: true
    treasury?: true
    reserves?: true
    tx_id?: true
  }

  export type Pot_transferCountAggregateInputType = {
    id?: true
    cert_index?: true
    treasury?: true
    reserves?: true
    tx_id?: true
    _all?: true
  }

  export type Pot_transferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pot_transfer to aggregate.
     */
    where?: pot_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pot_transfers to fetch.
     */
    orderBy?: pot_transferOrderByWithRelationInput | pot_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pot_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pot_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pot_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pot_transfers
    **/
    _count?: true | Pot_transferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pot_transferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pot_transferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pot_transferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pot_transferMaxAggregateInputType
  }

  export type GetPot_transferAggregateType<T extends Pot_transferAggregateArgs> = {
        [P in keyof T & keyof AggregatePot_transfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePot_transfer[P]>
      : GetScalarType<T[P], AggregatePot_transfer[P]>
  }




  export type pot_transferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pot_transferWhereInput
    orderBy?: pot_transferOrderByWithAggregationInput | pot_transferOrderByWithAggregationInput[]
    by: Pot_transferScalarFieldEnum[] | Pot_transferScalarFieldEnum
    having?: pot_transferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pot_transferCountAggregateInputType | true
    _avg?: Pot_transferAvgAggregateInputType
    _sum?: Pot_transferSumAggregateInputType
    _min?: Pot_transferMinAggregateInputType
    _max?: Pot_transferMaxAggregateInputType
  }

  export type Pot_transferGroupByOutputType = {
    id: bigint
    cert_index: number
    treasury: Decimal
    reserves: Decimal
    tx_id: bigint
    _count: Pot_transferCountAggregateOutputType | null
    _avg: Pot_transferAvgAggregateOutputType | null
    _sum: Pot_transferSumAggregateOutputType | null
    _min: Pot_transferMinAggregateOutputType | null
    _max: Pot_transferMaxAggregateOutputType | null
  }

  type GetPot_transferGroupByPayload<T extends pot_transferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pot_transferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pot_transferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pot_transferGroupByOutputType[P]>
            : GetScalarType<T[P], Pot_transferGroupByOutputType[P]>
        }
      >
    >


  export type pot_transferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cert_index?: boolean
    treasury?: boolean
    reserves?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["pot_transfer"]>

  export type pot_transferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cert_index?: boolean
    treasury?: boolean
    reserves?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["pot_transfer"]>

  export type pot_transferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cert_index?: boolean
    treasury?: boolean
    reserves?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["pot_transfer"]>

  export type pot_transferSelectScalar = {
    id?: boolean
    cert_index?: boolean
    treasury?: boolean
    reserves?: boolean
    tx_id?: boolean
  }

  export type pot_transferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cert_index" | "treasury" | "reserves" | "tx_id", ExtArgs["result"]["pot_transfer"]>

  export type $pot_transferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pot_transfer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      cert_index: number
      treasury: Prisma.Decimal
      reserves: Prisma.Decimal
      tx_id: bigint
    }, ExtArgs["result"]["pot_transfer"]>
    composites: {}
  }

  type pot_transferGetPayload<S extends boolean | null | undefined | pot_transferDefaultArgs> = $Result.GetResult<Prisma.$pot_transferPayload, S>

  type pot_transferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pot_transferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Pot_transferCountAggregateInputType | true
    }

  export interface pot_transferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pot_transfer'], meta: { name: 'pot_transfer' } }
    /**
     * Find zero or one Pot_transfer that matches the filter.
     * @param {pot_transferFindUniqueArgs} args - Arguments to find a Pot_transfer
     * @example
     * // Get one Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pot_transferFindUniqueArgs>(args: SelectSubset<T, pot_transferFindUniqueArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pot_transfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pot_transferFindUniqueOrThrowArgs} args - Arguments to find a Pot_transfer
     * @example
     * // Get one Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pot_transferFindUniqueOrThrowArgs>(args: SelectSubset<T, pot_transferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pot_transfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferFindFirstArgs} args - Arguments to find a Pot_transfer
     * @example
     * // Get one Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pot_transferFindFirstArgs>(args?: SelectSubset<T, pot_transferFindFirstArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pot_transfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferFindFirstOrThrowArgs} args - Arguments to find a Pot_transfer
     * @example
     * // Get one Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pot_transferFindFirstOrThrowArgs>(args?: SelectSubset<T, pot_transferFindFirstOrThrowArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pot_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pot_transfers
     * const pot_transfers = await prisma.pot_transfer.findMany()
     * 
     * // Get first 10 Pot_transfers
     * const pot_transfers = await prisma.pot_transfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pot_transferWithIdOnly = await prisma.pot_transfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pot_transferFindManyArgs>(args?: SelectSubset<T, pot_transferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pot_transfer.
     * @param {pot_transferCreateArgs} args - Arguments to create a Pot_transfer.
     * @example
     * // Create one Pot_transfer
     * const Pot_transfer = await prisma.pot_transfer.create({
     *   data: {
     *     // ... data to create a Pot_transfer
     *   }
     * })
     * 
     */
    create<T extends pot_transferCreateArgs>(args: SelectSubset<T, pot_transferCreateArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pot_transfers.
     * @param {pot_transferCreateManyArgs} args - Arguments to create many Pot_transfers.
     * @example
     * // Create many Pot_transfers
     * const pot_transfer = await prisma.pot_transfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pot_transferCreateManyArgs>(args?: SelectSubset<T, pot_transferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pot_transfers and returns the data saved in the database.
     * @param {pot_transferCreateManyAndReturnArgs} args - Arguments to create many Pot_transfers.
     * @example
     * // Create many Pot_transfers
     * const pot_transfer = await prisma.pot_transfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pot_transfers and only return the `id`
     * const pot_transferWithIdOnly = await prisma.pot_transfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pot_transferCreateManyAndReturnArgs>(args?: SelectSubset<T, pot_transferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Pot_transfer.
     * @param {pot_transferDeleteArgs} args - Arguments to delete one Pot_transfer.
     * @example
     * // Delete one Pot_transfer
     * const Pot_transfer = await prisma.pot_transfer.delete({
     *   where: {
     *     // ... filter to delete one Pot_transfer
     *   }
     * })
     * 
     */
    delete<T extends pot_transferDeleteArgs>(args: SelectSubset<T, pot_transferDeleteArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pot_transfer.
     * @param {pot_transferUpdateArgs} args - Arguments to update one Pot_transfer.
     * @example
     * // Update one Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pot_transferUpdateArgs>(args: SelectSubset<T, pot_transferUpdateArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pot_transfers.
     * @param {pot_transferDeleteManyArgs} args - Arguments to filter Pot_transfers to delete.
     * @example
     * // Delete a few Pot_transfers
     * const { count } = await prisma.pot_transfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pot_transferDeleteManyArgs>(args?: SelectSubset<T, pot_transferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pot_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pot_transfers
     * const pot_transfer = await prisma.pot_transfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pot_transferUpdateManyArgs>(args: SelectSubset<T, pot_transferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pot_transfers and returns the data updated in the database.
     * @param {pot_transferUpdateManyAndReturnArgs} args - Arguments to update many Pot_transfers.
     * @example
     * // Update many Pot_transfers
     * const pot_transfer = await prisma.pot_transfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pot_transfers and only return the `id`
     * const pot_transferWithIdOnly = await prisma.pot_transfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pot_transferUpdateManyAndReturnArgs>(args: SelectSubset<T, pot_transferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Pot_transfer.
     * @param {pot_transferUpsertArgs} args - Arguments to update or create a Pot_transfer.
     * @example
     * // Update or create a Pot_transfer
     * const pot_transfer = await prisma.pot_transfer.upsert({
     *   create: {
     *     // ... data to create a Pot_transfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pot_transfer we want to update
     *   }
     * })
     */
    upsert<T extends pot_transferUpsertArgs>(args: SelectSubset<T, pot_transferUpsertArgs<ExtArgs>>): Prisma__pot_transferClient<$Result.GetResult<Prisma.$pot_transferPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pot_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferCountArgs} args - Arguments to filter Pot_transfers to count.
     * @example
     * // Count the number of Pot_transfers
     * const count = await prisma.pot_transfer.count({
     *   where: {
     *     // ... the filter for the Pot_transfers we want to count
     *   }
     * })
    **/
    count<T extends pot_transferCountArgs>(
      args?: Subset<T, pot_transferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pot_transferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pot_transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pot_transferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pot_transferAggregateArgs>(args: Subset<T, Pot_transferAggregateArgs>): Prisma.PrismaPromise<GetPot_transferAggregateType<T>>

    /**
     * Group by Pot_transfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pot_transferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pot_transferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pot_transferGroupByArgs['orderBy'] }
        : { orderBy?: pot_transferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pot_transferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPot_transferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pot_transfer model
   */
  readonly fields: pot_transferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pot_transfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pot_transferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pot_transfer model
   */ 
  interface pot_transferFieldRefs {
    readonly id: FieldRef<"pot_transfer", 'BigInt'>
    readonly cert_index: FieldRef<"pot_transfer", 'Int'>
    readonly treasury: FieldRef<"pot_transfer", 'Decimal'>
    readonly reserves: FieldRef<"pot_transfer", 'Decimal'>
    readonly tx_id: FieldRef<"pot_transfer", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * pot_transfer findUnique
   */
  export type pot_transferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter, which pot_transfer to fetch.
     */
    where: pot_transferWhereUniqueInput
  }

  /**
   * pot_transfer findUniqueOrThrow
   */
  export type pot_transferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter, which pot_transfer to fetch.
     */
    where: pot_transferWhereUniqueInput
  }

  /**
   * pot_transfer findFirst
   */
  export type pot_transferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter, which pot_transfer to fetch.
     */
    where?: pot_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pot_transfers to fetch.
     */
    orderBy?: pot_transferOrderByWithRelationInput | pot_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pot_transfers.
     */
    cursor?: pot_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pot_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pot_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pot_transfers.
     */
    distinct?: Pot_transferScalarFieldEnum | Pot_transferScalarFieldEnum[]
  }

  /**
   * pot_transfer findFirstOrThrow
   */
  export type pot_transferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter, which pot_transfer to fetch.
     */
    where?: pot_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pot_transfers to fetch.
     */
    orderBy?: pot_transferOrderByWithRelationInput | pot_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pot_transfers.
     */
    cursor?: pot_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pot_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pot_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pot_transfers.
     */
    distinct?: Pot_transferScalarFieldEnum | Pot_transferScalarFieldEnum[]
  }

  /**
   * pot_transfer findMany
   */
  export type pot_transferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter, which pot_transfers to fetch.
     */
    where?: pot_transferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pot_transfers to fetch.
     */
    orderBy?: pot_transferOrderByWithRelationInput | pot_transferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pot_transfers.
     */
    cursor?: pot_transferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pot_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pot_transfers.
     */
    skip?: number
    distinct?: Pot_transferScalarFieldEnum | Pot_transferScalarFieldEnum[]
  }

  /**
   * pot_transfer create
   */
  export type pot_transferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * The data needed to create a pot_transfer.
     */
    data: XOR<pot_transferCreateInput, pot_transferUncheckedCreateInput>
  }

  /**
   * pot_transfer createMany
   */
  export type pot_transferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pot_transfers.
     */
    data: pot_transferCreateManyInput | pot_transferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pot_transfer createManyAndReturn
   */
  export type pot_transferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * The data used to create many pot_transfers.
     */
    data: pot_transferCreateManyInput | pot_transferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pot_transfer update
   */
  export type pot_transferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * The data needed to update a pot_transfer.
     */
    data: XOR<pot_transferUpdateInput, pot_transferUncheckedUpdateInput>
    /**
     * Choose, which pot_transfer to update.
     */
    where: pot_transferWhereUniqueInput
  }

  /**
   * pot_transfer updateMany
   */
  export type pot_transferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pot_transfers.
     */
    data: XOR<pot_transferUpdateManyMutationInput, pot_transferUncheckedUpdateManyInput>
    /**
     * Filter which pot_transfers to update
     */
    where?: pot_transferWhereInput
    /**
     * Limit how many pot_transfers to update.
     */
    limit?: number
  }

  /**
   * pot_transfer updateManyAndReturn
   */
  export type pot_transferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * The data used to update pot_transfers.
     */
    data: XOR<pot_transferUpdateManyMutationInput, pot_transferUncheckedUpdateManyInput>
    /**
     * Filter which pot_transfers to update
     */
    where?: pot_transferWhereInput
    /**
     * Limit how many pot_transfers to update.
     */
    limit?: number
  }

  /**
   * pot_transfer upsert
   */
  export type pot_transferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * The filter to search for the pot_transfer to update in case it exists.
     */
    where: pot_transferWhereUniqueInput
    /**
     * In case the pot_transfer found by the `where` argument doesn't exist, create a new pot_transfer with this data.
     */
    create: XOR<pot_transferCreateInput, pot_transferUncheckedCreateInput>
    /**
     * In case the pot_transfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pot_transferUpdateInput, pot_transferUncheckedUpdateInput>
  }

  /**
   * pot_transfer delete
   */
  export type pot_transferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
    /**
     * Filter which pot_transfer to delete.
     */
    where: pot_transferWhereUniqueInput
  }

  /**
   * pot_transfer deleteMany
   */
  export type pot_transferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pot_transfers to delete
     */
    where?: pot_transferWhereInput
    /**
     * Limit how many pot_transfers to delete.
     */
    limit?: number
  }

  /**
   * pot_transfer without action
   */
  export type pot_transferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pot_transfer
     */
    select?: pot_transferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pot_transfer
     */
    omit?: pot_transferOmit<ExtArgs> | null
  }


  /**
   * Model redeemer
   */

  export type AggregateRedeemer = {
    _count: RedeemerCountAggregateOutputType | null
    _avg: RedeemerAvgAggregateOutputType | null
    _sum: RedeemerSumAggregateOutputType | null
    _min: RedeemerMinAggregateOutputType | null
    _max: RedeemerMaxAggregateOutputType | null
  }

  export type RedeemerAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    unit_mem: number | null
    unit_steps: number | null
    fee: Decimal | null
    index: number | null
    redeemer_data_id: number | null
  }

  export type RedeemerSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    unit_mem: bigint | null
    unit_steps: bigint | null
    fee: Decimal | null
    index: number | null
    redeemer_data_id: bigint | null
  }

  export type RedeemerMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    unit_mem: bigint | null
    unit_steps: bigint | null
    fee: Decimal | null
    purpose: $Enums.scriptpurposetype | null
    index: number | null
    script_hash: Uint8Array | null
    redeemer_data_id: bigint | null
  }

  export type RedeemerMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    unit_mem: bigint | null
    unit_steps: bigint | null
    fee: Decimal | null
    purpose: $Enums.scriptpurposetype | null
    index: number | null
    script_hash: Uint8Array | null
    redeemer_data_id: bigint | null
  }

  export type RedeemerCountAggregateOutputType = {
    id: number
    tx_id: number
    unit_mem: number
    unit_steps: number
    fee: number
    purpose: number
    index: number
    script_hash: number
    redeemer_data_id: number
    _all: number
  }


  export type RedeemerAvgAggregateInputType = {
    id?: true
    tx_id?: true
    unit_mem?: true
    unit_steps?: true
    fee?: true
    index?: true
    redeemer_data_id?: true
  }

  export type RedeemerSumAggregateInputType = {
    id?: true
    tx_id?: true
    unit_mem?: true
    unit_steps?: true
    fee?: true
    index?: true
    redeemer_data_id?: true
  }

  export type RedeemerMinAggregateInputType = {
    id?: true
    tx_id?: true
    unit_mem?: true
    unit_steps?: true
    fee?: true
    purpose?: true
    index?: true
    script_hash?: true
    redeemer_data_id?: true
  }

  export type RedeemerMaxAggregateInputType = {
    id?: true
    tx_id?: true
    unit_mem?: true
    unit_steps?: true
    fee?: true
    purpose?: true
    index?: true
    script_hash?: true
    redeemer_data_id?: true
  }

  export type RedeemerCountAggregateInputType = {
    id?: true
    tx_id?: true
    unit_mem?: true
    unit_steps?: true
    fee?: true
    purpose?: true
    index?: true
    script_hash?: true
    redeemer_data_id?: true
    _all?: true
  }

  export type RedeemerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which redeemer to aggregate.
     */
    where?: redeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemers to fetch.
     */
    orderBy?: redeemerOrderByWithRelationInput | redeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: redeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned redeemers
    **/
    _count?: true | RedeemerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedeemerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedeemerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedeemerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedeemerMaxAggregateInputType
  }

  export type GetRedeemerAggregateType<T extends RedeemerAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemer[P]>
      : GetScalarType<T[P], AggregateRedeemer[P]>
  }




  export type redeemerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: redeemerWhereInput
    orderBy?: redeemerOrderByWithAggregationInput | redeemerOrderByWithAggregationInput[]
    by: RedeemerScalarFieldEnum[] | RedeemerScalarFieldEnum
    having?: redeemerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedeemerCountAggregateInputType | true
    _avg?: RedeemerAvgAggregateInputType
    _sum?: RedeemerSumAggregateInputType
    _min?: RedeemerMinAggregateInputType
    _max?: RedeemerMaxAggregateInputType
  }

  export type RedeemerGroupByOutputType = {
    id: bigint
    tx_id: bigint
    unit_mem: bigint
    unit_steps: bigint
    fee: Decimal | null
    purpose: $Enums.scriptpurposetype
    index: number
    script_hash: Uint8Array | null
    redeemer_data_id: bigint
    _count: RedeemerCountAggregateOutputType | null
    _avg: RedeemerAvgAggregateOutputType | null
    _sum: RedeemerSumAggregateOutputType | null
    _min: RedeemerMinAggregateOutputType | null
    _max: RedeemerMaxAggregateOutputType | null
  }

  type GetRedeemerGroupByPayload<T extends redeemerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedeemerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedeemerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedeemerGroupByOutputType[P]>
            : GetScalarType<T[P], RedeemerGroupByOutputType[P]>
        }
      >
    >


  export type redeemerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    unit_mem?: boolean
    unit_steps?: boolean
    fee?: boolean
    purpose?: boolean
    index?: boolean
    script_hash?: boolean
    redeemer_data_id?: boolean
  }, ExtArgs["result"]["redeemer"]>

  export type redeemerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    unit_mem?: boolean
    unit_steps?: boolean
    fee?: boolean
    purpose?: boolean
    index?: boolean
    script_hash?: boolean
    redeemer_data_id?: boolean
  }, ExtArgs["result"]["redeemer"]>

  export type redeemerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    unit_mem?: boolean
    unit_steps?: boolean
    fee?: boolean
    purpose?: boolean
    index?: boolean
    script_hash?: boolean
    redeemer_data_id?: boolean
  }, ExtArgs["result"]["redeemer"]>

  export type redeemerSelectScalar = {
    id?: boolean
    tx_id?: boolean
    unit_mem?: boolean
    unit_steps?: boolean
    fee?: boolean
    purpose?: boolean
    index?: boolean
    script_hash?: boolean
    redeemer_data_id?: boolean
  }

  export type redeemerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "unit_mem" | "unit_steps" | "fee" | "purpose" | "index" | "script_hash" | "redeemer_data_id", ExtArgs["result"]["redeemer"]>

  export type $redeemerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "redeemer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      unit_mem: bigint
      unit_steps: bigint
      fee: Prisma.Decimal | null
      purpose: $Enums.scriptpurposetype
      index: number
      script_hash: Uint8Array | null
      redeemer_data_id: bigint
    }, ExtArgs["result"]["redeemer"]>
    composites: {}
  }

  type redeemerGetPayload<S extends boolean | null | undefined | redeemerDefaultArgs> = $Result.GetResult<Prisma.$redeemerPayload, S>

  type redeemerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<redeemerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedeemerCountAggregateInputType | true
    }

  export interface redeemerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['redeemer'], meta: { name: 'redeemer' } }
    /**
     * Find zero or one Redeemer that matches the filter.
     * @param {redeemerFindUniqueArgs} args - Arguments to find a Redeemer
     * @example
     * // Get one Redeemer
     * const redeemer = await prisma.redeemer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends redeemerFindUniqueArgs>(args: SelectSubset<T, redeemerFindUniqueArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Redeemer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {redeemerFindUniqueOrThrowArgs} args - Arguments to find a Redeemer
     * @example
     * // Get one Redeemer
     * const redeemer = await prisma.redeemer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends redeemerFindUniqueOrThrowArgs>(args: SelectSubset<T, redeemerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Redeemer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerFindFirstArgs} args - Arguments to find a Redeemer
     * @example
     * // Get one Redeemer
     * const redeemer = await prisma.redeemer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends redeemerFindFirstArgs>(args?: SelectSubset<T, redeemerFindFirstArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Redeemer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerFindFirstOrThrowArgs} args - Arguments to find a Redeemer
     * @example
     * // Get one Redeemer
     * const redeemer = await prisma.redeemer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends redeemerFindFirstOrThrowArgs>(args?: SelectSubset<T, redeemerFindFirstOrThrowArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Redeemers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redeemers
     * const redeemers = await prisma.redeemer.findMany()
     * 
     * // Get first 10 Redeemers
     * const redeemers = await prisma.redeemer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemerWithIdOnly = await prisma.redeemer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends redeemerFindManyArgs>(args?: SelectSubset<T, redeemerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Redeemer.
     * @param {redeemerCreateArgs} args - Arguments to create a Redeemer.
     * @example
     * // Create one Redeemer
     * const Redeemer = await prisma.redeemer.create({
     *   data: {
     *     // ... data to create a Redeemer
     *   }
     * })
     * 
     */
    create<T extends redeemerCreateArgs>(args: SelectSubset<T, redeemerCreateArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Redeemers.
     * @param {redeemerCreateManyArgs} args - Arguments to create many Redeemers.
     * @example
     * // Create many Redeemers
     * const redeemer = await prisma.redeemer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends redeemerCreateManyArgs>(args?: SelectSubset<T, redeemerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Redeemers and returns the data saved in the database.
     * @param {redeemerCreateManyAndReturnArgs} args - Arguments to create many Redeemers.
     * @example
     * // Create many Redeemers
     * const redeemer = await prisma.redeemer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Redeemers and only return the `id`
     * const redeemerWithIdOnly = await prisma.redeemer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends redeemerCreateManyAndReturnArgs>(args?: SelectSubset<T, redeemerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Redeemer.
     * @param {redeemerDeleteArgs} args - Arguments to delete one Redeemer.
     * @example
     * // Delete one Redeemer
     * const Redeemer = await prisma.redeemer.delete({
     *   where: {
     *     // ... filter to delete one Redeemer
     *   }
     * })
     * 
     */
    delete<T extends redeemerDeleteArgs>(args: SelectSubset<T, redeemerDeleteArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Redeemer.
     * @param {redeemerUpdateArgs} args - Arguments to update one Redeemer.
     * @example
     * // Update one Redeemer
     * const redeemer = await prisma.redeemer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends redeemerUpdateArgs>(args: SelectSubset<T, redeemerUpdateArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Redeemers.
     * @param {redeemerDeleteManyArgs} args - Arguments to filter Redeemers to delete.
     * @example
     * // Delete a few Redeemers
     * const { count } = await prisma.redeemer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends redeemerDeleteManyArgs>(args?: SelectSubset<T, redeemerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redeemers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redeemers
     * const redeemer = await prisma.redeemer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends redeemerUpdateManyArgs>(args: SelectSubset<T, redeemerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redeemers and returns the data updated in the database.
     * @param {redeemerUpdateManyAndReturnArgs} args - Arguments to update many Redeemers.
     * @example
     * // Update many Redeemers
     * const redeemer = await prisma.redeemer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Redeemers and only return the `id`
     * const redeemerWithIdOnly = await prisma.redeemer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends redeemerUpdateManyAndReturnArgs>(args: SelectSubset<T, redeemerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Redeemer.
     * @param {redeemerUpsertArgs} args - Arguments to update or create a Redeemer.
     * @example
     * // Update or create a Redeemer
     * const redeemer = await prisma.redeemer.upsert({
     *   create: {
     *     // ... data to create a Redeemer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redeemer we want to update
     *   }
     * })
     */
    upsert<T extends redeemerUpsertArgs>(args: SelectSubset<T, redeemerUpsertArgs<ExtArgs>>): Prisma__redeemerClient<$Result.GetResult<Prisma.$redeemerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Redeemers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerCountArgs} args - Arguments to filter Redeemers to count.
     * @example
     * // Count the number of Redeemers
     * const count = await prisma.redeemer.count({
     *   where: {
     *     // ... the filter for the Redeemers we want to count
     *   }
     * })
    **/
    count<T extends redeemerCountArgs>(
      args?: Subset<T, redeemerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedeemerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redeemer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedeemerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedeemerAggregateArgs>(args: Subset<T, RedeemerAggregateArgs>): Prisma.PrismaPromise<GetRedeemerAggregateType<T>>

    /**
     * Group by Redeemer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends redeemerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: redeemerGroupByArgs['orderBy'] }
        : { orderBy?: redeemerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, redeemerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the redeemer model
   */
  readonly fields: redeemerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for redeemer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__redeemerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the redeemer model
   */ 
  interface redeemerFieldRefs {
    readonly id: FieldRef<"redeemer", 'BigInt'>
    readonly tx_id: FieldRef<"redeemer", 'BigInt'>
    readonly unit_mem: FieldRef<"redeemer", 'BigInt'>
    readonly unit_steps: FieldRef<"redeemer", 'BigInt'>
    readonly fee: FieldRef<"redeemer", 'Decimal'>
    readonly purpose: FieldRef<"redeemer", 'scriptpurposetype'>
    readonly index: FieldRef<"redeemer", 'Int'>
    readonly script_hash: FieldRef<"redeemer", 'Bytes'>
    readonly redeemer_data_id: FieldRef<"redeemer", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * redeemer findUnique
   */
  export type redeemerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter, which redeemer to fetch.
     */
    where: redeemerWhereUniqueInput
  }

  /**
   * redeemer findUniqueOrThrow
   */
  export type redeemerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter, which redeemer to fetch.
     */
    where: redeemerWhereUniqueInput
  }

  /**
   * redeemer findFirst
   */
  export type redeemerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter, which redeemer to fetch.
     */
    where?: redeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemers to fetch.
     */
    orderBy?: redeemerOrderByWithRelationInput | redeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for redeemers.
     */
    cursor?: redeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of redeemers.
     */
    distinct?: RedeemerScalarFieldEnum | RedeemerScalarFieldEnum[]
  }

  /**
   * redeemer findFirstOrThrow
   */
  export type redeemerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter, which redeemer to fetch.
     */
    where?: redeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemers to fetch.
     */
    orderBy?: redeemerOrderByWithRelationInput | redeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for redeemers.
     */
    cursor?: redeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of redeemers.
     */
    distinct?: RedeemerScalarFieldEnum | RedeemerScalarFieldEnum[]
  }

  /**
   * redeemer findMany
   */
  export type redeemerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter, which redeemers to fetch.
     */
    where?: redeemerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemers to fetch.
     */
    orderBy?: redeemerOrderByWithRelationInput | redeemerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing redeemers.
     */
    cursor?: redeemerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemers.
     */
    skip?: number
    distinct?: RedeemerScalarFieldEnum | RedeemerScalarFieldEnum[]
  }

  /**
   * redeemer create
   */
  export type redeemerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * The data needed to create a redeemer.
     */
    data: XOR<redeemerCreateInput, redeemerUncheckedCreateInput>
  }

  /**
   * redeemer createMany
   */
  export type redeemerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many redeemers.
     */
    data: redeemerCreateManyInput | redeemerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * redeemer createManyAndReturn
   */
  export type redeemerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * The data used to create many redeemers.
     */
    data: redeemerCreateManyInput | redeemerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * redeemer update
   */
  export type redeemerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * The data needed to update a redeemer.
     */
    data: XOR<redeemerUpdateInput, redeemerUncheckedUpdateInput>
    /**
     * Choose, which redeemer to update.
     */
    where: redeemerWhereUniqueInput
  }

  /**
   * redeemer updateMany
   */
  export type redeemerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update redeemers.
     */
    data: XOR<redeemerUpdateManyMutationInput, redeemerUncheckedUpdateManyInput>
    /**
     * Filter which redeemers to update
     */
    where?: redeemerWhereInput
    /**
     * Limit how many redeemers to update.
     */
    limit?: number
  }

  /**
   * redeemer updateManyAndReturn
   */
  export type redeemerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * The data used to update redeemers.
     */
    data: XOR<redeemerUpdateManyMutationInput, redeemerUncheckedUpdateManyInput>
    /**
     * Filter which redeemers to update
     */
    where?: redeemerWhereInput
    /**
     * Limit how many redeemers to update.
     */
    limit?: number
  }

  /**
   * redeemer upsert
   */
  export type redeemerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * The filter to search for the redeemer to update in case it exists.
     */
    where: redeemerWhereUniqueInput
    /**
     * In case the redeemer found by the `where` argument doesn't exist, create a new redeemer with this data.
     */
    create: XOR<redeemerCreateInput, redeemerUncheckedCreateInput>
    /**
     * In case the redeemer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<redeemerUpdateInput, redeemerUncheckedUpdateInput>
  }

  /**
   * redeemer delete
   */
  export type redeemerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
    /**
     * Filter which redeemer to delete.
     */
    where: redeemerWhereUniqueInput
  }

  /**
   * redeemer deleteMany
   */
  export type redeemerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which redeemers to delete
     */
    where?: redeemerWhereInput
    /**
     * Limit how many redeemers to delete.
     */
    limit?: number
  }

  /**
   * redeemer without action
   */
  export type redeemerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer
     */
    select?: redeemerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer
     */
    omit?: redeemerOmit<ExtArgs> | null
  }


  /**
   * Model redeemer_data
   */

  export type AggregateRedeemer_data = {
    _count: Redeemer_dataCountAggregateOutputType | null
    _avg: Redeemer_dataAvgAggregateOutputType | null
    _sum: Redeemer_dataSumAggregateOutputType | null
    _min: Redeemer_dataMinAggregateOutputType | null
    _max: Redeemer_dataMaxAggregateOutputType | null
  }

  export type Redeemer_dataAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
  }

  export type Redeemer_dataSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
  }

  export type Redeemer_dataMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type Redeemer_dataMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type Redeemer_dataCountAggregateOutputType = {
    id: number
    hash: number
    tx_id: number
    value: number
    bytes: number
    _all: number
  }


  export type Redeemer_dataAvgAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Redeemer_dataSumAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Redeemer_dataMinAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    bytes?: true
  }

  export type Redeemer_dataMaxAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    bytes?: true
  }

  export type Redeemer_dataCountAggregateInputType = {
    id?: true
    hash?: true
    tx_id?: true
    value?: true
    bytes?: true
    _all?: true
  }

  export type Redeemer_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which redeemer_data to aggregate.
     */
    where?: redeemer_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemer_data to fetch.
     */
    orderBy?: redeemer_dataOrderByWithRelationInput | redeemer_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: redeemer_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemer_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemer_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned redeemer_data
    **/
    _count?: true | Redeemer_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Redeemer_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Redeemer_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redeemer_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redeemer_dataMaxAggregateInputType
  }

  export type GetRedeemer_dataAggregateType<T extends Redeemer_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateRedeemer_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedeemer_data[P]>
      : GetScalarType<T[P], AggregateRedeemer_data[P]>
  }




  export type redeemer_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: redeemer_dataWhereInput
    orderBy?: redeemer_dataOrderByWithAggregationInput | redeemer_dataOrderByWithAggregationInput[]
    by: Redeemer_dataScalarFieldEnum[] | Redeemer_dataScalarFieldEnum
    having?: redeemer_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redeemer_dataCountAggregateInputType | true
    _avg?: Redeemer_dataAvgAggregateInputType
    _sum?: Redeemer_dataSumAggregateInputType
    _min?: Redeemer_dataMinAggregateInputType
    _max?: Redeemer_dataMaxAggregateInputType
  }

  export type Redeemer_dataGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    tx_id: bigint
    value: JsonValue | null
    bytes: Uint8Array
    _count: Redeemer_dataCountAggregateOutputType | null
    _avg: Redeemer_dataAvgAggregateOutputType | null
    _sum: Redeemer_dataSumAggregateOutputType | null
    _min: Redeemer_dataMinAggregateOutputType | null
    _max: Redeemer_dataMaxAggregateOutputType | null
  }

  type GetRedeemer_dataGroupByPayload<T extends redeemer_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redeemer_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redeemer_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redeemer_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Redeemer_dataGroupByOutputType[P]>
        }
      >
    >


  export type redeemer_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["redeemer_data"]>

  export type redeemer_dataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["redeemer_data"]>

  export type redeemer_dataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["redeemer_data"]>

  export type redeemer_dataSelectScalar = {
    id?: boolean
    hash?: boolean
    tx_id?: boolean
    value?: boolean
    bytes?: boolean
  }

  export type redeemer_dataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "tx_id" | "value" | "bytes", ExtArgs["result"]["redeemer_data"]>

  export type $redeemer_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "redeemer_data"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      tx_id: bigint
      value: Prisma.JsonValue | null
      bytes: Uint8Array
    }, ExtArgs["result"]["redeemer_data"]>
    composites: {}
  }

  type redeemer_dataGetPayload<S extends boolean | null | undefined | redeemer_dataDefaultArgs> = $Result.GetResult<Prisma.$redeemer_dataPayload, S>

  type redeemer_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<redeemer_dataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Redeemer_dataCountAggregateInputType | true
    }

  export interface redeemer_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['redeemer_data'], meta: { name: 'redeemer_data' } }
    /**
     * Find zero or one Redeemer_data that matches the filter.
     * @param {redeemer_dataFindUniqueArgs} args - Arguments to find a Redeemer_data
     * @example
     * // Get one Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends redeemer_dataFindUniqueArgs>(args: SelectSubset<T, redeemer_dataFindUniqueArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Redeemer_data that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {redeemer_dataFindUniqueOrThrowArgs} args - Arguments to find a Redeemer_data
     * @example
     * // Get one Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends redeemer_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, redeemer_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Redeemer_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataFindFirstArgs} args - Arguments to find a Redeemer_data
     * @example
     * // Get one Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends redeemer_dataFindFirstArgs>(args?: SelectSubset<T, redeemer_dataFindFirstArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Redeemer_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataFindFirstOrThrowArgs} args - Arguments to find a Redeemer_data
     * @example
     * // Get one Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends redeemer_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, redeemer_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Redeemer_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findMany()
     * 
     * // Get first 10 Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redeemer_dataWithIdOnly = await prisma.redeemer_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends redeemer_dataFindManyArgs>(args?: SelectSubset<T, redeemer_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Redeemer_data.
     * @param {redeemer_dataCreateArgs} args - Arguments to create a Redeemer_data.
     * @example
     * // Create one Redeemer_data
     * const Redeemer_data = await prisma.redeemer_data.create({
     *   data: {
     *     // ... data to create a Redeemer_data
     *   }
     * })
     * 
     */
    create<T extends redeemer_dataCreateArgs>(args: SelectSubset<T, redeemer_dataCreateArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Redeemer_data.
     * @param {redeemer_dataCreateManyArgs} args - Arguments to create many Redeemer_data.
     * @example
     * // Create many Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends redeemer_dataCreateManyArgs>(args?: SelectSubset<T, redeemer_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Redeemer_data and returns the data saved in the database.
     * @param {redeemer_dataCreateManyAndReturnArgs} args - Arguments to create many Redeemer_data.
     * @example
     * // Create many Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Redeemer_data and only return the `id`
     * const redeemer_dataWithIdOnly = await prisma.redeemer_data.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends redeemer_dataCreateManyAndReturnArgs>(args?: SelectSubset<T, redeemer_dataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Redeemer_data.
     * @param {redeemer_dataDeleteArgs} args - Arguments to delete one Redeemer_data.
     * @example
     * // Delete one Redeemer_data
     * const Redeemer_data = await prisma.redeemer_data.delete({
     *   where: {
     *     // ... filter to delete one Redeemer_data
     *   }
     * })
     * 
     */
    delete<T extends redeemer_dataDeleteArgs>(args: SelectSubset<T, redeemer_dataDeleteArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Redeemer_data.
     * @param {redeemer_dataUpdateArgs} args - Arguments to update one Redeemer_data.
     * @example
     * // Update one Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends redeemer_dataUpdateArgs>(args: SelectSubset<T, redeemer_dataUpdateArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Redeemer_data.
     * @param {redeemer_dataDeleteManyArgs} args - Arguments to filter Redeemer_data to delete.
     * @example
     * // Delete a few Redeemer_data
     * const { count } = await prisma.redeemer_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends redeemer_dataDeleteManyArgs>(args?: SelectSubset<T, redeemer_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redeemer_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends redeemer_dataUpdateManyArgs>(args: SelectSubset<T, redeemer_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redeemer_data and returns the data updated in the database.
     * @param {redeemer_dataUpdateManyAndReturnArgs} args - Arguments to update many Redeemer_data.
     * @example
     * // Update many Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Redeemer_data and only return the `id`
     * const redeemer_dataWithIdOnly = await prisma.redeemer_data.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends redeemer_dataUpdateManyAndReturnArgs>(args: SelectSubset<T, redeemer_dataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Redeemer_data.
     * @param {redeemer_dataUpsertArgs} args - Arguments to update or create a Redeemer_data.
     * @example
     * // Update or create a Redeemer_data
     * const redeemer_data = await prisma.redeemer_data.upsert({
     *   create: {
     *     // ... data to create a Redeemer_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redeemer_data we want to update
     *   }
     * })
     */
    upsert<T extends redeemer_dataUpsertArgs>(args: SelectSubset<T, redeemer_dataUpsertArgs<ExtArgs>>): Prisma__redeemer_dataClient<$Result.GetResult<Prisma.$redeemer_dataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Redeemer_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataCountArgs} args - Arguments to filter Redeemer_data to count.
     * @example
     * // Count the number of Redeemer_data
     * const count = await prisma.redeemer_data.count({
     *   where: {
     *     // ... the filter for the Redeemer_data we want to count
     *   }
     * })
    **/
    count<T extends redeemer_dataCountArgs>(
      args?: Subset<T, redeemer_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redeemer_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redeemer_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redeemer_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redeemer_dataAggregateArgs>(args: Subset<T, Redeemer_dataAggregateArgs>): Prisma.PrismaPromise<GetRedeemer_dataAggregateType<T>>

    /**
     * Group by Redeemer_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {redeemer_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends redeemer_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: redeemer_dataGroupByArgs['orderBy'] }
        : { orderBy?: redeemer_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, redeemer_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedeemer_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the redeemer_data model
   */
  readonly fields: redeemer_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for redeemer_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__redeemer_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the redeemer_data model
   */ 
  interface redeemer_dataFieldRefs {
    readonly id: FieldRef<"redeemer_data", 'BigInt'>
    readonly hash: FieldRef<"redeemer_data", 'Bytes'>
    readonly tx_id: FieldRef<"redeemer_data", 'BigInt'>
    readonly value: FieldRef<"redeemer_data", 'Json'>
    readonly bytes: FieldRef<"redeemer_data", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * redeemer_data findUnique
   */
  export type redeemer_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter, which redeemer_data to fetch.
     */
    where: redeemer_dataWhereUniqueInput
  }

  /**
   * redeemer_data findUniqueOrThrow
   */
  export type redeemer_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter, which redeemer_data to fetch.
     */
    where: redeemer_dataWhereUniqueInput
  }

  /**
   * redeemer_data findFirst
   */
  export type redeemer_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter, which redeemer_data to fetch.
     */
    where?: redeemer_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemer_data to fetch.
     */
    orderBy?: redeemer_dataOrderByWithRelationInput | redeemer_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for redeemer_data.
     */
    cursor?: redeemer_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemer_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemer_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of redeemer_data.
     */
    distinct?: Redeemer_dataScalarFieldEnum | Redeemer_dataScalarFieldEnum[]
  }

  /**
   * redeemer_data findFirstOrThrow
   */
  export type redeemer_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter, which redeemer_data to fetch.
     */
    where?: redeemer_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemer_data to fetch.
     */
    orderBy?: redeemer_dataOrderByWithRelationInput | redeemer_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for redeemer_data.
     */
    cursor?: redeemer_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemer_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemer_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of redeemer_data.
     */
    distinct?: Redeemer_dataScalarFieldEnum | Redeemer_dataScalarFieldEnum[]
  }

  /**
   * redeemer_data findMany
   */
  export type redeemer_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter, which redeemer_data to fetch.
     */
    where?: redeemer_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of redeemer_data to fetch.
     */
    orderBy?: redeemer_dataOrderByWithRelationInput | redeemer_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing redeemer_data.
     */
    cursor?: redeemer_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` redeemer_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` redeemer_data.
     */
    skip?: number
    distinct?: Redeemer_dataScalarFieldEnum | Redeemer_dataScalarFieldEnum[]
  }

  /**
   * redeemer_data create
   */
  export type redeemer_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * The data needed to create a redeemer_data.
     */
    data: XOR<redeemer_dataCreateInput, redeemer_dataUncheckedCreateInput>
  }

  /**
   * redeemer_data createMany
   */
  export type redeemer_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many redeemer_data.
     */
    data: redeemer_dataCreateManyInput | redeemer_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * redeemer_data createManyAndReturn
   */
  export type redeemer_dataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * The data used to create many redeemer_data.
     */
    data: redeemer_dataCreateManyInput | redeemer_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * redeemer_data update
   */
  export type redeemer_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * The data needed to update a redeemer_data.
     */
    data: XOR<redeemer_dataUpdateInput, redeemer_dataUncheckedUpdateInput>
    /**
     * Choose, which redeemer_data to update.
     */
    where: redeemer_dataWhereUniqueInput
  }

  /**
   * redeemer_data updateMany
   */
  export type redeemer_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update redeemer_data.
     */
    data: XOR<redeemer_dataUpdateManyMutationInput, redeemer_dataUncheckedUpdateManyInput>
    /**
     * Filter which redeemer_data to update
     */
    where?: redeemer_dataWhereInput
    /**
     * Limit how many redeemer_data to update.
     */
    limit?: number
  }

  /**
   * redeemer_data updateManyAndReturn
   */
  export type redeemer_dataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * The data used to update redeemer_data.
     */
    data: XOR<redeemer_dataUpdateManyMutationInput, redeemer_dataUncheckedUpdateManyInput>
    /**
     * Filter which redeemer_data to update
     */
    where?: redeemer_dataWhereInput
    /**
     * Limit how many redeemer_data to update.
     */
    limit?: number
  }

  /**
   * redeemer_data upsert
   */
  export type redeemer_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * The filter to search for the redeemer_data to update in case it exists.
     */
    where: redeemer_dataWhereUniqueInput
    /**
     * In case the redeemer_data found by the `where` argument doesn't exist, create a new redeemer_data with this data.
     */
    create: XOR<redeemer_dataCreateInput, redeemer_dataUncheckedCreateInput>
    /**
     * In case the redeemer_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<redeemer_dataUpdateInput, redeemer_dataUncheckedUpdateInput>
  }

  /**
   * redeemer_data delete
   */
  export type redeemer_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
    /**
     * Filter which redeemer_data to delete.
     */
    where: redeemer_dataWhereUniqueInput
  }

  /**
   * redeemer_data deleteMany
   */
  export type redeemer_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which redeemer_data to delete
     */
    where?: redeemer_dataWhereInput
    /**
     * Limit how many redeemer_data to delete.
     */
    limit?: number
  }

  /**
   * redeemer_data without action
   */
  export type redeemer_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the redeemer_data
     */
    select?: redeemer_dataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the redeemer_data
     */
    omit?: redeemer_dataOmit<ExtArgs> | null
  }


  /**
   * Model reference_tx_in
   */

  export type AggregateReference_tx_in = {
    _count: Reference_tx_inCountAggregateOutputType | null
    _avg: Reference_tx_inAvgAggregateOutputType | null
    _sum: Reference_tx_inSumAggregateOutputType | null
    _min: Reference_tx_inMinAggregateOutputType | null
    _max: Reference_tx_inMaxAggregateOutputType | null
  }

  export type Reference_tx_inAvgAggregateOutputType = {
    id: number | null
    tx_in_id: number | null
    tx_out_id: number | null
    tx_out_index: number | null
  }

  export type Reference_tx_inSumAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Reference_tx_inMinAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Reference_tx_inMaxAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
  }

  export type Reference_tx_inCountAggregateOutputType = {
    id: number
    tx_in_id: number
    tx_out_id: number
    tx_out_index: number
    _all: number
  }


  export type Reference_tx_inAvgAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Reference_tx_inSumAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Reference_tx_inMinAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Reference_tx_inMaxAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
  }

  export type Reference_tx_inCountAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    _all?: true
  }

  export type Reference_tx_inAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reference_tx_in to aggregate.
     */
    where?: reference_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reference_tx_ins to fetch.
     */
    orderBy?: reference_tx_inOrderByWithRelationInput | reference_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reference_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reference_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reference_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reference_tx_ins
    **/
    _count?: true | Reference_tx_inCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reference_tx_inAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reference_tx_inSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reference_tx_inMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reference_tx_inMaxAggregateInputType
  }

  export type GetReference_tx_inAggregateType<T extends Reference_tx_inAggregateArgs> = {
        [P in keyof T & keyof AggregateReference_tx_in]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReference_tx_in[P]>
      : GetScalarType<T[P], AggregateReference_tx_in[P]>
  }




  export type reference_tx_inGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reference_tx_inWhereInput
    orderBy?: reference_tx_inOrderByWithAggregationInput | reference_tx_inOrderByWithAggregationInput[]
    by: Reference_tx_inScalarFieldEnum[] | Reference_tx_inScalarFieldEnum
    having?: reference_tx_inScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reference_tx_inCountAggregateInputType | true
    _avg?: Reference_tx_inAvgAggregateInputType
    _sum?: Reference_tx_inSumAggregateInputType
    _min?: Reference_tx_inMinAggregateInputType
    _max?: Reference_tx_inMaxAggregateInputType
  }

  export type Reference_tx_inGroupByOutputType = {
    id: bigint
    tx_in_id: bigint
    tx_out_id: bigint
    tx_out_index: number
    _count: Reference_tx_inCountAggregateOutputType | null
    _avg: Reference_tx_inAvgAggregateOutputType | null
    _sum: Reference_tx_inSumAggregateOutputType | null
    _min: Reference_tx_inMinAggregateOutputType | null
    _max: Reference_tx_inMaxAggregateOutputType | null
  }

  type GetReference_tx_inGroupByPayload<T extends reference_tx_inGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reference_tx_inGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reference_tx_inGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reference_tx_inGroupByOutputType[P]>
            : GetScalarType<T[P], Reference_tx_inGroupByOutputType[P]>
        }
      >
    >


  export type reference_tx_inSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["reference_tx_in"]>

  export type reference_tx_inSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["reference_tx_in"]>

  export type reference_tx_inSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }, ExtArgs["result"]["reference_tx_in"]>

  export type reference_tx_inSelectScalar = {
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
  }

  export type reference_tx_inOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_in_id" | "tx_out_id" | "tx_out_index", ExtArgs["result"]["reference_tx_in"]>

  export type $reference_tx_inPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reference_tx_in"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_in_id: bigint
      tx_out_id: bigint
      tx_out_index: number
    }, ExtArgs["result"]["reference_tx_in"]>
    composites: {}
  }

  type reference_tx_inGetPayload<S extends boolean | null | undefined | reference_tx_inDefaultArgs> = $Result.GetResult<Prisma.$reference_tx_inPayload, S>

  type reference_tx_inCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reference_tx_inFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reference_tx_inCountAggregateInputType | true
    }

  export interface reference_tx_inDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reference_tx_in'], meta: { name: 'reference_tx_in' } }
    /**
     * Find zero or one Reference_tx_in that matches the filter.
     * @param {reference_tx_inFindUniqueArgs} args - Arguments to find a Reference_tx_in
     * @example
     * // Get one Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reference_tx_inFindUniqueArgs>(args: SelectSubset<T, reference_tx_inFindUniqueArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reference_tx_in that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reference_tx_inFindUniqueOrThrowArgs} args - Arguments to find a Reference_tx_in
     * @example
     * // Get one Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reference_tx_inFindUniqueOrThrowArgs>(args: SelectSubset<T, reference_tx_inFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reference_tx_in that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inFindFirstArgs} args - Arguments to find a Reference_tx_in
     * @example
     * // Get one Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reference_tx_inFindFirstArgs>(args?: SelectSubset<T, reference_tx_inFindFirstArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reference_tx_in that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inFindFirstOrThrowArgs} args - Arguments to find a Reference_tx_in
     * @example
     * // Get one Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reference_tx_inFindFirstOrThrowArgs>(args?: SelectSubset<T, reference_tx_inFindFirstOrThrowArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reference_tx_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reference_tx_ins
     * const reference_tx_ins = await prisma.reference_tx_in.findMany()
     * 
     * // Get first 10 Reference_tx_ins
     * const reference_tx_ins = await prisma.reference_tx_in.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reference_tx_inWithIdOnly = await prisma.reference_tx_in.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reference_tx_inFindManyArgs>(args?: SelectSubset<T, reference_tx_inFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reference_tx_in.
     * @param {reference_tx_inCreateArgs} args - Arguments to create a Reference_tx_in.
     * @example
     * // Create one Reference_tx_in
     * const Reference_tx_in = await prisma.reference_tx_in.create({
     *   data: {
     *     // ... data to create a Reference_tx_in
     *   }
     * })
     * 
     */
    create<T extends reference_tx_inCreateArgs>(args: SelectSubset<T, reference_tx_inCreateArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reference_tx_ins.
     * @param {reference_tx_inCreateManyArgs} args - Arguments to create many Reference_tx_ins.
     * @example
     * // Create many Reference_tx_ins
     * const reference_tx_in = await prisma.reference_tx_in.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reference_tx_inCreateManyArgs>(args?: SelectSubset<T, reference_tx_inCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reference_tx_ins and returns the data saved in the database.
     * @param {reference_tx_inCreateManyAndReturnArgs} args - Arguments to create many Reference_tx_ins.
     * @example
     * // Create many Reference_tx_ins
     * const reference_tx_in = await prisma.reference_tx_in.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reference_tx_ins and only return the `id`
     * const reference_tx_inWithIdOnly = await prisma.reference_tx_in.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reference_tx_inCreateManyAndReturnArgs>(args?: SelectSubset<T, reference_tx_inCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reference_tx_in.
     * @param {reference_tx_inDeleteArgs} args - Arguments to delete one Reference_tx_in.
     * @example
     * // Delete one Reference_tx_in
     * const Reference_tx_in = await prisma.reference_tx_in.delete({
     *   where: {
     *     // ... filter to delete one Reference_tx_in
     *   }
     * })
     * 
     */
    delete<T extends reference_tx_inDeleteArgs>(args: SelectSubset<T, reference_tx_inDeleteArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reference_tx_in.
     * @param {reference_tx_inUpdateArgs} args - Arguments to update one Reference_tx_in.
     * @example
     * // Update one Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reference_tx_inUpdateArgs>(args: SelectSubset<T, reference_tx_inUpdateArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reference_tx_ins.
     * @param {reference_tx_inDeleteManyArgs} args - Arguments to filter Reference_tx_ins to delete.
     * @example
     * // Delete a few Reference_tx_ins
     * const { count } = await prisma.reference_tx_in.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reference_tx_inDeleteManyArgs>(args?: SelectSubset<T, reference_tx_inDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reference_tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reference_tx_ins
     * const reference_tx_in = await prisma.reference_tx_in.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reference_tx_inUpdateManyArgs>(args: SelectSubset<T, reference_tx_inUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reference_tx_ins and returns the data updated in the database.
     * @param {reference_tx_inUpdateManyAndReturnArgs} args - Arguments to update many Reference_tx_ins.
     * @example
     * // Update many Reference_tx_ins
     * const reference_tx_in = await prisma.reference_tx_in.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reference_tx_ins and only return the `id`
     * const reference_tx_inWithIdOnly = await prisma.reference_tx_in.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reference_tx_inUpdateManyAndReturnArgs>(args: SelectSubset<T, reference_tx_inUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reference_tx_in.
     * @param {reference_tx_inUpsertArgs} args - Arguments to update or create a Reference_tx_in.
     * @example
     * // Update or create a Reference_tx_in
     * const reference_tx_in = await prisma.reference_tx_in.upsert({
     *   create: {
     *     // ... data to create a Reference_tx_in
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reference_tx_in we want to update
     *   }
     * })
     */
    upsert<T extends reference_tx_inUpsertArgs>(args: SelectSubset<T, reference_tx_inUpsertArgs<ExtArgs>>): Prisma__reference_tx_inClient<$Result.GetResult<Prisma.$reference_tx_inPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reference_tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inCountArgs} args - Arguments to filter Reference_tx_ins to count.
     * @example
     * // Count the number of Reference_tx_ins
     * const count = await prisma.reference_tx_in.count({
     *   where: {
     *     // ... the filter for the Reference_tx_ins we want to count
     *   }
     * })
    **/
    count<T extends reference_tx_inCountArgs>(
      args?: Subset<T, reference_tx_inCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reference_tx_inCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reference_tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reference_tx_inAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reference_tx_inAggregateArgs>(args: Subset<T, Reference_tx_inAggregateArgs>): Prisma.PrismaPromise<GetReference_tx_inAggregateType<T>>

    /**
     * Group by Reference_tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reference_tx_inGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reference_tx_inGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reference_tx_inGroupByArgs['orderBy'] }
        : { orderBy?: reference_tx_inGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reference_tx_inGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReference_tx_inGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reference_tx_in model
   */
  readonly fields: reference_tx_inFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reference_tx_in.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reference_tx_inClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reference_tx_in model
   */ 
  interface reference_tx_inFieldRefs {
    readonly id: FieldRef<"reference_tx_in", 'BigInt'>
    readonly tx_in_id: FieldRef<"reference_tx_in", 'BigInt'>
    readonly tx_out_id: FieldRef<"reference_tx_in", 'BigInt'>
    readonly tx_out_index: FieldRef<"reference_tx_in", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * reference_tx_in findUnique
   */
  export type reference_tx_inFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which reference_tx_in to fetch.
     */
    where: reference_tx_inWhereUniqueInput
  }

  /**
   * reference_tx_in findUniqueOrThrow
   */
  export type reference_tx_inFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which reference_tx_in to fetch.
     */
    where: reference_tx_inWhereUniqueInput
  }

  /**
   * reference_tx_in findFirst
   */
  export type reference_tx_inFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which reference_tx_in to fetch.
     */
    where?: reference_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reference_tx_ins to fetch.
     */
    orderBy?: reference_tx_inOrderByWithRelationInput | reference_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reference_tx_ins.
     */
    cursor?: reference_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reference_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reference_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reference_tx_ins.
     */
    distinct?: Reference_tx_inScalarFieldEnum | Reference_tx_inScalarFieldEnum[]
  }

  /**
   * reference_tx_in findFirstOrThrow
   */
  export type reference_tx_inFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which reference_tx_in to fetch.
     */
    where?: reference_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reference_tx_ins to fetch.
     */
    orderBy?: reference_tx_inOrderByWithRelationInput | reference_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reference_tx_ins.
     */
    cursor?: reference_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reference_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reference_tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reference_tx_ins.
     */
    distinct?: Reference_tx_inScalarFieldEnum | Reference_tx_inScalarFieldEnum[]
  }

  /**
   * reference_tx_in findMany
   */
  export type reference_tx_inFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter, which reference_tx_ins to fetch.
     */
    where?: reference_tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reference_tx_ins to fetch.
     */
    orderBy?: reference_tx_inOrderByWithRelationInput | reference_tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reference_tx_ins.
     */
    cursor?: reference_tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reference_tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reference_tx_ins.
     */
    skip?: number
    distinct?: Reference_tx_inScalarFieldEnum | Reference_tx_inScalarFieldEnum[]
  }

  /**
   * reference_tx_in create
   */
  export type reference_tx_inCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * The data needed to create a reference_tx_in.
     */
    data: XOR<reference_tx_inCreateInput, reference_tx_inUncheckedCreateInput>
  }

  /**
   * reference_tx_in createMany
   */
  export type reference_tx_inCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reference_tx_ins.
     */
    data: reference_tx_inCreateManyInput | reference_tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reference_tx_in createManyAndReturn
   */
  export type reference_tx_inCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * The data used to create many reference_tx_ins.
     */
    data: reference_tx_inCreateManyInput | reference_tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reference_tx_in update
   */
  export type reference_tx_inUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * The data needed to update a reference_tx_in.
     */
    data: XOR<reference_tx_inUpdateInput, reference_tx_inUncheckedUpdateInput>
    /**
     * Choose, which reference_tx_in to update.
     */
    where: reference_tx_inWhereUniqueInput
  }

  /**
   * reference_tx_in updateMany
   */
  export type reference_tx_inUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reference_tx_ins.
     */
    data: XOR<reference_tx_inUpdateManyMutationInput, reference_tx_inUncheckedUpdateManyInput>
    /**
     * Filter which reference_tx_ins to update
     */
    where?: reference_tx_inWhereInput
    /**
     * Limit how many reference_tx_ins to update.
     */
    limit?: number
  }

  /**
   * reference_tx_in updateManyAndReturn
   */
  export type reference_tx_inUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * The data used to update reference_tx_ins.
     */
    data: XOR<reference_tx_inUpdateManyMutationInput, reference_tx_inUncheckedUpdateManyInput>
    /**
     * Filter which reference_tx_ins to update
     */
    where?: reference_tx_inWhereInput
    /**
     * Limit how many reference_tx_ins to update.
     */
    limit?: number
  }

  /**
   * reference_tx_in upsert
   */
  export type reference_tx_inUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * The filter to search for the reference_tx_in to update in case it exists.
     */
    where: reference_tx_inWhereUniqueInput
    /**
     * In case the reference_tx_in found by the `where` argument doesn't exist, create a new reference_tx_in with this data.
     */
    create: XOR<reference_tx_inCreateInput, reference_tx_inUncheckedCreateInput>
    /**
     * In case the reference_tx_in was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reference_tx_inUpdateInput, reference_tx_inUncheckedUpdateInput>
  }

  /**
   * reference_tx_in delete
   */
  export type reference_tx_inDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
    /**
     * Filter which reference_tx_in to delete.
     */
    where: reference_tx_inWhereUniqueInput
  }

  /**
   * reference_tx_in deleteMany
   */
  export type reference_tx_inDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reference_tx_ins to delete
     */
    where?: reference_tx_inWhereInput
    /**
     * Limit how many reference_tx_ins to delete.
     */
    limit?: number
  }

  /**
   * reference_tx_in without action
   */
  export type reference_tx_inDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reference_tx_in
     */
    select?: reference_tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reference_tx_in
     */
    omit?: reference_tx_inOmit<ExtArgs> | null
  }


  /**
   * Model reserve
   */

  export type AggregateReserve = {
    _count: ReserveCountAggregateOutputType | null
    _avg: ReserveAvgAggregateOutputType | null
    _sum: ReserveSumAggregateOutputType | null
    _min: ReserveMinAggregateOutputType | null
    _max: ReserveMaxAggregateOutputType | null
  }

  export type ReserveAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: number | null
  }

  export type ReserveSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type ReserveMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type ReserveMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type ReserveCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    amount: number
    tx_id: number
    _all: number
  }


  export type ReserveAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type ReserveSumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type ReserveMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type ReserveMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type ReserveCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
    _all?: true
  }

  export type ReserveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reserve to aggregate.
     */
    where?: reserveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserves to fetch.
     */
    orderBy?: reserveOrderByWithRelationInput | reserveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reserveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reserves
    **/
    _count?: true | ReserveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReserveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReserveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReserveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReserveMaxAggregateInputType
  }

  export type GetReserveAggregateType<T extends ReserveAggregateArgs> = {
        [P in keyof T & keyof AggregateReserve]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserve[P]>
      : GetScalarType<T[P], AggregateReserve[P]>
  }




  export type reserveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reserveWhereInput
    orderBy?: reserveOrderByWithAggregationInput | reserveOrderByWithAggregationInput[]
    by: ReserveScalarFieldEnum[] | ReserveScalarFieldEnum
    having?: reserveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReserveCountAggregateInputType | true
    _avg?: ReserveAvgAggregateInputType
    _sum?: ReserveSumAggregateInputType
    _min?: ReserveMinAggregateInputType
    _max?: ReserveMaxAggregateInputType
  }

  export type ReserveGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    amount: Decimal
    tx_id: bigint
    _count: ReserveCountAggregateOutputType | null
    _avg: ReserveAvgAggregateOutputType | null
    _sum: ReserveSumAggregateOutputType | null
    _min: ReserveMinAggregateOutputType | null
    _max: ReserveMaxAggregateOutputType | null
  }

  type GetReserveGroupByPayload<T extends reserveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReserveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReserveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReserveGroupByOutputType[P]>
            : GetScalarType<T[P], ReserveGroupByOutputType[P]>
        }
      >
    >


  export type reserveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["reserve"]>

  export type reserveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["reserve"]>

  export type reserveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["reserve"]>

  export type reserveSelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }

  export type reserveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "amount" | "tx_id", ExtArgs["result"]["reserve"]>

  export type $reservePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reserve"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      amount: Prisma.Decimal
      tx_id: bigint
    }, ExtArgs["result"]["reserve"]>
    composites: {}
  }

  type reserveGetPayload<S extends boolean | null | undefined | reserveDefaultArgs> = $Result.GetResult<Prisma.$reservePayload, S>

  type reserveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reserveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReserveCountAggregateInputType | true
    }

  export interface reserveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reserve'], meta: { name: 'reserve' } }
    /**
     * Find zero or one Reserve that matches the filter.
     * @param {reserveFindUniqueArgs} args - Arguments to find a Reserve
     * @example
     * // Get one Reserve
     * const reserve = await prisma.reserve.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reserveFindUniqueArgs>(args: SelectSubset<T, reserveFindUniqueArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reserve that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reserveFindUniqueOrThrowArgs} args - Arguments to find a Reserve
     * @example
     * // Get one Reserve
     * const reserve = await prisma.reserve.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reserveFindUniqueOrThrowArgs>(args: SelectSubset<T, reserveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reserve that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveFindFirstArgs} args - Arguments to find a Reserve
     * @example
     * // Get one Reserve
     * const reserve = await prisma.reserve.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reserveFindFirstArgs>(args?: SelectSubset<T, reserveFindFirstArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reserve that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveFindFirstOrThrowArgs} args - Arguments to find a Reserve
     * @example
     * // Get one Reserve
     * const reserve = await prisma.reserve.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reserveFindFirstOrThrowArgs>(args?: SelectSubset<T, reserveFindFirstOrThrowArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reserves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reserves
     * const reserves = await prisma.reserve.findMany()
     * 
     * // Get first 10 Reserves
     * const reserves = await prisma.reserve.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reserveWithIdOnly = await prisma.reserve.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reserveFindManyArgs>(args?: SelectSubset<T, reserveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reserve.
     * @param {reserveCreateArgs} args - Arguments to create a Reserve.
     * @example
     * // Create one Reserve
     * const Reserve = await prisma.reserve.create({
     *   data: {
     *     // ... data to create a Reserve
     *   }
     * })
     * 
     */
    create<T extends reserveCreateArgs>(args: SelectSubset<T, reserveCreateArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reserves.
     * @param {reserveCreateManyArgs} args - Arguments to create many Reserves.
     * @example
     * // Create many Reserves
     * const reserve = await prisma.reserve.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reserveCreateManyArgs>(args?: SelectSubset<T, reserveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reserves and returns the data saved in the database.
     * @param {reserveCreateManyAndReturnArgs} args - Arguments to create many Reserves.
     * @example
     * // Create many Reserves
     * const reserve = await prisma.reserve.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reserves and only return the `id`
     * const reserveWithIdOnly = await prisma.reserve.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reserveCreateManyAndReturnArgs>(args?: SelectSubset<T, reserveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reserve.
     * @param {reserveDeleteArgs} args - Arguments to delete one Reserve.
     * @example
     * // Delete one Reserve
     * const Reserve = await prisma.reserve.delete({
     *   where: {
     *     // ... filter to delete one Reserve
     *   }
     * })
     * 
     */
    delete<T extends reserveDeleteArgs>(args: SelectSubset<T, reserveDeleteArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reserve.
     * @param {reserveUpdateArgs} args - Arguments to update one Reserve.
     * @example
     * // Update one Reserve
     * const reserve = await prisma.reserve.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reserveUpdateArgs>(args: SelectSubset<T, reserveUpdateArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reserves.
     * @param {reserveDeleteManyArgs} args - Arguments to filter Reserves to delete.
     * @example
     * // Delete a few Reserves
     * const { count } = await prisma.reserve.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reserveDeleteManyArgs>(args?: SelectSubset<T, reserveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reserves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reserves
     * const reserve = await prisma.reserve.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reserveUpdateManyArgs>(args: SelectSubset<T, reserveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reserves and returns the data updated in the database.
     * @param {reserveUpdateManyAndReturnArgs} args - Arguments to update many Reserves.
     * @example
     * // Update many Reserves
     * const reserve = await prisma.reserve.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reserves and only return the `id`
     * const reserveWithIdOnly = await prisma.reserve.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reserveUpdateManyAndReturnArgs>(args: SelectSubset<T, reserveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reserve.
     * @param {reserveUpsertArgs} args - Arguments to update or create a Reserve.
     * @example
     * // Update or create a Reserve
     * const reserve = await prisma.reserve.upsert({
     *   create: {
     *     // ... data to create a Reserve
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserve we want to update
     *   }
     * })
     */
    upsert<T extends reserveUpsertArgs>(args: SelectSubset<T, reserveUpsertArgs<ExtArgs>>): Prisma__reserveClient<$Result.GetResult<Prisma.$reservePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reserves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveCountArgs} args - Arguments to filter Reserves to count.
     * @example
     * // Count the number of Reserves
     * const count = await prisma.reserve.count({
     *   where: {
     *     // ... the filter for the Reserves we want to count
     *   }
     * })
    **/
    count<T extends reserveCountArgs>(
      args?: Subset<T, reserveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReserveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReserveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReserveAggregateArgs>(args: Subset<T, ReserveAggregateArgs>): Prisma.PrismaPromise<GetReserveAggregateType<T>>

    /**
     * Group by Reserve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reserveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reserveGroupByArgs['orderBy'] }
        : { orderBy?: reserveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reserveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReserveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reserve model
   */
  readonly fields: reserveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reserve.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reserveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reserve model
   */ 
  interface reserveFieldRefs {
    readonly id: FieldRef<"reserve", 'BigInt'>
    readonly addr_id: FieldRef<"reserve", 'BigInt'>
    readonly cert_index: FieldRef<"reserve", 'Int'>
    readonly amount: FieldRef<"reserve", 'Decimal'>
    readonly tx_id: FieldRef<"reserve", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * reserve findUnique
   */
  export type reserveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter, which reserve to fetch.
     */
    where: reserveWhereUniqueInput
  }

  /**
   * reserve findUniqueOrThrow
   */
  export type reserveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter, which reserve to fetch.
     */
    where: reserveWhereUniqueInput
  }

  /**
   * reserve findFirst
   */
  export type reserveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter, which reserve to fetch.
     */
    where?: reserveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserves to fetch.
     */
    orderBy?: reserveOrderByWithRelationInput | reserveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reserves.
     */
    cursor?: reserveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reserves.
     */
    distinct?: ReserveScalarFieldEnum | ReserveScalarFieldEnum[]
  }

  /**
   * reserve findFirstOrThrow
   */
  export type reserveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter, which reserve to fetch.
     */
    where?: reserveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserves to fetch.
     */
    orderBy?: reserveOrderByWithRelationInput | reserveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reserves.
     */
    cursor?: reserveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reserves.
     */
    distinct?: ReserveScalarFieldEnum | ReserveScalarFieldEnum[]
  }

  /**
   * reserve findMany
   */
  export type reserveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter, which reserves to fetch.
     */
    where?: reserveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserves to fetch.
     */
    orderBy?: reserveOrderByWithRelationInput | reserveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reserves.
     */
    cursor?: reserveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserves.
     */
    skip?: number
    distinct?: ReserveScalarFieldEnum | ReserveScalarFieldEnum[]
  }

  /**
   * reserve create
   */
  export type reserveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * The data needed to create a reserve.
     */
    data: XOR<reserveCreateInput, reserveUncheckedCreateInput>
  }

  /**
   * reserve createMany
   */
  export type reserveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reserves.
     */
    data: reserveCreateManyInput | reserveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reserve createManyAndReturn
   */
  export type reserveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * The data used to create many reserves.
     */
    data: reserveCreateManyInput | reserveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reserve update
   */
  export type reserveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * The data needed to update a reserve.
     */
    data: XOR<reserveUpdateInput, reserveUncheckedUpdateInput>
    /**
     * Choose, which reserve to update.
     */
    where: reserveWhereUniqueInput
  }

  /**
   * reserve updateMany
   */
  export type reserveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reserves.
     */
    data: XOR<reserveUpdateManyMutationInput, reserveUncheckedUpdateManyInput>
    /**
     * Filter which reserves to update
     */
    where?: reserveWhereInput
    /**
     * Limit how many reserves to update.
     */
    limit?: number
  }

  /**
   * reserve updateManyAndReturn
   */
  export type reserveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * The data used to update reserves.
     */
    data: XOR<reserveUpdateManyMutationInput, reserveUncheckedUpdateManyInput>
    /**
     * Filter which reserves to update
     */
    where?: reserveWhereInput
    /**
     * Limit how many reserves to update.
     */
    limit?: number
  }

  /**
   * reserve upsert
   */
  export type reserveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * The filter to search for the reserve to update in case it exists.
     */
    where: reserveWhereUniqueInput
    /**
     * In case the reserve found by the `where` argument doesn't exist, create a new reserve with this data.
     */
    create: XOR<reserveCreateInput, reserveUncheckedCreateInput>
    /**
     * In case the reserve was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reserveUpdateInput, reserveUncheckedUpdateInput>
  }

  /**
   * reserve delete
   */
  export type reserveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
    /**
     * Filter which reserve to delete.
     */
    where: reserveWhereUniqueInput
  }

  /**
   * reserve deleteMany
   */
  export type reserveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reserves to delete
     */
    where?: reserveWhereInput
    /**
     * Limit how many reserves to delete.
     */
    limit?: number
  }

  /**
   * reserve without action
   */
  export type reserveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserve
     */
    select?: reserveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserve
     */
    omit?: reserveOmit<ExtArgs> | null
  }


  /**
   * Model reserved_pool_ticker
   */

  export type AggregateReserved_pool_ticker = {
    _count: Reserved_pool_tickerCountAggregateOutputType | null
    _avg: Reserved_pool_tickerAvgAggregateOutputType | null
    _sum: Reserved_pool_tickerSumAggregateOutputType | null
    _min: Reserved_pool_tickerMinAggregateOutputType | null
    _max: Reserved_pool_tickerMaxAggregateOutputType | null
  }

  export type Reserved_pool_tickerAvgAggregateOutputType = {
    id: number | null
  }

  export type Reserved_pool_tickerSumAggregateOutputType = {
    id: bigint | null
  }

  export type Reserved_pool_tickerMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    pool_hash: Uint8Array | null
  }

  export type Reserved_pool_tickerMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    pool_hash: Uint8Array | null
  }

  export type Reserved_pool_tickerCountAggregateOutputType = {
    id: number
    name: number
    pool_hash: number
    _all: number
  }


  export type Reserved_pool_tickerAvgAggregateInputType = {
    id?: true
  }

  export type Reserved_pool_tickerSumAggregateInputType = {
    id?: true
  }

  export type Reserved_pool_tickerMinAggregateInputType = {
    id?: true
    name?: true
    pool_hash?: true
  }

  export type Reserved_pool_tickerMaxAggregateInputType = {
    id?: true
    name?: true
    pool_hash?: true
  }

  export type Reserved_pool_tickerCountAggregateInputType = {
    id?: true
    name?: true
    pool_hash?: true
    _all?: true
  }

  export type Reserved_pool_tickerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reserved_pool_ticker to aggregate.
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserved_pool_tickers to fetch.
     */
    orderBy?: reserved_pool_tickerOrderByWithRelationInput | reserved_pool_tickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reserved_pool_tickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserved_pool_tickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserved_pool_tickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reserved_pool_tickers
    **/
    _count?: true | Reserved_pool_tickerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reserved_pool_tickerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reserved_pool_tickerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reserved_pool_tickerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reserved_pool_tickerMaxAggregateInputType
  }

  export type GetReserved_pool_tickerAggregateType<T extends Reserved_pool_tickerAggregateArgs> = {
        [P in keyof T & keyof AggregateReserved_pool_ticker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserved_pool_ticker[P]>
      : GetScalarType<T[P], AggregateReserved_pool_ticker[P]>
  }




  export type reserved_pool_tickerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reserved_pool_tickerWhereInput
    orderBy?: reserved_pool_tickerOrderByWithAggregationInput | reserved_pool_tickerOrderByWithAggregationInput[]
    by: Reserved_pool_tickerScalarFieldEnum[] | Reserved_pool_tickerScalarFieldEnum
    having?: reserved_pool_tickerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reserved_pool_tickerCountAggregateInputType | true
    _avg?: Reserved_pool_tickerAvgAggregateInputType
    _sum?: Reserved_pool_tickerSumAggregateInputType
    _min?: Reserved_pool_tickerMinAggregateInputType
    _max?: Reserved_pool_tickerMaxAggregateInputType
  }

  export type Reserved_pool_tickerGroupByOutputType = {
    id: bigint
    name: string
    pool_hash: Uint8Array
    _count: Reserved_pool_tickerCountAggregateOutputType | null
    _avg: Reserved_pool_tickerAvgAggregateOutputType | null
    _sum: Reserved_pool_tickerSumAggregateOutputType | null
    _min: Reserved_pool_tickerMinAggregateOutputType | null
    _max: Reserved_pool_tickerMaxAggregateOutputType | null
  }

  type GetReserved_pool_tickerGroupByPayload<T extends reserved_pool_tickerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reserved_pool_tickerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reserved_pool_tickerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reserved_pool_tickerGroupByOutputType[P]>
            : GetScalarType<T[P], Reserved_pool_tickerGroupByOutputType[P]>
        }
      >
    >


  export type reserved_pool_tickerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pool_hash?: boolean
  }, ExtArgs["result"]["reserved_pool_ticker"]>

  export type reserved_pool_tickerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pool_hash?: boolean
  }, ExtArgs["result"]["reserved_pool_ticker"]>

  export type reserved_pool_tickerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pool_hash?: boolean
  }, ExtArgs["result"]["reserved_pool_ticker"]>

  export type reserved_pool_tickerSelectScalar = {
    id?: boolean
    name?: boolean
    pool_hash?: boolean
  }

  export type reserved_pool_tickerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pool_hash", ExtArgs["result"]["reserved_pool_ticker"]>

  export type $reserved_pool_tickerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reserved_pool_ticker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      pool_hash: Uint8Array
    }, ExtArgs["result"]["reserved_pool_ticker"]>
    composites: {}
  }

  type reserved_pool_tickerGetPayload<S extends boolean | null | undefined | reserved_pool_tickerDefaultArgs> = $Result.GetResult<Prisma.$reserved_pool_tickerPayload, S>

  type reserved_pool_tickerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reserved_pool_tickerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reserved_pool_tickerCountAggregateInputType | true
    }

  export interface reserved_pool_tickerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reserved_pool_ticker'], meta: { name: 'reserved_pool_ticker' } }
    /**
     * Find zero or one Reserved_pool_ticker that matches the filter.
     * @param {reserved_pool_tickerFindUniqueArgs} args - Arguments to find a Reserved_pool_ticker
     * @example
     * // Get one Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reserved_pool_tickerFindUniqueArgs>(args: SelectSubset<T, reserved_pool_tickerFindUniqueArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reserved_pool_ticker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reserved_pool_tickerFindUniqueOrThrowArgs} args - Arguments to find a Reserved_pool_ticker
     * @example
     * // Get one Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reserved_pool_tickerFindUniqueOrThrowArgs>(args: SelectSubset<T, reserved_pool_tickerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reserved_pool_ticker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerFindFirstArgs} args - Arguments to find a Reserved_pool_ticker
     * @example
     * // Get one Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reserved_pool_tickerFindFirstArgs>(args?: SelectSubset<T, reserved_pool_tickerFindFirstArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reserved_pool_ticker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerFindFirstOrThrowArgs} args - Arguments to find a Reserved_pool_ticker
     * @example
     * // Get one Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reserved_pool_tickerFindFirstOrThrowArgs>(args?: SelectSubset<T, reserved_pool_tickerFindFirstOrThrowArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reserved_pool_tickers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reserved_pool_tickers
     * const reserved_pool_tickers = await prisma.reserved_pool_ticker.findMany()
     * 
     * // Get first 10 Reserved_pool_tickers
     * const reserved_pool_tickers = await prisma.reserved_pool_ticker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reserved_pool_tickerWithIdOnly = await prisma.reserved_pool_ticker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reserved_pool_tickerFindManyArgs>(args?: SelectSubset<T, reserved_pool_tickerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reserved_pool_ticker.
     * @param {reserved_pool_tickerCreateArgs} args - Arguments to create a Reserved_pool_ticker.
     * @example
     * // Create one Reserved_pool_ticker
     * const Reserved_pool_ticker = await prisma.reserved_pool_ticker.create({
     *   data: {
     *     // ... data to create a Reserved_pool_ticker
     *   }
     * })
     * 
     */
    create<T extends reserved_pool_tickerCreateArgs>(args: SelectSubset<T, reserved_pool_tickerCreateArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reserved_pool_tickers.
     * @param {reserved_pool_tickerCreateManyArgs} args - Arguments to create many Reserved_pool_tickers.
     * @example
     * // Create many Reserved_pool_tickers
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reserved_pool_tickerCreateManyArgs>(args?: SelectSubset<T, reserved_pool_tickerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reserved_pool_tickers and returns the data saved in the database.
     * @param {reserved_pool_tickerCreateManyAndReturnArgs} args - Arguments to create many Reserved_pool_tickers.
     * @example
     * // Create many Reserved_pool_tickers
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reserved_pool_tickers and only return the `id`
     * const reserved_pool_tickerWithIdOnly = await prisma.reserved_pool_ticker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reserved_pool_tickerCreateManyAndReturnArgs>(args?: SelectSubset<T, reserved_pool_tickerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reserved_pool_ticker.
     * @param {reserved_pool_tickerDeleteArgs} args - Arguments to delete one Reserved_pool_ticker.
     * @example
     * // Delete one Reserved_pool_ticker
     * const Reserved_pool_ticker = await prisma.reserved_pool_ticker.delete({
     *   where: {
     *     // ... filter to delete one Reserved_pool_ticker
     *   }
     * })
     * 
     */
    delete<T extends reserved_pool_tickerDeleteArgs>(args: SelectSubset<T, reserved_pool_tickerDeleteArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reserved_pool_ticker.
     * @param {reserved_pool_tickerUpdateArgs} args - Arguments to update one Reserved_pool_ticker.
     * @example
     * // Update one Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reserved_pool_tickerUpdateArgs>(args: SelectSubset<T, reserved_pool_tickerUpdateArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reserved_pool_tickers.
     * @param {reserved_pool_tickerDeleteManyArgs} args - Arguments to filter Reserved_pool_tickers to delete.
     * @example
     * // Delete a few Reserved_pool_tickers
     * const { count } = await prisma.reserved_pool_ticker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reserved_pool_tickerDeleteManyArgs>(args?: SelectSubset<T, reserved_pool_tickerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reserved_pool_tickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reserved_pool_tickers
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reserved_pool_tickerUpdateManyArgs>(args: SelectSubset<T, reserved_pool_tickerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reserved_pool_tickers and returns the data updated in the database.
     * @param {reserved_pool_tickerUpdateManyAndReturnArgs} args - Arguments to update many Reserved_pool_tickers.
     * @example
     * // Update many Reserved_pool_tickers
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reserved_pool_tickers and only return the `id`
     * const reserved_pool_tickerWithIdOnly = await prisma.reserved_pool_ticker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reserved_pool_tickerUpdateManyAndReturnArgs>(args: SelectSubset<T, reserved_pool_tickerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reserved_pool_ticker.
     * @param {reserved_pool_tickerUpsertArgs} args - Arguments to update or create a Reserved_pool_ticker.
     * @example
     * // Update or create a Reserved_pool_ticker
     * const reserved_pool_ticker = await prisma.reserved_pool_ticker.upsert({
     *   create: {
     *     // ... data to create a Reserved_pool_ticker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserved_pool_ticker we want to update
     *   }
     * })
     */
    upsert<T extends reserved_pool_tickerUpsertArgs>(args: SelectSubset<T, reserved_pool_tickerUpsertArgs<ExtArgs>>): Prisma__reserved_pool_tickerClient<$Result.GetResult<Prisma.$reserved_pool_tickerPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reserved_pool_tickers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerCountArgs} args - Arguments to filter Reserved_pool_tickers to count.
     * @example
     * // Count the number of Reserved_pool_tickers
     * const count = await prisma.reserved_pool_ticker.count({
     *   where: {
     *     // ... the filter for the Reserved_pool_tickers we want to count
     *   }
     * })
    **/
    count<T extends reserved_pool_tickerCountArgs>(
      args?: Subset<T, reserved_pool_tickerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reserved_pool_tickerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserved_pool_ticker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reserved_pool_tickerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reserved_pool_tickerAggregateArgs>(args: Subset<T, Reserved_pool_tickerAggregateArgs>): Prisma.PrismaPromise<GetReserved_pool_tickerAggregateType<T>>

    /**
     * Group by Reserved_pool_ticker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reserved_pool_tickerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reserved_pool_tickerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reserved_pool_tickerGroupByArgs['orderBy'] }
        : { orderBy?: reserved_pool_tickerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reserved_pool_tickerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReserved_pool_tickerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reserved_pool_ticker model
   */
  readonly fields: reserved_pool_tickerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reserved_pool_ticker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reserved_pool_tickerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reserved_pool_ticker model
   */ 
  interface reserved_pool_tickerFieldRefs {
    readonly id: FieldRef<"reserved_pool_ticker", 'BigInt'>
    readonly name: FieldRef<"reserved_pool_ticker", 'String'>
    readonly pool_hash: FieldRef<"reserved_pool_ticker", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * reserved_pool_ticker findUnique
   */
  export type reserved_pool_tickerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter, which reserved_pool_ticker to fetch.
     */
    where: reserved_pool_tickerWhereUniqueInput
  }

  /**
   * reserved_pool_ticker findUniqueOrThrow
   */
  export type reserved_pool_tickerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter, which reserved_pool_ticker to fetch.
     */
    where: reserved_pool_tickerWhereUniqueInput
  }

  /**
   * reserved_pool_ticker findFirst
   */
  export type reserved_pool_tickerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter, which reserved_pool_ticker to fetch.
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserved_pool_tickers to fetch.
     */
    orderBy?: reserved_pool_tickerOrderByWithRelationInput | reserved_pool_tickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reserved_pool_tickers.
     */
    cursor?: reserved_pool_tickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserved_pool_tickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserved_pool_tickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reserved_pool_tickers.
     */
    distinct?: Reserved_pool_tickerScalarFieldEnum | Reserved_pool_tickerScalarFieldEnum[]
  }

  /**
   * reserved_pool_ticker findFirstOrThrow
   */
  export type reserved_pool_tickerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter, which reserved_pool_ticker to fetch.
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserved_pool_tickers to fetch.
     */
    orderBy?: reserved_pool_tickerOrderByWithRelationInput | reserved_pool_tickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reserved_pool_tickers.
     */
    cursor?: reserved_pool_tickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserved_pool_tickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserved_pool_tickers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reserved_pool_tickers.
     */
    distinct?: Reserved_pool_tickerScalarFieldEnum | Reserved_pool_tickerScalarFieldEnum[]
  }

  /**
   * reserved_pool_ticker findMany
   */
  export type reserved_pool_tickerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter, which reserved_pool_tickers to fetch.
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reserved_pool_tickers to fetch.
     */
    orderBy?: reserved_pool_tickerOrderByWithRelationInput | reserved_pool_tickerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reserved_pool_tickers.
     */
    cursor?: reserved_pool_tickerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reserved_pool_tickers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reserved_pool_tickers.
     */
    skip?: number
    distinct?: Reserved_pool_tickerScalarFieldEnum | Reserved_pool_tickerScalarFieldEnum[]
  }

  /**
   * reserved_pool_ticker create
   */
  export type reserved_pool_tickerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * The data needed to create a reserved_pool_ticker.
     */
    data: XOR<reserved_pool_tickerCreateInput, reserved_pool_tickerUncheckedCreateInput>
  }

  /**
   * reserved_pool_ticker createMany
   */
  export type reserved_pool_tickerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reserved_pool_tickers.
     */
    data: reserved_pool_tickerCreateManyInput | reserved_pool_tickerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reserved_pool_ticker createManyAndReturn
   */
  export type reserved_pool_tickerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * The data used to create many reserved_pool_tickers.
     */
    data: reserved_pool_tickerCreateManyInput | reserved_pool_tickerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reserved_pool_ticker update
   */
  export type reserved_pool_tickerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * The data needed to update a reserved_pool_ticker.
     */
    data: XOR<reserved_pool_tickerUpdateInput, reserved_pool_tickerUncheckedUpdateInput>
    /**
     * Choose, which reserved_pool_ticker to update.
     */
    where: reserved_pool_tickerWhereUniqueInput
  }

  /**
   * reserved_pool_ticker updateMany
   */
  export type reserved_pool_tickerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reserved_pool_tickers.
     */
    data: XOR<reserved_pool_tickerUpdateManyMutationInput, reserved_pool_tickerUncheckedUpdateManyInput>
    /**
     * Filter which reserved_pool_tickers to update
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * Limit how many reserved_pool_tickers to update.
     */
    limit?: number
  }

  /**
   * reserved_pool_ticker updateManyAndReturn
   */
  export type reserved_pool_tickerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * The data used to update reserved_pool_tickers.
     */
    data: XOR<reserved_pool_tickerUpdateManyMutationInput, reserved_pool_tickerUncheckedUpdateManyInput>
    /**
     * Filter which reserved_pool_tickers to update
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * Limit how many reserved_pool_tickers to update.
     */
    limit?: number
  }

  /**
   * reserved_pool_ticker upsert
   */
  export type reserved_pool_tickerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * The filter to search for the reserved_pool_ticker to update in case it exists.
     */
    where: reserved_pool_tickerWhereUniqueInput
    /**
     * In case the reserved_pool_ticker found by the `where` argument doesn't exist, create a new reserved_pool_ticker with this data.
     */
    create: XOR<reserved_pool_tickerCreateInput, reserved_pool_tickerUncheckedCreateInput>
    /**
     * In case the reserved_pool_ticker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reserved_pool_tickerUpdateInput, reserved_pool_tickerUncheckedUpdateInput>
  }

  /**
   * reserved_pool_ticker delete
   */
  export type reserved_pool_tickerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
    /**
     * Filter which reserved_pool_ticker to delete.
     */
    where: reserved_pool_tickerWhereUniqueInput
  }

  /**
   * reserved_pool_ticker deleteMany
   */
  export type reserved_pool_tickerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reserved_pool_tickers to delete
     */
    where?: reserved_pool_tickerWhereInput
    /**
     * Limit how many reserved_pool_tickers to delete.
     */
    limit?: number
  }

  /**
   * reserved_pool_ticker without action
   */
  export type reserved_pool_tickerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reserved_pool_ticker
     */
    select?: reserved_pool_tickerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reserved_pool_ticker
     */
    omit?: reserved_pool_tickerOmit<ExtArgs> | null
  }


  /**
   * Model reverse_index
   */

  export type AggregateReverse_index = {
    _count: Reverse_indexCountAggregateOutputType | null
    _avg: Reverse_indexAvgAggregateOutputType | null
    _sum: Reverse_indexSumAggregateOutputType | null
    _min: Reverse_indexMinAggregateOutputType | null
    _max: Reverse_indexMaxAggregateOutputType | null
  }

  export type Reverse_indexAvgAggregateOutputType = {
    id: number | null
    block_id: number | null
  }

  export type Reverse_indexSumAggregateOutputType = {
    id: bigint | null
    block_id: bigint | null
  }

  export type Reverse_indexMinAggregateOutputType = {
    id: bigint | null
    block_id: bigint | null
    min_ids: string | null
  }

  export type Reverse_indexMaxAggregateOutputType = {
    id: bigint | null
    block_id: bigint | null
    min_ids: string | null
  }

  export type Reverse_indexCountAggregateOutputType = {
    id: number
    block_id: number
    min_ids: number
    _all: number
  }


  export type Reverse_indexAvgAggregateInputType = {
    id?: true
    block_id?: true
  }

  export type Reverse_indexSumAggregateInputType = {
    id?: true
    block_id?: true
  }

  export type Reverse_indexMinAggregateInputType = {
    id?: true
    block_id?: true
    min_ids?: true
  }

  export type Reverse_indexMaxAggregateInputType = {
    id?: true
    block_id?: true
    min_ids?: true
  }

  export type Reverse_indexCountAggregateInputType = {
    id?: true
    block_id?: true
    min_ids?: true
    _all?: true
  }

  export type Reverse_indexAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reverse_index to aggregate.
     */
    where?: reverse_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reverse_indices to fetch.
     */
    orderBy?: reverse_indexOrderByWithRelationInput | reverse_indexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reverse_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reverse_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reverse_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reverse_indices
    **/
    _count?: true | Reverse_indexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reverse_indexAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reverse_indexSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reverse_indexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reverse_indexMaxAggregateInputType
  }

  export type GetReverse_indexAggregateType<T extends Reverse_indexAggregateArgs> = {
        [P in keyof T & keyof AggregateReverse_index]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReverse_index[P]>
      : GetScalarType<T[P], AggregateReverse_index[P]>
  }




  export type reverse_indexGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reverse_indexWhereInput
    orderBy?: reverse_indexOrderByWithAggregationInput | reverse_indexOrderByWithAggregationInput[]
    by: Reverse_indexScalarFieldEnum[] | Reverse_indexScalarFieldEnum
    having?: reverse_indexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reverse_indexCountAggregateInputType | true
    _avg?: Reverse_indexAvgAggregateInputType
    _sum?: Reverse_indexSumAggregateInputType
    _min?: Reverse_indexMinAggregateInputType
    _max?: Reverse_indexMaxAggregateInputType
  }

  export type Reverse_indexGroupByOutputType = {
    id: bigint
    block_id: bigint
    min_ids: string
    _count: Reverse_indexCountAggregateOutputType | null
    _avg: Reverse_indexAvgAggregateOutputType | null
    _sum: Reverse_indexSumAggregateOutputType | null
    _min: Reverse_indexMinAggregateOutputType | null
    _max: Reverse_indexMaxAggregateOutputType | null
  }

  type GetReverse_indexGroupByPayload<T extends reverse_indexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reverse_indexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reverse_indexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reverse_indexGroupByOutputType[P]>
            : GetScalarType<T[P], Reverse_indexGroupByOutputType[P]>
        }
      >
    >


  export type reverse_indexSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_id?: boolean
    min_ids?: boolean
  }, ExtArgs["result"]["reverse_index"]>

  export type reverse_indexSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_id?: boolean
    min_ids?: boolean
  }, ExtArgs["result"]["reverse_index"]>

  export type reverse_indexSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    block_id?: boolean
    min_ids?: boolean
  }, ExtArgs["result"]["reverse_index"]>

  export type reverse_indexSelectScalar = {
    id?: boolean
    block_id?: boolean
    min_ids?: boolean
  }

  export type reverse_indexOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "block_id" | "min_ids", ExtArgs["result"]["reverse_index"]>

  export type $reverse_indexPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reverse_index"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      block_id: bigint
      min_ids: string
    }, ExtArgs["result"]["reverse_index"]>
    composites: {}
  }

  type reverse_indexGetPayload<S extends boolean | null | undefined | reverse_indexDefaultArgs> = $Result.GetResult<Prisma.$reverse_indexPayload, S>

  type reverse_indexCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reverse_indexFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reverse_indexCountAggregateInputType | true
    }

  export interface reverse_indexDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reverse_index'], meta: { name: 'reverse_index' } }
    /**
     * Find zero or one Reverse_index that matches the filter.
     * @param {reverse_indexFindUniqueArgs} args - Arguments to find a Reverse_index
     * @example
     * // Get one Reverse_index
     * const reverse_index = await prisma.reverse_index.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reverse_indexFindUniqueArgs>(args: SelectSubset<T, reverse_indexFindUniqueArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reverse_index that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reverse_indexFindUniqueOrThrowArgs} args - Arguments to find a Reverse_index
     * @example
     * // Get one Reverse_index
     * const reverse_index = await prisma.reverse_index.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reverse_indexFindUniqueOrThrowArgs>(args: SelectSubset<T, reverse_indexFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reverse_index that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexFindFirstArgs} args - Arguments to find a Reverse_index
     * @example
     * // Get one Reverse_index
     * const reverse_index = await prisma.reverse_index.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reverse_indexFindFirstArgs>(args?: SelectSubset<T, reverse_indexFindFirstArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reverse_index that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexFindFirstOrThrowArgs} args - Arguments to find a Reverse_index
     * @example
     * // Get one Reverse_index
     * const reverse_index = await prisma.reverse_index.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reverse_indexFindFirstOrThrowArgs>(args?: SelectSubset<T, reverse_indexFindFirstOrThrowArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reverse_indices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reverse_indices
     * const reverse_indices = await prisma.reverse_index.findMany()
     * 
     * // Get first 10 Reverse_indices
     * const reverse_indices = await prisma.reverse_index.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reverse_indexWithIdOnly = await prisma.reverse_index.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reverse_indexFindManyArgs>(args?: SelectSubset<T, reverse_indexFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reverse_index.
     * @param {reverse_indexCreateArgs} args - Arguments to create a Reverse_index.
     * @example
     * // Create one Reverse_index
     * const Reverse_index = await prisma.reverse_index.create({
     *   data: {
     *     // ... data to create a Reverse_index
     *   }
     * })
     * 
     */
    create<T extends reverse_indexCreateArgs>(args: SelectSubset<T, reverse_indexCreateArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reverse_indices.
     * @param {reverse_indexCreateManyArgs} args - Arguments to create many Reverse_indices.
     * @example
     * // Create many Reverse_indices
     * const reverse_index = await prisma.reverse_index.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reverse_indexCreateManyArgs>(args?: SelectSubset<T, reverse_indexCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reverse_indices and returns the data saved in the database.
     * @param {reverse_indexCreateManyAndReturnArgs} args - Arguments to create many Reverse_indices.
     * @example
     * // Create many Reverse_indices
     * const reverse_index = await prisma.reverse_index.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reverse_indices and only return the `id`
     * const reverse_indexWithIdOnly = await prisma.reverse_index.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reverse_indexCreateManyAndReturnArgs>(args?: SelectSubset<T, reverse_indexCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reverse_index.
     * @param {reverse_indexDeleteArgs} args - Arguments to delete one Reverse_index.
     * @example
     * // Delete one Reverse_index
     * const Reverse_index = await prisma.reverse_index.delete({
     *   where: {
     *     // ... filter to delete one Reverse_index
     *   }
     * })
     * 
     */
    delete<T extends reverse_indexDeleteArgs>(args: SelectSubset<T, reverse_indexDeleteArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reverse_index.
     * @param {reverse_indexUpdateArgs} args - Arguments to update one Reverse_index.
     * @example
     * // Update one Reverse_index
     * const reverse_index = await prisma.reverse_index.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reverse_indexUpdateArgs>(args: SelectSubset<T, reverse_indexUpdateArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reverse_indices.
     * @param {reverse_indexDeleteManyArgs} args - Arguments to filter Reverse_indices to delete.
     * @example
     * // Delete a few Reverse_indices
     * const { count } = await prisma.reverse_index.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reverse_indexDeleteManyArgs>(args?: SelectSubset<T, reverse_indexDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reverse_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reverse_indices
     * const reverse_index = await prisma.reverse_index.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reverse_indexUpdateManyArgs>(args: SelectSubset<T, reverse_indexUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reverse_indices and returns the data updated in the database.
     * @param {reverse_indexUpdateManyAndReturnArgs} args - Arguments to update many Reverse_indices.
     * @example
     * // Update many Reverse_indices
     * const reverse_index = await prisma.reverse_index.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reverse_indices and only return the `id`
     * const reverse_indexWithIdOnly = await prisma.reverse_index.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reverse_indexUpdateManyAndReturnArgs>(args: SelectSubset<T, reverse_indexUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reverse_index.
     * @param {reverse_indexUpsertArgs} args - Arguments to update or create a Reverse_index.
     * @example
     * // Update or create a Reverse_index
     * const reverse_index = await prisma.reverse_index.upsert({
     *   create: {
     *     // ... data to create a Reverse_index
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reverse_index we want to update
     *   }
     * })
     */
    upsert<T extends reverse_indexUpsertArgs>(args: SelectSubset<T, reverse_indexUpsertArgs<ExtArgs>>): Prisma__reverse_indexClient<$Result.GetResult<Prisma.$reverse_indexPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reverse_indices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexCountArgs} args - Arguments to filter Reverse_indices to count.
     * @example
     * // Count the number of Reverse_indices
     * const count = await prisma.reverse_index.count({
     *   where: {
     *     // ... the filter for the Reverse_indices we want to count
     *   }
     * })
    **/
    count<T extends reverse_indexCountArgs>(
      args?: Subset<T, reverse_indexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reverse_indexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reverse_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reverse_indexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reverse_indexAggregateArgs>(args: Subset<T, Reverse_indexAggregateArgs>): Prisma.PrismaPromise<GetReverse_indexAggregateType<T>>

    /**
     * Group by Reverse_index.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reverse_indexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reverse_indexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reverse_indexGroupByArgs['orderBy'] }
        : { orderBy?: reverse_indexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reverse_indexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReverse_indexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reverse_index model
   */
  readonly fields: reverse_indexFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reverse_index.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reverse_indexClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reverse_index model
   */ 
  interface reverse_indexFieldRefs {
    readonly id: FieldRef<"reverse_index", 'BigInt'>
    readonly block_id: FieldRef<"reverse_index", 'BigInt'>
    readonly min_ids: FieldRef<"reverse_index", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reverse_index findUnique
   */
  export type reverse_indexFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter, which reverse_index to fetch.
     */
    where: reverse_indexWhereUniqueInput
  }

  /**
   * reverse_index findUniqueOrThrow
   */
  export type reverse_indexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter, which reverse_index to fetch.
     */
    where: reverse_indexWhereUniqueInput
  }

  /**
   * reverse_index findFirst
   */
  export type reverse_indexFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter, which reverse_index to fetch.
     */
    where?: reverse_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reverse_indices to fetch.
     */
    orderBy?: reverse_indexOrderByWithRelationInput | reverse_indexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reverse_indices.
     */
    cursor?: reverse_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reverse_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reverse_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reverse_indices.
     */
    distinct?: Reverse_indexScalarFieldEnum | Reverse_indexScalarFieldEnum[]
  }

  /**
   * reverse_index findFirstOrThrow
   */
  export type reverse_indexFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter, which reverse_index to fetch.
     */
    where?: reverse_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reverse_indices to fetch.
     */
    orderBy?: reverse_indexOrderByWithRelationInput | reverse_indexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reverse_indices.
     */
    cursor?: reverse_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reverse_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reverse_indices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reverse_indices.
     */
    distinct?: Reverse_indexScalarFieldEnum | Reverse_indexScalarFieldEnum[]
  }

  /**
   * reverse_index findMany
   */
  export type reverse_indexFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter, which reverse_indices to fetch.
     */
    where?: reverse_indexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reverse_indices to fetch.
     */
    orderBy?: reverse_indexOrderByWithRelationInput | reverse_indexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reverse_indices.
     */
    cursor?: reverse_indexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reverse_indices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reverse_indices.
     */
    skip?: number
    distinct?: Reverse_indexScalarFieldEnum | Reverse_indexScalarFieldEnum[]
  }

  /**
   * reverse_index create
   */
  export type reverse_indexCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * The data needed to create a reverse_index.
     */
    data: XOR<reverse_indexCreateInput, reverse_indexUncheckedCreateInput>
  }

  /**
   * reverse_index createMany
   */
  export type reverse_indexCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reverse_indices.
     */
    data: reverse_indexCreateManyInput | reverse_indexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reverse_index createManyAndReturn
   */
  export type reverse_indexCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * The data used to create many reverse_indices.
     */
    data: reverse_indexCreateManyInput | reverse_indexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reverse_index update
   */
  export type reverse_indexUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * The data needed to update a reverse_index.
     */
    data: XOR<reverse_indexUpdateInput, reverse_indexUncheckedUpdateInput>
    /**
     * Choose, which reverse_index to update.
     */
    where: reverse_indexWhereUniqueInput
  }

  /**
   * reverse_index updateMany
   */
  export type reverse_indexUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reverse_indices.
     */
    data: XOR<reverse_indexUpdateManyMutationInput, reverse_indexUncheckedUpdateManyInput>
    /**
     * Filter which reverse_indices to update
     */
    where?: reverse_indexWhereInput
    /**
     * Limit how many reverse_indices to update.
     */
    limit?: number
  }

  /**
   * reverse_index updateManyAndReturn
   */
  export type reverse_indexUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * The data used to update reverse_indices.
     */
    data: XOR<reverse_indexUpdateManyMutationInput, reverse_indexUncheckedUpdateManyInput>
    /**
     * Filter which reverse_indices to update
     */
    where?: reverse_indexWhereInput
    /**
     * Limit how many reverse_indices to update.
     */
    limit?: number
  }

  /**
   * reverse_index upsert
   */
  export type reverse_indexUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * The filter to search for the reverse_index to update in case it exists.
     */
    where: reverse_indexWhereUniqueInput
    /**
     * In case the reverse_index found by the `where` argument doesn't exist, create a new reverse_index with this data.
     */
    create: XOR<reverse_indexCreateInput, reverse_indexUncheckedCreateInput>
    /**
     * In case the reverse_index was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reverse_indexUpdateInput, reverse_indexUncheckedUpdateInput>
  }

  /**
   * reverse_index delete
   */
  export type reverse_indexDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
    /**
     * Filter which reverse_index to delete.
     */
    where: reverse_indexWhereUniqueInput
  }

  /**
   * reverse_index deleteMany
   */
  export type reverse_indexDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reverse_indices to delete
     */
    where?: reverse_indexWhereInput
    /**
     * Limit how many reverse_indices to delete.
     */
    limit?: number
  }

  /**
   * reverse_index without action
   */
  export type reverse_indexDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reverse_index
     */
    select?: reverse_indexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reverse_index
     */
    omit?: reverse_indexOmit<ExtArgs> | null
  }


  /**
   * Model reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    addr_id: number | null
    amount: Decimal | null
    spendable_epoch: number | null
    pool_id: number | null
    earned_epoch: number | null
  }

  export type RewardSumAggregateOutputType = {
    addr_id: bigint | null
    amount: Decimal | null
    spendable_epoch: bigint | null
    pool_id: bigint | null
    earned_epoch: bigint | null
  }

  export type RewardMinAggregateOutputType = {
    addr_id: bigint | null
    type: $Enums.rewardtype | null
    amount: Decimal | null
    spendable_epoch: bigint | null
    pool_id: bigint | null
    earned_epoch: bigint | null
  }

  export type RewardMaxAggregateOutputType = {
    addr_id: bigint | null
    type: $Enums.rewardtype | null
    amount: Decimal | null
    spendable_epoch: bigint | null
    pool_id: bigint | null
    earned_epoch: bigint | null
  }

  export type RewardCountAggregateOutputType = {
    addr_id: number
    type: number
    amount: number
    spendable_epoch: number
    pool_id: number
    earned_epoch: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    addr_id?: true
    amount?: true
    spendable_epoch?: true
    pool_id?: true
    earned_epoch?: true
  }

  export type RewardSumAggregateInputType = {
    addr_id?: true
    amount?: true
    spendable_epoch?: true
    pool_id?: true
    earned_epoch?: true
  }

  export type RewardMinAggregateInputType = {
    addr_id?: true
    type?: true
    amount?: true
    spendable_epoch?: true
    pool_id?: true
    earned_epoch?: true
  }

  export type RewardMaxAggregateInputType = {
    addr_id?: true
    type?: true
    amount?: true
    spendable_epoch?: true
    pool_id?: true
    earned_epoch?: true
  }

  export type RewardCountAggregateInputType = {
    addr_id?: true
    type?: true
    amount?: true
    spendable_epoch?: true
    pool_id?: true
    earned_epoch?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward to aggregate.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type rewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardWhereInput
    orderBy?: rewardOrderByWithAggregationInput | rewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: rewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    addr_id: bigint
    type: $Enums.rewardtype
    amount: Decimal
    spendable_epoch: bigint
    pool_id: bigint
    earned_epoch: bigint
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends rewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type rewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addr_id?: boolean
    type?: boolean
    amount?: boolean
    spendable_epoch?: boolean
    pool_id?: boolean
    earned_epoch?: boolean
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addr_id?: boolean
    type?: boolean
    amount?: boolean
    spendable_epoch?: boolean
    pool_id?: boolean
    earned_epoch?: boolean
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    addr_id?: boolean
    type?: boolean
    amount?: boolean
    spendable_epoch?: boolean
    pool_id?: boolean
    earned_epoch?: boolean
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectScalar = {
    addr_id?: boolean
    type?: boolean
    amount?: boolean
    spendable_epoch?: boolean
    pool_id?: boolean
    earned_epoch?: boolean
  }

  export type rewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"addr_id" | "type" | "amount" | "spendable_epoch" | "pool_id" | "earned_epoch", ExtArgs["result"]["reward"]>

  export type $rewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reward"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      addr_id: bigint
      type: $Enums.rewardtype
      amount: Prisma.Decimal
      spendable_epoch: bigint
      pool_id: bigint
      earned_epoch: bigint
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type rewardGetPayload<S extends boolean | null | undefined | rewardDefaultArgs> = $Result.GetResult<Prisma.$rewardPayload, S>

  type rewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface rewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reward'], meta: { name: 'reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {rewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rewardFindUniqueArgs>(args: SelectSubset<T, rewardFindUniqueArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rewardFindUniqueOrThrowArgs>(args: SelectSubset<T, rewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rewardFindFirstArgs>(args?: SelectSubset<T, rewardFindFirstArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rewardFindFirstOrThrowArgs>(args?: SelectSubset<T, rewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `addr_id`
     * const rewardWithAddr_idOnly = await prisma.reward.findMany({ select: { addr_id: true } })
     * 
     */
    findMany<T extends rewardFindManyArgs>(args?: SelectSubset<T, rewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reward.
     * @param {rewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends rewardCreateArgs>(args: SelectSubset<T, rewardCreateArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rewards.
     * @param {rewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rewardCreateManyArgs>(args?: SelectSubset<T, rewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {rewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `addr_id`
     * const rewardWithAddr_idOnly = await prisma.reward.createManyAndReturn({
     *   select: { addr_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rewardCreateManyAndReturnArgs>(args?: SelectSubset<T, rewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reward.
     * @param {rewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends rewardDeleteArgs>(args: SelectSubset<T, rewardDeleteArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reward.
     * @param {rewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rewardUpdateArgs>(args: SelectSubset<T, rewardUpdateArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rewards.
     * @param {rewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rewardDeleteManyArgs>(args?: SelectSubset<T, rewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rewardUpdateManyArgs>(args: SelectSubset<T, rewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {rewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rewards and only return the `addr_id`
     * const rewardWithAddr_idOnly = await prisma.reward.updateManyAndReturn({
     *   select: { addr_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rewardUpdateManyAndReturnArgs>(args: SelectSubset<T, rewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reward.
     * @param {rewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends rewardUpsertArgs>(args: SelectSubset<T, rewardUpsertArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends rewardCountArgs>(
      args?: Subset<T, rewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rewardGroupByArgs['orderBy'] }
        : { orderBy?: rewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reward model
   */
  readonly fields: rewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reward model
   */ 
  interface rewardFieldRefs {
    readonly addr_id: FieldRef<"reward", 'BigInt'>
    readonly type: FieldRef<"reward", 'rewardtype'>
    readonly amount: FieldRef<"reward", 'Decimal'>
    readonly spendable_epoch: FieldRef<"reward", 'BigInt'>
    readonly pool_id: FieldRef<"reward", 'BigInt'>
    readonly earned_epoch: FieldRef<"reward", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * reward findUnique
   */
  export type rewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward findUniqueOrThrow
   */
  export type rewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward findFirst
   */
  export type rewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward findFirstOrThrow
   */
  export type rewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward findMany
   */
  export type rewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward create
   */
  export type rewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data needed to create a reward.
     */
    data: XOR<rewardCreateInput, rewardUncheckedCreateInput>
  }

  /**
   * reward createMany
   */
  export type rewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rewards.
     */
    data: rewardCreateManyInput | rewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reward createManyAndReturn
   */
  export type rewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data used to create many rewards.
     */
    data: rewardCreateManyInput | rewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reward update
   */
  export type rewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data needed to update a reward.
     */
    data: XOR<rewardUpdateInput, rewardUncheckedUpdateInput>
    /**
     * Choose, which reward to update.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward updateMany
   */
  export type rewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardUpdateManyMutationInput, rewardUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to update.
     */
    limit?: number
  }

  /**
   * reward updateManyAndReturn
   */
  export type rewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardUpdateManyMutationInput, rewardUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to update.
     */
    limit?: number
  }

  /**
   * reward upsert
   */
  export type rewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The filter to search for the reward to update in case it exists.
     */
    where: rewardWhereUniqueInput
    /**
     * In case the reward found by the `where` argument doesn't exist, create a new reward with this data.
     */
    create: XOR<rewardCreateInput, rewardUncheckedCreateInput>
    /**
     * In case the reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rewardUpdateInput, rewardUncheckedUpdateInput>
  }

  /**
   * reward delete
   */
  export type rewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Filter which reward to delete.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward deleteMany
   */
  export type rewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to delete
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to delete.
     */
    limit?: number
  }

  /**
   * reward without action
   */
  export type rewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
  }


  /**
   * Model schema_version
   */

  export type AggregateSchema_version = {
    _count: Schema_versionCountAggregateOutputType | null
    _avg: Schema_versionAvgAggregateOutputType | null
    _sum: Schema_versionSumAggregateOutputType | null
    _min: Schema_versionMinAggregateOutputType | null
    _max: Schema_versionMaxAggregateOutputType | null
  }

  export type Schema_versionAvgAggregateOutputType = {
    id: number | null
    stage_one: number | null
    stage_two: number | null
    stage_three: number | null
  }

  export type Schema_versionSumAggregateOutputType = {
    id: bigint | null
    stage_one: bigint | null
    stage_two: bigint | null
    stage_three: bigint | null
  }

  export type Schema_versionMinAggregateOutputType = {
    id: bigint | null
    stage_one: bigint | null
    stage_two: bigint | null
    stage_three: bigint | null
  }

  export type Schema_versionMaxAggregateOutputType = {
    id: bigint | null
    stage_one: bigint | null
    stage_two: bigint | null
    stage_three: bigint | null
  }

  export type Schema_versionCountAggregateOutputType = {
    id: number
    stage_one: number
    stage_two: number
    stage_three: number
    _all: number
  }


  export type Schema_versionAvgAggregateInputType = {
    id?: true
    stage_one?: true
    stage_two?: true
    stage_three?: true
  }

  export type Schema_versionSumAggregateInputType = {
    id?: true
    stage_one?: true
    stage_two?: true
    stage_three?: true
  }

  export type Schema_versionMinAggregateInputType = {
    id?: true
    stage_one?: true
    stage_two?: true
    stage_three?: true
  }

  export type Schema_versionMaxAggregateInputType = {
    id?: true
    stage_one?: true
    stage_two?: true
    stage_three?: true
  }

  export type Schema_versionCountAggregateInputType = {
    id?: true
    stage_one?: true
    stage_two?: true
    stage_three?: true
    _all?: true
  }

  export type Schema_versionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_version to aggregate.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schema_versions
    **/
    _count?: true | Schema_versionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Schema_versionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Schema_versionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Schema_versionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Schema_versionMaxAggregateInputType
  }

  export type GetSchema_versionAggregateType<T extends Schema_versionAggregateArgs> = {
        [P in keyof T & keyof AggregateSchema_version]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchema_version[P]>
      : GetScalarType<T[P], AggregateSchema_version[P]>
  }




  export type schema_versionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schema_versionWhereInput
    orderBy?: schema_versionOrderByWithAggregationInput | schema_versionOrderByWithAggregationInput[]
    by: Schema_versionScalarFieldEnum[] | Schema_versionScalarFieldEnum
    having?: schema_versionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Schema_versionCountAggregateInputType | true
    _avg?: Schema_versionAvgAggregateInputType
    _sum?: Schema_versionSumAggregateInputType
    _min?: Schema_versionMinAggregateInputType
    _max?: Schema_versionMaxAggregateInputType
  }

  export type Schema_versionGroupByOutputType = {
    id: bigint
    stage_one: bigint
    stage_two: bigint
    stage_three: bigint
    _count: Schema_versionCountAggregateOutputType | null
    _avg: Schema_versionAvgAggregateOutputType | null
    _sum: Schema_versionSumAggregateOutputType | null
    _min: Schema_versionMinAggregateOutputType | null
    _max: Schema_versionMaxAggregateOutputType | null
  }

  type GetSchema_versionGroupByPayload<T extends schema_versionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Schema_versionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Schema_versionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Schema_versionGroupByOutputType[P]>
            : GetScalarType<T[P], Schema_versionGroupByOutputType[P]>
        }
      >
    >


  export type schema_versionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stage_one?: boolean
    stage_two?: boolean
    stage_three?: boolean
  }, ExtArgs["result"]["schema_version"]>

  export type schema_versionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stage_one?: boolean
    stage_two?: boolean
    stage_three?: boolean
  }, ExtArgs["result"]["schema_version"]>

  export type schema_versionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stage_one?: boolean
    stage_two?: boolean
    stage_three?: boolean
  }, ExtArgs["result"]["schema_version"]>

  export type schema_versionSelectScalar = {
    id?: boolean
    stage_one?: boolean
    stage_two?: boolean
    stage_three?: boolean
  }

  export type schema_versionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stage_one" | "stage_two" | "stage_three", ExtArgs["result"]["schema_version"]>

  export type $schema_versionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schema_version"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      stage_one: bigint
      stage_two: bigint
      stage_three: bigint
    }, ExtArgs["result"]["schema_version"]>
    composites: {}
  }

  type schema_versionGetPayload<S extends boolean | null | undefined | schema_versionDefaultArgs> = $Result.GetResult<Prisma.$schema_versionPayload, S>

  type schema_versionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<schema_versionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Schema_versionCountAggregateInputType | true
    }

  export interface schema_versionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schema_version'], meta: { name: 'schema_version' } }
    /**
     * Find zero or one Schema_version that matches the filter.
     * @param {schema_versionFindUniqueArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schema_versionFindUniqueArgs>(args: SelectSubset<T, schema_versionFindUniqueArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Schema_version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {schema_versionFindUniqueOrThrowArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schema_versionFindUniqueOrThrowArgs>(args: SelectSubset<T, schema_versionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Schema_version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindFirstArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schema_versionFindFirstArgs>(args?: SelectSubset<T, schema_versionFindFirstArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Schema_version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindFirstOrThrowArgs} args - Arguments to find a Schema_version
     * @example
     * // Get one Schema_version
     * const schema_version = await prisma.schema_version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schema_versionFindFirstOrThrowArgs>(args?: SelectSubset<T, schema_versionFindFirstOrThrowArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Schema_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schema_versions
     * const schema_versions = await prisma.schema_version.findMany()
     * 
     * // Get first 10 Schema_versions
     * const schema_versions = await prisma.schema_version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schema_versionWithIdOnly = await prisma.schema_version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends schema_versionFindManyArgs>(args?: SelectSubset<T, schema_versionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Schema_version.
     * @param {schema_versionCreateArgs} args - Arguments to create a Schema_version.
     * @example
     * // Create one Schema_version
     * const Schema_version = await prisma.schema_version.create({
     *   data: {
     *     // ... data to create a Schema_version
     *   }
     * })
     * 
     */
    create<T extends schema_versionCreateArgs>(args: SelectSubset<T, schema_versionCreateArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Schema_versions.
     * @param {schema_versionCreateManyArgs} args - Arguments to create many Schema_versions.
     * @example
     * // Create many Schema_versions
     * const schema_version = await prisma.schema_version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schema_versionCreateManyArgs>(args?: SelectSubset<T, schema_versionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schema_versions and returns the data saved in the database.
     * @param {schema_versionCreateManyAndReturnArgs} args - Arguments to create many Schema_versions.
     * @example
     * // Create many Schema_versions
     * const schema_version = await prisma.schema_version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schema_versions and only return the `id`
     * const schema_versionWithIdOnly = await prisma.schema_version.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schema_versionCreateManyAndReturnArgs>(args?: SelectSubset<T, schema_versionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Schema_version.
     * @param {schema_versionDeleteArgs} args - Arguments to delete one Schema_version.
     * @example
     * // Delete one Schema_version
     * const Schema_version = await prisma.schema_version.delete({
     *   where: {
     *     // ... filter to delete one Schema_version
     *   }
     * })
     * 
     */
    delete<T extends schema_versionDeleteArgs>(args: SelectSubset<T, schema_versionDeleteArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Schema_version.
     * @param {schema_versionUpdateArgs} args - Arguments to update one Schema_version.
     * @example
     * // Update one Schema_version
     * const schema_version = await prisma.schema_version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schema_versionUpdateArgs>(args: SelectSubset<T, schema_versionUpdateArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Schema_versions.
     * @param {schema_versionDeleteManyArgs} args - Arguments to filter Schema_versions to delete.
     * @example
     * // Delete a few Schema_versions
     * const { count } = await prisma.schema_version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schema_versionDeleteManyArgs>(args?: SelectSubset<T, schema_versionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schema_versions
     * const schema_version = await prisma.schema_version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schema_versionUpdateManyArgs>(args: SelectSubset<T, schema_versionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_versions and returns the data updated in the database.
     * @param {schema_versionUpdateManyAndReturnArgs} args - Arguments to update many Schema_versions.
     * @example
     * // Update many Schema_versions
     * const schema_version = await prisma.schema_version.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schema_versions and only return the `id`
     * const schema_versionWithIdOnly = await prisma.schema_version.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends schema_versionUpdateManyAndReturnArgs>(args: SelectSubset<T, schema_versionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Schema_version.
     * @param {schema_versionUpsertArgs} args - Arguments to update or create a Schema_version.
     * @example
     * // Update or create a Schema_version
     * const schema_version = await prisma.schema_version.upsert({
     *   create: {
     *     // ... data to create a Schema_version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schema_version we want to update
     *   }
     * })
     */
    upsert<T extends schema_versionUpsertArgs>(args: SelectSubset<T, schema_versionUpsertArgs<ExtArgs>>): Prisma__schema_versionClient<$Result.GetResult<Prisma.$schema_versionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Schema_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionCountArgs} args - Arguments to filter Schema_versions to count.
     * @example
     * // Count the number of Schema_versions
     * const count = await prisma.schema_version.count({
     *   where: {
     *     // ... the filter for the Schema_versions we want to count
     *   }
     * })
    **/
    count<T extends schema_versionCountArgs>(
      args?: Subset<T, schema_versionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Schema_versionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schema_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Schema_versionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Schema_versionAggregateArgs>(args: Subset<T, Schema_versionAggregateArgs>): Prisma.PrismaPromise<GetSchema_versionAggregateType<T>>

    /**
     * Group by Schema_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_versionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schema_versionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schema_versionGroupByArgs['orderBy'] }
        : { orderBy?: schema_versionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schema_versionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchema_versionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schema_version model
   */
  readonly fields: schema_versionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schema_version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schema_versionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schema_version model
   */ 
  interface schema_versionFieldRefs {
    readonly id: FieldRef<"schema_version", 'BigInt'>
    readonly stage_one: FieldRef<"schema_version", 'BigInt'>
    readonly stage_two: FieldRef<"schema_version", 'BigInt'>
    readonly stage_three: FieldRef<"schema_version", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * schema_version findUnique
   */
  export type schema_versionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version findUniqueOrThrow
   */
  export type schema_versionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version findFirst
   */
  export type schema_versionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_versions.
     */
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version findFirstOrThrow
   */
  export type schema_versionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter, which schema_version to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_versions.
     */
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version findMany
   */
  export type schema_versionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter, which schema_versions to fetch.
     */
    where?: schema_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_versions to fetch.
     */
    orderBy?: schema_versionOrderByWithRelationInput | schema_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schema_versions.
     */
    cursor?: schema_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_versions.
     */
    skip?: number
    distinct?: Schema_versionScalarFieldEnum | Schema_versionScalarFieldEnum[]
  }

  /**
   * schema_version create
   */
  export type schema_versionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * The data needed to create a schema_version.
     */
    data: XOR<schema_versionCreateInput, schema_versionUncheckedCreateInput>
  }

  /**
   * schema_version createMany
   */
  export type schema_versionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schema_versions.
     */
    data: schema_versionCreateManyInput | schema_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_version createManyAndReturn
   */
  export type schema_versionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * The data used to create many schema_versions.
     */
    data: schema_versionCreateManyInput | schema_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_version update
   */
  export type schema_versionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * The data needed to update a schema_version.
     */
    data: XOR<schema_versionUpdateInput, schema_versionUncheckedUpdateInput>
    /**
     * Choose, which schema_version to update.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version updateMany
   */
  export type schema_versionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schema_versions.
     */
    data: XOR<schema_versionUpdateManyMutationInput, schema_versionUncheckedUpdateManyInput>
    /**
     * Filter which schema_versions to update
     */
    where?: schema_versionWhereInput
    /**
     * Limit how many schema_versions to update.
     */
    limit?: number
  }

  /**
   * schema_version updateManyAndReturn
   */
  export type schema_versionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * The data used to update schema_versions.
     */
    data: XOR<schema_versionUpdateManyMutationInput, schema_versionUncheckedUpdateManyInput>
    /**
     * Filter which schema_versions to update
     */
    where?: schema_versionWhereInput
    /**
     * Limit how many schema_versions to update.
     */
    limit?: number
  }

  /**
   * schema_version upsert
   */
  export type schema_versionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * The filter to search for the schema_version to update in case it exists.
     */
    where: schema_versionWhereUniqueInput
    /**
     * In case the schema_version found by the `where` argument doesn't exist, create a new schema_version with this data.
     */
    create: XOR<schema_versionCreateInput, schema_versionUncheckedCreateInput>
    /**
     * In case the schema_version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schema_versionUpdateInput, schema_versionUncheckedUpdateInput>
  }

  /**
   * schema_version delete
   */
  export type schema_versionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
    /**
     * Filter which schema_version to delete.
     */
    where: schema_versionWhereUniqueInput
  }

  /**
   * schema_version deleteMany
   */
  export type schema_versionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_versions to delete
     */
    where?: schema_versionWhereInput
    /**
     * Limit how many schema_versions to delete.
     */
    limit?: number
  }

  /**
   * schema_version without action
   */
  export type schema_versionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_version
     */
    select?: schema_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_version
     */
    omit?: schema_versionOmit<ExtArgs> | null
  }


  /**
   * Model script
   */

  export type AggregateScript = {
    _count: ScriptCountAggregateOutputType | null
    _avg: ScriptAvgAggregateOutputType | null
    _sum: ScriptSumAggregateOutputType | null
    _min: ScriptMinAggregateOutputType | null
    _max: ScriptMaxAggregateOutputType | null
  }

  export type ScriptAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    serialised_size: number | null
  }

  export type ScriptSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    serialised_size: number | null
  }

  export type ScriptMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    hash: Uint8Array | null
    type: $Enums.scripttype | null
    bytes: Uint8Array | null
    serialised_size: number | null
  }

  export type ScriptMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    hash: Uint8Array | null
    type: $Enums.scripttype | null
    bytes: Uint8Array | null
    serialised_size: number | null
  }

  export type ScriptCountAggregateOutputType = {
    id: number
    tx_id: number
    hash: number
    type: number
    json: number
    bytes: number
    serialised_size: number
    _all: number
  }


  export type ScriptAvgAggregateInputType = {
    id?: true
    tx_id?: true
    serialised_size?: true
  }

  export type ScriptSumAggregateInputType = {
    id?: true
    tx_id?: true
    serialised_size?: true
  }

  export type ScriptMinAggregateInputType = {
    id?: true
    tx_id?: true
    hash?: true
    type?: true
    bytes?: true
    serialised_size?: true
  }

  export type ScriptMaxAggregateInputType = {
    id?: true
    tx_id?: true
    hash?: true
    type?: true
    bytes?: true
    serialised_size?: true
  }

  export type ScriptCountAggregateInputType = {
    id?: true
    tx_id?: true
    hash?: true
    type?: true
    json?: true
    bytes?: true
    serialised_size?: true
    _all?: true
  }

  export type ScriptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which script to aggregate.
     */
    where?: scriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scripts to fetch.
     */
    orderBy?: scriptOrderByWithRelationInput | scriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scripts
    **/
    _count?: true | ScriptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScriptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScriptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScriptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScriptMaxAggregateInputType
  }

  export type GetScriptAggregateType<T extends ScriptAggregateArgs> = {
        [P in keyof T & keyof AggregateScript]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScript[P]>
      : GetScalarType<T[P], AggregateScript[P]>
  }




  export type scriptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scriptWhereInput
    orderBy?: scriptOrderByWithAggregationInput | scriptOrderByWithAggregationInput[]
    by: ScriptScalarFieldEnum[] | ScriptScalarFieldEnum
    having?: scriptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScriptCountAggregateInputType | true
    _avg?: ScriptAvgAggregateInputType
    _sum?: ScriptSumAggregateInputType
    _min?: ScriptMinAggregateInputType
    _max?: ScriptMaxAggregateInputType
  }

  export type ScriptGroupByOutputType = {
    id: bigint
    tx_id: bigint
    hash: Uint8Array
    type: $Enums.scripttype
    json: JsonValue | null
    bytes: Uint8Array | null
    serialised_size: number | null
    _count: ScriptCountAggregateOutputType | null
    _avg: ScriptAvgAggregateOutputType | null
    _sum: ScriptSumAggregateOutputType | null
    _min: ScriptMinAggregateOutputType | null
    _max: ScriptMaxAggregateOutputType | null
  }

  type GetScriptGroupByPayload<T extends scriptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScriptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScriptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScriptGroupByOutputType[P]>
            : GetScalarType<T[P], ScriptGroupByOutputType[P]>
        }
      >
    >


  export type scriptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    hash?: boolean
    type?: boolean
    json?: boolean
    bytes?: boolean
    serialised_size?: boolean
  }, ExtArgs["result"]["script"]>

  export type scriptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    hash?: boolean
    type?: boolean
    json?: boolean
    bytes?: boolean
    serialised_size?: boolean
  }, ExtArgs["result"]["script"]>

  export type scriptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    hash?: boolean
    type?: boolean
    json?: boolean
    bytes?: boolean
    serialised_size?: boolean
  }, ExtArgs["result"]["script"]>

  export type scriptSelectScalar = {
    id?: boolean
    tx_id?: boolean
    hash?: boolean
    type?: boolean
    json?: boolean
    bytes?: boolean
    serialised_size?: boolean
  }

  export type scriptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "hash" | "type" | "json" | "bytes" | "serialised_size", ExtArgs["result"]["script"]>

  export type $scriptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "script"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      hash: Uint8Array
      type: $Enums.scripttype
      json: Prisma.JsonValue | null
      bytes: Uint8Array | null
      serialised_size: number | null
    }, ExtArgs["result"]["script"]>
    composites: {}
  }

  type scriptGetPayload<S extends boolean | null | undefined | scriptDefaultArgs> = $Result.GetResult<Prisma.$scriptPayload, S>

  type scriptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<scriptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScriptCountAggregateInputType | true
    }

  export interface scriptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['script'], meta: { name: 'script' } }
    /**
     * Find zero or one Script that matches the filter.
     * @param {scriptFindUniqueArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends scriptFindUniqueArgs>(args: SelectSubset<T, scriptFindUniqueArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Script that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {scriptFindUniqueOrThrowArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends scriptFindUniqueOrThrowArgs>(args: SelectSubset<T, scriptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Script that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptFindFirstArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends scriptFindFirstArgs>(args?: SelectSubset<T, scriptFindFirstArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Script that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptFindFirstOrThrowArgs} args - Arguments to find a Script
     * @example
     * // Get one Script
     * const script = await prisma.script.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends scriptFindFirstOrThrowArgs>(args?: SelectSubset<T, scriptFindFirstOrThrowArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Scripts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scripts
     * const scripts = await prisma.script.findMany()
     * 
     * // Get first 10 Scripts
     * const scripts = await prisma.script.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scriptWithIdOnly = await prisma.script.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends scriptFindManyArgs>(args?: SelectSubset<T, scriptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Script.
     * @param {scriptCreateArgs} args - Arguments to create a Script.
     * @example
     * // Create one Script
     * const Script = await prisma.script.create({
     *   data: {
     *     // ... data to create a Script
     *   }
     * })
     * 
     */
    create<T extends scriptCreateArgs>(args: SelectSubset<T, scriptCreateArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Scripts.
     * @param {scriptCreateManyArgs} args - Arguments to create many Scripts.
     * @example
     * // Create many Scripts
     * const script = await prisma.script.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends scriptCreateManyArgs>(args?: SelectSubset<T, scriptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scripts and returns the data saved in the database.
     * @param {scriptCreateManyAndReturnArgs} args - Arguments to create many Scripts.
     * @example
     * // Create many Scripts
     * const script = await prisma.script.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scripts and only return the `id`
     * const scriptWithIdOnly = await prisma.script.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends scriptCreateManyAndReturnArgs>(args?: SelectSubset<T, scriptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Script.
     * @param {scriptDeleteArgs} args - Arguments to delete one Script.
     * @example
     * // Delete one Script
     * const Script = await prisma.script.delete({
     *   where: {
     *     // ... filter to delete one Script
     *   }
     * })
     * 
     */
    delete<T extends scriptDeleteArgs>(args: SelectSubset<T, scriptDeleteArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Script.
     * @param {scriptUpdateArgs} args - Arguments to update one Script.
     * @example
     * // Update one Script
     * const script = await prisma.script.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends scriptUpdateArgs>(args: SelectSubset<T, scriptUpdateArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Scripts.
     * @param {scriptDeleteManyArgs} args - Arguments to filter Scripts to delete.
     * @example
     * // Delete a few Scripts
     * const { count } = await prisma.script.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends scriptDeleteManyArgs>(args?: SelectSubset<T, scriptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scripts
     * const script = await prisma.script.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends scriptUpdateManyArgs>(args: SelectSubset<T, scriptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scripts and returns the data updated in the database.
     * @param {scriptUpdateManyAndReturnArgs} args - Arguments to update many Scripts.
     * @example
     * // Update many Scripts
     * const script = await prisma.script.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scripts and only return the `id`
     * const scriptWithIdOnly = await prisma.script.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends scriptUpdateManyAndReturnArgs>(args: SelectSubset<T, scriptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Script.
     * @param {scriptUpsertArgs} args - Arguments to update or create a Script.
     * @example
     * // Update or create a Script
     * const script = await prisma.script.upsert({
     *   create: {
     *     // ... data to create a Script
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Script we want to update
     *   }
     * })
     */
    upsert<T extends scriptUpsertArgs>(args: SelectSubset<T, scriptUpsertArgs<ExtArgs>>): Prisma__scriptClient<$Result.GetResult<Prisma.$scriptPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Scripts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptCountArgs} args - Arguments to filter Scripts to count.
     * @example
     * // Count the number of Scripts
     * const count = await prisma.script.count({
     *   where: {
     *     // ... the filter for the Scripts we want to count
     *   }
     * })
    **/
    count<T extends scriptCountArgs>(
      args?: Subset<T, scriptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScriptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Script.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScriptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScriptAggregateArgs>(args: Subset<T, ScriptAggregateArgs>): Prisma.PrismaPromise<GetScriptAggregateType<T>>

    /**
     * Group by Script.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scriptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scriptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scriptGroupByArgs['orderBy'] }
        : { orderBy?: scriptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scriptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScriptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the script model
   */
  readonly fields: scriptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for script.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scriptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the script model
   */ 
  interface scriptFieldRefs {
    readonly id: FieldRef<"script", 'BigInt'>
    readonly tx_id: FieldRef<"script", 'BigInt'>
    readonly hash: FieldRef<"script", 'Bytes'>
    readonly type: FieldRef<"script", 'scripttype'>
    readonly json: FieldRef<"script", 'Json'>
    readonly bytes: FieldRef<"script", 'Bytes'>
    readonly serialised_size: FieldRef<"script", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * script findUnique
   */
  export type scriptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter, which script to fetch.
     */
    where: scriptWhereUniqueInput
  }

  /**
   * script findUniqueOrThrow
   */
  export type scriptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter, which script to fetch.
     */
    where: scriptWhereUniqueInput
  }

  /**
   * script findFirst
   */
  export type scriptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter, which script to fetch.
     */
    where?: scriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scripts to fetch.
     */
    orderBy?: scriptOrderByWithRelationInput | scriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scripts.
     */
    cursor?: scriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scripts.
     */
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * script findFirstOrThrow
   */
  export type scriptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter, which script to fetch.
     */
    where?: scriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scripts to fetch.
     */
    orderBy?: scriptOrderByWithRelationInput | scriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scripts.
     */
    cursor?: scriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scripts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scripts.
     */
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * script findMany
   */
  export type scriptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter, which scripts to fetch.
     */
    where?: scriptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scripts to fetch.
     */
    orderBy?: scriptOrderByWithRelationInput | scriptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scripts.
     */
    cursor?: scriptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scripts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scripts.
     */
    skip?: number
    distinct?: ScriptScalarFieldEnum | ScriptScalarFieldEnum[]
  }

  /**
   * script create
   */
  export type scriptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * The data needed to create a script.
     */
    data: XOR<scriptCreateInput, scriptUncheckedCreateInput>
  }

  /**
   * script createMany
   */
  export type scriptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many scripts.
     */
    data: scriptCreateManyInput | scriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * script createManyAndReturn
   */
  export type scriptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * The data used to create many scripts.
     */
    data: scriptCreateManyInput | scriptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * script update
   */
  export type scriptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * The data needed to update a script.
     */
    data: XOR<scriptUpdateInput, scriptUncheckedUpdateInput>
    /**
     * Choose, which script to update.
     */
    where: scriptWhereUniqueInput
  }

  /**
   * script updateMany
   */
  export type scriptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update scripts.
     */
    data: XOR<scriptUpdateManyMutationInput, scriptUncheckedUpdateManyInput>
    /**
     * Filter which scripts to update
     */
    where?: scriptWhereInput
    /**
     * Limit how many scripts to update.
     */
    limit?: number
  }

  /**
   * script updateManyAndReturn
   */
  export type scriptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * The data used to update scripts.
     */
    data: XOR<scriptUpdateManyMutationInput, scriptUncheckedUpdateManyInput>
    /**
     * Filter which scripts to update
     */
    where?: scriptWhereInput
    /**
     * Limit how many scripts to update.
     */
    limit?: number
  }

  /**
   * script upsert
   */
  export type scriptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * The filter to search for the script to update in case it exists.
     */
    where: scriptWhereUniqueInput
    /**
     * In case the script found by the `where` argument doesn't exist, create a new script with this data.
     */
    create: XOR<scriptCreateInput, scriptUncheckedCreateInput>
    /**
     * In case the script was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scriptUpdateInput, scriptUncheckedUpdateInput>
  }

  /**
   * script delete
   */
  export type scriptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
    /**
     * Filter which script to delete.
     */
    where: scriptWhereUniqueInput
  }

  /**
   * script deleteMany
   */
  export type scriptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scripts to delete
     */
    where?: scriptWhereInput
    /**
     * Limit how many scripts to delete.
     */
    limit?: number
  }

  /**
   * script without action
   */
  export type scriptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the script
     */
    select?: scriptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the script
     */
    omit?: scriptOmit<ExtArgs> | null
  }


  /**
   * Model slot_leader
   */

  export type AggregateSlot_leader = {
    _count: Slot_leaderCountAggregateOutputType | null
    _avg: Slot_leaderAvgAggregateOutputType | null
    _sum: Slot_leaderSumAggregateOutputType | null
    _min: Slot_leaderMinAggregateOutputType | null
    _max: Slot_leaderMaxAggregateOutputType | null
  }

  export type Slot_leaderAvgAggregateOutputType = {
    id: number | null
    pool_hash_id: number | null
  }

  export type Slot_leaderSumAggregateOutputType = {
    id: bigint | null
    pool_hash_id: bigint | null
  }

  export type Slot_leaderMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    pool_hash_id: bigint | null
    description: string | null
  }

  export type Slot_leaderMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    pool_hash_id: bigint | null
    description: string | null
  }

  export type Slot_leaderCountAggregateOutputType = {
    id: number
    hash: number
    pool_hash_id: number
    description: number
    _all: number
  }


  export type Slot_leaderAvgAggregateInputType = {
    id?: true
    pool_hash_id?: true
  }

  export type Slot_leaderSumAggregateInputType = {
    id?: true
    pool_hash_id?: true
  }

  export type Slot_leaderMinAggregateInputType = {
    id?: true
    hash?: true
    pool_hash_id?: true
    description?: true
  }

  export type Slot_leaderMaxAggregateInputType = {
    id?: true
    hash?: true
    pool_hash_id?: true
    description?: true
  }

  export type Slot_leaderCountAggregateInputType = {
    id?: true
    hash?: true
    pool_hash_id?: true
    description?: true
    _all?: true
  }

  export type Slot_leaderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_leader to aggregate.
     */
    where?: slot_leaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_leaders to fetch.
     */
    orderBy?: slot_leaderOrderByWithRelationInput | slot_leaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: slot_leaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_leaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_leaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned slot_leaders
    **/
    _count?: true | Slot_leaderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Slot_leaderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Slot_leaderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Slot_leaderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Slot_leaderMaxAggregateInputType
  }

  export type GetSlot_leaderAggregateType<T extends Slot_leaderAggregateArgs> = {
        [P in keyof T & keyof AggregateSlot_leader]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlot_leader[P]>
      : GetScalarType<T[P], AggregateSlot_leader[P]>
  }




  export type slot_leaderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: slot_leaderWhereInput
    orderBy?: slot_leaderOrderByWithAggregationInput | slot_leaderOrderByWithAggregationInput[]
    by: Slot_leaderScalarFieldEnum[] | Slot_leaderScalarFieldEnum
    having?: slot_leaderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Slot_leaderCountAggregateInputType | true
    _avg?: Slot_leaderAvgAggregateInputType
    _sum?: Slot_leaderSumAggregateInputType
    _min?: Slot_leaderMinAggregateInputType
    _max?: Slot_leaderMaxAggregateInputType
  }

  export type Slot_leaderGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    pool_hash_id: bigint | null
    description: string
    _count: Slot_leaderCountAggregateOutputType | null
    _avg: Slot_leaderAvgAggregateOutputType | null
    _sum: Slot_leaderSumAggregateOutputType | null
    _min: Slot_leaderMinAggregateOutputType | null
    _max: Slot_leaderMaxAggregateOutputType | null
  }

  type GetSlot_leaderGroupByPayload<T extends slot_leaderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Slot_leaderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Slot_leaderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Slot_leaderGroupByOutputType[P]>
            : GetScalarType<T[P], Slot_leaderGroupByOutputType[P]>
        }
      >
    >


  export type slot_leaderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    pool_hash_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["slot_leader"]>

  export type slot_leaderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    pool_hash_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["slot_leader"]>

  export type slot_leaderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    pool_hash_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["slot_leader"]>

  export type slot_leaderSelectScalar = {
    id?: boolean
    hash?: boolean
    pool_hash_id?: boolean
    description?: boolean
  }

  export type slot_leaderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "pool_hash_id" | "description", ExtArgs["result"]["slot_leader"]>

  export type $slot_leaderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "slot_leader"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      pool_hash_id: bigint | null
      description: string
    }, ExtArgs["result"]["slot_leader"]>
    composites: {}
  }

  type slot_leaderGetPayload<S extends boolean | null | undefined | slot_leaderDefaultArgs> = $Result.GetResult<Prisma.$slot_leaderPayload, S>

  type slot_leaderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<slot_leaderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Slot_leaderCountAggregateInputType | true
    }

  export interface slot_leaderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['slot_leader'], meta: { name: 'slot_leader' } }
    /**
     * Find zero or one Slot_leader that matches the filter.
     * @param {slot_leaderFindUniqueArgs} args - Arguments to find a Slot_leader
     * @example
     * // Get one Slot_leader
     * const slot_leader = await prisma.slot_leader.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends slot_leaderFindUniqueArgs>(args: SelectSubset<T, slot_leaderFindUniqueArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Slot_leader that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {slot_leaderFindUniqueOrThrowArgs} args - Arguments to find a Slot_leader
     * @example
     * // Get one Slot_leader
     * const slot_leader = await prisma.slot_leader.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends slot_leaderFindUniqueOrThrowArgs>(args: SelectSubset<T, slot_leaderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Slot_leader that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderFindFirstArgs} args - Arguments to find a Slot_leader
     * @example
     * // Get one Slot_leader
     * const slot_leader = await prisma.slot_leader.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends slot_leaderFindFirstArgs>(args?: SelectSubset<T, slot_leaderFindFirstArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Slot_leader that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderFindFirstOrThrowArgs} args - Arguments to find a Slot_leader
     * @example
     * // Get one Slot_leader
     * const slot_leader = await prisma.slot_leader.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends slot_leaderFindFirstOrThrowArgs>(args?: SelectSubset<T, slot_leaderFindFirstOrThrowArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Slot_leaders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Slot_leaders
     * const slot_leaders = await prisma.slot_leader.findMany()
     * 
     * // Get first 10 Slot_leaders
     * const slot_leaders = await prisma.slot_leader.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slot_leaderWithIdOnly = await prisma.slot_leader.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends slot_leaderFindManyArgs>(args?: SelectSubset<T, slot_leaderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Slot_leader.
     * @param {slot_leaderCreateArgs} args - Arguments to create a Slot_leader.
     * @example
     * // Create one Slot_leader
     * const Slot_leader = await prisma.slot_leader.create({
     *   data: {
     *     // ... data to create a Slot_leader
     *   }
     * })
     * 
     */
    create<T extends slot_leaderCreateArgs>(args: SelectSubset<T, slot_leaderCreateArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Slot_leaders.
     * @param {slot_leaderCreateManyArgs} args - Arguments to create many Slot_leaders.
     * @example
     * // Create many Slot_leaders
     * const slot_leader = await prisma.slot_leader.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends slot_leaderCreateManyArgs>(args?: SelectSubset<T, slot_leaderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Slot_leaders and returns the data saved in the database.
     * @param {slot_leaderCreateManyAndReturnArgs} args - Arguments to create many Slot_leaders.
     * @example
     * // Create many Slot_leaders
     * const slot_leader = await prisma.slot_leader.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Slot_leaders and only return the `id`
     * const slot_leaderWithIdOnly = await prisma.slot_leader.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends slot_leaderCreateManyAndReturnArgs>(args?: SelectSubset<T, slot_leaderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Slot_leader.
     * @param {slot_leaderDeleteArgs} args - Arguments to delete one Slot_leader.
     * @example
     * // Delete one Slot_leader
     * const Slot_leader = await prisma.slot_leader.delete({
     *   where: {
     *     // ... filter to delete one Slot_leader
     *   }
     * })
     * 
     */
    delete<T extends slot_leaderDeleteArgs>(args: SelectSubset<T, slot_leaderDeleteArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Slot_leader.
     * @param {slot_leaderUpdateArgs} args - Arguments to update one Slot_leader.
     * @example
     * // Update one Slot_leader
     * const slot_leader = await prisma.slot_leader.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends slot_leaderUpdateArgs>(args: SelectSubset<T, slot_leaderUpdateArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Slot_leaders.
     * @param {slot_leaderDeleteManyArgs} args - Arguments to filter Slot_leaders to delete.
     * @example
     * // Delete a few Slot_leaders
     * const { count } = await prisma.slot_leader.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends slot_leaderDeleteManyArgs>(args?: SelectSubset<T, slot_leaderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slot_leaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Slot_leaders
     * const slot_leader = await prisma.slot_leader.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends slot_leaderUpdateManyArgs>(args: SelectSubset<T, slot_leaderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Slot_leaders and returns the data updated in the database.
     * @param {slot_leaderUpdateManyAndReturnArgs} args - Arguments to update many Slot_leaders.
     * @example
     * // Update many Slot_leaders
     * const slot_leader = await prisma.slot_leader.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Slot_leaders and only return the `id`
     * const slot_leaderWithIdOnly = await prisma.slot_leader.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends slot_leaderUpdateManyAndReturnArgs>(args: SelectSubset<T, slot_leaderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Slot_leader.
     * @param {slot_leaderUpsertArgs} args - Arguments to update or create a Slot_leader.
     * @example
     * // Update or create a Slot_leader
     * const slot_leader = await prisma.slot_leader.upsert({
     *   create: {
     *     // ... data to create a Slot_leader
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Slot_leader we want to update
     *   }
     * })
     */
    upsert<T extends slot_leaderUpsertArgs>(args: SelectSubset<T, slot_leaderUpsertArgs<ExtArgs>>): Prisma__slot_leaderClient<$Result.GetResult<Prisma.$slot_leaderPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Slot_leaders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderCountArgs} args - Arguments to filter Slot_leaders to count.
     * @example
     * // Count the number of Slot_leaders
     * const count = await prisma.slot_leader.count({
     *   where: {
     *     // ... the filter for the Slot_leaders we want to count
     *   }
     * })
    **/
    count<T extends slot_leaderCountArgs>(
      args?: Subset<T, slot_leaderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Slot_leaderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Slot_leader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Slot_leaderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Slot_leaderAggregateArgs>(args: Subset<T, Slot_leaderAggregateArgs>): Prisma.PrismaPromise<GetSlot_leaderAggregateType<T>>

    /**
     * Group by Slot_leader.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {slot_leaderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends slot_leaderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: slot_leaderGroupByArgs['orderBy'] }
        : { orderBy?: slot_leaderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, slot_leaderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlot_leaderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the slot_leader model
   */
  readonly fields: slot_leaderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for slot_leader.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__slot_leaderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the slot_leader model
   */ 
  interface slot_leaderFieldRefs {
    readonly id: FieldRef<"slot_leader", 'BigInt'>
    readonly hash: FieldRef<"slot_leader", 'Bytes'>
    readonly pool_hash_id: FieldRef<"slot_leader", 'BigInt'>
    readonly description: FieldRef<"slot_leader", 'String'>
  }
    

  // Custom InputTypes
  /**
   * slot_leader findUnique
   */
  export type slot_leaderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter, which slot_leader to fetch.
     */
    where: slot_leaderWhereUniqueInput
  }

  /**
   * slot_leader findUniqueOrThrow
   */
  export type slot_leaderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter, which slot_leader to fetch.
     */
    where: slot_leaderWhereUniqueInput
  }

  /**
   * slot_leader findFirst
   */
  export type slot_leaderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter, which slot_leader to fetch.
     */
    where?: slot_leaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_leaders to fetch.
     */
    orderBy?: slot_leaderOrderByWithRelationInput | slot_leaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_leaders.
     */
    cursor?: slot_leaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_leaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_leaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_leaders.
     */
    distinct?: Slot_leaderScalarFieldEnum | Slot_leaderScalarFieldEnum[]
  }

  /**
   * slot_leader findFirstOrThrow
   */
  export type slot_leaderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter, which slot_leader to fetch.
     */
    where?: slot_leaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_leaders to fetch.
     */
    orderBy?: slot_leaderOrderByWithRelationInput | slot_leaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for slot_leaders.
     */
    cursor?: slot_leaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_leaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_leaders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of slot_leaders.
     */
    distinct?: Slot_leaderScalarFieldEnum | Slot_leaderScalarFieldEnum[]
  }

  /**
   * slot_leader findMany
   */
  export type slot_leaderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter, which slot_leaders to fetch.
     */
    where?: slot_leaderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of slot_leaders to fetch.
     */
    orderBy?: slot_leaderOrderByWithRelationInput | slot_leaderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing slot_leaders.
     */
    cursor?: slot_leaderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` slot_leaders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` slot_leaders.
     */
    skip?: number
    distinct?: Slot_leaderScalarFieldEnum | Slot_leaderScalarFieldEnum[]
  }

  /**
   * slot_leader create
   */
  export type slot_leaderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * The data needed to create a slot_leader.
     */
    data: XOR<slot_leaderCreateInput, slot_leaderUncheckedCreateInput>
  }

  /**
   * slot_leader createMany
   */
  export type slot_leaderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many slot_leaders.
     */
    data: slot_leaderCreateManyInput | slot_leaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * slot_leader createManyAndReturn
   */
  export type slot_leaderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * The data used to create many slot_leaders.
     */
    data: slot_leaderCreateManyInput | slot_leaderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * slot_leader update
   */
  export type slot_leaderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * The data needed to update a slot_leader.
     */
    data: XOR<slot_leaderUpdateInput, slot_leaderUncheckedUpdateInput>
    /**
     * Choose, which slot_leader to update.
     */
    where: slot_leaderWhereUniqueInput
  }

  /**
   * slot_leader updateMany
   */
  export type slot_leaderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update slot_leaders.
     */
    data: XOR<slot_leaderUpdateManyMutationInput, slot_leaderUncheckedUpdateManyInput>
    /**
     * Filter which slot_leaders to update
     */
    where?: slot_leaderWhereInput
    /**
     * Limit how many slot_leaders to update.
     */
    limit?: number
  }

  /**
   * slot_leader updateManyAndReturn
   */
  export type slot_leaderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * The data used to update slot_leaders.
     */
    data: XOR<slot_leaderUpdateManyMutationInput, slot_leaderUncheckedUpdateManyInput>
    /**
     * Filter which slot_leaders to update
     */
    where?: slot_leaderWhereInput
    /**
     * Limit how many slot_leaders to update.
     */
    limit?: number
  }

  /**
   * slot_leader upsert
   */
  export type slot_leaderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * The filter to search for the slot_leader to update in case it exists.
     */
    where: slot_leaderWhereUniqueInput
    /**
     * In case the slot_leader found by the `where` argument doesn't exist, create a new slot_leader with this data.
     */
    create: XOR<slot_leaderCreateInput, slot_leaderUncheckedCreateInput>
    /**
     * In case the slot_leader was found with the provided `where` argument, update it with this data.
     */
    update: XOR<slot_leaderUpdateInput, slot_leaderUncheckedUpdateInput>
  }

  /**
   * slot_leader delete
   */
  export type slot_leaderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
    /**
     * Filter which slot_leader to delete.
     */
    where: slot_leaderWhereUniqueInput
  }

  /**
   * slot_leader deleteMany
   */
  export type slot_leaderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which slot_leaders to delete
     */
    where?: slot_leaderWhereInput
    /**
     * Limit how many slot_leaders to delete.
     */
    limit?: number
  }

  /**
   * slot_leader without action
   */
  export type slot_leaderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the slot_leader
     */
    select?: slot_leaderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the slot_leader
     */
    omit?: slot_leaderOmit<ExtArgs> | null
  }


  /**
   * Model stake_address
   */

  export type AggregateStake_address = {
    _count: Stake_addressCountAggregateOutputType | null
    _avg: Stake_addressAvgAggregateOutputType | null
    _sum: Stake_addressSumAggregateOutputType | null
    _min: Stake_addressMinAggregateOutputType | null
    _max: Stake_addressMaxAggregateOutputType | null
  }

  export type Stake_addressAvgAggregateOutputType = {
    id: number | null
  }

  export type Stake_addressSumAggregateOutputType = {
    id: bigint | null
  }

  export type Stake_addressMinAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
    view: string | null
    script_hash: Uint8Array | null
  }

  export type Stake_addressMaxAggregateOutputType = {
    id: bigint | null
    hash_raw: Uint8Array | null
    view: string | null
    script_hash: Uint8Array | null
  }

  export type Stake_addressCountAggregateOutputType = {
    id: number
    hash_raw: number
    view: number
    script_hash: number
    _all: number
  }


  export type Stake_addressAvgAggregateInputType = {
    id?: true
  }

  export type Stake_addressSumAggregateInputType = {
    id?: true
  }

  export type Stake_addressMinAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
    script_hash?: true
  }

  export type Stake_addressMaxAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
    script_hash?: true
  }

  export type Stake_addressCountAggregateInputType = {
    id?: true
    hash_raw?: true
    view?: true
    script_hash?: true
    _all?: true
  }

  export type Stake_addressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_address to aggregate.
     */
    where?: stake_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_addresses to fetch.
     */
    orderBy?: stake_addressOrderByWithRelationInput | stake_addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stake_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stake_addresses
    **/
    _count?: true | Stake_addressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stake_addressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stake_addressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stake_addressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stake_addressMaxAggregateInputType
  }

  export type GetStake_addressAggregateType<T extends Stake_addressAggregateArgs> = {
        [P in keyof T & keyof AggregateStake_address]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStake_address[P]>
      : GetScalarType<T[P], AggregateStake_address[P]>
  }




  export type stake_addressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stake_addressWhereInput
    orderBy?: stake_addressOrderByWithAggregationInput | stake_addressOrderByWithAggregationInput[]
    by: Stake_addressScalarFieldEnum[] | Stake_addressScalarFieldEnum
    having?: stake_addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stake_addressCountAggregateInputType | true
    _avg?: Stake_addressAvgAggregateInputType
    _sum?: Stake_addressSumAggregateInputType
    _min?: Stake_addressMinAggregateInputType
    _max?: Stake_addressMaxAggregateInputType
  }

  export type Stake_addressGroupByOutputType = {
    id: bigint
    hash_raw: Uint8Array
    view: string
    script_hash: Uint8Array | null
    _count: Stake_addressCountAggregateOutputType | null
    _avg: Stake_addressAvgAggregateOutputType | null
    _sum: Stake_addressSumAggregateOutputType | null
    _min: Stake_addressMinAggregateOutputType | null
    _max: Stake_addressMaxAggregateOutputType | null
  }

  type GetStake_addressGroupByPayload<T extends stake_addressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stake_addressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stake_addressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stake_addressGroupByOutputType[P]>
            : GetScalarType<T[P], Stake_addressGroupByOutputType[P]>
        }
      >
    >


  export type stake_addressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["stake_address"]>

  export type stake_addressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["stake_address"]>

  export type stake_addressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash_raw?: boolean
    view?: boolean
    script_hash?: boolean
  }, ExtArgs["result"]["stake_address"]>

  export type stake_addressSelectScalar = {
    id?: boolean
    hash_raw?: boolean
    view?: boolean
    script_hash?: boolean
  }

  export type stake_addressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash_raw" | "view" | "script_hash", ExtArgs["result"]["stake_address"]>

  export type $stake_addressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stake_address"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash_raw: Uint8Array
      view: string
      script_hash: Uint8Array | null
    }, ExtArgs["result"]["stake_address"]>
    composites: {}
  }

  type stake_addressGetPayload<S extends boolean | null | undefined | stake_addressDefaultArgs> = $Result.GetResult<Prisma.$stake_addressPayload, S>

  type stake_addressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stake_addressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stake_addressCountAggregateInputType | true
    }

  export interface stake_addressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stake_address'], meta: { name: 'stake_address' } }
    /**
     * Find zero or one Stake_address that matches the filter.
     * @param {stake_addressFindUniqueArgs} args - Arguments to find a Stake_address
     * @example
     * // Get one Stake_address
     * const stake_address = await prisma.stake_address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stake_addressFindUniqueArgs>(args: SelectSubset<T, stake_addressFindUniqueArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stake_address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stake_addressFindUniqueOrThrowArgs} args - Arguments to find a Stake_address
     * @example
     * // Get one Stake_address
     * const stake_address = await prisma.stake_address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stake_addressFindUniqueOrThrowArgs>(args: SelectSubset<T, stake_addressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressFindFirstArgs} args - Arguments to find a Stake_address
     * @example
     * // Get one Stake_address
     * const stake_address = await prisma.stake_address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stake_addressFindFirstArgs>(args?: SelectSubset<T, stake_addressFindFirstArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressFindFirstOrThrowArgs} args - Arguments to find a Stake_address
     * @example
     * // Get one Stake_address
     * const stake_address = await prisma.stake_address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stake_addressFindFirstOrThrowArgs>(args?: SelectSubset<T, stake_addressFindFirstOrThrowArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stake_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stake_addresses
     * const stake_addresses = await prisma.stake_address.findMany()
     * 
     * // Get first 10 Stake_addresses
     * const stake_addresses = await prisma.stake_address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stake_addressWithIdOnly = await prisma.stake_address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stake_addressFindManyArgs>(args?: SelectSubset<T, stake_addressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stake_address.
     * @param {stake_addressCreateArgs} args - Arguments to create a Stake_address.
     * @example
     * // Create one Stake_address
     * const Stake_address = await prisma.stake_address.create({
     *   data: {
     *     // ... data to create a Stake_address
     *   }
     * })
     * 
     */
    create<T extends stake_addressCreateArgs>(args: SelectSubset<T, stake_addressCreateArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stake_addresses.
     * @param {stake_addressCreateManyArgs} args - Arguments to create many Stake_addresses.
     * @example
     * // Create many Stake_addresses
     * const stake_address = await prisma.stake_address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stake_addressCreateManyArgs>(args?: SelectSubset<T, stake_addressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stake_addresses and returns the data saved in the database.
     * @param {stake_addressCreateManyAndReturnArgs} args - Arguments to create many Stake_addresses.
     * @example
     * // Create many Stake_addresses
     * const stake_address = await prisma.stake_address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stake_addresses and only return the `id`
     * const stake_addressWithIdOnly = await prisma.stake_address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stake_addressCreateManyAndReturnArgs>(args?: SelectSubset<T, stake_addressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stake_address.
     * @param {stake_addressDeleteArgs} args - Arguments to delete one Stake_address.
     * @example
     * // Delete one Stake_address
     * const Stake_address = await prisma.stake_address.delete({
     *   where: {
     *     // ... filter to delete one Stake_address
     *   }
     * })
     * 
     */
    delete<T extends stake_addressDeleteArgs>(args: SelectSubset<T, stake_addressDeleteArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stake_address.
     * @param {stake_addressUpdateArgs} args - Arguments to update one Stake_address.
     * @example
     * // Update one Stake_address
     * const stake_address = await prisma.stake_address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stake_addressUpdateArgs>(args: SelectSubset<T, stake_addressUpdateArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stake_addresses.
     * @param {stake_addressDeleteManyArgs} args - Arguments to filter Stake_addresses to delete.
     * @example
     * // Delete a few Stake_addresses
     * const { count } = await prisma.stake_address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stake_addressDeleteManyArgs>(args?: SelectSubset<T, stake_addressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stake_addresses
     * const stake_address = await prisma.stake_address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stake_addressUpdateManyArgs>(args: SelectSubset<T, stake_addressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_addresses and returns the data updated in the database.
     * @param {stake_addressUpdateManyAndReturnArgs} args - Arguments to update many Stake_addresses.
     * @example
     * // Update many Stake_addresses
     * const stake_address = await prisma.stake_address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stake_addresses and only return the `id`
     * const stake_addressWithIdOnly = await prisma.stake_address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stake_addressUpdateManyAndReturnArgs>(args: SelectSubset<T, stake_addressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stake_address.
     * @param {stake_addressUpsertArgs} args - Arguments to update or create a Stake_address.
     * @example
     * // Update or create a Stake_address
     * const stake_address = await prisma.stake_address.upsert({
     *   create: {
     *     // ... data to create a Stake_address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stake_address we want to update
     *   }
     * })
     */
    upsert<T extends stake_addressUpsertArgs>(args: SelectSubset<T, stake_addressUpsertArgs<ExtArgs>>): Prisma__stake_addressClient<$Result.GetResult<Prisma.$stake_addressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stake_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressCountArgs} args - Arguments to filter Stake_addresses to count.
     * @example
     * // Count the number of Stake_addresses
     * const count = await prisma.stake_address.count({
     *   where: {
     *     // ... the filter for the Stake_addresses we want to count
     *   }
     * })
    **/
    count<T extends stake_addressCountArgs>(
      args?: Subset<T, stake_addressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stake_addressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stake_address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stake_addressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stake_addressAggregateArgs>(args: Subset<T, Stake_addressAggregateArgs>): Prisma.PrismaPromise<GetStake_addressAggregateType<T>>

    /**
     * Group by Stake_address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_addressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stake_addressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stake_addressGroupByArgs['orderBy'] }
        : { orderBy?: stake_addressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stake_addressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStake_addressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stake_address model
   */
  readonly fields: stake_addressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stake_address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stake_addressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stake_address model
   */ 
  interface stake_addressFieldRefs {
    readonly id: FieldRef<"stake_address", 'BigInt'>
    readonly hash_raw: FieldRef<"stake_address", 'Bytes'>
    readonly view: FieldRef<"stake_address", 'String'>
    readonly script_hash: FieldRef<"stake_address", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * stake_address findUnique
   */
  export type stake_addressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter, which stake_address to fetch.
     */
    where: stake_addressWhereUniqueInput
  }

  /**
   * stake_address findUniqueOrThrow
   */
  export type stake_addressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter, which stake_address to fetch.
     */
    where: stake_addressWhereUniqueInput
  }

  /**
   * stake_address findFirst
   */
  export type stake_addressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter, which stake_address to fetch.
     */
    where?: stake_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_addresses to fetch.
     */
    orderBy?: stake_addressOrderByWithRelationInput | stake_addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_addresses.
     */
    cursor?: stake_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_addresses.
     */
    distinct?: Stake_addressScalarFieldEnum | Stake_addressScalarFieldEnum[]
  }

  /**
   * stake_address findFirstOrThrow
   */
  export type stake_addressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter, which stake_address to fetch.
     */
    where?: stake_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_addresses to fetch.
     */
    orderBy?: stake_addressOrderByWithRelationInput | stake_addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_addresses.
     */
    cursor?: stake_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_addresses.
     */
    distinct?: Stake_addressScalarFieldEnum | Stake_addressScalarFieldEnum[]
  }

  /**
   * stake_address findMany
   */
  export type stake_addressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter, which stake_addresses to fetch.
     */
    where?: stake_addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_addresses to fetch.
     */
    orderBy?: stake_addressOrderByWithRelationInput | stake_addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stake_addresses.
     */
    cursor?: stake_addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_addresses.
     */
    skip?: number
    distinct?: Stake_addressScalarFieldEnum | Stake_addressScalarFieldEnum[]
  }

  /**
   * stake_address create
   */
  export type stake_addressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * The data needed to create a stake_address.
     */
    data: XOR<stake_addressCreateInput, stake_addressUncheckedCreateInput>
  }

  /**
   * stake_address createMany
   */
  export type stake_addressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stake_addresses.
     */
    data: stake_addressCreateManyInput | stake_addressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_address createManyAndReturn
   */
  export type stake_addressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * The data used to create many stake_addresses.
     */
    data: stake_addressCreateManyInput | stake_addressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_address update
   */
  export type stake_addressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * The data needed to update a stake_address.
     */
    data: XOR<stake_addressUpdateInput, stake_addressUncheckedUpdateInput>
    /**
     * Choose, which stake_address to update.
     */
    where: stake_addressWhereUniqueInput
  }

  /**
   * stake_address updateMany
   */
  export type stake_addressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stake_addresses.
     */
    data: XOR<stake_addressUpdateManyMutationInput, stake_addressUncheckedUpdateManyInput>
    /**
     * Filter which stake_addresses to update
     */
    where?: stake_addressWhereInput
    /**
     * Limit how many stake_addresses to update.
     */
    limit?: number
  }

  /**
   * stake_address updateManyAndReturn
   */
  export type stake_addressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * The data used to update stake_addresses.
     */
    data: XOR<stake_addressUpdateManyMutationInput, stake_addressUncheckedUpdateManyInput>
    /**
     * Filter which stake_addresses to update
     */
    where?: stake_addressWhereInput
    /**
     * Limit how many stake_addresses to update.
     */
    limit?: number
  }

  /**
   * stake_address upsert
   */
  export type stake_addressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * The filter to search for the stake_address to update in case it exists.
     */
    where: stake_addressWhereUniqueInput
    /**
     * In case the stake_address found by the `where` argument doesn't exist, create a new stake_address with this data.
     */
    create: XOR<stake_addressCreateInput, stake_addressUncheckedCreateInput>
    /**
     * In case the stake_address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stake_addressUpdateInput, stake_addressUncheckedUpdateInput>
  }

  /**
   * stake_address delete
   */
  export type stake_addressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
    /**
     * Filter which stake_address to delete.
     */
    where: stake_addressWhereUniqueInput
  }

  /**
   * stake_address deleteMany
   */
  export type stake_addressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_addresses to delete
     */
    where?: stake_addressWhereInput
    /**
     * Limit how many stake_addresses to delete.
     */
    limit?: number
  }

  /**
   * stake_address without action
   */
  export type stake_addressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_address
     */
    select?: stake_addressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_address
     */
    omit?: stake_addressOmit<ExtArgs> | null
  }


  /**
   * Model stake_deregistration
   */

  export type AggregateStake_deregistration = {
    _count: Stake_deregistrationCountAggregateOutputType | null
    _avg: Stake_deregistrationAvgAggregateOutputType | null
    _sum: Stake_deregistrationSumAggregateOutputType | null
    _min: Stake_deregistrationMinAggregateOutputType | null
    _max: Stake_deregistrationMaxAggregateOutputType | null
  }

  export type Stake_deregistrationAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: number | null
    redeemer_id: number | null
  }

  export type Stake_deregistrationSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Stake_deregistrationMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Stake_deregistrationMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    redeemer_id: bigint | null
  }

  export type Stake_deregistrationCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    epoch_no: number
    tx_id: number
    redeemer_id: number
    _all: number
  }


  export type Stake_deregistrationAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Stake_deregistrationSumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Stake_deregistrationMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Stake_deregistrationMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    redeemer_id?: true
  }

  export type Stake_deregistrationCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    redeemer_id?: true
    _all?: true
  }

  export type Stake_deregistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_deregistration to aggregate.
     */
    where?: stake_deregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_deregistrations to fetch.
     */
    orderBy?: stake_deregistrationOrderByWithRelationInput | stake_deregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stake_deregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_deregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_deregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stake_deregistrations
    **/
    _count?: true | Stake_deregistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stake_deregistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stake_deregistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stake_deregistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stake_deregistrationMaxAggregateInputType
  }

  export type GetStake_deregistrationAggregateType<T extends Stake_deregistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStake_deregistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStake_deregistration[P]>
      : GetScalarType<T[P], AggregateStake_deregistration[P]>
  }




  export type stake_deregistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stake_deregistrationWhereInput
    orderBy?: stake_deregistrationOrderByWithAggregationInput | stake_deregistrationOrderByWithAggregationInput[]
    by: Stake_deregistrationScalarFieldEnum[] | Stake_deregistrationScalarFieldEnum
    having?: stake_deregistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stake_deregistrationCountAggregateInputType | true
    _avg?: Stake_deregistrationAvgAggregateInputType
    _sum?: Stake_deregistrationSumAggregateInputType
    _min?: Stake_deregistrationMinAggregateInputType
    _max?: Stake_deregistrationMaxAggregateInputType
  }

  export type Stake_deregistrationGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    epoch_no: number
    tx_id: bigint
    redeemer_id: bigint | null
    _count: Stake_deregistrationCountAggregateOutputType | null
    _avg: Stake_deregistrationAvgAggregateOutputType | null
    _sum: Stake_deregistrationSumAggregateOutputType | null
    _min: Stake_deregistrationMinAggregateOutputType | null
    _max: Stake_deregistrationMaxAggregateOutputType | null
  }

  type GetStake_deregistrationGroupByPayload<T extends stake_deregistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stake_deregistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stake_deregistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stake_deregistrationGroupByOutputType[P]>
            : GetScalarType<T[P], Stake_deregistrationGroupByOutputType[P]>
        }
      >
    >


  export type stake_deregistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["stake_deregistration"]>

  export type stake_deregistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["stake_deregistration"]>

  export type stake_deregistrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["stake_deregistration"]>

  export type stake_deregistrationSelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    redeemer_id?: boolean
  }

  export type stake_deregistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "epoch_no" | "tx_id" | "redeemer_id", ExtArgs["result"]["stake_deregistration"]>

  export type $stake_deregistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stake_deregistration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      epoch_no: number
      tx_id: bigint
      redeemer_id: bigint | null
    }, ExtArgs["result"]["stake_deregistration"]>
    composites: {}
  }

  type stake_deregistrationGetPayload<S extends boolean | null | undefined | stake_deregistrationDefaultArgs> = $Result.GetResult<Prisma.$stake_deregistrationPayload, S>

  type stake_deregistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stake_deregistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stake_deregistrationCountAggregateInputType | true
    }

  export interface stake_deregistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stake_deregistration'], meta: { name: 'stake_deregistration' } }
    /**
     * Find zero or one Stake_deregistration that matches the filter.
     * @param {stake_deregistrationFindUniqueArgs} args - Arguments to find a Stake_deregistration
     * @example
     * // Get one Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stake_deregistrationFindUniqueArgs>(args: SelectSubset<T, stake_deregistrationFindUniqueArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stake_deregistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stake_deregistrationFindUniqueOrThrowArgs} args - Arguments to find a Stake_deregistration
     * @example
     * // Get one Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stake_deregistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, stake_deregistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_deregistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationFindFirstArgs} args - Arguments to find a Stake_deregistration
     * @example
     * // Get one Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stake_deregistrationFindFirstArgs>(args?: SelectSubset<T, stake_deregistrationFindFirstArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_deregistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationFindFirstOrThrowArgs} args - Arguments to find a Stake_deregistration
     * @example
     * // Get one Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stake_deregistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, stake_deregistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stake_deregistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stake_deregistrations
     * const stake_deregistrations = await prisma.stake_deregistration.findMany()
     * 
     * // Get first 10 Stake_deregistrations
     * const stake_deregistrations = await prisma.stake_deregistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stake_deregistrationWithIdOnly = await prisma.stake_deregistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stake_deregistrationFindManyArgs>(args?: SelectSubset<T, stake_deregistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stake_deregistration.
     * @param {stake_deregistrationCreateArgs} args - Arguments to create a Stake_deregistration.
     * @example
     * // Create one Stake_deregistration
     * const Stake_deregistration = await prisma.stake_deregistration.create({
     *   data: {
     *     // ... data to create a Stake_deregistration
     *   }
     * })
     * 
     */
    create<T extends stake_deregistrationCreateArgs>(args: SelectSubset<T, stake_deregistrationCreateArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stake_deregistrations.
     * @param {stake_deregistrationCreateManyArgs} args - Arguments to create many Stake_deregistrations.
     * @example
     * // Create many Stake_deregistrations
     * const stake_deregistration = await prisma.stake_deregistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stake_deregistrationCreateManyArgs>(args?: SelectSubset<T, stake_deregistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stake_deregistrations and returns the data saved in the database.
     * @param {stake_deregistrationCreateManyAndReturnArgs} args - Arguments to create many Stake_deregistrations.
     * @example
     * // Create many Stake_deregistrations
     * const stake_deregistration = await prisma.stake_deregistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stake_deregistrations and only return the `id`
     * const stake_deregistrationWithIdOnly = await prisma.stake_deregistration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stake_deregistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, stake_deregistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stake_deregistration.
     * @param {stake_deregistrationDeleteArgs} args - Arguments to delete one Stake_deregistration.
     * @example
     * // Delete one Stake_deregistration
     * const Stake_deregistration = await prisma.stake_deregistration.delete({
     *   where: {
     *     // ... filter to delete one Stake_deregistration
     *   }
     * })
     * 
     */
    delete<T extends stake_deregistrationDeleteArgs>(args: SelectSubset<T, stake_deregistrationDeleteArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stake_deregistration.
     * @param {stake_deregistrationUpdateArgs} args - Arguments to update one Stake_deregistration.
     * @example
     * // Update one Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stake_deregistrationUpdateArgs>(args: SelectSubset<T, stake_deregistrationUpdateArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stake_deregistrations.
     * @param {stake_deregistrationDeleteManyArgs} args - Arguments to filter Stake_deregistrations to delete.
     * @example
     * // Delete a few Stake_deregistrations
     * const { count } = await prisma.stake_deregistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stake_deregistrationDeleteManyArgs>(args?: SelectSubset<T, stake_deregistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_deregistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stake_deregistrations
     * const stake_deregistration = await prisma.stake_deregistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stake_deregistrationUpdateManyArgs>(args: SelectSubset<T, stake_deregistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_deregistrations and returns the data updated in the database.
     * @param {stake_deregistrationUpdateManyAndReturnArgs} args - Arguments to update many Stake_deregistrations.
     * @example
     * // Update many Stake_deregistrations
     * const stake_deregistration = await prisma.stake_deregistration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stake_deregistrations and only return the `id`
     * const stake_deregistrationWithIdOnly = await prisma.stake_deregistration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stake_deregistrationUpdateManyAndReturnArgs>(args: SelectSubset<T, stake_deregistrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stake_deregistration.
     * @param {stake_deregistrationUpsertArgs} args - Arguments to update or create a Stake_deregistration.
     * @example
     * // Update or create a Stake_deregistration
     * const stake_deregistration = await prisma.stake_deregistration.upsert({
     *   create: {
     *     // ... data to create a Stake_deregistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stake_deregistration we want to update
     *   }
     * })
     */
    upsert<T extends stake_deregistrationUpsertArgs>(args: SelectSubset<T, stake_deregistrationUpsertArgs<ExtArgs>>): Prisma__stake_deregistrationClient<$Result.GetResult<Prisma.$stake_deregistrationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stake_deregistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationCountArgs} args - Arguments to filter Stake_deregistrations to count.
     * @example
     * // Count the number of Stake_deregistrations
     * const count = await prisma.stake_deregistration.count({
     *   where: {
     *     // ... the filter for the Stake_deregistrations we want to count
     *   }
     * })
    **/
    count<T extends stake_deregistrationCountArgs>(
      args?: Subset<T, stake_deregistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stake_deregistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stake_deregistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stake_deregistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stake_deregistrationAggregateArgs>(args: Subset<T, Stake_deregistrationAggregateArgs>): Prisma.PrismaPromise<GetStake_deregistrationAggregateType<T>>

    /**
     * Group by Stake_deregistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_deregistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stake_deregistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stake_deregistrationGroupByArgs['orderBy'] }
        : { orderBy?: stake_deregistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stake_deregistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStake_deregistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stake_deregistration model
   */
  readonly fields: stake_deregistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stake_deregistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stake_deregistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stake_deregistration model
   */ 
  interface stake_deregistrationFieldRefs {
    readonly id: FieldRef<"stake_deregistration", 'BigInt'>
    readonly addr_id: FieldRef<"stake_deregistration", 'BigInt'>
    readonly cert_index: FieldRef<"stake_deregistration", 'Int'>
    readonly epoch_no: FieldRef<"stake_deregistration", 'Int'>
    readonly tx_id: FieldRef<"stake_deregistration", 'BigInt'>
    readonly redeemer_id: FieldRef<"stake_deregistration", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * stake_deregistration findUnique
   */
  export type stake_deregistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_deregistration to fetch.
     */
    where: stake_deregistrationWhereUniqueInput
  }

  /**
   * stake_deregistration findUniqueOrThrow
   */
  export type stake_deregistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_deregistration to fetch.
     */
    where: stake_deregistrationWhereUniqueInput
  }

  /**
   * stake_deregistration findFirst
   */
  export type stake_deregistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_deregistration to fetch.
     */
    where?: stake_deregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_deregistrations to fetch.
     */
    orderBy?: stake_deregistrationOrderByWithRelationInput | stake_deregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_deregistrations.
     */
    cursor?: stake_deregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_deregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_deregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_deregistrations.
     */
    distinct?: Stake_deregistrationScalarFieldEnum | Stake_deregistrationScalarFieldEnum[]
  }

  /**
   * stake_deregistration findFirstOrThrow
   */
  export type stake_deregistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_deregistration to fetch.
     */
    where?: stake_deregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_deregistrations to fetch.
     */
    orderBy?: stake_deregistrationOrderByWithRelationInput | stake_deregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_deregistrations.
     */
    cursor?: stake_deregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_deregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_deregistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_deregistrations.
     */
    distinct?: Stake_deregistrationScalarFieldEnum | Stake_deregistrationScalarFieldEnum[]
  }

  /**
   * stake_deregistration findMany
   */
  export type stake_deregistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_deregistrations to fetch.
     */
    where?: stake_deregistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_deregistrations to fetch.
     */
    orderBy?: stake_deregistrationOrderByWithRelationInput | stake_deregistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stake_deregistrations.
     */
    cursor?: stake_deregistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_deregistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_deregistrations.
     */
    skip?: number
    distinct?: Stake_deregistrationScalarFieldEnum | Stake_deregistrationScalarFieldEnum[]
  }

  /**
   * stake_deregistration create
   */
  export type stake_deregistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * The data needed to create a stake_deregistration.
     */
    data: XOR<stake_deregistrationCreateInput, stake_deregistrationUncheckedCreateInput>
  }

  /**
   * stake_deregistration createMany
   */
  export type stake_deregistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stake_deregistrations.
     */
    data: stake_deregistrationCreateManyInput | stake_deregistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_deregistration createManyAndReturn
   */
  export type stake_deregistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * The data used to create many stake_deregistrations.
     */
    data: stake_deregistrationCreateManyInput | stake_deregistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_deregistration update
   */
  export type stake_deregistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * The data needed to update a stake_deregistration.
     */
    data: XOR<stake_deregistrationUpdateInput, stake_deregistrationUncheckedUpdateInput>
    /**
     * Choose, which stake_deregistration to update.
     */
    where: stake_deregistrationWhereUniqueInput
  }

  /**
   * stake_deregistration updateMany
   */
  export type stake_deregistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stake_deregistrations.
     */
    data: XOR<stake_deregistrationUpdateManyMutationInput, stake_deregistrationUncheckedUpdateManyInput>
    /**
     * Filter which stake_deregistrations to update
     */
    where?: stake_deregistrationWhereInput
    /**
     * Limit how many stake_deregistrations to update.
     */
    limit?: number
  }

  /**
   * stake_deregistration updateManyAndReturn
   */
  export type stake_deregistrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * The data used to update stake_deregistrations.
     */
    data: XOR<stake_deregistrationUpdateManyMutationInput, stake_deregistrationUncheckedUpdateManyInput>
    /**
     * Filter which stake_deregistrations to update
     */
    where?: stake_deregistrationWhereInput
    /**
     * Limit how many stake_deregistrations to update.
     */
    limit?: number
  }

  /**
   * stake_deregistration upsert
   */
  export type stake_deregistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * The filter to search for the stake_deregistration to update in case it exists.
     */
    where: stake_deregistrationWhereUniqueInput
    /**
     * In case the stake_deregistration found by the `where` argument doesn't exist, create a new stake_deregistration with this data.
     */
    create: XOR<stake_deregistrationCreateInput, stake_deregistrationUncheckedCreateInput>
    /**
     * In case the stake_deregistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stake_deregistrationUpdateInput, stake_deregistrationUncheckedUpdateInput>
  }

  /**
   * stake_deregistration delete
   */
  export type stake_deregistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
    /**
     * Filter which stake_deregistration to delete.
     */
    where: stake_deregistrationWhereUniqueInput
  }

  /**
   * stake_deregistration deleteMany
   */
  export type stake_deregistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_deregistrations to delete
     */
    where?: stake_deregistrationWhereInput
    /**
     * Limit how many stake_deregistrations to delete.
     */
    limit?: number
  }

  /**
   * stake_deregistration without action
   */
  export type stake_deregistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_deregistration
     */
    select?: stake_deregistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_deregistration
     */
    omit?: stake_deregistrationOmit<ExtArgs> | null
  }


  /**
   * Model stake_registration
   */

  export type AggregateStake_registration = {
    _count: Stake_registrationCountAggregateOutputType | null
    _avg: Stake_registrationAvgAggregateOutputType | null
    _sum: Stake_registrationSumAggregateOutputType | null
    _min: Stake_registrationMinAggregateOutputType | null
    _max: Stake_registrationMaxAggregateOutputType | null
  }

  export type Stake_registrationAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: number | null
    deposit: Decimal | null
  }

  export type Stake_registrationSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    deposit: Decimal | null
  }

  export type Stake_registrationMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    deposit: Decimal | null
  }

  export type Stake_registrationMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    epoch_no: number | null
    tx_id: bigint | null
    deposit: Decimal | null
  }

  export type Stake_registrationCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    epoch_no: number
    tx_id: number
    deposit: number
    _all: number
  }


  export type Stake_registrationAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    deposit?: true
  }

  export type Stake_registrationSumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    deposit?: true
  }

  export type Stake_registrationMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    deposit?: true
  }

  export type Stake_registrationMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    deposit?: true
  }

  export type Stake_registrationCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    epoch_no?: true
    tx_id?: true
    deposit?: true
    _all?: true
  }

  export type Stake_registrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_registration to aggregate.
     */
    where?: stake_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_registrations to fetch.
     */
    orderBy?: stake_registrationOrderByWithRelationInput | stake_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stake_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stake_registrations
    **/
    _count?: true | Stake_registrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stake_registrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stake_registrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stake_registrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stake_registrationMaxAggregateInputType
  }

  export type GetStake_registrationAggregateType<T extends Stake_registrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStake_registration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStake_registration[P]>
      : GetScalarType<T[P], AggregateStake_registration[P]>
  }




  export type stake_registrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stake_registrationWhereInput
    orderBy?: stake_registrationOrderByWithAggregationInput | stake_registrationOrderByWithAggregationInput[]
    by: Stake_registrationScalarFieldEnum[] | Stake_registrationScalarFieldEnum
    having?: stake_registrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stake_registrationCountAggregateInputType | true
    _avg?: Stake_registrationAvgAggregateInputType
    _sum?: Stake_registrationSumAggregateInputType
    _min?: Stake_registrationMinAggregateInputType
    _max?: Stake_registrationMaxAggregateInputType
  }

  export type Stake_registrationGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    epoch_no: number
    tx_id: bigint
    deposit: Decimal | null
    _count: Stake_registrationCountAggregateOutputType | null
    _avg: Stake_registrationAvgAggregateOutputType | null
    _sum: Stake_registrationSumAggregateOutputType | null
    _min: Stake_registrationMinAggregateOutputType | null
    _max: Stake_registrationMaxAggregateOutputType | null
  }

  type GetStake_registrationGroupByPayload<T extends stake_registrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stake_registrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stake_registrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stake_registrationGroupByOutputType[P]>
            : GetScalarType<T[P], Stake_registrationGroupByOutputType[P]>
        }
      >
    >


  export type stake_registrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["stake_registration"]>

  export type stake_registrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["stake_registration"]>

  export type stake_registrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    deposit?: boolean
  }, ExtArgs["result"]["stake_registration"]>

  export type stake_registrationSelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    epoch_no?: boolean
    tx_id?: boolean
    deposit?: boolean
  }

  export type stake_registrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "epoch_no" | "tx_id" | "deposit", ExtArgs["result"]["stake_registration"]>

  export type $stake_registrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stake_registration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      epoch_no: number
      tx_id: bigint
      deposit: Prisma.Decimal | null
    }, ExtArgs["result"]["stake_registration"]>
    composites: {}
  }

  type stake_registrationGetPayload<S extends boolean | null | undefined | stake_registrationDefaultArgs> = $Result.GetResult<Prisma.$stake_registrationPayload, S>

  type stake_registrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stake_registrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stake_registrationCountAggregateInputType | true
    }

  export interface stake_registrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stake_registration'], meta: { name: 'stake_registration' } }
    /**
     * Find zero or one Stake_registration that matches the filter.
     * @param {stake_registrationFindUniqueArgs} args - Arguments to find a Stake_registration
     * @example
     * // Get one Stake_registration
     * const stake_registration = await prisma.stake_registration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stake_registrationFindUniqueArgs>(args: SelectSubset<T, stake_registrationFindUniqueArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stake_registration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stake_registrationFindUniqueOrThrowArgs} args - Arguments to find a Stake_registration
     * @example
     * // Get one Stake_registration
     * const stake_registration = await prisma.stake_registration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stake_registrationFindUniqueOrThrowArgs>(args: SelectSubset<T, stake_registrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_registration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationFindFirstArgs} args - Arguments to find a Stake_registration
     * @example
     * // Get one Stake_registration
     * const stake_registration = await prisma.stake_registration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stake_registrationFindFirstArgs>(args?: SelectSubset<T, stake_registrationFindFirstArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stake_registration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationFindFirstOrThrowArgs} args - Arguments to find a Stake_registration
     * @example
     * // Get one Stake_registration
     * const stake_registration = await prisma.stake_registration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stake_registrationFindFirstOrThrowArgs>(args?: SelectSubset<T, stake_registrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stake_registrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stake_registrations
     * const stake_registrations = await prisma.stake_registration.findMany()
     * 
     * // Get first 10 Stake_registrations
     * const stake_registrations = await prisma.stake_registration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stake_registrationWithIdOnly = await prisma.stake_registration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stake_registrationFindManyArgs>(args?: SelectSubset<T, stake_registrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stake_registration.
     * @param {stake_registrationCreateArgs} args - Arguments to create a Stake_registration.
     * @example
     * // Create one Stake_registration
     * const Stake_registration = await prisma.stake_registration.create({
     *   data: {
     *     // ... data to create a Stake_registration
     *   }
     * })
     * 
     */
    create<T extends stake_registrationCreateArgs>(args: SelectSubset<T, stake_registrationCreateArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stake_registrations.
     * @param {stake_registrationCreateManyArgs} args - Arguments to create many Stake_registrations.
     * @example
     * // Create many Stake_registrations
     * const stake_registration = await prisma.stake_registration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stake_registrationCreateManyArgs>(args?: SelectSubset<T, stake_registrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stake_registrations and returns the data saved in the database.
     * @param {stake_registrationCreateManyAndReturnArgs} args - Arguments to create many Stake_registrations.
     * @example
     * // Create many Stake_registrations
     * const stake_registration = await prisma.stake_registration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stake_registrations and only return the `id`
     * const stake_registrationWithIdOnly = await prisma.stake_registration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stake_registrationCreateManyAndReturnArgs>(args?: SelectSubset<T, stake_registrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stake_registration.
     * @param {stake_registrationDeleteArgs} args - Arguments to delete one Stake_registration.
     * @example
     * // Delete one Stake_registration
     * const Stake_registration = await prisma.stake_registration.delete({
     *   where: {
     *     // ... filter to delete one Stake_registration
     *   }
     * })
     * 
     */
    delete<T extends stake_registrationDeleteArgs>(args: SelectSubset<T, stake_registrationDeleteArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stake_registration.
     * @param {stake_registrationUpdateArgs} args - Arguments to update one Stake_registration.
     * @example
     * // Update one Stake_registration
     * const stake_registration = await prisma.stake_registration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stake_registrationUpdateArgs>(args: SelectSubset<T, stake_registrationUpdateArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stake_registrations.
     * @param {stake_registrationDeleteManyArgs} args - Arguments to filter Stake_registrations to delete.
     * @example
     * // Delete a few Stake_registrations
     * const { count } = await prisma.stake_registration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stake_registrationDeleteManyArgs>(args?: SelectSubset<T, stake_registrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stake_registrations
     * const stake_registration = await prisma.stake_registration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stake_registrationUpdateManyArgs>(args: SelectSubset<T, stake_registrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stake_registrations and returns the data updated in the database.
     * @param {stake_registrationUpdateManyAndReturnArgs} args - Arguments to update many Stake_registrations.
     * @example
     * // Update many Stake_registrations
     * const stake_registration = await prisma.stake_registration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stake_registrations and only return the `id`
     * const stake_registrationWithIdOnly = await prisma.stake_registration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stake_registrationUpdateManyAndReturnArgs>(args: SelectSubset<T, stake_registrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stake_registration.
     * @param {stake_registrationUpsertArgs} args - Arguments to update or create a Stake_registration.
     * @example
     * // Update or create a Stake_registration
     * const stake_registration = await prisma.stake_registration.upsert({
     *   create: {
     *     // ... data to create a Stake_registration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stake_registration we want to update
     *   }
     * })
     */
    upsert<T extends stake_registrationUpsertArgs>(args: SelectSubset<T, stake_registrationUpsertArgs<ExtArgs>>): Prisma__stake_registrationClient<$Result.GetResult<Prisma.$stake_registrationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stake_registrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationCountArgs} args - Arguments to filter Stake_registrations to count.
     * @example
     * // Count the number of Stake_registrations
     * const count = await prisma.stake_registration.count({
     *   where: {
     *     // ... the filter for the Stake_registrations we want to count
     *   }
     * })
    **/
    count<T extends stake_registrationCountArgs>(
      args?: Subset<T, stake_registrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stake_registrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stake_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stake_registrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stake_registrationAggregateArgs>(args: Subset<T, Stake_registrationAggregateArgs>): Prisma.PrismaPromise<GetStake_registrationAggregateType<T>>

    /**
     * Group by Stake_registration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stake_registrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stake_registrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stake_registrationGroupByArgs['orderBy'] }
        : { orderBy?: stake_registrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stake_registrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStake_registrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stake_registration model
   */
  readonly fields: stake_registrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stake_registration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stake_registrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stake_registration model
   */ 
  interface stake_registrationFieldRefs {
    readonly id: FieldRef<"stake_registration", 'BigInt'>
    readonly addr_id: FieldRef<"stake_registration", 'BigInt'>
    readonly cert_index: FieldRef<"stake_registration", 'Int'>
    readonly epoch_no: FieldRef<"stake_registration", 'Int'>
    readonly tx_id: FieldRef<"stake_registration", 'BigInt'>
    readonly deposit: FieldRef<"stake_registration", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * stake_registration findUnique
   */
  export type stake_registrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_registration to fetch.
     */
    where: stake_registrationWhereUniqueInput
  }

  /**
   * stake_registration findUniqueOrThrow
   */
  export type stake_registrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_registration to fetch.
     */
    where: stake_registrationWhereUniqueInput
  }

  /**
   * stake_registration findFirst
   */
  export type stake_registrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_registration to fetch.
     */
    where?: stake_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_registrations to fetch.
     */
    orderBy?: stake_registrationOrderByWithRelationInput | stake_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_registrations.
     */
    cursor?: stake_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_registrations.
     */
    distinct?: Stake_registrationScalarFieldEnum | Stake_registrationScalarFieldEnum[]
  }

  /**
   * stake_registration findFirstOrThrow
   */
  export type stake_registrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_registration to fetch.
     */
    where?: stake_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_registrations to fetch.
     */
    orderBy?: stake_registrationOrderByWithRelationInput | stake_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stake_registrations.
     */
    cursor?: stake_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_registrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stake_registrations.
     */
    distinct?: Stake_registrationScalarFieldEnum | Stake_registrationScalarFieldEnum[]
  }

  /**
   * stake_registration findMany
   */
  export type stake_registrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter, which stake_registrations to fetch.
     */
    where?: stake_registrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stake_registrations to fetch.
     */
    orderBy?: stake_registrationOrderByWithRelationInput | stake_registrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stake_registrations.
     */
    cursor?: stake_registrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stake_registrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stake_registrations.
     */
    skip?: number
    distinct?: Stake_registrationScalarFieldEnum | Stake_registrationScalarFieldEnum[]
  }

  /**
   * stake_registration create
   */
  export type stake_registrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * The data needed to create a stake_registration.
     */
    data: XOR<stake_registrationCreateInput, stake_registrationUncheckedCreateInput>
  }

  /**
   * stake_registration createMany
   */
  export type stake_registrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stake_registrations.
     */
    data: stake_registrationCreateManyInput | stake_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_registration createManyAndReturn
   */
  export type stake_registrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * The data used to create many stake_registrations.
     */
    data: stake_registrationCreateManyInput | stake_registrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stake_registration update
   */
  export type stake_registrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * The data needed to update a stake_registration.
     */
    data: XOR<stake_registrationUpdateInput, stake_registrationUncheckedUpdateInput>
    /**
     * Choose, which stake_registration to update.
     */
    where: stake_registrationWhereUniqueInput
  }

  /**
   * stake_registration updateMany
   */
  export type stake_registrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stake_registrations.
     */
    data: XOR<stake_registrationUpdateManyMutationInput, stake_registrationUncheckedUpdateManyInput>
    /**
     * Filter which stake_registrations to update
     */
    where?: stake_registrationWhereInput
    /**
     * Limit how many stake_registrations to update.
     */
    limit?: number
  }

  /**
   * stake_registration updateManyAndReturn
   */
  export type stake_registrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * The data used to update stake_registrations.
     */
    data: XOR<stake_registrationUpdateManyMutationInput, stake_registrationUncheckedUpdateManyInput>
    /**
     * Filter which stake_registrations to update
     */
    where?: stake_registrationWhereInput
    /**
     * Limit how many stake_registrations to update.
     */
    limit?: number
  }

  /**
   * stake_registration upsert
   */
  export type stake_registrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * The filter to search for the stake_registration to update in case it exists.
     */
    where: stake_registrationWhereUniqueInput
    /**
     * In case the stake_registration found by the `where` argument doesn't exist, create a new stake_registration with this data.
     */
    create: XOR<stake_registrationCreateInput, stake_registrationUncheckedCreateInput>
    /**
     * In case the stake_registration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stake_registrationUpdateInput, stake_registrationUncheckedUpdateInput>
  }

  /**
   * stake_registration delete
   */
  export type stake_registrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
    /**
     * Filter which stake_registration to delete.
     */
    where: stake_registrationWhereUniqueInput
  }

  /**
   * stake_registration deleteMany
   */
  export type stake_registrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stake_registrations to delete
     */
    where?: stake_registrationWhereInput
    /**
     * Limit how many stake_registrations to delete.
     */
    limit?: number
  }

  /**
   * stake_registration without action
   */
  export type stake_registrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stake_registration
     */
    select?: stake_registrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stake_registration
     */
    omit?: stake_registrationOmit<ExtArgs> | null
  }


  /**
   * Model treasury
   */

  export type AggregateTreasury = {
    _count: TreasuryCountAggregateOutputType | null
    _avg: TreasuryAvgAggregateOutputType | null
    _sum: TreasurySumAggregateOutputType | null
    _min: TreasuryMinAggregateOutputType | null
    _max: TreasuryMaxAggregateOutputType | null
  }

  export type TreasuryAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: number | null
  }

  export type TreasurySumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type TreasuryMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type TreasuryMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    cert_index: number | null
    amount: Decimal | null
    tx_id: bigint | null
  }

  export type TreasuryCountAggregateOutputType = {
    id: number
    addr_id: number
    cert_index: number
    amount: number
    tx_id: number
    _all: number
  }


  export type TreasuryAvgAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type TreasurySumAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type TreasuryMinAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type TreasuryMaxAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
  }

  export type TreasuryCountAggregateInputType = {
    id?: true
    addr_id?: true
    cert_index?: true
    amount?: true
    tx_id?: true
    _all?: true
  }

  export type TreasuryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasury to aggregate.
     */
    where?: treasuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasuries to fetch.
     */
    orderBy?: treasuryOrderByWithRelationInput | treasuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: treasuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned treasuries
    **/
    _count?: true | TreasuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreasuryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreasurySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreasuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreasuryMaxAggregateInputType
  }

  export type GetTreasuryAggregateType<T extends TreasuryAggregateArgs> = {
        [P in keyof T & keyof AggregateTreasury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasury[P]>
      : GetScalarType<T[P], AggregateTreasury[P]>
  }




  export type treasuryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasuryWhereInput
    orderBy?: treasuryOrderByWithAggregationInput | treasuryOrderByWithAggregationInput[]
    by: TreasuryScalarFieldEnum[] | TreasuryScalarFieldEnum
    having?: treasuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreasuryCountAggregateInputType | true
    _avg?: TreasuryAvgAggregateInputType
    _sum?: TreasurySumAggregateInputType
    _min?: TreasuryMinAggregateInputType
    _max?: TreasuryMaxAggregateInputType
  }

  export type TreasuryGroupByOutputType = {
    id: bigint
    addr_id: bigint
    cert_index: number
    amount: Decimal
    tx_id: bigint
    _count: TreasuryCountAggregateOutputType | null
    _avg: TreasuryAvgAggregateOutputType | null
    _sum: TreasurySumAggregateOutputType | null
    _min: TreasuryMinAggregateOutputType | null
    _max: TreasuryMaxAggregateOutputType | null
  }

  type GetTreasuryGroupByPayload<T extends treasuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreasuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreasuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreasuryGroupByOutputType[P]>
            : GetScalarType<T[P], TreasuryGroupByOutputType[P]>
        }
      >
    >


  export type treasurySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["treasury"]>

  export type treasurySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["treasury"]>

  export type treasurySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["treasury"]>

  export type treasurySelectScalar = {
    id?: boolean
    addr_id?: boolean
    cert_index?: boolean
    amount?: boolean
    tx_id?: boolean
  }

  export type treasuryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "cert_index" | "amount" | "tx_id", ExtArgs["result"]["treasury"]>

  export type $treasuryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "treasury"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      cert_index: number
      amount: Prisma.Decimal
      tx_id: bigint
    }, ExtArgs["result"]["treasury"]>
    composites: {}
  }

  type treasuryGetPayload<S extends boolean | null | undefined | treasuryDefaultArgs> = $Result.GetResult<Prisma.$treasuryPayload, S>

  type treasuryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<treasuryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreasuryCountAggregateInputType | true
    }

  export interface treasuryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['treasury'], meta: { name: 'treasury' } }
    /**
     * Find zero or one Treasury that matches the filter.
     * @param {treasuryFindUniqueArgs} args - Arguments to find a Treasury
     * @example
     * // Get one Treasury
     * const treasury = await prisma.treasury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends treasuryFindUniqueArgs>(args: SelectSubset<T, treasuryFindUniqueArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Treasury that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {treasuryFindUniqueOrThrowArgs} args - Arguments to find a Treasury
     * @example
     * // Get one Treasury
     * const treasury = await prisma.treasury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends treasuryFindUniqueOrThrowArgs>(args: SelectSubset<T, treasuryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Treasury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryFindFirstArgs} args - Arguments to find a Treasury
     * @example
     * // Get one Treasury
     * const treasury = await prisma.treasury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends treasuryFindFirstArgs>(args?: SelectSubset<T, treasuryFindFirstArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Treasury that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryFindFirstOrThrowArgs} args - Arguments to find a Treasury
     * @example
     * // Get one Treasury
     * const treasury = await prisma.treasury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends treasuryFindFirstOrThrowArgs>(args?: SelectSubset<T, treasuryFindFirstOrThrowArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Treasuries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treasuries
     * const treasuries = await prisma.treasury.findMany()
     * 
     * // Get first 10 Treasuries
     * const treasuries = await prisma.treasury.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treasuryWithIdOnly = await prisma.treasury.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends treasuryFindManyArgs>(args?: SelectSubset<T, treasuryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Treasury.
     * @param {treasuryCreateArgs} args - Arguments to create a Treasury.
     * @example
     * // Create one Treasury
     * const Treasury = await prisma.treasury.create({
     *   data: {
     *     // ... data to create a Treasury
     *   }
     * })
     * 
     */
    create<T extends treasuryCreateArgs>(args: SelectSubset<T, treasuryCreateArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Treasuries.
     * @param {treasuryCreateManyArgs} args - Arguments to create many Treasuries.
     * @example
     * // Create many Treasuries
     * const treasury = await prisma.treasury.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends treasuryCreateManyArgs>(args?: SelectSubset<T, treasuryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treasuries and returns the data saved in the database.
     * @param {treasuryCreateManyAndReturnArgs} args - Arguments to create many Treasuries.
     * @example
     * // Create many Treasuries
     * const treasury = await prisma.treasury.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treasuries and only return the `id`
     * const treasuryWithIdOnly = await prisma.treasury.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends treasuryCreateManyAndReturnArgs>(args?: SelectSubset<T, treasuryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Treasury.
     * @param {treasuryDeleteArgs} args - Arguments to delete one Treasury.
     * @example
     * // Delete one Treasury
     * const Treasury = await prisma.treasury.delete({
     *   where: {
     *     // ... filter to delete one Treasury
     *   }
     * })
     * 
     */
    delete<T extends treasuryDeleteArgs>(args: SelectSubset<T, treasuryDeleteArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Treasury.
     * @param {treasuryUpdateArgs} args - Arguments to update one Treasury.
     * @example
     * // Update one Treasury
     * const treasury = await prisma.treasury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends treasuryUpdateArgs>(args: SelectSubset<T, treasuryUpdateArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Treasuries.
     * @param {treasuryDeleteManyArgs} args - Arguments to filter Treasuries to delete.
     * @example
     * // Delete a few Treasuries
     * const { count } = await prisma.treasury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends treasuryDeleteManyArgs>(args?: SelectSubset<T, treasuryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treasuries
     * const treasury = await prisma.treasury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends treasuryUpdateManyArgs>(args: SelectSubset<T, treasuryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasuries and returns the data updated in the database.
     * @param {treasuryUpdateManyAndReturnArgs} args - Arguments to update many Treasuries.
     * @example
     * // Update many Treasuries
     * const treasury = await prisma.treasury.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Treasuries and only return the `id`
     * const treasuryWithIdOnly = await prisma.treasury.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends treasuryUpdateManyAndReturnArgs>(args: SelectSubset<T, treasuryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Treasury.
     * @param {treasuryUpsertArgs} args - Arguments to update or create a Treasury.
     * @example
     * // Update or create a Treasury
     * const treasury = await prisma.treasury.upsert({
     *   create: {
     *     // ... data to create a Treasury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treasury we want to update
     *   }
     * })
     */
    upsert<T extends treasuryUpsertArgs>(args: SelectSubset<T, treasuryUpsertArgs<ExtArgs>>): Prisma__treasuryClient<$Result.GetResult<Prisma.$treasuryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Treasuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryCountArgs} args - Arguments to filter Treasuries to count.
     * @example
     * // Count the number of Treasuries
     * const count = await prisma.treasury.count({
     *   where: {
     *     // ... the filter for the Treasuries we want to count
     *   }
     * })
    **/
    count<T extends treasuryCountArgs>(
      args?: Subset<T, treasuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreasuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treasury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreasuryAggregateArgs>(args: Subset<T, TreasuryAggregateArgs>): Prisma.PrismaPromise<GetTreasuryAggregateType<T>>

    /**
     * Group by Treasury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends treasuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: treasuryGroupByArgs['orderBy'] }
        : { orderBy?: treasuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, treasuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreasuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the treasury model
   */
  readonly fields: treasuryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for treasury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__treasuryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the treasury model
   */ 
  interface treasuryFieldRefs {
    readonly id: FieldRef<"treasury", 'BigInt'>
    readonly addr_id: FieldRef<"treasury", 'BigInt'>
    readonly cert_index: FieldRef<"treasury", 'Int'>
    readonly amount: FieldRef<"treasury", 'Decimal'>
    readonly tx_id: FieldRef<"treasury", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * treasury findUnique
   */
  export type treasuryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter, which treasury to fetch.
     */
    where: treasuryWhereUniqueInput
  }

  /**
   * treasury findUniqueOrThrow
   */
  export type treasuryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter, which treasury to fetch.
     */
    where: treasuryWhereUniqueInput
  }

  /**
   * treasury findFirst
   */
  export type treasuryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter, which treasury to fetch.
     */
    where?: treasuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasuries to fetch.
     */
    orderBy?: treasuryOrderByWithRelationInput | treasuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasuries.
     */
    cursor?: treasuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasuries.
     */
    distinct?: TreasuryScalarFieldEnum | TreasuryScalarFieldEnum[]
  }

  /**
   * treasury findFirstOrThrow
   */
  export type treasuryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter, which treasury to fetch.
     */
    where?: treasuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasuries to fetch.
     */
    orderBy?: treasuryOrderByWithRelationInput | treasuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasuries.
     */
    cursor?: treasuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasuries.
     */
    distinct?: TreasuryScalarFieldEnum | TreasuryScalarFieldEnum[]
  }

  /**
   * treasury findMany
   */
  export type treasuryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter, which treasuries to fetch.
     */
    where?: treasuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasuries to fetch.
     */
    orderBy?: treasuryOrderByWithRelationInput | treasuryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing treasuries.
     */
    cursor?: treasuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasuries.
     */
    skip?: number
    distinct?: TreasuryScalarFieldEnum | TreasuryScalarFieldEnum[]
  }

  /**
   * treasury create
   */
  export type treasuryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * The data needed to create a treasury.
     */
    data: XOR<treasuryCreateInput, treasuryUncheckedCreateInput>
  }

  /**
   * treasury createMany
   */
  export type treasuryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many treasuries.
     */
    data: treasuryCreateManyInput | treasuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasury createManyAndReturn
   */
  export type treasuryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * The data used to create many treasuries.
     */
    data: treasuryCreateManyInput | treasuryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasury update
   */
  export type treasuryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * The data needed to update a treasury.
     */
    data: XOR<treasuryUpdateInput, treasuryUncheckedUpdateInput>
    /**
     * Choose, which treasury to update.
     */
    where: treasuryWhereUniqueInput
  }

  /**
   * treasury updateMany
   */
  export type treasuryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update treasuries.
     */
    data: XOR<treasuryUpdateManyMutationInput, treasuryUncheckedUpdateManyInput>
    /**
     * Filter which treasuries to update
     */
    where?: treasuryWhereInput
    /**
     * Limit how many treasuries to update.
     */
    limit?: number
  }

  /**
   * treasury updateManyAndReturn
   */
  export type treasuryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * The data used to update treasuries.
     */
    data: XOR<treasuryUpdateManyMutationInput, treasuryUncheckedUpdateManyInput>
    /**
     * Filter which treasuries to update
     */
    where?: treasuryWhereInput
    /**
     * Limit how many treasuries to update.
     */
    limit?: number
  }

  /**
   * treasury upsert
   */
  export type treasuryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * The filter to search for the treasury to update in case it exists.
     */
    where: treasuryWhereUniqueInput
    /**
     * In case the treasury found by the `where` argument doesn't exist, create a new treasury with this data.
     */
    create: XOR<treasuryCreateInput, treasuryUncheckedCreateInput>
    /**
     * In case the treasury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<treasuryUpdateInput, treasuryUncheckedUpdateInput>
  }

  /**
   * treasury delete
   */
  export type treasuryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
    /**
     * Filter which treasury to delete.
     */
    where: treasuryWhereUniqueInput
  }

  /**
   * treasury deleteMany
   */
  export type treasuryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasuries to delete
     */
    where?: treasuryWhereInput
    /**
     * Limit how many treasuries to delete.
     */
    limit?: number
  }

  /**
   * treasury without action
   */
  export type treasuryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury
     */
    select?: treasurySelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury
     */
    omit?: treasuryOmit<ExtArgs> | null
  }


  /**
   * Model treasury_withdrawal
   */

  export type AggregateTreasury_withdrawal = {
    _count: Treasury_withdrawalCountAggregateOutputType | null
    _avg: Treasury_withdrawalAvgAggregateOutputType | null
    _sum: Treasury_withdrawalSumAggregateOutputType | null
    _min: Treasury_withdrawalMinAggregateOutputType | null
    _max: Treasury_withdrawalMaxAggregateOutputType | null
  }

  export type Treasury_withdrawalAvgAggregateOutputType = {
    id: number | null
    gov_action_proposal_id: number | null
    stake_address_id: number | null
    amount: Decimal | null
  }

  export type Treasury_withdrawalSumAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    stake_address_id: bigint | null
    amount: Decimal | null
  }

  export type Treasury_withdrawalMinAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    stake_address_id: bigint | null
    amount: Decimal | null
  }

  export type Treasury_withdrawalMaxAggregateOutputType = {
    id: bigint | null
    gov_action_proposal_id: bigint | null
    stake_address_id: bigint | null
    amount: Decimal | null
  }

  export type Treasury_withdrawalCountAggregateOutputType = {
    id: number
    gov_action_proposal_id: number
    stake_address_id: number
    amount: number
    _all: number
  }


  export type Treasury_withdrawalAvgAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    stake_address_id?: true
    amount?: true
  }

  export type Treasury_withdrawalSumAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    stake_address_id?: true
    amount?: true
  }

  export type Treasury_withdrawalMinAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    stake_address_id?: true
    amount?: true
  }

  export type Treasury_withdrawalMaxAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    stake_address_id?: true
    amount?: true
  }

  export type Treasury_withdrawalCountAggregateInputType = {
    id?: true
    gov_action_proposal_id?: true
    stake_address_id?: true
    amount?: true
    _all?: true
  }

  export type Treasury_withdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasury_withdrawal to aggregate.
     */
    where?: treasury_withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasury_withdrawals to fetch.
     */
    orderBy?: treasury_withdrawalOrderByWithRelationInput | treasury_withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: treasury_withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasury_withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasury_withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned treasury_withdrawals
    **/
    _count?: true | Treasury_withdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Treasury_withdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Treasury_withdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Treasury_withdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Treasury_withdrawalMaxAggregateInputType
  }

  export type GetTreasury_withdrawalAggregateType<T extends Treasury_withdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateTreasury_withdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasury_withdrawal[P]>
      : GetScalarType<T[P], AggregateTreasury_withdrawal[P]>
  }




  export type treasury_withdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasury_withdrawalWhereInput
    orderBy?: treasury_withdrawalOrderByWithAggregationInput | treasury_withdrawalOrderByWithAggregationInput[]
    by: Treasury_withdrawalScalarFieldEnum[] | Treasury_withdrawalScalarFieldEnum
    having?: treasury_withdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Treasury_withdrawalCountAggregateInputType | true
    _avg?: Treasury_withdrawalAvgAggregateInputType
    _sum?: Treasury_withdrawalSumAggregateInputType
    _min?: Treasury_withdrawalMinAggregateInputType
    _max?: Treasury_withdrawalMaxAggregateInputType
  }

  export type Treasury_withdrawalGroupByOutputType = {
    id: bigint
    gov_action_proposal_id: bigint
    stake_address_id: bigint
    amount: Decimal
    _count: Treasury_withdrawalCountAggregateOutputType | null
    _avg: Treasury_withdrawalAvgAggregateOutputType | null
    _sum: Treasury_withdrawalSumAggregateOutputType | null
    _min: Treasury_withdrawalMinAggregateOutputType | null
    _max: Treasury_withdrawalMaxAggregateOutputType | null
  }

  type GetTreasury_withdrawalGroupByPayload<T extends treasury_withdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Treasury_withdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Treasury_withdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Treasury_withdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], Treasury_withdrawalGroupByOutputType[P]>
        }
      >
    >


  export type treasury_withdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    stake_address_id?: boolean
    amount?: boolean
  }, ExtArgs["result"]["treasury_withdrawal"]>

  export type treasury_withdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    stake_address_id?: boolean
    amount?: boolean
  }, ExtArgs["result"]["treasury_withdrawal"]>

  export type treasury_withdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gov_action_proposal_id?: boolean
    stake_address_id?: boolean
    amount?: boolean
  }, ExtArgs["result"]["treasury_withdrawal"]>

  export type treasury_withdrawalSelectScalar = {
    id?: boolean
    gov_action_proposal_id?: boolean
    stake_address_id?: boolean
    amount?: boolean
  }

  export type treasury_withdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gov_action_proposal_id" | "stake_address_id" | "amount", ExtArgs["result"]["treasury_withdrawal"]>

  export type $treasury_withdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "treasury_withdrawal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      gov_action_proposal_id: bigint
      stake_address_id: bigint
      amount: Prisma.Decimal
    }, ExtArgs["result"]["treasury_withdrawal"]>
    composites: {}
  }

  type treasury_withdrawalGetPayload<S extends boolean | null | undefined | treasury_withdrawalDefaultArgs> = $Result.GetResult<Prisma.$treasury_withdrawalPayload, S>

  type treasury_withdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<treasury_withdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Treasury_withdrawalCountAggregateInputType | true
    }

  export interface treasury_withdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['treasury_withdrawal'], meta: { name: 'treasury_withdrawal' } }
    /**
     * Find zero or one Treasury_withdrawal that matches the filter.
     * @param {treasury_withdrawalFindUniqueArgs} args - Arguments to find a Treasury_withdrawal
     * @example
     * // Get one Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends treasury_withdrawalFindUniqueArgs>(args: SelectSubset<T, treasury_withdrawalFindUniqueArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Treasury_withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {treasury_withdrawalFindUniqueOrThrowArgs} args - Arguments to find a Treasury_withdrawal
     * @example
     * // Get one Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends treasury_withdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, treasury_withdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Treasury_withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalFindFirstArgs} args - Arguments to find a Treasury_withdrawal
     * @example
     * // Get one Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends treasury_withdrawalFindFirstArgs>(args?: SelectSubset<T, treasury_withdrawalFindFirstArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Treasury_withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalFindFirstOrThrowArgs} args - Arguments to find a Treasury_withdrawal
     * @example
     * // Get one Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends treasury_withdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, treasury_withdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Treasury_withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treasury_withdrawals
     * const treasury_withdrawals = await prisma.treasury_withdrawal.findMany()
     * 
     * // Get first 10 Treasury_withdrawals
     * const treasury_withdrawals = await prisma.treasury_withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treasury_withdrawalWithIdOnly = await prisma.treasury_withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends treasury_withdrawalFindManyArgs>(args?: SelectSubset<T, treasury_withdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Treasury_withdrawal.
     * @param {treasury_withdrawalCreateArgs} args - Arguments to create a Treasury_withdrawal.
     * @example
     * // Create one Treasury_withdrawal
     * const Treasury_withdrawal = await prisma.treasury_withdrawal.create({
     *   data: {
     *     // ... data to create a Treasury_withdrawal
     *   }
     * })
     * 
     */
    create<T extends treasury_withdrawalCreateArgs>(args: SelectSubset<T, treasury_withdrawalCreateArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Treasury_withdrawals.
     * @param {treasury_withdrawalCreateManyArgs} args - Arguments to create many Treasury_withdrawals.
     * @example
     * // Create many Treasury_withdrawals
     * const treasury_withdrawal = await prisma.treasury_withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends treasury_withdrawalCreateManyArgs>(args?: SelectSubset<T, treasury_withdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treasury_withdrawals and returns the data saved in the database.
     * @param {treasury_withdrawalCreateManyAndReturnArgs} args - Arguments to create many Treasury_withdrawals.
     * @example
     * // Create many Treasury_withdrawals
     * const treasury_withdrawal = await prisma.treasury_withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treasury_withdrawals and only return the `id`
     * const treasury_withdrawalWithIdOnly = await prisma.treasury_withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends treasury_withdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, treasury_withdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Treasury_withdrawal.
     * @param {treasury_withdrawalDeleteArgs} args - Arguments to delete one Treasury_withdrawal.
     * @example
     * // Delete one Treasury_withdrawal
     * const Treasury_withdrawal = await prisma.treasury_withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Treasury_withdrawal
     *   }
     * })
     * 
     */
    delete<T extends treasury_withdrawalDeleteArgs>(args: SelectSubset<T, treasury_withdrawalDeleteArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Treasury_withdrawal.
     * @param {treasury_withdrawalUpdateArgs} args - Arguments to update one Treasury_withdrawal.
     * @example
     * // Update one Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends treasury_withdrawalUpdateArgs>(args: SelectSubset<T, treasury_withdrawalUpdateArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Treasury_withdrawals.
     * @param {treasury_withdrawalDeleteManyArgs} args - Arguments to filter Treasury_withdrawals to delete.
     * @example
     * // Delete a few Treasury_withdrawals
     * const { count } = await prisma.treasury_withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends treasury_withdrawalDeleteManyArgs>(args?: SelectSubset<T, treasury_withdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasury_withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treasury_withdrawals
     * const treasury_withdrawal = await prisma.treasury_withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends treasury_withdrawalUpdateManyArgs>(args: SelectSubset<T, treasury_withdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasury_withdrawals and returns the data updated in the database.
     * @param {treasury_withdrawalUpdateManyAndReturnArgs} args - Arguments to update many Treasury_withdrawals.
     * @example
     * // Update many Treasury_withdrawals
     * const treasury_withdrawal = await prisma.treasury_withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Treasury_withdrawals and only return the `id`
     * const treasury_withdrawalWithIdOnly = await prisma.treasury_withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends treasury_withdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, treasury_withdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Treasury_withdrawal.
     * @param {treasury_withdrawalUpsertArgs} args - Arguments to update or create a Treasury_withdrawal.
     * @example
     * // Update or create a Treasury_withdrawal
     * const treasury_withdrawal = await prisma.treasury_withdrawal.upsert({
     *   create: {
     *     // ... data to create a Treasury_withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treasury_withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends treasury_withdrawalUpsertArgs>(args: SelectSubset<T, treasury_withdrawalUpsertArgs<ExtArgs>>): Prisma__treasury_withdrawalClient<$Result.GetResult<Prisma.$treasury_withdrawalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Treasury_withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalCountArgs} args - Arguments to filter Treasury_withdrawals to count.
     * @example
     * // Count the number of Treasury_withdrawals
     * const count = await prisma.treasury_withdrawal.count({
     *   where: {
     *     // ... the filter for the Treasury_withdrawals we want to count
     *   }
     * })
    **/
    count<T extends treasury_withdrawalCountArgs>(
      args?: Subset<T, treasury_withdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Treasury_withdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treasury_withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Treasury_withdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Treasury_withdrawalAggregateArgs>(args: Subset<T, Treasury_withdrawalAggregateArgs>): Prisma.PrismaPromise<GetTreasury_withdrawalAggregateType<T>>

    /**
     * Group by Treasury_withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasury_withdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends treasury_withdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: treasury_withdrawalGroupByArgs['orderBy'] }
        : { orderBy?: treasury_withdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, treasury_withdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreasury_withdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the treasury_withdrawal model
   */
  readonly fields: treasury_withdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for treasury_withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__treasury_withdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the treasury_withdrawal model
   */ 
  interface treasury_withdrawalFieldRefs {
    readonly id: FieldRef<"treasury_withdrawal", 'BigInt'>
    readonly gov_action_proposal_id: FieldRef<"treasury_withdrawal", 'BigInt'>
    readonly stake_address_id: FieldRef<"treasury_withdrawal", 'BigInt'>
    readonly amount: FieldRef<"treasury_withdrawal", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * treasury_withdrawal findUnique
   */
  export type treasury_withdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which treasury_withdrawal to fetch.
     */
    where: treasury_withdrawalWhereUniqueInput
  }

  /**
   * treasury_withdrawal findUniqueOrThrow
   */
  export type treasury_withdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which treasury_withdrawal to fetch.
     */
    where: treasury_withdrawalWhereUniqueInput
  }

  /**
   * treasury_withdrawal findFirst
   */
  export type treasury_withdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which treasury_withdrawal to fetch.
     */
    where?: treasury_withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasury_withdrawals to fetch.
     */
    orderBy?: treasury_withdrawalOrderByWithRelationInput | treasury_withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasury_withdrawals.
     */
    cursor?: treasury_withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasury_withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasury_withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasury_withdrawals.
     */
    distinct?: Treasury_withdrawalScalarFieldEnum | Treasury_withdrawalScalarFieldEnum[]
  }

  /**
   * treasury_withdrawal findFirstOrThrow
   */
  export type treasury_withdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which treasury_withdrawal to fetch.
     */
    where?: treasury_withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasury_withdrawals to fetch.
     */
    orderBy?: treasury_withdrawalOrderByWithRelationInput | treasury_withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasury_withdrawals.
     */
    cursor?: treasury_withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasury_withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasury_withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasury_withdrawals.
     */
    distinct?: Treasury_withdrawalScalarFieldEnum | Treasury_withdrawalScalarFieldEnum[]
  }

  /**
   * treasury_withdrawal findMany
   */
  export type treasury_withdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which treasury_withdrawals to fetch.
     */
    where?: treasury_withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasury_withdrawals to fetch.
     */
    orderBy?: treasury_withdrawalOrderByWithRelationInput | treasury_withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing treasury_withdrawals.
     */
    cursor?: treasury_withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasury_withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasury_withdrawals.
     */
    skip?: number
    distinct?: Treasury_withdrawalScalarFieldEnum | Treasury_withdrawalScalarFieldEnum[]
  }

  /**
   * treasury_withdrawal create
   */
  export type treasury_withdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * The data needed to create a treasury_withdrawal.
     */
    data: XOR<treasury_withdrawalCreateInput, treasury_withdrawalUncheckedCreateInput>
  }

  /**
   * treasury_withdrawal createMany
   */
  export type treasury_withdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many treasury_withdrawals.
     */
    data: treasury_withdrawalCreateManyInput | treasury_withdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasury_withdrawal createManyAndReturn
   */
  export type treasury_withdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many treasury_withdrawals.
     */
    data: treasury_withdrawalCreateManyInput | treasury_withdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasury_withdrawal update
   */
  export type treasury_withdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * The data needed to update a treasury_withdrawal.
     */
    data: XOR<treasury_withdrawalUpdateInput, treasury_withdrawalUncheckedUpdateInput>
    /**
     * Choose, which treasury_withdrawal to update.
     */
    where: treasury_withdrawalWhereUniqueInput
  }

  /**
   * treasury_withdrawal updateMany
   */
  export type treasury_withdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update treasury_withdrawals.
     */
    data: XOR<treasury_withdrawalUpdateManyMutationInput, treasury_withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which treasury_withdrawals to update
     */
    where?: treasury_withdrawalWhereInput
    /**
     * Limit how many treasury_withdrawals to update.
     */
    limit?: number
  }

  /**
   * treasury_withdrawal updateManyAndReturn
   */
  export type treasury_withdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * The data used to update treasury_withdrawals.
     */
    data: XOR<treasury_withdrawalUpdateManyMutationInput, treasury_withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which treasury_withdrawals to update
     */
    where?: treasury_withdrawalWhereInput
    /**
     * Limit how many treasury_withdrawals to update.
     */
    limit?: number
  }

  /**
   * treasury_withdrawal upsert
   */
  export type treasury_withdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * The filter to search for the treasury_withdrawal to update in case it exists.
     */
    where: treasury_withdrawalWhereUniqueInput
    /**
     * In case the treasury_withdrawal found by the `where` argument doesn't exist, create a new treasury_withdrawal with this data.
     */
    create: XOR<treasury_withdrawalCreateInput, treasury_withdrawalUncheckedCreateInput>
    /**
     * In case the treasury_withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<treasury_withdrawalUpdateInput, treasury_withdrawalUncheckedUpdateInput>
  }

  /**
   * treasury_withdrawal delete
   */
  export type treasury_withdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
    /**
     * Filter which treasury_withdrawal to delete.
     */
    where: treasury_withdrawalWhereUniqueInput
  }

  /**
   * treasury_withdrawal deleteMany
   */
  export type treasury_withdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasury_withdrawals to delete
     */
    where?: treasury_withdrawalWhereInput
    /**
     * Limit how many treasury_withdrawals to delete.
     */
    limit?: number
  }

  /**
   * treasury_withdrawal without action
   */
  export type treasury_withdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasury_withdrawal
     */
    select?: treasury_withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasury_withdrawal
     */
    omit?: treasury_withdrawalOmit<ExtArgs> | null
  }


  /**
   * Model tx
   */

  export type AggregateTx = {
    _count: TxCountAggregateOutputType | null
    _avg: TxAvgAggregateOutputType | null
    _sum: TxSumAggregateOutputType | null
    _min: TxMinAggregateOutputType | null
    _max: TxMaxAggregateOutputType | null
  }

  export type TxAvgAggregateOutputType = {
    id: number | null
    block_id: number | null
    block_index: number | null
    out_sum: Decimal | null
    fee: Decimal | null
    deposit: number | null
    size: number | null
    invalid_before: Decimal | null
    invalid_hereafter: Decimal | null
    script_size: number | null
    treasury_donation: Decimal | null
  }

  export type TxSumAggregateOutputType = {
    id: bigint | null
    block_id: bigint | null
    block_index: number | null
    out_sum: Decimal | null
    fee: Decimal | null
    deposit: bigint | null
    size: number | null
    invalid_before: Decimal | null
    invalid_hereafter: Decimal | null
    script_size: number | null
    treasury_donation: Decimal | null
  }

  export type TxMinAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    block_id: bigint | null
    block_index: number | null
    out_sum: Decimal | null
    fee: Decimal | null
    deposit: bigint | null
    size: number | null
    invalid_before: Decimal | null
    invalid_hereafter: Decimal | null
    valid_contract: boolean | null
    script_size: number | null
    treasury_donation: Decimal | null
  }

  export type TxMaxAggregateOutputType = {
    id: bigint | null
    hash: Uint8Array | null
    block_id: bigint | null
    block_index: number | null
    out_sum: Decimal | null
    fee: Decimal | null
    deposit: bigint | null
    size: number | null
    invalid_before: Decimal | null
    invalid_hereafter: Decimal | null
    valid_contract: boolean | null
    script_size: number | null
    treasury_donation: Decimal | null
  }

  export type TxCountAggregateOutputType = {
    id: number
    hash: number
    block_id: number
    block_index: number
    out_sum: number
    fee: number
    deposit: number
    size: number
    invalid_before: number
    invalid_hereafter: number
    valid_contract: number
    script_size: number
    treasury_donation: number
    _all: number
  }


  export type TxAvgAggregateInputType = {
    id?: true
    block_id?: true
    block_index?: true
    out_sum?: true
    fee?: true
    deposit?: true
    size?: true
    invalid_before?: true
    invalid_hereafter?: true
    script_size?: true
    treasury_donation?: true
  }

  export type TxSumAggregateInputType = {
    id?: true
    block_id?: true
    block_index?: true
    out_sum?: true
    fee?: true
    deposit?: true
    size?: true
    invalid_before?: true
    invalid_hereafter?: true
    script_size?: true
    treasury_donation?: true
  }

  export type TxMinAggregateInputType = {
    id?: true
    hash?: true
    block_id?: true
    block_index?: true
    out_sum?: true
    fee?: true
    deposit?: true
    size?: true
    invalid_before?: true
    invalid_hereafter?: true
    valid_contract?: true
    script_size?: true
    treasury_donation?: true
  }

  export type TxMaxAggregateInputType = {
    id?: true
    hash?: true
    block_id?: true
    block_index?: true
    out_sum?: true
    fee?: true
    deposit?: true
    size?: true
    invalid_before?: true
    invalid_hereafter?: true
    valid_contract?: true
    script_size?: true
    treasury_donation?: true
  }

  export type TxCountAggregateInputType = {
    id?: true
    hash?: true
    block_id?: true
    block_index?: true
    out_sum?: true
    fee?: true
    deposit?: true
    size?: true
    invalid_before?: true
    invalid_hereafter?: true
    valid_contract?: true
    script_size?: true
    treasury_donation?: true
    _all?: true
  }

  export type TxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx to aggregate.
     */
    where?: txWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txes to fetch.
     */
    orderBy?: txOrderByWithRelationInput | txOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: txWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned txes
    **/
    _count?: true | TxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TxMaxAggregateInputType
  }

  export type GetTxAggregateType<T extends TxAggregateArgs> = {
        [P in keyof T & keyof AggregateTx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTx[P]>
      : GetScalarType<T[P], AggregateTx[P]>
  }




  export type txGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: txWhereInput
    orderBy?: txOrderByWithAggregationInput | txOrderByWithAggregationInput[]
    by: TxScalarFieldEnum[] | TxScalarFieldEnum
    having?: txScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TxCountAggregateInputType | true
    _avg?: TxAvgAggregateInputType
    _sum?: TxSumAggregateInputType
    _min?: TxMinAggregateInputType
    _max?: TxMaxAggregateInputType
  }

  export type TxGroupByOutputType = {
    id: bigint
    hash: Uint8Array
    block_id: bigint
    block_index: number
    out_sum: Decimal
    fee: Decimal
    deposit: bigint | null
    size: number
    invalid_before: Decimal | null
    invalid_hereafter: Decimal | null
    valid_contract: boolean
    script_size: number
    treasury_donation: Decimal
    _count: TxCountAggregateOutputType | null
    _avg: TxAvgAggregateOutputType | null
    _sum: TxSumAggregateOutputType | null
    _min: TxMinAggregateOutputType | null
    _max: TxMaxAggregateOutputType | null
  }

  type GetTxGroupByPayload<T extends txGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TxGroupByOutputType[P]>
            : GetScalarType<T[P], TxGroupByOutputType[P]>
        }
      >
    >


  export type txSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    block_id?: boolean
    block_index?: boolean
    out_sum?: boolean
    fee?: boolean
    deposit?: boolean
    size?: boolean
    invalid_before?: boolean
    invalid_hereafter?: boolean
    valid_contract?: boolean
    script_size?: boolean
    treasury_donation?: boolean
  }, ExtArgs["result"]["tx"]>

  export type txSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    block_id?: boolean
    block_index?: boolean
    out_sum?: boolean
    fee?: boolean
    deposit?: boolean
    size?: boolean
    invalid_before?: boolean
    invalid_hereafter?: boolean
    valid_contract?: boolean
    script_size?: boolean
    treasury_donation?: boolean
  }, ExtArgs["result"]["tx"]>

  export type txSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hash?: boolean
    block_id?: boolean
    block_index?: boolean
    out_sum?: boolean
    fee?: boolean
    deposit?: boolean
    size?: boolean
    invalid_before?: boolean
    invalid_hereafter?: boolean
    valid_contract?: boolean
    script_size?: boolean
    treasury_donation?: boolean
  }, ExtArgs["result"]["tx"]>

  export type txSelectScalar = {
    id?: boolean
    hash?: boolean
    block_id?: boolean
    block_index?: boolean
    out_sum?: boolean
    fee?: boolean
    deposit?: boolean
    size?: boolean
    invalid_before?: boolean
    invalid_hereafter?: boolean
    valid_contract?: boolean
    script_size?: boolean
    treasury_donation?: boolean
  }

  export type txOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hash" | "block_id" | "block_index" | "out_sum" | "fee" | "deposit" | "size" | "invalid_before" | "invalid_hereafter" | "valid_contract" | "script_size" | "treasury_donation", ExtArgs["result"]["tx"]>

  export type $txPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tx"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      hash: Uint8Array
      block_id: bigint
      block_index: number
      out_sum: Prisma.Decimal
      fee: Prisma.Decimal
      deposit: bigint | null
      size: number
      invalid_before: Prisma.Decimal | null
      invalid_hereafter: Prisma.Decimal | null
      valid_contract: boolean
      script_size: number
      treasury_donation: Prisma.Decimal
    }, ExtArgs["result"]["tx"]>
    composites: {}
  }

  type txGetPayload<S extends boolean | null | undefined | txDefaultArgs> = $Result.GetResult<Prisma.$txPayload, S>

  type txCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<txFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TxCountAggregateInputType | true
    }

  export interface txDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tx'], meta: { name: 'tx' } }
    /**
     * Find zero or one Tx that matches the filter.
     * @param {txFindUniqueArgs} args - Arguments to find a Tx
     * @example
     * // Get one Tx
     * const tx = await prisma.tx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends txFindUniqueArgs>(args: SelectSubset<T, txFindUniqueArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tx that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {txFindUniqueOrThrowArgs} args - Arguments to find a Tx
     * @example
     * // Get one Tx
     * const tx = await prisma.tx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends txFindUniqueOrThrowArgs>(args: SelectSubset<T, txFindUniqueOrThrowArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txFindFirstArgs} args - Arguments to find a Tx
     * @example
     * // Get one Tx
     * const tx = await prisma.tx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends txFindFirstArgs>(args?: SelectSubset<T, txFindFirstArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tx that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txFindFirstOrThrowArgs} args - Arguments to find a Tx
     * @example
     * // Get one Tx
     * const tx = await prisma.tx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends txFindFirstOrThrowArgs>(args?: SelectSubset<T, txFindFirstOrThrowArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Txes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Txes
     * const txes = await prisma.tx.findMany()
     * 
     * // Get first 10 Txes
     * const txes = await prisma.tx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const txWithIdOnly = await prisma.tx.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends txFindManyArgs>(args?: SelectSubset<T, txFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tx.
     * @param {txCreateArgs} args - Arguments to create a Tx.
     * @example
     * // Create one Tx
     * const Tx = await prisma.tx.create({
     *   data: {
     *     // ... data to create a Tx
     *   }
     * })
     * 
     */
    create<T extends txCreateArgs>(args: SelectSubset<T, txCreateArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Txes.
     * @param {txCreateManyArgs} args - Arguments to create many Txes.
     * @example
     * // Create many Txes
     * const tx = await prisma.tx.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends txCreateManyArgs>(args?: SelectSubset<T, txCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Txes and returns the data saved in the database.
     * @param {txCreateManyAndReturnArgs} args - Arguments to create many Txes.
     * @example
     * // Create many Txes
     * const tx = await prisma.tx.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Txes and only return the `id`
     * const txWithIdOnly = await prisma.tx.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends txCreateManyAndReturnArgs>(args?: SelectSubset<T, txCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tx.
     * @param {txDeleteArgs} args - Arguments to delete one Tx.
     * @example
     * // Delete one Tx
     * const Tx = await prisma.tx.delete({
     *   where: {
     *     // ... filter to delete one Tx
     *   }
     * })
     * 
     */
    delete<T extends txDeleteArgs>(args: SelectSubset<T, txDeleteArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tx.
     * @param {txUpdateArgs} args - Arguments to update one Tx.
     * @example
     * // Update one Tx
     * const tx = await prisma.tx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends txUpdateArgs>(args: SelectSubset<T, txUpdateArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Txes.
     * @param {txDeleteManyArgs} args - Arguments to filter Txes to delete.
     * @example
     * // Delete a few Txes
     * const { count } = await prisma.tx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends txDeleteManyArgs>(args?: SelectSubset<T, txDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Txes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Txes
     * const tx = await prisma.tx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends txUpdateManyArgs>(args: SelectSubset<T, txUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Txes and returns the data updated in the database.
     * @param {txUpdateManyAndReturnArgs} args - Arguments to update many Txes.
     * @example
     * // Update many Txes
     * const tx = await prisma.tx.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Txes and only return the `id`
     * const txWithIdOnly = await prisma.tx.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends txUpdateManyAndReturnArgs>(args: SelectSubset<T, txUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tx.
     * @param {txUpsertArgs} args - Arguments to update or create a Tx.
     * @example
     * // Update or create a Tx
     * const tx = await prisma.tx.upsert({
     *   create: {
     *     // ... data to create a Tx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tx we want to update
     *   }
     * })
     */
    upsert<T extends txUpsertArgs>(args: SelectSubset<T, txUpsertArgs<ExtArgs>>): Prisma__txClient<$Result.GetResult<Prisma.$txPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Txes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txCountArgs} args - Arguments to filter Txes to count.
     * @example
     * // Count the number of Txes
     * const count = await prisma.tx.count({
     *   where: {
     *     // ... the filter for the Txes we want to count
     *   }
     * })
    **/
    count<T extends txCountArgs>(
      args?: Subset<T, txCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TxAggregateArgs>(args: Subset<T, TxAggregateArgs>): Prisma.PrismaPromise<GetTxAggregateType<T>>

    /**
     * Group by Tx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends txGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: txGroupByArgs['orderBy'] }
        : { orderBy?: txGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, txGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tx model
   */
  readonly fields: txFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__txClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tx model
   */ 
  interface txFieldRefs {
    readonly id: FieldRef<"tx", 'BigInt'>
    readonly hash: FieldRef<"tx", 'Bytes'>
    readonly block_id: FieldRef<"tx", 'BigInt'>
    readonly block_index: FieldRef<"tx", 'Int'>
    readonly out_sum: FieldRef<"tx", 'Decimal'>
    readonly fee: FieldRef<"tx", 'Decimal'>
    readonly deposit: FieldRef<"tx", 'BigInt'>
    readonly size: FieldRef<"tx", 'Int'>
    readonly invalid_before: FieldRef<"tx", 'Decimal'>
    readonly invalid_hereafter: FieldRef<"tx", 'Decimal'>
    readonly valid_contract: FieldRef<"tx", 'Boolean'>
    readonly script_size: FieldRef<"tx", 'Int'>
    readonly treasury_donation: FieldRef<"tx", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * tx findUnique
   */
  export type txFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter, which tx to fetch.
     */
    where: txWhereUniqueInput
  }

  /**
   * tx findUniqueOrThrow
   */
  export type txFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter, which tx to fetch.
     */
    where: txWhereUniqueInput
  }

  /**
   * tx findFirst
   */
  export type txFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter, which tx to fetch.
     */
    where?: txWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txes to fetch.
     */
    orderBy?: txOrderByWithRelationInput | txOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for txes.
     */
    cursor?: txWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of txes.
     */
    distinct?: TxScalarFieldEnum | TxScalarFieldEnum[]
  }

  /**
   * tx findFirstOrThrow
   */
  export type txFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter, which tx to fetch.
     */
    where?: txWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txes to fetch.
     */
    orderBy?: txOrderByWithRelationInput | txOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for txes.
     */
    cursor?: txWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of txes.
     */
    distinct?: TxScalarFieldEnum | TxScalarFieldEnum[]
  }

  /**
   * tx findMany
   */
  export type txFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter, which txes to fetch.
     */
    where?: txWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txes to fetch.
     */
    orderBy?: txOrderByWithRelationInput | txOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing txes.
     */
    cursor?: txWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txes.
     */
    skip?: number
    distinct?: TxScalarFieldEnum | TxScalarFieldEnum[]
  }

  /**
   * tx create
   */
  export type txCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * The data needed to create a tx.
     */
    data: XOR<txCreateInput, txUncheckedCreateInput>
  }

  /**
   * tx createMany
   */
  export type txCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many txes.
     */
    data: txCreateManyInput | txCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx createManyAndReturn
   */
  export type txCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * The data used to create many txes.
     */
    data: txCreateManyInput | txCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx update
   */
  export type txUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * The data needed to update a tx.
     */
    data: XOR<txUpdateInput, txUncheckedUpdateInput>
    /**
     * Choose, which tx to update.
     */
    where: txWhereUniqueInput
  }

  /**
   * tx updateMany
   */
  export type txUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update txes.
     */
    data: XOR<txUpdateManyMutationInput, txUncheckedUpdateManyInput>
    /**
     * Filter which txes to update
     */
    where?: txWhereInput
    /**
     * Limit how many txes to update.
     */
    limit?: number
  }

  /**
   * tx updateManyAndReturn
   */
  export type txUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * The data used to update txes.
     */
    data: XOR<txUpdateManyMutationInput, txUncheckedUpdateManyInput>
    /**
     * Filter which txes to update
     */
    where?: txWhereInput
    /**
     * Limit how many txes to update.
     */
    limit?: number
  }

  /**
   * tx upsert
   */
  export type txUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * The filter to search for the tx to update in case it exists.
     */
    where: txWhereUniqueInput
    /**
     * In case the tx found by the `where` argument doesn't exist, create a new tx with this data.
     */
    create: XOR<txCreateInput, txUncheckedCreateInput>
    /**
     * In case the tx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<txUpdateInput, txUncheckedUpdateInput>
  }

  /**
   * tx delete
   */
  export type txDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
    /**
     * Filter which tx to delete.
     */
    where: txWhereUniqueInput
  }

  /**
   * tx deleteMany
   */
  export type txDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which txes to delete
     */
    where?: txWhereInput
    /**
     * Limit how many txes to delete.
     */
    limit?: number
  }

  /**
   * tx without action
   */
  export type txDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx
     */
    select?: txSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx
     */
    omit?: txOmit<ExtArgs> | null
  }


  /**
   * Model tx_cbor
   */

  export type AggregateTx_cbor = {
    _count: Tx_cborCountAggregateOutputType | null
    _avg: Tx_cborAvgAggregateOutputType | null
    _sum: Tx_cborSumAggregateOutputType | null
    _min: Tx_cborMinAggregateOutputType | null
    _max: Tx_cborMaxAggregateOutputType | null
  }

  export type Tx_cborAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
  }

  export type Tx_cborSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
  }

  export type Tx_cborMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type Tx_cborMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    bytes: Uint8Array | null
  }

  export type Tx_cborCountAggregateOutputType = {
    id: number
    tx_id: number
    bytes: number
    _all: number
  }


  export type Tx_cborAvgAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Tx_cborSumAggregateInputType = {
    id?: true
    tx_id?: true
  }

  export type Tx_cborMinAggregateInputType = {
    id?: true
    tx_id?: true
    bytes?: true
  }

  export type Tx_cborMaxAggregateInputType = {
    id?: true
    tx_id?: true
    bytes?: true
  }

  export type Tx_cborCountAggregateInputType = {
    id?: true
    tx_id?: true
    bytes?: true
    _all?: true
  }

  export type Tx_cborAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_cbor to aggregate.
     */
    where?: tx_cborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_cbors to fetch.
     */
    orderBy?: tx_cborOrderByWithRelationInput | tx_cborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tx_cborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_cbors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_cbors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tx_cbors
    **/
    _count?: true | Tx_cborCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tx_cborAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tx_cborSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tx_cborMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tx_cborMaxAggregateInputType
  }

  export type GetTx_cborAggregateType<T extends Tx_cborAggregateArgs> = {
        [P in keyof T & keyof AggregateTx_cbor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTx_cbor[P]>
      : GetScalarType<T[P], AggregateTx_cbor[P]>
  }




  export type tx_cborGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tx_cborWhereInput
    orderBy?: tx_cborOrderByWithAggregationInput | tx_cborOrderByWithAggregationInput[]
    by: Tx_cborScalarFieldEnum[] | Tx_cborScalarFieldEnum
    having?: tx_cborScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tx_cborCountAggregateInputType | true
    _avg?: Tx_cborAvgAggregateInputType
    _sum?: Tx_cborSumAggregateInputType
    _min?: Tx_cborMinAggregateInputType
    _max?: Tx_cborMaxAggregateInputType
  }

  export type Tx_cborGroupByOutputType = {
    id: bigint
    tx_id: bigint
    bytes: Uint8Array
    _count: Tx_cborCountAggregateOutputType | null
    _avg: Tx_cborAvgAggregateOutputType | null
    _sum: Tx_cborSumAggregateOutputType | null
    _min: Tx_cborMinAggregateOutputType | null
    _max: Tx_cborMaxAggregateOutputType | null
  }

  type GetTx_cborGroupByPayload<T extends tx_cborGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tx_cborGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tx_cborGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tx_cborGroupByOutputType[P]>
            : GetScalarType<T[P], Tx_cborGroupByOutputType[P]>
        }
      >
    >


  export type tx_cborSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["tx_cbor"]>

  export type tx_cborSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["tx_cbor"]>

  export type tx_cborSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    bytes?: boolean
  }, ExtArgs["result"]["tx_cbor"]>

  export type tx_cborSelectScalar = {
    id?: boolean
    tx_id?: boolean
    bytes?: boolean
  }

  export type tx_cborOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "bytes", ExtArgs["result"]["tx_cbor"]>

  export type $tx_cborPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tx_cbor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      bytes: Uint8Array
    }, ExtArgs["result"]["tx_cbor"]>
    composites: {}
  }

  type tx_cborGetPayload<S extends boolean | null | undefined | tx_cborDefaultArgs> = $Result.GetResult<Prisma.$tx_cborPayload, S>

  type tx_cborCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tx_cborFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tx_cborCountAggregateInputType | true
    }

  export interface tx_cborDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tx_cbor'], meta: { name: 'tx_cbor' } }
    /**
     * Find zero or one Tx_cbor that matches the filter.
     * @param {tx_cborFindUniqueArgs} args - Arguments to find a Tx_cbor
     * @example
     * // Get one Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tx_cborFindUniqueArgs>(args: SelectSubset<T, tx_cborFindUniqueArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tx_cbor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tx_cborFindUniqueOrThrowArgs} args - Arguments to find a Tx_cbor
     * @example
     * // Get one Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tx_cborFindUniqueOrThrowArgs>(args: SelectSubset<T, tx_cborFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_cbor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborFindFirstArgs} args - Arguments to find a Tx_cbor
     * @example
     * // Get one Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tx_cborFindFirstArgs>(args?: SelectSubset<T, tx_cborFindFirstArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_cbor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborFindFirstOrThrowArgs} args - Arguments to find a Tx_cbor
     * @example
     * // Get one Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tx_cborFindFirstOrThrowArgs>(args?: SelectSubset<T, tx_cborFindFirstOrThrowArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tx_cbors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tx_cbors
     * const tx_cbors = await prisma.tx_cbor.findMany()
     * 
     * // Get first 10 Tx_cbors
     * const tx_cbors = await prisma.tx_cbor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tx_cborWithIdOnly = await prisma.tx_cbor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tx_cborFindManyArgs>(args?: SelectSubset<T, tx_cborFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tx_cbor.
     * @param {tx_cborCreateArgs} args - Arguments to create a Tx_cbor.
     * @example
     * // Create one Tx_cbor
     * const Tx_cbor = await prisma.tx_cbor.create({
     *   data: {
     *     // ... data to create a Tx_cbor
     *   }
     * })
     * 
     */
    create<T extends tx_cborCreateArgs>(args: SelectSubset<T, tx_cborCreateArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tx_cbors.
     * @param {tx_cborCreateManyArgs} args - Arguments to create many Tx_cbors.
     * @example
     * // Create many Tx_cbors
     * const tx_cbor = await prisma.tx_cbor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tx_cborCreateManyArgs>(args?: SelectSubset<T, tx_cborCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tx_cbors and returns the data saved in the database.
     * @param {tx_cborCreateManyAndReturnArgs} args - Arguments to create many Tx_cbors.
     * @example
     * // Create many Tx_cbors
     * const tx_cbor = await prisma.tx_cbor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tx_cbors and only return the `id`
     * const tx_cborWithIdOnly = await prisma.tx_cbor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tx_cborCreateManyAndReturnArgs>(args?: SelectSubset<T, tx_cborCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tx_cbor.
     * @param {tx_cborDeleteArgs} args - Arguments to delete one Tx_cbor.
     * @example
     * // Delete one Tx_cbor
     * const Tx_cbor = await prisma.tx_cbor.delete({
     *   where: {
     *     // ... filter to delete one Tx_cbor
     *   }
     * })
     * 
     */
    delete<T extends tx_cborDeleteArgs>(args: SelectSubset<T, tx_cborDeleteArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tx_cbor.
     * @param {tx_cborUpdateArgs} args - Arguments to update one Tx_cbor.
     * @example
     * // Update one Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tx_cborUpdateArgs>(args: SelectSubset<T, tx_cborUpdateArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tx_cbors.
     * @param {tx_cborDeleteManyArgs} args - Arguments to filter Tx_cbors to delete.
     * @example
     * // Delete a few Tx_cbors
     * const { count } = await prisma.tx_cbor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tx_cborDeleteManyArgs>(args?: SelectSubset<T, tx_cborDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_cbors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tx_cbors
     * const tx_cbor = await prisma.tx_cbor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tx_cborUpdateManyArgs>(args: SelectSubset<T, tx_cborUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_cbors and returns the data updated in the database.
     * @param {tx_cborUpdateManyAndReturnArgs} args - Arguments to update many Tx_cbors.
     * @example
     * // Update many Tx_cbors
     * const tx_cbor = await prisma.tx_cbor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tx_cbors and only return the `id`
     * const tx_cborWithIdOnly = await prisma.tx_cbor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tx_cborUpdateManyAndReturnArgs>(args: SelectSubset<T, tx_cborUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tx_cbor.
     * @param {tx_cborUpsertArgs} args - Arguments to update or create a Tx_cbor.
     * @example
     * // Update or create a Tx_cbor
     * const tx_cbor = await prisma.tx_cbor.upsert({
     *   create: {
     *     // ... data to create a Tx_cbor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tx_cbor we want to update
     *   }
     * })
     */
    upsert<T extends tx_cborUpsertArgs>(args: SelectSubset<T, tx_cborUpsertArgs<ExtArgs>>): Prisma__tx_cborClient<$Result.GetResult<Prisma.$tx_cborPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tx_cbors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborCountArgs} args - Arguments to filter Tx_cbors to count.
     * @example
     * // Count the number of Tx_cbors
     * const count = await prisma.tx_cbor.count({
     *   where: {
     *     // ... the filter for the Tx_cbors we want to count
     *   }
     * })
    **/
    count<T extends tx_cborCountArgs>(
      args?: Subset<T, tx_cborCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tx_cborCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tx_cbor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tx_cborAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tx_cborAggregateArgs>(args: Subset<T, Tx_cborAggregateArgs>): Prisma.PrismaPromise<GetTx_cborAggregateType<T>>

    /**
     * Group by Tx_cbor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_cborGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tx_cborGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tx_cborGroupByArgs['orderBy'] }
        : { orderBy?: tx_cborGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tx_cborGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTx_cborGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tx_cbor model
   */
  readonly fields: tx_cborFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tx_cbor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tx_cborClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tx_cbor model
   */ 
  interface tx_cborFieldRefs {
    readonly id: FieldRef<"tx_cbor", 'BigInt'>
    readonly tx_id: FieldRef<"tx_cbor", 'BigInt'>
    readonly bytes: FieldRef<"tx_cbor", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * tx_cbor findUnique
   */
  export type tx_cborFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter, which tx_cbor to fetch.
     */
    where: tx_cborWhereUniqueInput
  }

  /**
   * tx_cbor findUniqueOrThrow
   */
  export type tx_cborFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter, which tx_cbor to fetch.
     */
    where: tx_cborWhereUniqueInput
  }

  /**
   * tx_cbor findFirst
   */
  export type tx_cborFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter, which tx_cbor to fetch.
     */
    where?: tx_cborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_cbors to fetch.
     */
    orderBy?: tx_cborOrderByWithRelationInput | tx_cborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_cbors.
     */
    cursor?: tx_cborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_cbors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_cbors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_cbors.
     */
    distinct?: Tx_cborScalarFieldEnum | Tx_cborScalarFieldEnum[]
  }

  /**
   * tx_cbor findFirstOrThrow
   */
  export type tx_cborFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter, which tx_cbor to fetch.
     */
    where?: tx_cborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_cbors to fetch.
     */
    orderBy?: tx_cborOrderByWithRelationInput | tx_cborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_cbors.
     */
    cursor?: tx_cborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_cbors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_cbors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_cbors.
     */
    distinct?: Tx_cborScalarFieldEnum | Tx_cborScalarFieldEnum[]
  }

  /**
   * tx_cbor findMany
   */
  export type tx_cborFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter, which tx_cbors to fetch.
     */
    where?: tx_cborWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_cbors to fetch.
     */
    orderBy?: tx_cborOrderByWithRelationInput | tx_cborOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tx_cbors.
     */
    cursor?: tx_cborWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_cbors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_cbors.
     */
    skip?: number
    distinct?: Tx_cborScalarFieldEnum | Tx_cborScalarFieldEnum[]
  }

  /**
   * tx_cbor create
   */
  export type tx_cborCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * The data needed to create a tx_cbor.
     */
    data: XOR<tx_cborCreateInput, tx_cborUncheckedCreateInput>
  }

  /**
   * tx_cbor createMany
   */
  export type tx_cborCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tx_cbors.
     */
    data: tx_cborCreateManyInput | tx_cborCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_cbor createManyAndReturn
   */
  export type tx_cborCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * The data used to create many tx_cbors.
     */
    data: tx_cborCreateManyInput | tx_cborCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_cbor update
   */
  export type tx_cborUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * The data needed to update a tx_cbor.
     */
    data: XOR<tx_cborUpdateInput, tx_cborUncheckedUpdateInput>
    /**
     * Choose, which tx_cbor to update.
     */
    where: tx_cborWhereUniqueInput
  }

  /**
   * tx_cbor updateMany
   */
  export type tx_cborUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tx_cbors.
     */
    data: XOR<tx_cborUpdateManyMutationInput, tx_cborUncheckedUpdateManyInput>
    /**
     * Filter which tx_cbors to update
     */
    where?: tx_cborWhereInput
    /**
     * Limit how many tx_cbors to update.
     */
    limit?: number
  }

  /**
   * tx_cbor updateManyAndReturn
   */
  export type tx_cborUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * The data used to update tx_cbors.
     */
    data: XOR<tx_cborUpdateManyMutationInput, tx_cborUncheckedUpdateManyInput>
    /**
     * Filter which tx_cbors to update
     */
    where?: tx_cborWhereInput
    /**
     * Limit how many tx_cbors to update.
     */
    limit?: number
  }

  /**
   * tx_cbor upsert
   */
  export type tx_cborUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * The filter to search for the tx_cbor to update in case it exists.
     */
    where: tx_cborWhereUniqueInput
    /**
     * In case the tx_cbor found by the `where` argument doesn't exist, create a new tx_cbor with this data.
     */
    create: XOR<tx_cborCreateInput, tx_cborUncheckedCreateInput>
    /**
     * In case the tx_cbor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tx_cborUpdateInput, tx_cborUncheckedUpdateInput>
  }

  /**
   * tx_cbor delete
   */
  export type tx_cborDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
    /**
     * Filter which tx_cbor to delete.
     */
    where: tx_cborWhereUniqueInput
  }

  /**
   * tx_cbor deleteMany
   */
  export type tx_cborDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_cbors to delete
     */
    where?: tx_cborWhereInput
    /**
     * Limit how many tx_cbors to delete.
     */
    limit?: number
  }

  /**
   * tx_cbor without action
   */
  export type tx_cborDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_cbor
     */
    select?: tx_cborSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_cbor
     */
    omit?: tx_cborOmit<ExtArgs> | null
  }


  /**
   * Model tx_in
   */

  export type AggregateTx_in = {
    _count: Tx_inCountAggregateOutputType | null
    _avg: Tx_inAvgAggregateOutputType | null
    _sum: Tx_inSumAggregateOutputType | null
    _min: Tx_inMinAggregateOutputType | null
    _max: Tx_inMaxAggregateOutputType | null
  }

  export type Tx_inAvgAggregateOutputType = {
    id: number | null
    tx_in_id: number | null
    tx_out_id: number | null
    tx_out_index: number | null
    redeemer_id: number | null
  }

  export type Tx_inSumAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
    redeemer_id: bigint | null
  }

  export type Tx_inMinAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
    redeemer_id: bigint | null
  }

  export type Tx_inMaxAggregateOutputType = {
    id: bigint | null
    tx_in_id: bigint | null
    tx_out_id: bigint | null
    tx_out_index: number | null
    redeemer_id: bigint | null
  }

  export type Tx_inCountAggregateOutputType = {
    id: number
    tx_in_id: number
    tx_out_id: number
    tx_out_index: number
    redeemer_id: number
    _all: number
  }


  export type Tx_inAvgAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    redeemer_id?: true
  }

  export type Tx_inSumAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    redeemer_id?: true
  }

  export type Tx_inMinAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    redeemer_id?: true
  }

  export type Tx_inMaxAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    redeemer_id?: true
  }

  export type Tx_inCountAggregateInputType = {
    id?: true
    tx_in_id?: true
    tx_out_id?: true
    tx_out_index?: true
    redeemer_id?: true
    _all?: true
  }

  export type Tx_inAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_in to aggregate.
     */
    where?: tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_ins to fetch.
     */
    orderBy?: tx_inOrderByWithRelationInput | tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tx_ins
    **/
    _count?: true | Tx_inCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tx_inAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tx_inSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tx_inMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tx_inMaxAggregateInputType
  }

  export type GetTx_inAggregateType<T extends Tx_inAggregateArgs> = {
        [P in keyof T & keyof AggregateTx_in]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTx_in[P]>
      : GetScalarType<T[P], AggregateTx_in[P]>
  }




  export type tx_inGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tx_inWhereInput
    orderBy?: tx_inOrderByWithAggregationInput | tx_inOrderByWithAggregationInput[]
    by: Tx_inScalarFieldEnum[] | Tx_inScalarFieldEnum
    having?: tx_inScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tx_inCountAggregateInputType | true
    _avg?: Tx_inAvgAggregateInputType
    _sum?: Tx_inSumAggregateInputType
    _min?: Tx_inMinAggregateInputType
    _max?: Tx_inMaxAggregateInputType
  }

  export type Tx_inGroupByOutputType = {
    id: bigint
    tx_in_id: bigint
    tx_out_id: bigint
    tx_out_index: number
    redeemer_id: bigint | null
    _count: Tx_inCountAggregateOutputType | null
    _avg: Tx_inAvgAggregateOutputType | null
    _sum: Tx_inSumAggregateOutputType | null
    _min: Tx_inMinAggregateOutputType | null
    _max: Tx_inMaxAggregateOutputType | null
  }

  type GetTx_inGroupByPayload<T extends tx_inGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tx_inGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tx_inGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tx_inGroupByOutputType[P]>
            : GetScalarType<T[P], Tx_inGroupByOutputType[P]>
        }
      >
    >


  export type tx_inSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["tx_in"]>

  export type tx_inSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["tx_in"]>

  export type tx_inSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
    redeemer_id?: boolean
  }, ExtArgs["result"]["tx_in"]>

  export type tx_inSelectScalar = {
    id?: boolean
    tx_in_id?: boolean
    tx_out_id?: boolean
    tx_out_index?: boolean
    redeemer_id?: boolean
  }

  export type tx_inOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_in_id" | "tx_out_id" | "tx_out_index" | "redeemer_id", ExtArgs["result"]["tx_in"]>

  export type $tx_inPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tx_in"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_in_id: bigint
      tx_out_id: bigint
      tx_out_index: number
      redeemer_id: bigint | null
    }, ExtArgs["result"]["tx_in"]>
    composites: {}
  }

  type tx_inGetPayload<S extends boolean | null | undefined | tx_inDefaultArgs> = $Result.GetResult<Prisma.$tx_inPayload, S>

  type tx_inCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tx_inFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tx_inCountAggregateInputType | true
    }

  export interface tx_inDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tx_in'], meta: { name: 'tx_in' } }
    /**
     * Find zero or one Tx_in that matches the filter.
     * @param {tx_inFindUniqueArgs} args - Arguments to find a Tx_in
     * @example
     * // Get one Tx_in
     * const tx_in = await prisma.tx_in.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tx_inFindUniqueArgs>(args: SelectSubset<T, tx_inFindUniqueArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tx_in that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tx_inFindUniqueOrThrowArgs} args - Arguments to find a Tx_in
     * @example
     * // Get one Tx_in
     * const tx_in = await prisma.tx_in.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tx_inFindUniqueOrThrowArgs>(args: SelectSubset<T, tx_inFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_in that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inFindFirstArgs} args - Arguments to find a Tx_in
     * @example
     * // Get one Tx_in
     * const tx_in = await prisma.tx_in.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tx_inFindFirstArgs>(args?: SelectSubset<T, tx_inFindFirstArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_in that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inFindFirstOrThrowArgs} args - Arguments to find a Tx_in
     * @example
     * // Get one Tx_in
     * const tx_in = await prisma.tx_in.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tx_inFindFirstOrThrowArgs>(args?: SelectSubset<T, tx_inFindFirstOrThrowArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tx_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tx_ins
     * const tx_ins = await prisma.tx_in.findMany()
     * 
     * // Get first 10 Tx_ins
     * const tx_ins = await prisma.tx_in.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tx_inWithIdOnly = await prisma.tx_in.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tx_inFindManyArgs>(args?: SelectSubset<T, tx_inFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tx_in.
     * @param {tx_inCreateArgs} args - Arguments to create a Tx_in.
     * @example
     * // Create one Tx_in
     * const Tx_in = await prisma.tx_in.create({
     *   data: {
     *     // ... data to create a Tx_in
     *   }
     * })
     * 
     */
    create<T extends tx_inCreateArgs>(args: SelectSubset<T, tx_inCreateArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tx_ins.
     * @param {tx_inCreateManyArgs} args - Arguments to create many Tx_ins.
     * @example
     * // Create many Tx_ins
     * const tx_in = await prisma.tx_in.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tx_inCreateManyArgs>(args?: SelectSubset<T, tx_inCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tx_ins and returns the data saved in the database.
     * @param {tx_inCreateManyAndReturnArgs} args - Arguments to create many Tx_ins.
     * @example
     * // Create many Tx_ins
     * const tx_in = await prisma.tx_in.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tx_ins and only return the `id`
     * const tx_inWithIdOnly = await prisma.tx_in.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tx_inCreateManyAndReturnArgs>(args?: SelectSubset<T, tx_inCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tx_in.
     * @param {tx_inDeleteArgs} args - Arguments to delete one Tx_in.
     * @example
     * // Delete one Tx_in
     * const Tx_in = await prisma.tx_in.delete({
     *   where: {
     *     // ... filter to delete one Tx_in
     *   }
     * })
     * 
     */
    delete<T extends tx_inDeleteArgs>(args: SelectSubset<T, tx_inDeleteArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tx_in.
     * @param {tx_inUpdateArgs} args - Arguments to update one Tx_in.
     * @example
     * // Update one Tx_in
     * const tx_in = await prisma.tx_in.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tx_inUpdateArgs>(args: SelectSubset<T, tx_inUpdateArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tx_ins.
     * @param {tx_inDeleteManyArgs} args - Arguments to filter Tx_ins to delete.
     * @example
     * // Delete a few Tx_ins
     * const { count } = await prisma.tx_in.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tx_inDeleteManyArgs>(args?: SelectSubset<T, tx_inDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tx_ins
     * const tx_in = await prisma.tx_in.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tx_inUpdateManyArgs>(args: SelectSubset<T, tx_inUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_ins and returns the data updated in the database.
     * @param {tx_inUpdateManyAndReturnArgs} args - Arguments to update many Tx_ins.
     * @example
     * // Update many Tx_ins
     * const tx_in = await prisma.tx_in.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tx_ins and only return the `id`
     * const tx_inWithIdOnly = await prisma.tx_in.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tx_inUpdateManyAndReturnArgs>(args: SelectSubset<T, tx_inUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tx_in.
     * @param {tx_inUpsertArgs} args - Arguments to update or create a Tx_in.
     * @example
     * // Update or create a Tx_in
     * const tx_in = await prisma.tx_in.upsert({
     *   create: {
     *     // ... data to create a Tx_in
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tx_in we want to update
     *   }
     * })
     */
    upsert<T extends tx_inUpsertArgs>(args: SelectSubset<T, tx_inUpsertArgs<ExtArgs>>): Prisma__tx_inClient<$Result.GetResult<Prisma.$tx_inPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tx_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inCountArgs} args - Arguments to filter Tx_ins to count.
     * @example
     * // Count the number of Tx_ins
     * const count = await prisma.tx_in.count({
     *   where: {
     *     // ... the filter for the Tx_ins we want to count
     *   }
     * })
    **/
    count<T extends tx_inCountArgs>(
      args?: Subset<T, tx_inCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tx_inCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tx_inAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tx_inAggregateArgs>(args: Subset<T, Tx_inAggregateArgs>): Prisma.PrismaPromise<GetTx_inAggregateType<T>>

    /**
     * Group by Tx_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_inGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tx_inGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tx_inGroupByArgs['orderBy'] }
        : { orderBy?: tx_inGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tx_inGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTx_inGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tx_in model
   */
  readonly fields: tx_inFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tx_in.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tx_inClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tx_in model
   */ 
  interface tx_inFieldRefs {
    readonly id: FieldRef<"tx_in", 'BigInt'>
    readonly tx_in_id: FieldRef<"tx_in", 'BigInt'>
    readonly tx_out_id: FieldRef<"tx_in", 'BigInt'>
    readonly tx_out_index: FieldRef<"tx_in", 'Int'>
    readonly redeemer_id: FieldRef<"tx_in", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * tx_in findUnique
   */
  export type tx_inFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter, which tx_in to fetch.
     */
    where: tx_inWhereUniqueInput
  }

  /**
   * tx_in findUniqueOrThrow
   */
  export type tx_inFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter, which tx_in to fetch.
     */
    where: tx_inWhereUniqueInput
  }

  /**
   * tx_in findFirst
   */
  export type tx_inFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter, which tx_in to fetch.
     */
    where?: tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_ins to fetch.
     */
    orderBy?: tx_inOrderByWithRelationInput | tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_ins.
     */
    cursor?: tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_ins.
     */
    distinct?: Tx_inScalarFieldEnum | Tx_inScalarFieldEnum[]
  }

  /**
   * tx_in findFirstOrThrow
   */
  export type tx_inFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter, which tx_in to fetch.
     */
    where?: tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_ins to fetch.
     */
    orderBy?: tx_inOrderByWithRelationInput | tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_ins.
     */
    cursor?: tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_ins.
     */
    distinct?: Tx_inScalarFieldEnum | Tx_inScalarFieldEnum[]
  }

  /**
   * tx_in findMany
   */
  export type tx_inFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter, which tx_ins to fetch.
     */
    where?: tx_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_ins to fetch.
     */
    orderBy?: tx_inOrderByWithRelationInput | tx_inOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tx_ins.
     */
    cursor?: tx_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_ins.
     */
    skip?: number
    distinct?: Tx_inScalarFieldEnum | Tx_inScalarFieldEnum[]
  }

  /**
   * tx_in create
   */
  export type tx_inCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * The data needed to create a tx_in.
     */
    data: XOR<tx_inCreateInput, tx_inUncheckedCreateInput>
  }

  /**
   * tx_in createMany
   */
  export type tx_inCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tx_ins.
     */
    data: tx_inCreateManyInput | tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_in createManyAndReturn
   */
  export type tx_inCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * The data used to create many tx_ins.
     */
    data: tx_inCreateManyInput | tx_inCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_in update
   */
  export type tx_inUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * The data needed to update a tx_in.
     */
    data: XOR<tx_inUpdateInput, tx_inUncheckedUpdateInput>
    /**
     * Choose, which tx_in to update.
     */
    where: tx_inWhereUniqueInput
  }

  /**
   * tx_in updateMany
   */
  export type tx_inUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tx_ins.
     */
    data: XOR<tx_inUpdateManyMutationInput, tx_inUncheckedUpdateManyInput>
    /**
     * Filter which tx_ins to update
     */
    where?: tx_inWhereInput
    /**
     * Limit how many tx_ins to update.
     */
    limit?: number
  }

  /**
   * tx_in updateManyAndReturn
   */
  export type tx_inUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * The data used to update tx_ins.
     */
    data: XOR<tx_inUpdateManyMutationInput, tx_inUncheckedUpdateManyInput>
    /**
     * Filter which tx_ins to update
     */
    where?: tx_inWhereInput
    /**
     * Limit how many tx_ins to update.
     */
    limit?: number
  }

  /**
   * tx_in upsert
   */
  export type tx_inUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * The filter to search for the tx_in to update in case it exists.
     */
    where: tx_inWhereUniqueInput
    /**
     * In case the tx_in found by the `where` argument doesn't exist, create a new tx_in with this data.
     */
    create: XOR<tx_inCreateInput, tx_inUncheckedCreateInput>
    /**
     * In case the tx_in was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tx_inUpdateInput, tx_inUncheckedUpdateInput>
  }

  /**
   * tx_in delete
   */
  export type tx_inDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
    /**
     * Filter which tx_in to delete.
     */
    where: tx_inWhereUniqueInput
  }

  /**
   * tx_in deleteMany
   */
  export type tx_inDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_ins to delete
     */
    where?: tx_inWhereInput
    /**
     * Limit how many tx_ins to delete.
     */
    limit?: number
  }

  /**
   * tx_in without action
   */
  export type tx_inDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_in
     */
    select?: tx_inSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_in
     */
    omit?: tx_inOmit<ExtArgs> | null
  }


  /**
   * Model tx_metadata
   */

  export type AggregateTx_metadata = {
    _count: Tx_metadataCountAggregateOutputType | null
    _avg: Tx_metadataAvgAggregateOutputType | null
    _sum: Tx_metadataSumAggregateOutputType | null
    _min: Tx_metadataMinAggregateOutputType | null
    _max: Tx_metadataMaxAggregateOutputType | null
  }

  export type Tx_metadataAvgAggregateOutputType = {
    id: number | null
    key: Decimal | null
    tx_id: number | null
  }

  export type Tx_metadataSumAggregateOutputType = {
    id: bigint | null
    key: Decimal | null
    tx_id: bigint | null
  }

  export type Tx_metadataMinAggregateOutputType = {
    id: bigint | null
    key: Decimal | null
    bytes: Uint8Array | null
    tx_id: bigint | null
  }

  export type Tx_metadataMaxAggregateOutputType = {
    id: bigint | null
    key: Decimal | null
    bytes: Uint8Array | null
    tx_id: bigint | null
  }

  export type Tx_metadataCountAggregateOutputType = {
    id: number
    key: number
    json: number
    bytes: number
    tx_id: number
    _all: number
  }


  export type Tx_metadataAvgAggregateInputType = {
    id?: true
    key?: true
    tx_id?: true
  }

  export type Tx_metadataSumAggregateInputType = {
    id?: true
    key?: true
    tx_id?: true
  }

  export type Tx_metadataMinAggregateInputType = {
    id?: true
    key?: true
    bytes?: true
    tx_id?: true
  }

  export type Tx_metadataMaxAggregateInputType = {
    id?: true
    key?: true
    bytes?: true
    tx_id?: true
  }

  export type Tx_metadataCountAggregateInputType = {
    id?: true
    key?: true
    json?: true
    bytes?: true
    tx_id?: true
    _all?: true
  }

  export type Tx_metadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_metadata to aggregate.
     */
    where?: tx_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_metadata to fetch.
     */
    orderBy?: tx_metadataOrderByWithRelationInput | tx_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tx_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tx_metadata
    **/
    _count?: true | Tx_metadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tx_metadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tx_metadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tx_metadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tx_metadataMaxAggregateInputType
  }

  export type GetTx_metadataAggregateType<T extends Tx_metadataAggregateArgs> = {
        [P in keyof T & keyof AggregateTx_metadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTx_metadata[P]>
      : GetScalarType<T[P], AggregateTx_metadata[P]>
  }




  export type tx_metadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tx_metadataWhereInput
    orderBy?: tx_metadataOrderByWithAggregationInput | tx_metadataOrderByWithAggregationInput[]
    by: Tx_metadataScalarFieldEnum[] | Tx_metadataScalarFieldEnum
    having?: tx_metadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tx_metadataCountAggregateInputType | true
    _avg?: Tx_metadataAvgAggregateInputType
    _sum?: Tx_metadataSumAggregateInputType
    _min?: Tx_metadataMinAggregateInputType
    _max?: Tx_metadataMaxAggregateInputType
  }

  export type Tx_metadataGroupByOutputType = {
    id: bigint
    key: Decimal
    json: JsonValue | null
    bytes: Uint8Array
    tx_id: bigint
    _count: Tx_metadataCountAggregateOutputType | null
    _avg: Tx_metadataAvgAggregateOutputType | null
    _sum: Tx_metadataSumAggregateOutputType | null
    _min: Tx_metadataMinAggregateOutputType | null
    _max: Tx_metadataMaxAggregateOutputType | null
  }

  type GetTx_metadataGroupByPayload<T extends tx_metadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tx_metadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tx_metadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tx_metadataGroupByOutputType[P]>
            : GetScalarType<T[P], Tx_metadataGroupByOutputType[P]>
        }
      >
    >


  export type tx_metadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    json?: boolean
    bytes?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["tx_metadata"]>

  export type tx_metadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    json?: boolean
    bytes?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["tx_metadata"]>

  export type tx_metadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    json?: boolean
    bytes?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["tx_metadata"]>

  export type tx_metadataSelectScalar = {
    id?: boolean
    key?: boolean
    json?: boolean
    bytes?: boolean
    tx_id?: boolean
  }

  export type tx_metadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "json" | "bytes" | "tx_id", ExtArgs["result"]["tx_metadata"]>

  export type $tx_metadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tx_metadata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      key: Prisma.Decimal
      json: Prisma.JsonValue | null
      bytes: Uint8Array
      tx_id: bigint
    }, ExtArgs["result"]["tx_metadata"]>
    composites: {}
  }

  type tx_metadataGetPayload<S extends boolean | null | undefined | tx_metadataDefaultArgs> = $Result.GetResult<Prisma.$tx_metadataPayload, S>

  type tx_metadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tx_metadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tx_metadataCountAggregateInputType | true
    }

  export interface tx_metadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tx_metadata'], meta: { name: 'tx_metadata' } }
    /**
     * Find zero or one Tx_metadata that matches the filter.
     * @param {tx_metadataFindUniqueArgs} args - Arguments to find a Tx_metadata
     * @example
     * // Get one Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tx_metadataFindUniqueArgs>(args: SelectSubset<T, tx_metadataFindUniqueArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tx_metadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tx_metadataFindUniqueOrThrowArgs} args - Arguments to find a Tx_metadata
     * @example
     * // Get one Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tx_metadataFindUniqueOrThrowArgs>(args: SelectSubset<T, tx_metadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataFindFirstArgs} args - Arguments to find a Tx_metadata
     * @example
     * // Get one Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tx_metadataFindFirstArgs>(args?: SelectSubset<T, tx_metadataFindFirstArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_metadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataFindFirstOrThrowArgs} args - Arguments to find a Tx_metadata
     * @example
     * // Get one Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tx_metadataFindFirstOrThrowArgs>(args?: SelectSubset<T, tx_metadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tx_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findMany()
     * 
     * // Get first 10 Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tx_metadataWithIdOnly = await prisma.tx_metadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tx_metadataFindManyArgs>(args?: SelectSubset<T, tx_metadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tx_metadata.
     * @param {tx_metadataCreateArgs} args - Arguments to create a Tx_metadata.
     * @example
     * // Create one Tx_metadata
     * const Tx_metadata = await prisma.tx_metadata.create({
     *   data: {
     *     // ... data to create a Tx_metadata
     *   }
     * })
     * 
     */
    create<T extends tx_metadataCreateArgs>(args: SelectSubset<T, tx_metadataCreateArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tx_metadata.
     * @param {tx_metadataCreateManyArgs} args - Arguments to create many Tx_metadata.
     * @example
     * // Create many Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tx_metadataCreateManyArgs>(args?: SelectSubset<T, tx_metadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tx_metadata and returns the data saved in the database.
     * @param {tx_metadataCreateManyAndReturnArgs} args - Arguments to create many Tx_metadata.
     * @example
     * // Create many Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tx_metadata and only return the `id`
     * const tx_metadataWithIdOnly = await prisma.tx_metadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tx_metadataCreateManyAndReturnArgs>(args?: SelectSubset<T, tx_metadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tx_metadata.
     * @param {tx_metadataDeleteArgs} args - Arguments to delete one Tx_metadata.
     * @example
     * // Delete one Tx_metadata
     * const Tx_metadata = await prisma.tx_metadata.delete({
     *   where: {
     *     // ... filter to delete one Tx_metadata
     *   }
     * })
     * 
     */
    delete<T extends tx_metadataDeleteArgs>(args: SelectSubset<T, tx_metadataDeleteArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tx_metadata.
     * @param {tx_metadataUpdateArgs} args - Arguments to update one Tx_metadata.
     * @example
     * // Update one Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tx_metadataUpdateArgs>(args: SelectSubset<T, tx_metadataUpdateArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tx_metadata.
     * @param {tx_metadataDeleteManyArgs} args - Arguments to filter Tx_metadata to delete.
     * @example
     * // Delete a few Tx_metadata
     * const { count } = await prisma.tx_metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tx_metadataDeleteManyArgs>(args?: SelectSubset<T, tx_metadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tx_metadataUpdateManyArgs>(args: SelectSubset<T, tx_metadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_metadata and returns the data updated in the database.
     * @param {tx_metadataUpdateManyAndReturnArgs} args - Arguments to update many Tx_metadata.
     * @example
     * // Update many Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tx_metadata and only return the `id`
     * const tx_metadataWithIdOnly = await prisma.tx_metadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tx_metadataUpdateManyAndReturnArgs>(args: SelectSubset<T, tx_metadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tx_metadata.
     * @param {tx_metadataUpsertArgs} args - Arguments to update or create a Tx_metadata.
     * @example
     * // Update or create a Tx_metadata
     * const tx_metadata = await prisma.tx_metadata.upsert({
     *   create: {
     *     // ... data to create a Tx_metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tx_metadata we want to update
     *   }
     * })
     */
    upsert<T extends tx_metadataUpsertArgs>(args: SelectSubset<T, tx_metadataUpsertArgs<ExtArgs>>): Prisma__tx_metadataClient<$Result.GetResult<Prisma.$tx_metadataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tx_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataCountArgs} args - Arguments to filter Tx_metadata to count.
     * @example
     * // Count the number of Tx_metadata
     * const count = await prisma.tx_metadata.count({
     *   where: {
     *     // ... the filter for the Tx_metadata we want to count
     *   }
     * })
    **/
    count<T extends tx_metadataCountArgs>(
      args?: Subset<T, tx_metadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tx_metadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tx_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tx_metadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tx_metadataAggregateArgs>(args: Subset<T, Tx_metadataAggregateArgs>): Prisma.PrismaPromise<GetTx_metadataAggregateType<T>>

    /**
     * Group by Tx_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_metadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tx_metadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tx_metadataGroupByArgs['orderBy'] }
        : { orderBy?: tx_metadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tx_metadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTx_metadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tx_metadata model
   */
  readonly fields: tx_metadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tx_metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tx_metadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tx_metadata model
   */ 
  interface tx_metadataFieldRefs {
    readonly id: FieldRef<"tx_metadata", 'BigInt'>
    readonly key: FieldRef<"tx_metadata", 'Decimal'>
    readonly json: FieldRef<"tx_metadata", 'Json'>
    readonly bytes: FieldRef<"tx_metadata", 'Bytes'>
    readonly tx_id: FieldRef<"tx_metadata", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * tx_metadata findUnique
   */
  export type tx_metadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter, which tx_metadata to fetch.
     */
    where: tx_metadataWhereUniqueInput
  }

  /**
   * tx_metadata findUniqueOrThrow
   */
  export type tx_metadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter, which tx_metadata to fetch.
     */
    where: tx_metadataWhereUniqueInput
  }

  /**
   * tx_metadata findFirst
   */
  export type tx_metadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter, which tx_metadata to fetch.
     */
    where?: tx_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_metadata to fetch.
     */
    orderBy?: tx_metadataOrderByWithRelationInput | tx_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_metadata.
     */
    cursor?: tx_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_metadata.
     */
    distinct?: Tx_metadataScalarFieldEnum | Tx_metadataScalarFieldEnum[]
  }

  /**
   * tx_metadata findFirstOrThrow
   */
  export type tx_metadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter, which tx_metadata to fetch.
     */
    where?: tx_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_metadata to fetch.
     */
    orderBy?: tx_metadataOrderByWithRelationInput | tx_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_metadata.
     */
    cursor?: tx_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_metadata.
     */
    distinct?: Tx_metadataScalarFieldEnum | Tx_metadataScalarFieldEnum[]
  }

  /**
   * tx_metadata findMany
   */
  export type tx_metadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter, which tx_metadata to fetch.
     */
    where?: tx_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_metadata to fetch.
     */
    orderBy?: tx_metadataOrderByWithRelationInput | tx_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tx_metadata.
     */
    cursor?: tx_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_metadata.
     */
    skip?: number
    distinct?: Tx_metadataScalarFieldEnum | Tx_metadataScalarFieldEnum[]
  }

  /**
   * tx_metadata create
   */
  export type tx_metadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * The data needed to create a tx_metadata.
     */
    data: XOR<tx_metadataCreateInput, tx_metadataUncheckedCreateInput>
  }

  /**
   * tx_metadata createMany
   */
  export type tx_metadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tx_metadata.
     */
    data: tx_metadataCreateManyInput | tx_metadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_metadata createManyAndReturn
   */
  export type tx_metadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * The data used to create many tx_metadata.
     */
    data: tx_metadataCreateManyInput | tx_metadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_metadata update
   */
  export type tx_metadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * The data needed to update a tx_metadata.
     */
    data: XOR<tx_metadataUpdateInput, tx_metadataUncheckedUpdateInput>
    /**
     * Choose, which tx_metadata to update.
     */
    where: tx_metadataWhereUniqueInput
  }

  /**
   * tx_metadata updateMany
   */
  export type tx_metadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tx_metadata.
     */
    data: XOR<tx_metadataUpdateManyMutationInput, tx_metadataUncheckedUpdateManyInput>
    /**
     * Filter which tx_metadata to update
     */
    where?: tx_metadataWhereInput
    /**
     * Limit how many tx_metadata to update.
     */
    limit?: number
  }

  /**
   * tx_metadata updateManyAndReturn
   */
  export type tx_metadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * The data used to update tx_metadata.
     */
    data: XOR<tx_metadataUpdateManyMutationInput, tx_metadataUncheckedUpdateManyInput>
    /**
     * Filter which tx_metadata to update
     */
    where?: tx_metadataWhereInput
    /**
     * Limit how many tx_metadata to update.
     */
    limit?: number
  }

  /**
   * tx_metadata upsert
   */
  export type tx_metadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * The filter to search for the tx_metadata to update in case it exists.
     */
    where: tx_metadataWhereUniqueInput
    /**
     * In case the tx_metadata found by the `where` argument doesn't exist, create a new tx_metadata with this data.
     */
    create: XOR<tx_metadataCreateInput, tx_metadataUncheckedCreateInput>
    /**
     * In case the tx_metadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tx_metadataUpdateInput, tx_metadataUncheckedUpdateInput>
  }

  /**
   * tx_metadata delete
   */
  export type tx_metadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
    /**
     * Filter which tx_metadata to delete.
     */
    where: tx_metadataWhereUniqueInput
  }

  /**
   * tx_metadata deleteMany
   */
  export type tx_metadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_metadata to delete
     */
    where?: tx_metadataWhereInput
    /**
     * Limit how many tx_metadata to delete.
     */
    limit?: number
  }

  /**
   * tx_metadata without action
   */
  export type tx_metadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_metadata
     */
    select?: tx_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_metadata
     */
    omit?: tx_metadataOmit<ExtArgs> | null
  }


  /**
   * Model tx_out
   */

  export type AggregateTx_out = {
    _count: Tx_outCountAggregateOutputType | null
    _avg: Tx_outAvgAggregateOutputType | null
    _sum: Tx_outSumAggregateOutputType | null
    _min: Tx_outMinAggregateOutputType | null
    _max: Tx_outMaxAggregateOutputType | null
  }

  export type Tx_outAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    index: number | null
    stake_address_id: number | null
    value: Decimal | null
    inline_datum_id: number | null
    reference_script_id: number | null
    consumed_by_tx_id: number | null
  }

  export type Tx_outSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    stake_address_id: bigint | null
    value: Decimal | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
    consumed_by_tx_id: bigint | null
  }

  export type Tx_outMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    address: string | null
    address_has_script: boolean | null
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal | null
    data_hash: Uint8Array | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
    consumed_by_tx_id: bigint | null
  }

  export type Tx_outMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    address: string | null
    address_has_script: boolean | null
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal | null
    data_hash: Uint8Array | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
    consumed_by_tx_id: bigint | null
  }

  export type Tx_outCountAggregateOutputType = {
    id: number
    tx_id: number
    index: number
    address: number
    address_has_script: number
    payment_cred: number
    stake_address_id: number
    value: number
    data_hash: number
    inline_datum_id: number
    reference_script_id: number
    consumed_by_tx_id: number
    _all: number
  }


  export type Tx_outAvgAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    stake_address_id?: true
    value?: true
    inline_datum_id?: true
    reference_script_id?: true
    consumed_by_tx_id?: true
  }

  export type Tx_outSumAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    stake_address_id?: true
    value?: true
    inline_datum_id?: true
    reference_script_id?: true
    consumed_by_tx_id?: true
  }

  export type Tx_outMinAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    inline_datum_id?: true
    reference_script_id?: true
    consumed_by_tx_id?: true
  }

  export type Tx_outMaxAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    inline_datum_id?: true
    reference_script_id?: true
    consumed_by_tx_id?: true
  }

  export type Tx_outCountAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    address?: true
    address_has_script?: true
    payment_cred?: true
    stake_address_id?: true
    value?: true
    data_hash?: true
    inline_datum_id?: true
    reference_script_id?: true
    consumed_by_tx_id?: true
    _all?: true
  }

  export type Tx_outAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_out to aggregate.
     */
    where?: tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_outs to fetch.
     */
    orderBy?: tx_outOrderByWithRelationInput | tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tx_outs
    **/
    _count?: true | Tx_outCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tx_outAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tx_outSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tx_outMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tx_outMaxAggregateInputType
  }

  export type GetTx_outAggregateType<T extends Tx_outAggregateArgs> = {
        [P in keyof T & keyof AggregateTx_out]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTx_out[P]>
      : GetScalarType<T[P], AggregateTx_out[P]>
  }




  export type tx_outGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tx_outWhereInput
    orderBy?: tx_outOrderByWithAggregationInput | tx_outOrderByWithAggregationInput[]
    by: Tx_outScalarFieldEnum[] | Tx_outScalarFieldEnum
    having?: tx_outScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tx_outCountAggregateInputType | true
    _avg?: Tx_outAvgAggregateInputType
    _sum?: Tx_outSumAggregateInputType
    _min?: Tx_outMinAggregateInputType
    _max?: Tx_outMaxAggregateInputType
  }

  export type Tx_outGroupByOutputType = {
    id: bigint
    tx_id: bigint
    index: number
    address: string
    address_has_script: boolean
    payment_cred: Uint8Array | null
    stake_address_id: bigint | null
    value: Decimal
    data_hash: Uint8Array | null
    inline_datum_id: bigint | null
    reference_script_id: bigint | null
    consumed_by_tx_id: bigint | null
    _count: Tx_outCountAggregateOutputType | null
    _avg: Tx_outAvgAggregateOutputType | null
    _sum: Tx_outSumAggregateOutputType | null
    _min: Tx_outMinAggregateOutputType | null
    _max: Tx_outMaxAggregateOutputType | null
  }

  type GetTx_outGroupByPayload<T extends tx_outGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tx_outGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tx_outGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tx_outGroupByOutputType[P]>
            : GetScalarType<T[P], Tx_outGroupByOutputType[P]>
        }
      >
    >


  export type tx_outSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
    consumed_by_tx_id?: boolean
  }, ExtArgs["result"]["tx_out"]>

  export type tx_outSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
    consumed_by_tx_id?: boolean
  }, ExtArgs["result"]["tx_out"]>

  export type tx_outSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
    consumed_by_tx_id?: boolean
  }, ExtArgs["result"]["tx_out"]>

  export type tx_outSelectScalar = {
    id?: boolean
    tx_id?: boolean
    index?: boolean
    address?: boolean
    address_has_script?: boolean
    payment_cred?: boolean
    stake_address_id?: boolean
    value?: boolean
    data_hash?: boolean
    inline_datum_id?: boolean
    reference_script_id?: boolean
    consumed_by_tx_id?: boolean
  }

  export type tx_outOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "index" | "address" | "address_has_script" | "payment_cred" | "stake_address_id" | "value" | "data_hash" | "inline_datum_id" | "reference_script_id" | "consumed_by_tx_id", ExtArgs["result"]["tx_out"]>

  export type $tx_outPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tx_out"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      index: number
      address: string
      address_has_script: boolean
      payment_cred: Uint8Array | null
      stake_address_id: bigint | null
      value: Prisma.Decimal
      data_hash: Uint8Array | null
      inline_datum_id: bigint | null
      reference_script_id: bigint | null
      consumed_by_tx_id: bigint | null
    }, ExtArgs["result"]["tx_out"]>
    composites: {}
  }

  type tx_outGetPayload<S extends boolean | null | undefined | tx_outDefaultArgs> = $Result.GetResult<Prisma.$tx_outPayload, S>

  type tx_outCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tx_outFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tx_outCountAggregateInputType | true
    }

  export interface tx_outDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tx_out'], meta: { name: 'tx_out' } }
    /**
     * Find zero or one Tx_out that matches the filter.
     * @param {tx_outFindUniqueArgs} args - Arguments to find a Tx_out
     * @example
     * // Get one Tx_out
     * const tx_out = await prisma.tx_out.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tx_outFindUniqueArgs>(args: SelectSubset<T, tx_outFindUniqueArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tx_out that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tx_outFindUniqueOrThrowArgs} args - Arguments to find a Tx_out
     * @example
     * // Get one Tx_out
     * const tx_out = await prisma.tx_out.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tx_outFindUniqueOrThrowArgs>(args: SelectSubset<T, tx_outFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_out that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outFindFirstArgs} args - Arguments to find a Tx_out
     * @example
     * // Get one Tx_out
     * const tx_out = await prisma.tx_out.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tx_outFindFirstArgs>(args?: SelectSubset<T, tx_outFindFirstArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tx_out that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outFindFirstOrThrowArgs} args - Arguments to find a Tx_out
     * @example
     * // Get one Tx_out
     * const tx_out = await prisma.tx_out.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tx_outFindFirstOrThrowArgs>(args?: SelectSubset<T, tx_outFindFirstOrThrowArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tx_outs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tx_outs
     * const tx_outs = await prisma.tx_out.findMany()
     * 
     * // Get first 10 Tx_outs
     * const tx_outs = await prisma.tx_out.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tx_outWithIdOnly = await prisma.tx_out.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tx_outFindManyArgs>(args?: SelectSubset<T, tx_outFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tx_out.
     * @param {tx_outCreateArgs} args - Arguments to create a Tx_out.
     * @example
     * // Create one Tx_out
     * const Tx_out = await prisma.tx_out.create({
     *   data: {
     *     // ... data to create a Tx_out
     *   }
     * })
     * 
     */
    create<T extends tx_outCreateArgs>(args: SelectSubset<T, tx_outCreateArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tx_outs.
     * @param {tx_outCreateManyArgs} args - Arguments to create many Tx_outs.
     * @example
     * // Create many Tx_outs
     * const tx_out = await prisma.tx_out.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tx_outCreateManyArgs>(args?: SelectSubset<T, tx_outCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tx_outs and returns the data saved in the database.
     * @param {tx_outCreateManyAndReturnArgs} args - Arguments to create many Tx_outs.
     * @example
     * // Create many Tx_outs
     * const tx_out = await prisma.tx_out.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tx_outs and only return the `id`
     * const tx_outWithIdOnly = await prisma.tx_out.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tx_outCreateManyAndReturnArgs>(args?: SelectSubset<T, tx_outCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tx_out.
     * @param {tx_outDeleteArgs} args - Arguments to delete one Tx_out.
     * @example
     * // Delete one Tx_out
     * const Tx_out = await prisma.tx_out.delete({
     *   where: {
     *     // ... filter to delete one Tx_out
     *   }
     * })
     * 
     */
    delete<T extends tx_outDeleteArgs>(args: SelectSubset<T, tx_outDeleteArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tx_out.
     * @param {tx_outUpdateArgs} args - Arguments to update one Tx_out.
     * @example
     * // Update one Tx_out
     * const tx_out = await prisma.tx_out.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tx_outUpdateArgs>(args: SelectSubset<T, tx_outUpdateArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tx_outs.
     * @param {tx_outDeleteManyArgs} args - Arguments to filter Tx_outs to delete.
     * @example
     * // Delete a few Tx_outs
     * const { count } = await prisma.tx_out.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tx_outDeleteManyArgs>(args?: SelectSubset<T, tx_outDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tx_outs
     * const tx_out = await prisma.tx_out.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tx_outUpdateManyArgs>(args: SelectSubset<T, tx_outUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tx_outs and returns the data updated in the database.
     * @param {tx_outUpdateManyAndReturnArgs} args - Arguments to update many Tx_outs.
     * @example
     * // Update many Tx_outs
     * const tx_out = await prisma.tx_out.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tx_outs and only return the `id`
     * const tx_outWithIdOnly = await prisma.tx_out.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tx_outUpdateManyAndReturnArgs>(args: SelectSubset<T, tx_outUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tx_out.
     * @param {tx_outUpsertArgs} args - Arguments to update or create a Tx_out.
     * @example
     * // Update or create a Tx_out
     * const tx_out = await prisma.tx_out.upsert({
     *   create: {
     *     // ... data to create a Tx_out
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tx_out we want to update
     *   }
     * })
     */
    upsert<T extends tx_outUpsertArgs>(args: SelectSubset<T, tx_outUpsertArgs<ExtArgs>>): Prisma__tx_outClient<$Result.GetResult<Prisma.$tx_outPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tx_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outCountArgs} args - Arguments to filter Tx_outs to count.
     * @example
     * // Count the number of Tx_outs
     * const count = await prisma.tx_out.count({
     *   where: {
     *     // ... the filter for the Tx_outs we want to count
     *   }
     * })
    **/
    count<T extends tx_outCountArgs>(
      args?: Subset<T, tx_outCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tx_outCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tx_outAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tx_outAggregateArgs>(args: Subset<T, Tx_outAggregateArgs>): Prisma.PrismaPromise<GetTx_outAggregateType<T>>

    /**
     * Group by Tx_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tx_outGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tx_outGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tx_outGroupByArgs['orderBy'] }
        : { orderBy?: tx_outGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tx_outGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTx_outGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tx_out model
   */
  readonly fields: tx_outFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tx_out.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tx_outClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tx_out model
   */ 
  interface tx_outFieldRefs {
    readonly id: FieldRef<"tx_out", 'BigInt'>
    readonly tx_id: FieldRef<"tx_out", 'BigInt'>
    readonly index: FieldRef<"tx_out", 'Int'>
    readonly address: FieldRef<"tx_out", 'String'>
    readonly address_has_script: FieldRef<"tx_out", 'Boolean'>
    readonly payment_cred: FieldRef<"tx_out", 'Bytes'>
    readonly stake_address_id: FieldRef<"tx_out", 'BigInt'>
    readonly value: FieldRef<"tx_out", 'Decimal'>
    readonly data_hash: FieldRef<"tx_out", 'Bytes'>
    readonly inline_datum_id: FieldRef<"tx_out", 'BigInt'>
    readonly reference_script_id: FieldRef<"tx_out", 'BigInt'>
    readonly consumed_by_tx_id: FieldRef<"tx_out", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * tx_out findUnique
   */
  export type tx_outFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter, which tx_out to fetch.
     */
    where: tx_outWhereUniqueInput
  }

  /**
   * tx_out findUniqueOrThrow
   */
  export type tx_outFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter, which tx_out to fetch.
     */
    where: tx_outWhereUniqueInput
  }

  /**
   * tx_out findFirst
   */
  export type tx_outFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter, which tx_out to fetch.
     */
    where?: tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_outs to fetch.
     */
    orderBy?: tx_outOrderByWithRelationInput | tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_outs.
     */
    cursor?: tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_outs.
     */
    distinct?: Tx_outScalarFieldEnum | Tx_outScalarFieldEnum[]
  }

  /**
   * tx_out findFirstOrThrow
   */
  export type tx_outFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter, which tx_out to fetch.
     */
    where?: tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_outs to fetch.
     */
    orderBy?: tx_outOrderByWithRelationInput | tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tx_outs.
     */
    cursor?: tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tx_outs.
     */
    distinct?: Tx_outScalarFieldEnum | Tx_outScalarFieldEnum[]
  }

  /**
   * tx_out findMany
   */
  export type tx_outFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter, which tx_outs to fetch.
     */
    where?: tx_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tx_outs to fetch.
     */
    orderBy?: tx_outOrderByWithRelationInput | tx_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tx_outs.
     */
    cursor?: tx_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tx_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tx_outs.
     */
    skip?: number
    distinct?: Tx_outScalarFieldEnum | Tx_outScalarFieldEnum[]
  }

  /**
   * tx_out create
   */
  export type tx_outCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * The data needed to create a tx_out.
     */
    data: XOR<tx_outCreateInput, tx_outUncheckedCreateInput>
  }

  /**
   * tx_out createMany
   */
  export type tx_outCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tx_outs.
     */
    data: tx_outCreateManyInput | tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_out createManyAndReturn
   */
  export type tx_outCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * The data used to create many tx_outs.
     */
    data: tx_outCreateManyInput | tx_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tx_out update
   */
  export type tx_outUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * The data needed to update a tx_out.
     */
    data: XOR<tx_outUpdateInput, tx_outUncheckedUpdateInput>
    /**
     * Choose, which tx_out to update.
     */
    where: tx_outWhereUniqueInput
  }

  /**
   * tx_out updateMany
   */
  export type tx_outUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tx_outs.
     */
    data: XOR<tx_outUpdateManyMutationInput, tx_outUncheckedUpdateManyInput>
    /**
     * Filter which tx_outs to update
     */
    where?: tx_outWhereInput
    /**
     * Limit how many tx_outs to update.
     */
    limit?: number
  }

  /**
   * tx_out updateManyAndReturn
   */
  export type tx_outUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * The data used to update tx_outs.
     */
    data: XOR<tx_outUpdateManyMutationInput, tx_outUncheckedUpdateManyInput>
    /**
     * Filter which tx_outs to update
     */
    where?: tx_outWhereInput
    /**
     * Limit how many tx_outs to update.
     */
    limit?: number
  }

  /**
   * tx_out upsert
   */
  export type tx_outUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * The filter to search for the tx_out to update in case it exists.
     */
    where: tx_outWhereUniqueInput
    /**
     * In case the tx_out found by the `where` argument doesn't exist, create a new tx_out with this data.
     */
    create: XOR<tx_outCreateInput, tx_outUncheckedCreateInput>
    /**
     * In case the tx_out was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tx_outUpdateInput, tx_outUncheckedUpdateInput>
  }

  /**
   * tx_out delete
   */
  export type tx_outDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
    /**
     * Filter which tx_out to delete.
     */
    where: tx_outWhereUniqueInput
  }

  /**
   * tx_out deleteMany
   */
  export type tx_outDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tx_outs to delete
     */
    where?: tx_outWhereInput
    /**
     * Limit how many tx_outs to delete.
     */
    limit?: number
  }

  /**
   * tx_out without action
   */
  export type tx_outDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tx_out
     */
    select?: tx_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tx_out
     */
    omit?: tx_outOmit<ExtArgs> | null
  }


  /**
   * Model voting_anchor
   */

  export type AggregateVoting_anchor = {
    _count: Voting_anchorCountAggregateOutputType | null
    _avg: Voting_anchorAvgAggregateOutputType | null
    _sum: Voting_anchorSumAggregateOutputType | null
    _min: Voting_anchorMinAggregateOutputType | null
    _max: Voting_anchorMaxAggregateOutputType | null
  }

  export type Voting_anchorAvgAggregateOutputType = {
    id: number | null
    block_id: number | null
  }

  export type Voting_anchorSumAggregateOutputType = {
    id: bigint | null
    block_id: bigint | null
  }

  export type Voting_anchorMinAggregateOutputType = {
    id: bigint | null
    url: string | null
    data_hash: Uint8Array | null
    type: $Enums.anchortype | null
    block_id: bigint | null
  }

  export type Voting_anchorMaxAggregateOutputType = {
    id: bigint | null
    url: string | null
    data_hash: Uint8Array | null
    type: $Enums.anchortype | null
    block_id: bigint | null
  }

  export type Voting_anchorCountAggregateOutputType = {
    id: number
    url: number
    data_hash: number
    type: number
    block_id: number
    _all: number
  }


  export type Voting_anchorAvgAggregateInputType = {
    id?: true
    block_id?: true
  }

  export type Voting_anchorSumAggregateInputType = {
    id?: true
    block_id?: true
  }

  export type Voting_anchorMinAggregateInputType = {
    id?: true
    url?: true
    data_hash?: true
    type?: true
    block_id?: true
  }

  export type Voting_anchorMaxAggregateInputType = {
    id?: true
    url?: true
    data_hash?: true
    type?: true
    block_id?: true
  }

  export type Voting_anchorCountAggregateInputType = {
    id?: true
    url?: true
    data_hash?: true
    type?: true
    block_id?: true
    _all?: true
  }

  export type Voting_anchorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voting_anchor to aggregate.
     */
    where?: voting_anchorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_anchors to fetch.
     */
    orderBy?: voting_anchorOrderByWithRelationInput | voting_anchorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: voting_anchorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_anchors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_anchors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned voting_anchors
    **/
    _count?: true | Voting_anchorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Voting_anchorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Voting_anchorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Voting_anchorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Voting_anchorMaxAggregateInputType
  }

  export type GetVoting_anchorAggregateType<T extends Voting_anchorAggregateArgs> = {
        [P in keyof T & keyof AggregateVoting_anchor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoting_anchor[P]>
      : GetScalarType<T[P], AggregateVoting_anchor[P]>
  }




  export type voting_anchorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: voting_anchorWhereInput
    orderBy?: voting_anchorOrderByWithAggregationInput | voting_anchorOrderByWithAggregationInput[]
    by: Voting_anchorScalarFieldEnum[] | Voting_anchorScalarFieldEnum
    having?: voting_anchorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Voting_anchorCountAggregateInputType | true
    _avg?: Voting_anchorAvgAggregateInputType
    _sum?: Voting_anchorSumAggregateInputType
    _min?: Voting_anchorMinAggregateInputType
    _max?: Voting_anchorMaxAggregateInputType
  }

  export type Voting_anchorGroupByOutputType = {
    id: bigint
    url: string
    data_hash: Uint8Array
    type: $Enums.anchortype
    block_id: bigint
    _count: Voting_anchorCountAggregateOutputType | null
    _avg: Voting_anchorAvgAggregateOutputType | null
    _sum: Voting_anchorSumAggregateOutputType | null
    _min: Voting_anchorMinAggregateOutputType | null
    _max: Voting_anchorMaxAggregateOutputType | null
  }

  type GetVoting_anchorGroupByPayload<T extends voting_anchorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Voting_anchorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Voting_anchorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Voting_anchorGroupByOutputType[P]>
            : GetScalarType<T[P], Voting_anchorGroupByOutputType[P]>
        }
      >
    >


  export type voting_anchorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    data_hash?: boolean
    type?: boolean
    block_id?: boolean
  }, ExtArgs["result"]["voting_anchor"]>

  export type voting_anchorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    data_hash?: boolean
    type?: boolean
    block_id?: boolean
  }, ExtArgs["result"]["voting_anchor"]>

  export type voting_anchorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    data_hash?: boolean
    type?: boolean
    block_id?: boolean
  }, ExtArgs["result"]["voting_anchor"]>

  export type voting_anchorSelectScalar = {
    id?: boolean
    url?: boolean
    data_hash?: boolean
    type?: boolean
    block_id?: boolean
  }

  export type voting_anchorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "data_hash" | "type" | "block_id", ExtArgs["result"]["voting_anchor"]>

  export type $voting_anchorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "voting_anchor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      url: string
      data_hash: Uint8Array
      type: $Enums.anchortype
      block_id: bigint
    }, ExtArgs["result"]["voting_anchor"]>
    composites: {}
  }

  type voting_anchorGetPayload<S extends boolean | null | undefined | voting_anchorDefaultArgs> = $Result.GetResult<Prisma.$voting_anchorPayload, S>

  type voting_anchorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<voting_anchorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Voting_anchorCountAggregateInputType | true
    }

  export interface voting_anchorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['voting_anchor'], meta: { name: 'voting_anchor' } }
    /**
     * Find zero or one Voting_anchor that matches the filter.
     * @param {voting_anchorFindUniqueArgs} args - Arguments to find a Voting_anchor
     * @example
     * // Get one Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends voting_anchorFindUniqueArgs>(args: SelectSubset<T, voting_anchorFindUniqueArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Voting_anchor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {voting_anchorFindUniqueOrThrowArgs} args - Arguments to find a Voting_anchor
     * @example
     * // Get one Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends voting_anchorFindUniqueOrThrowArgs>(args: SelectSubset<T, voting_anchorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Voting_anchor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorFindFirstArgs} args - Arguments to find a Voting_anchor
     * @example
     * // Get one Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends voting_anchorFindFirstArgs>(args?: SelectSubset<T, voting_anchorFindFirstArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Voting_anchor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorFindFirstOrThrowArgs} args - Arguments to find a Voting_anchor
     * @example
     * // Get one Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends voting_anchorFindFirstOrThrowArgs>(args?: SelectSubset<T, voting_anchorFindFirstOrThrowArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Voting_anchors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Voting_anchors
     * const voting_anchors = await prisma.voting_anchor.findMany()
     * 
     * // Get first 10 Voting_anchors
     * const voting_anchors = await prisma.voting_anchor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voting_anchorWithIdOnly = await prisma.voting_anchor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends voting_anchorFindManyArgs>(args?: SelectSubset<T, voting_anchorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Voting_anchor.
     * @param {voting_anchorCreateArgs} args - Arguments to create a Voting_anchor.
     * @example
     * // Create one Voting_anchor
     * const Voting_anchor = await prisma.voting_anchor.create({
     *   data: {
     *     // ... data to create a Voting_anchor
     *   }
     * })
     * 
     */
    create<T extends voting_anchorCreateArgs>(args: SelectSubset<T, voting_anchorCreateArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Voting_anchors.
     * @param {voting_anchorCreateManyArgs} args - Arguments to create many Voting_anchors.
     * @example
     * // Create many Voting_anchors
     * const voting_anchor = await prisma.voting_anchor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends voting_anchorCreateManyArgs>(args?: SelectSubset<T, voting_anchorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Voting_anchors and returns the data saved in the database.
     * @param {voting_anchorCreateManyAndReturnArgs} args - Arguments to create many Voting_anchors.
     * @example
     * // Create many Voting_anchors
     * const voting_anchor = await prisma.voting_anchor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Voting_anchors and only return the `id`
     * const voting_anchorWithIdOnly = await prisma.voting_anchor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends voting_anchorCreateManyAndReturnArgs>(args?: SelectSubset<T, voting_anchorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Voting_anchor.
     * @param {voting_anchorDeleteArgs} args - Arguments to delete one Voting_anchor.
     * @example
     * // Delete one Voting_anchor
     * const Voting_anchor = await prisma.voting_anchor.delete({
     *   where: {
     *     // ... filter to delete one Voting_anchor
     *   }
     * })
     * 
     */
    delete<T extends voting_anchorDeleteArgs>(args: SelectSubset<T, voting_anchorDeleteArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Voting_anchor.
     * @param {voting_anchorUpdateArgs} args - Arguments to update one Voting_anchor.
     * @example
     * // Update one Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends voting_anchorUpdateArgs>(args: SelectSubset<T, voting_anchorUpdateArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Voting_anchors.
     * @param {voting_anchorDeleteManyArgs} args - Arguments to filter Voting_anchors to delete.
     * @example
     * // Delete a few Voting_anchors
     * const { count } = await prisma.voting_anchor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends voting_anchorDeleteManyArgs>(args?: SelectSubset<T, voting_anchorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voting_anchors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Voting_anchors
     * const voting_anchor = await prisma.voting_anchor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends voting_anchorUpdateManyArgs>(args: SelectSubset<T, voting_anchorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voting_anchors and returns the data updated in the database.
     * @param {voting_anchorUpdateManyAndReturnArgs} args - Arguments to update many Voting_anchors.
     * @example
     * // Update many Voting_anchors
     * const voting_anchor = await prisma.voting_anchor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Voting_anchors and only return the `id`
     * const voting_anchorWithIdOnly = await prisma.voting_anchor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends voting_anchorUpdateManyAndReturnArgs>(args: SelectSubset<T, voting_anchorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Voting_anchor.
     * @param {voting_anchorUpsertArgs} args - Arguments to update or create a Voting_anchor.
     * @example
     * // Update or create a Voting_anchor
     * const voting_anchor = await prisma.voting_anchor.upsert({
     *   create: {
     *     // ... data to create a Voting_anchor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voting_anchor we want to update
     *   }
     * })
     */
    upsert<T extends voting_anchorUpsertArgs>(args: SelectSubset<T, voting_anchorUpsertArgs<ExtArgs>>): Prisma__voting_anchorClient<$Result.GetResult<Prisma.$voting_anchorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Voting_anchors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorCountArgs} args - Arguments to filter Voting_anchors to count.
     * @example
     * // Count the number of Voting_anchors
     * const count = await prisma.voting_anchor.count({
     *   where: {
     *     // ... the filter for the Voting_anchors we want to count
     *   }
     * })
    **/
    count<T extends voting_anchorCountArgs>(
      args?: Subset<T, voting_anchorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Voting_anchorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voting_anchor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Voting_anchorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Voting_anchorAggregateArgs>(args: Subset<T, Voting_anchorAggregateArgs>): Prisma.PrismaPromise<GetVoting_anchorAggregateType<T>>

    /**
     * Group by Voting_anchor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_anchorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends voting_anchorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: voting_anchorGroupByArgs['orderBy'] }
        : { orderBy?: voting_anchorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, voting_anchorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoting_anchorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the voting_anchor model
   */
  readonly fields: voting_anchorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for voting_anchor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__voting_anchorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the voting_anchor model
   */ 
  interface voting_anchorFieldRefs {
    readonly id: FieldRef<"voting_anchor", 'BigInt'>
    readonly url: FieldRef<"voting_anchor", 'String'>
    readonly data_hash: FieldRef<"voting_anchor", 'Bytes'>
    readonly type: FieldRef<"voting_anchor", 'anchortype'>
    readonly block_id: FieldRef<"voting_anchor", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * voting_anchor findUnique
   */
  export type voting_anchorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter, which voting_anchor to fetch.
     */
    where: voting_anchorWhereUniqueInput
  }

  /**
   * voting_anchor findUniqueOrThrow
   */
  export type voting_anchorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter, which voting_anchor to fetch.
     */
    where: voting_anchorWhereUniqueInput
  }

  /**
   * voting_anchor findFirst
   */
  export type voting_anchorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter, which voting_anchor to fetch.
     */
    where?: voting_anchorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_anchors to fetch.
     */
    orderBy?: voting_anchorOrderByWithRelationInput | voting_anchorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voting_anchors.
     */
    cursor?: voting_anchorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_anchors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_anchors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voting_anchors.
     */
    distinct?: Voting_anchorScalarFieldEnum | Voting_anchorScalarFieldEnum[]
  }

  /**
   * voting_anchor findFirstOrThrow
   */
  export type voting_anchorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter, which voting_anchor to fetch.
     */
    where?: voting_anchorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_anchors to fetch.
     */
    orderBy?: voting_anchorOrderByWithRelationInput | voting_anchorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voting_anchors.
     */
    cursor?: voting_anchorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_anchors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_anchors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voting_anchors.
     */
    distinct?: Voting_anchorScalarFieldEnum | Voting_anchorScalarFieldEnum[]
  }

  /**
   * voting_anchor findMany
   */
  export type voting_anchorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter, which voting_anchors to fetch.
     */
    where?: voting_anchorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_anchors to fetch.
     */
    orderBy?: voting_anchorOrderByWithRelationInput | voting_anchorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing voting_anchors.
     */
    cursor?: voting_anchorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_anchors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_anchors.
     */
    skip?: number
    distinct?: Voting_anchorScalarFieldEnum | Voting_anchorScalarFieldEnum[]
  }

  /**
   * voting_anchor create
   */
  export type voting_anchorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * The data needed to create a voting_anchor.
     */
    data: XOR<voting_anchorCreateInput, voting_anchorUncheckedCreateInput>
  }

  /**
   * voting_anchor createMany
   */
  export type voting_anchorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many voting_anchors.
     */
    data: voting_anchorCreateManyInput | voting_anchorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voting_anchor createManyAndReturn
   */
  export type voting_anchorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * The data used to create many voting_anchors.
     */
    data: voting_anchorCreateManyInput | voting_anchorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voting_anchor update
   */
  export type voting_anchorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * The data needed to update a voting_anchor.
     */
    data: XOR<voting_anchorUpdateInput, voting_anchorUncheckedUpdateInput>
    /**
     * Choose, which voting_anchor to update.
     */
    where: voting_anchorWhereUniqueInput
  }

  /**
   * voting_anchor updateMany
   */
  export type voting_anchorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update voting_anchors.
     */
    data: XOR<voting_anchorUpdateManyMutationInput, voting_anchorUncheckedUpdateManyInput>
    /**
     * Filter which voting_anchors to update
     */
    where?: voting_anchorWhereInput
    /**
     * Limit how many voting_anchors to update.
     */
    limit?: number
  }

  /**
   * voting_anchor updateManyAndReturn
   */
  export type voting_anchorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * The data used to update voting_anchors.
     */
    data: XOR<voting_anchorUpdateManyMutationInput, voting_anchorUncheckedUpdateManyInput>
    /**
     * Filter which voting_anchors to update
     */
    where?: voting_anchorWhereInput
    /**
     * Limit how many voting_anchors to update.
     */
    limit?: number
  }

  /**
   * voting_anchor upsert
   */
  export type voting_anchorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * The filter to search for the voting_anchor to update in case it exists.
     */
    where: voting_anchorWhereUniqueInput
    /**
     * In case the voting_anchor found by the `where` argument doesn't exist, create a new voting_anchor with this data.
     */
    create: XOR<voting_anchorCreateInput, voting_anchorUncheckedCreateInput>
    /**
     * In case the voting_anchor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<voting_anchorUpdateInput, voting_anchorUncheckedUpdateInput>
  }

  /**
   * voting_anchor delete
   */
  export type voting_anchorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
    /**
     * Filter which voting_anchor to delete.
     */
    where: voting_anchorWhereUniqueInput
  }

  /**
   * voting_anchor deleteMany
   */
  export type voting_anchorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voting_anchors to delete
     */
    where?: voting_anchorWhereInput
    /**
     * Limit how many voting_anchors to delete.
     */
    limit?: number
  }

  /**
   * voting_anchor without action
   */
  export type voting_anchorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_anchor
     */
    select?: voting_anchorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_anchor
     */
    omit?: voting_anchorOmit<ExtArgs> | null
  }


  /**
   * Model voting_procedure
   */

  export type AggregateVoting_procedure = {
    _count: Voting_procedureCountAggregateOutputType | null
    _avg: Voting_procedureAvgAggregateOutputType | null
    _sum: Voting_procedureSumAggregateOutputType | null
    _min: Voting_procedureMinAggregateOutputType | null
    _max: Voting_procedureMaxAggregateOutputType | null
  }

  export type Voting_procedureAvgAggregateOutputType = {
    id: number | null
    tx_id: number | null
    index: number | null
    gov_action_proposal_id: number | null
    drep_voter: number | null
    pool_voter: number | null
    voting_anchor_id: number | null
    committee_voter: number | null
    invalid: number | null
  }

  export type Voting_procedureSumAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    gov_action_proposal_id: bigint | null
    drep_voter: bigint | null
    pool_voter: bigint | null
    voting_anchor_id: bigint | null
    committee_voter: bigint | null
    invalid: bigint | null
  }

  export type Voting_procedureMinAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    gov_action_proposal_id: bigint | null
    voter_role: $Enums.voterrole | null
    drep_voter: bigint | null
    pool_voter: bigint | null
    vote: $Enums.vote | null
    voting_anchor_id: bigint | null
    committee_voter: bigint | null
    invalid: bigint | null
  }

  export type Voting_procedureMaxAggregateOutputType = {
    id: bigint | null
    tx_id: bigint | null
    index: number | null
    gov_action_proposal_id: bigint | null
    voter_role: $Enums.voterrole | null
    drep_voter: bigint | null
    pool_voter: bigint | null
    vote: $Enums.vote | null
    voting_anchor_id: bigint | null
    committee_voter: bigint | null
    invalid: bigint | null
  }

  export type Voting_procedureCountAggregateOutputType = {
    id: number
    tx_id: number
    index: number
    gov_action_proposal_id: number
    voter_role: number
    drep_voter: number
    pool_voter: number
    vote: number
    voting_anchor_id: number
    committee_voter: number
    invalid: number
    _all: number
  }


  export type Voting_procedureAvgAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    gov_action_proposal_id?: true
    drep_voter?: true
    pool_voter?: true
    voting_anchor_id?: true
    committee_voter?: true
    invalid?: true
  }

  export type Voting_procedureSumAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    gov_action_proposal_id?: true
    drep_voter?: true
    pool_voter?: true
    voting_anchor_id?: true
    committee_voter?: true
    invalid?: true
  }

  export type Voting_procedureMinAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    gov_action_proposal_id?: true
    voter_role?: true
    drep_voter?: true
    pool_voter?: true
    vote?: true
    voting_anchor_id?: true
    committee_voter?: true
    invalid?: true
  }

  export type Voting_procedureMaxAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    gov_action_proposal_id?: true
    voter_role?: true
    drep_voter?: true
    pool_voter?: true
    vote?: true
    voting_anchor_id?: true
    committee_voter?: true
    invalid?: true
  }

  export type Voting_procedureCountAggregateInputType = {
    id?: true
    tx_id?: true
    index?: true
    gov_action_proposal_id?: true
    voter_role?: true
    drep_voter?: true
    pool_voter?: true
    vote?: true
    voting_anchor_id?: true
    committee_voter?: true
    invalid?: true
    _all?: true
  }

  export type Voting_procedureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voting_procedure to aggregate.
     */
    where?: voting_procedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_procedures to fetch.
     */
    orderBy?: voting_procedureOrderByWithRelationInput | voting_procedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: voting_procedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned voting_procedures
    **/
    _count?: true | Voting_procedureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Voting_procedureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Voting_procedureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Voting_procedureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Voting_procedureMaxAggregateInputType
  }

  export type GetVoting_procedureAggregateType<T extends Voting_procedureAggregateArgs> = {
        [P in keyof T & keyof AggregateVoting_procedure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoting_procedure[P]>
      : GetScalarType<T[P], AggregateVoting_procedure[P]>
  }




  export type voting_procedureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: voting_procedureWhereInput
    orderBy?: voting_procedureOrderByWithAggregationInput | voting_procedureOrderByWithAggregationInput[]
    by: Voting_procedureScalarFieldEnum[] | Voting_procedureScalarFieldEnum
    having?: voting_procedureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Voting_procedureCountAggregateInputType | true
    _avg?: Voting_procedureAvgAggregateInputType
    _sum?: Voting_procedureSumAggregateInputType
    _min?: Voting_procedureMinAggregateInputType
    _max?: Voting_procedureMaxAggregateInputType
  }

  export type Voting_procedureGroupByOutputType = {
    id: bigint
    tx_id: bigint
    index: number
    gov_action_proposal_id: bigint
    voter_role: $Enums.voterrole
    drep_voter: bigint | null
    pool_voter: bigint | null
    vote: $Enums.vote
    voting_anchor_id: bigint | null
    committee_voter: bigint | null
    invalid: bigint | null
    _count: Voting_procedureCountAggregateOutputType | null
    _avg: Voting_procedureAvgAggregateOutputType | null
    _sum: Voting_procedureSumAggregateOutputType | null
    _min: Voting_procedureMinAggregateOutputType | null
    _max: Voting_procedureMaxAggregateOutputType | null
  }

  type GetVoting_procedureGroupByPayload<T extends voting_procedureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Voting_procedureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Voting_procedureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Voting_procedureGroupByOutputType[P]>
            : GetScalarType<T[P], Voting_procedureGroupByOutputType[P]>
        }
      >
    >


  export type voting_procedureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    gov_action_proposal_id?: boolean
    voter_role?: boolean
    drep_voter?: boolean
    pool_voter?: boolean
    vote?: boolean
    voting_anchor_id?: boolean
    committee_voter?: boolean
    invalid?: boolean
  }, ExtArgs["result"]["voting_procedure"]>

  export type voting_procedureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    gov_action_proposal_id?: boolean
    voter_role?: boolean
    drep_voter?: boolean
    pool_voter?: boolean
    vote?: boolean
    voting_anchor_id?: boolean
    committee_voter?: boolean
    invalid?: boolean
  }, ExtArgs["result"]["voting_procedure"]>

  export type voting_procedureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tx_id?: boolean
    index?: boolean
    gov_action_proposal_id?: boolean
    voter_role?: boolean
    drep_voter?: boolean
    pool_voter?: boolean
    vote?: boolean
    voting_anchor_id?: boolean
    committee_voter?: boolean
    invalid?: boolean
  }, ExtArgs["result"]["voting_procedure"]>

  export type voting_procedureSelectScalar = {
    id?: boolean
    tx_id?: boolean
    index?: boolean
    gov_action_proposal_id?: boolean
    voter_role?: boolean
    drep_voter?: boolean
    pool_voter?: boolean
    vote?: boolean
    voting_anchor_id?: boolean
    committee_voter?: boolean
    invalid?: boolean
  }

  export type voting_procedureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tx_id" | "index" | "gov_action_proposal_id" | "voter_role" | "drep_voter" | "pool_voter" | "vote" | "voting_anchor_id" | "committee_voter" | "invalid", ExtArgs["result"]["voting_procedure"]>

  export type $voting_procedurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "voting_procedure"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      tx_id: bigint
      index: number
      gov_action_proposal_id: bigint
      voter_role: $Enums.voterrole
      drep_voter: bigint | null
      pool_voter: bigint | null
      vote: $Enums.vote
      voting_anchor_id: bigint | null
      committee_voter: bigint | null
      invalid: bigint | null
    }, ExtArgs["result"]["voting_procedure"]>
    composites: {}
  }

  type voting_procedureGetPayload<S extends boolean | null | undefined | voting_procedureDefaultArgs> = $Result.GetResult<Prisma.$voting_procedurePayload, S>

  type voting_procedureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<voting_procedureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Voting_procedureCountAggregateInputType | true
    }

  export interface voting_procedureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['voting_procedure'], meta: { name: 'voting_procedure' } }
    /**
     * Find zero or one Voting_procedure that matches the filter.
     * @param {voting_procedureFindUniqueArgs} args - Arguments to find a Voting_procedure
     * @example
     * // Get one Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends voting_procedureFindUniqueArgs>(args: SelectSubset<T, voting_procedureFindUniqueArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Voting_procedure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {voting_procedureFindUniqueOrThrowArgs} args - Arguments to find a Voting_procedure
     * @example
     * // Get one Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends voting_procedureFindUniqueOrThrowArgs>(args: SelectSubset<T, voting_procedureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Voting_procedure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureFindFirstArgs} args - Arguments to find a Voting_procedure
     * @example
     * // Get one Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends voting_procedureFindFirstArgs>(args?: SelectSubset<T, voting_procedureFindFirstArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Voting_procedure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureFindFirstOrThrowArgs} args - Arguments to find a Voting_procedure
     * @example
     * // Get one Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends voting_procedureFindFirstOrThrowArgs>(args?: SelectSubset<T, voting_procedureFindFirstOrThrowArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Voting_procedures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Voting_procedures
     * const voting_procedures = await prisma.voting_procedure.findMany()
     * 
     * // Get first 10 Voting_procedures
     * const voting_procedures = await prisma.voting_procedure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voting_procedureWithIdOnly = await prisma.voting_procedure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends voting_procedureFindManyArgs>(args?: SelectSubset<T, voting_procedureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Voting_procedure.
     * @param {voting_procedureCreateArgs} args - Arguments to create a Voting_procedure.
     * @example
     * // Create one Voting_procedure
     * const Voting_procedure = await prisma.voting_procedure.create({
     *   data: {
     *     // ... data to create a Voting_procedure
     *   }
     * })
     * 
     */
    create<T extends voting_procedureCreateArgs>(args: SelectSubset<T, voting_procedureCreateArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Voting_procedures.
     * @param {voting_procedureCreateManyArgs} args - Arguments to create many Voting_procedures.
     * @example
     * // Create many Voting_procedures
     * const voting_procedure = await prisma.voting_procedure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends voting_procedureCreateManyArgs>(args?: SelectSubset<T, voting_procedureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Voting_procedures and returns the data saved in the database.
     * @param {voting_procedureCreateManyAndReturnArgs} args - Arguments to create many Voting_procedures.
     * @example
     * // Create many Voting_procedures
     * const voting_procedure = await prisma.voting_procedure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Voting_procedures and only return the `id`
     * const voting_procedureWithIdOnly = await prisma.voting_procedure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends voting_procedureCreateManyAndReturnArgs>(args?: SelectSubset<T, voting_procedureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Voting_procedure.
     * @param {voting_procedureDeleteArgs} args - Arguments to delete one Voting_procedure.
     * @example
     * // Delete one Voting_procedure
     * const Voting_procedure = await prisma.voting_procedure.delete({
     *   where: {
     *     // ... filter to delete one Voting_procedure
     *   }
     * })
     * 
     */
    delete<T extends voting_procedureDeleteArgs>(args: SelectSubset<T, voting_procedureDeleteArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Voting_procedure.
     * @param {voting_procedureUpdateArgs} args - Arguments to update one Voting_procedure.
     * @example
     * // Update one Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends voting_procedureUpdateArgs>(args: SelectSubset<T, voting_procedureUpdateArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Voting_procedures.
     * @param {voting_procedureDeleteManyArgs} args - Arguments to filter Voting_procedures to delete.
     * @example
     * // Delete a few Voting_procedures
     * const { count } = await prisma.voting_procedure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends voting_procedureDeleteManyArgs>(args?: SelectSubset<T, voting_procedureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voting_procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Voting_procedures
     * const voting_procedure = await prisma.voting_procedure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends voting_procedureUpdateManyArgs>(args: SelectSubset<T, voting_procedureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voting_procedures and returns the data updated in the database.
     * @param {voting_procedureUpdateManyAndReturnArgs} args - Arguments to update many Voting_procedures.
     * @example
     * // Update many Voting_procedures
     * const voting_procedure = await prisma.voting_procedure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Voting_procedures and only return the `id`
     * const voting_procedureWithIdOnly = await prisma.voting_procedure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends voting_procedureUpdateManyAndReturnArgs>(args: SelectSubset<T, voting_procedureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Voting_procedure.
     * @param {voting_procedureUpsertArgs} args - Arguments to update or create a Voting_procedure.
     * @example
     * // Update or create a Voting_procedure
     * const voting_procedure = await prisma.voting_procedure.upsert({
     *   create: {
     *     // ... data to create a Voting_procedure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voting_procedure we want to update
     *   }
     * })
     */
    upsert<T extends voting_procedureUpsertArgs>(args: SelectSubset<T, voting_procedureUpsertArgs<ExtArgs>>): Prisma__voting_procedureClient<$Result.GetResult<Prisma.$voting_procedurePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Voting_procedures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureCountArgs} args - Arguments to filter Voting_procedures to count.
     * @example
     * // Count the number of Voting_procedures
     * const count = await prisma.voting_procedure.count({
     *   where: {
     *     // ... the filter for the Voting_procedures we want to count
     *   }
     * })
    **/
    count<T extends voting_procedureCountArgs>(
      args?: Subset<T, voting_procedureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Voting_procedureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voting_procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Voting_procedureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Voting_procedureAggregateArgs>(args: Subset<T, Voting_procedureAggregateArgs>): Prisma.PrismaPromise<GetVoting_procedureAggregateType<T>>

    /**
     * Group by Voting_procedure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {voting_procedureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends voting_procedureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: voting_procedureGroupByArgs['orderBy'] }
        : { orderBy?: voting_procedureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, voting_procedureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoting_procedureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the voting_procedure model
   */
  readonly fields: voting_procedureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for voting_procedure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__voting_procedureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the voting_procedure model
   */ 
  interface voting_procedureFieldRefs {
    readonly id: FieldRef<"voting_procedure", 'BigInt'>
    readonly tx_id: FieldRef<"voting_procedure", 'BigInt'>
    readonly index: FieldRef<"voting_procedure", 'Int'>
    readonly gov_action_proposal_id: FieldRef<"voting_procedure", 'BigInt'>
    readonly voter_role: FieldRef<"voting_procedure", 'voterrole'>
    readonly drep_voter: FieldRef<"voting_procedure", 'BigInt'>
    readonly pool_voter: FieldRef<"voting_procedure", 'BigInt'>
    readonly vote: FieldRef<"voting_procedure", 'vote'>
    readonly voting_anchor_id: FieldRef<"voting_procedure", 'BigInt'>
    readonly committee_voter: FieldRef<"voting_procedure", 'BigInt'>
    readonly invalid: FieldRef<"voting_procedure", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * voting_procedure findUnique
   */
  export type voting_procedureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter, which voting_procedure to fetch.
     */
    where: voting_procedureWhereUniqueInput
  }

  /**
   * voting_procedure findUniqueOrThrow
   */
  export type voting_procedureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter, which voting_procedure to fetch.
     */
    where: voting_procedureWhereUniqueInput
  }

  /**
   * voting_procedure findFirst
   */
  export type voting_procedureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter, which voting_procedure to fetch.
     */
    where?: voting_procedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_procedures to fetch.
     */
    orderBy?: voting_procedureOrderByWithRelationInput | voting_procedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voting_procedures.
     */
    cursor?: voting_procedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voting_procedures.
     */
    distinct?: Voting_procedureScalarFieldEnum | Voting_procedureScalarFieldEnum[]
  }

  /**
   * voting_procedure findFirstOrThrow
   */
  export type voting_procedureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter, which voting_procedure to fetch.
     */
    where?: voting_procedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_procedures to fetch.
     */
    orderBy?: voting_procedureOrderByWithRelationInput | voting_procedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for voting_procedures.
     */
    cursor?: voting_procedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_procedures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of voting_procedures.
     */
    distinct?: Voting_procedureScalarFieldEnum | Voting_procedureScalarFieldEnum[]
  }

  /**
   * voting_procedure findMany
   */
  export type voting_procedureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter, which voting_procedures to fetch.
     */
    where?: voting_procedureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of voting_procedures to fetch.
     */
    orderBy?: voting_procedureOrderByWithRelationInput | voting_procedureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing voting_procedures.
     */
    cursor?: voting_procedureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` voting_procedures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` voting_procedures.
     */
    skip?: number
    distinct?: Voting_procedureScalarFieldEnum | Voting_procedureScalarFieldEnum[]
  }

  /**
   * voting_procedure create
   */
  export type voting_procedureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * The data needed to create a voting_procedure.
     */
    data: XOR<voting_procedureCreateInput, voting_procedureUncheckedCreateInput>
  }

  /**
   * voting_procedure createMany
   */
  export type voting_procedureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many voting_procedures.
     */
    data: voting_procedureCreateManyInput | voting_procedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voting_procedure createManyAndReturn
   */
  export type voting_procedureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * The data used to create many voting_procedures.
     */
    data: voting_procedureCreateManyInput | voting_procedureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * voting_procedure update
   */
  export type voting_procedureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * The data needed to update a voting_procedure.
     */
    data: XOR<voting_procedureUpdateInput, voting_procedureUncheckedUpdateInput>
    /**
     * Choose, which voting_procedure to update.
     */
    where: voting_procedureWhereUniqueInput
  }

  /**
   * voting_procedure updateMany
   */
  export type voting_procedureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update voting_procedures.
     */
    data: XOR<voting_procedureUpdateManyMutationInput, voting_procedureUncheckedUpdateManyInput>
    /**
     * Filter which voting_procedures to update
     */
    where?: voting_procedureWhereInput
    /**
     * Limit how many voting_procedures to update.
     */
    limit?: number
  }

  /**
   * voting_procedure updateManyAndReturn
   */
  export type voting_procedureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * The data used to update voting_procedures.
     */
    data: XOR<voting_procedureUpdateManyMutationInput, voting_procedureUncheckedUpdateManyInput>
    /**
     * Filter which voting_procedures to update
     */
    where?: voting_procedureWhereInput
    /**
     * Limit how many voting_procedures to update.
     */
    limit?: number
  }

  /**
   * voting_procedure upsert
   */
  export type voting_procedureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * The filter to search for the voting_procedure to update in case it exists.
     */
    where: voting_procedureWhereUniqueInput
    /**
     * In case the voting_procedure found by the `where` argument doesn't exist, create a new voting_procedure with this data.
     */
    create: XOR<voting_procedureCreateInput, voting_procedureUncheckedCreateInput>
    /**
     * In case the voting_procedure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<voting_procedureUpdateInput, voting_procedureUncheckedUpdateInput>
  }

  /**
   * voting_procedure delete
   */
  export type voting_procedureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
    /**
     * Filter which voting_procedure to delete.
     */
    where: voting_procedureWhereUniqueInput
  }

  /**
   * voting_procedure deleteMany
   */
  export type voting_procedureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which voting_procedures to delete
     */
    where?: voting_procedureWhereInput
    /**
     * Limit how many voting_procedures to delete.
     */
    limit?: number
  }

  /**
   * voting_procedure without action
   */
  export type voting_procedureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the voting_procedure
     */
    select?: voting_procedureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the voting_procedure
     */
    omit?: voting_procedureOmit<ExtArgs> | null
  }


  /**
   * Model withdrawal
   */

  export type AggregateWithdrawal = {
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  export type WithdrawalAvgAggregateOutputType = {
    id: number | null
    addr_id: number | null
    amount: Decimal | null
    redeemer_id: number | null
    tx_id: number | null
  }

  export type WithdrawalSumAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    amount: Decimal | null
    redeemer_id: bigint | null
    tx_id: bigint | null
  }

  export type WithdrawalMinAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    amount: Decimal | null
    redeemer_id: bigint | null
    tx_id: bigint | null
  }

  export type WithdrawalMaxAggregateOutputType = {
    id: bigint | null
    addr_id: bigint | null
    amount: Decimal | null
    redeemer_id: bigint | null
    tx_id: bigint | null
  }

  export type WithdrawalCountAggregateOutputType = {
    id: number
    addr_id: number
    amount: number
    redeemer_id: number
    tx_id: number
    _all: number
  }


  export type WithdrawalAvgAggregateInputType = {
    id?: true
    addr_id?: true
    amount?: true
    redeemer_id?: true
    tx_id?: true
  }

  export type WithdrawalSumAggregateInputType = {
    id?: true
    addr_id?: true
    amount?: true
    redeemer_id?: true
    tx_id?: true
  }

  export type WithdrawalMinAggregateInputType = {
    id?: true
    addr_id?: true
    amount?: true
    redeemer_id?: true
    tx_id?: true
  }

  export type WithdrawalMaxAggregateInputType = {
    id?: true
    addr_id?: true
    amount?: true
    redeemer_id?: true
    tx_id?: true
  }

  export type WithdrawalCountAggregateInputType = {
    id?: true
    addr_id?: true
    amount?: true
    redeemer_id?: true
    tx_id?: true
    _all?: true
  }

  export type WithdrawalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawal to aggregate.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned withdrawals
    **/
    _count?: true | WithdrawalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalMaxAggregateInputType
  }

  export type GetWithdrawalAggregateType<T extends WithdrawalAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawal[P]>
      : GetScalarType<T[P], AggregateWithdrawal[P]>
  }




  export type withdrawalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: withdrawalWhereInput
    orderBy?: withdrawalOrderByWithAggregationInput | withdrawalOrderByWithAggregationInput[]
    by: WithdrawalScalarFieldEnum[] | WithdrawalScalarFieldEnum
    having?: withdrawalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalCountAggregateInputType | true
    _avg?: WithdrawalAvgAggregateInputType
    _sum?: WithdrawalSumAggregateInputType
    _min?: WithdrawalMinAggregateInputType
    _max?: WithdrawalMaxAggregateInputType
  }

  export type WithdrawalGroupByOutputType = {
    id: bigint
    addr_id: bigint
    amount: Decimal
    redeemer_id: bigint | null
    tx_id: bigint
    _count: WithdrawalCountAggregateOutputType | null
    _avg: WithdrawalAvgAggregateOutputType | null
    _sum: WithdrawalSumAggregateOutputType | null
    _min: WithdrawalMinAggregateOutputType | null
    _max: WithdrawalMaxAggregateOutputType | null
  }

  type GetWithdrawalGroupByPayload<T extends withdrawalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WithdrawalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalGroupByOutputType[P]>
        }
      >
    >


  export type withdrawalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    amount?: boolean
    redeemer_id?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    amount?: boolean
    redeemer_id?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addr_id?: boolean
    amount?: boolean
    redeemer_id?: boolean
    tx_id?: boolean
  }, ExtArgs["result"]["withdrawal"]>

  export type withdrawalSelectScalar = {
    id?: boolean
    addr_id?: boolean
    amount?: boolean
    redeemer_id?: boolean
    tx_id?: boolean
  }

  export type withdrawalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addr_id" | "amount" | "redeemer_id" | "tx_id", ExtArgs["result"]["withdrawal"]>

  export type $withdrawalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "withdrawal"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      addr_id: bigint
      amount: Prisma.Decimal
      redeemer_id: bigint | null
      tx_id: bigint
    }, ExtArgs["result"]["withdrawal"]>
    composites: {}
  }

  type withdrawalGetPayload<S extends boolean | null | undefined | withdrawalDefaultArgs> = $Result.GetResult<Prisma.$withdrawalPayload, S>

  type withdrawalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<withdrawalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WithdrawalCountAggregateInputType | true
    }

  export interface withdrawalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['withdrawal'], meta: { name: 'withdrawal' } }
    /**
     * Find zero or one Withdrawal that matches the filter.
     * @param {withdrawalFindUniqueArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends withdrawalFindUniqueArgs>(args: SelectSubset<T, withdrawalFindUniqueArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Withdrawal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {withdrawalFindUniqueOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends withdrawalFindUniqueOrThrowArgs>(args: SelectSubset<T, withdrawalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Withdrawal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindFirstArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends withdrawalFindFirstArgs>(args?: SelectSubset<T, withdrawalFindFirstArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Withdrawal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindFirstOrThrowArgs} args - Arguments to find a Withdrawal
     * @example
     * // Get one Withdrawal
     * const withdrawal = await prisma.withdrawal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends withdrawalFindFirstOrThrowArgs>(args?: SelectSubset<T, withdrawalFindFirstOrThrowArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Withdrawals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany()
     * 
     * // Get first 10 Withdrawals
     * const withdrawals = await prisma.withdrawal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends withdrawalFindManyArgs>(args?: SelectSubset<T, withdrawalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Withdrawal.
     * @param {withdrawalCreateArgs} args - Arguments to create a Withdrawal.
     * @example
     * // Create one Withdrawal
     * const Withdrawal = await prisma.withdrawal.create({
     *   data: {
     *     // ... data to create a Withdrawal
     *   }
     * })
     * 
     */
    create<T extends withdrawalCreateArgs>(args: SelectSubset<T, withdrawalCreateArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Withdrawals.
     * @param {withdrawalCreateManyArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends withdrawalCreateManyArgs>(args?: SelectSubset<T, withdrawalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Withdrawals and returns the data saved in the database.
     * @param {withdrawalCreateManyAndReturnArgs} args - Arguments to create many Withdrawals.
     * @example
     * // Create many Withdrawals
     * const withdrawal = await prisma.withdrawal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends withdrawalCreateManyAndReturnArgs>(args?: SelectSubset<T, withdrawalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Withdrawal.
     * @param {withdrawalDeleteArgs} args - Arguments to delete one Withdrawal.
     * @example
     * // Delete one Withdrawal
     * const Withdrawal = await prisma.withdrawal.delete({
     *   where: {
     *     // ... filter to delete one Withdrawal
     *   }
     * })
     * 
     */
    delete<T extends withdrawalDeleteArgs>(args: SelectSubset<T, withdrawalDeleteArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Withdrawal.
     * @param {withdrawalUpdateArgs} args - Arguments to update one Withdrawal.
     * @example
     * // Update one Withdrawal
     * const withdrawal = await prisma.withdrawal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends withdrawalUpdateArgs>(args: SelectSubset<T, withdrawalUpdateArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Withdrawals.
     * @param {withdrawalDeleteManyArgs} args - Arguments to filter Withdrawals to delete.
     * @example
     * // Delete a few Withdrawals
     * const { count } = await prisma.withdrawal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends withdrawalDeleteManyArgs>(args?: SelectSubset<T, withdrawalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends withdrawalUpdateManyArgs>(args: SelectSubset<T, withdrawalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Withdrawals and returns the data updated in the database.
     * @param {withdrawalUpdateManyAndReturnArgs} args - Arguments to update many Withdrawals.
     * @example
     * // Update many Withdrawals
     * const withdrawal = await prisma.withdrawal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Withdrawals and only return the `id`
     * const withdrawalWithIdOnly = await prisma.withdrawal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends withdrawalUpdateManyAndReturnArgs>(args: SelectSubset<T, withdrawalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Withdrawal.
     * @param {withdrawalUpsertArgs} args - Arguments to update or create a Withdrawal.
     * @example
     * // Update or create a Withdrawal
     * const withdrawal = await prisma.withdrawal.upsert({
     *   create: {
     *     // ... data to create a Withdrawal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Withdrawal we want to update
     *   }
     * })
     */
    upsert<T extends withdrawalUpsertArgs>(args: SelectSubset<T, withdrawalUpsertArgs<ExtArgs>>): Prisma__withdrawalClient<$Result.GetResult<Prisma.$withdrawalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Withdrawals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalCountArgs} args - Arguments to filter Withdrawals to count.
     * @example
     * // Count the number of Withdrawals
     * const count = await prisma.withdrawal.count({
     *   where: {
     *     // ... the filter for the Withdrawals we want to count
     *   }
     * })
    **/
    count<T extends withdrawalCountArgs>(
      args?: Subset<T, withdrawalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAggregateArgs>(args: Subset<T, WithdrawalAggregateArgs>): Prisma.PrismaPromise<GetWithdrawalAggregateType<T>>

    /**
     * Group by Withdrawal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends withdrawalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: withdrawalGroupByArgs['orderBy'] }
        : { orderBy?: withdrawalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, withdrawalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the withdrawal model
   */
  readonly fields: withdrawalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for withdrawal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__withdrawalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the withdrawal model
   */ 
  interface withdrawalFieldRefs {
    readonly id: FieldRef<"withdrawal", 'BigInt'>
    readonly addr_id: FieldRef<"withdrawal", 'BigInt'>
    readonly amount: FieldRef<"withdrawal", 'Decimal'>
    readonly redeemer_id: FieldRef<"withdrawal", 'BigInt'>
    readonly tx_id: FieldRef<"withdrawal", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * withdrawal findUnique
   */
  export type withdrawalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal findUniqueOrThrow
   */
  export type withdrawalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal findFirst
   */
  export type withdrawalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal findFirstOrThrow
   */
  export type withdrawalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which withdrawal to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawals.
     */
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal findMany
   */
  export type withdrawalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter, which withdrawals to fetch.
     */
    where?: withdrawalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawals to fetch.
     */
    orderBy?: withdrawalOrderByWithRelationInput | withdrawalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing withdrawals.
     */
    cursor?: withdrawalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawals.
     */
    skip?: number
    distinct?: WithdrawalScalarFieldEnum | WithdrawalScalarFieldEnum[]
  }

  /**
   * withdrawal create
   */
  export type withdrawalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data needed to create a withdrawal.
     */
    data: XOR<withdrawalCreateInput, withdrawalUncheckedCreateInput>
  }

  /**
   * withdrawal createMany
   */
  export type withdrawalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalCreateManyInput | withdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * withdrawal createManyAndReturn
   */
  export type withdrawalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data used to create many withdrawals.
     */
    data: withdrawalCreateManyInput | withdrawalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * withdrawal update
   */
  export type withdrawalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data needed to update a withdrawal.
     */
    data: XOR<withdrawalUpdateInput, withdrawalUncheckedUpdateInput>
    /**
     * Choose, which withdrawal to update.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal updateMany
   */
  export type withdrawalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalUpdateManyMutationInput, withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
  }

  /**
   * withdrawal updateManyAndReturn
   */
  export type withdrawalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The data used to update withdrawals.
     */
    data: XOR<withdrawalUpdateManyMutationInput, withdrawalUncheckedUpdateManyInput>
    /**
     * Filter which withdrawals to update
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to update.
     */
    limit?: number
  }

  /**
   * withdrawal upsert
   */
  export type withdrawalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * The filter to search for the withdrawal to update in case it exists.
     */
    where: withdrawalWhereUniqueInput
    /**
     * In case the withdrawal found by the `where` argument doesn't exist, create a new withdrawal with this data.
     */
    create: XOR<withdrawalCreateInput, withdrawalUncheckedCreateInput>
    /**
     * In case the withdrawal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<withdrawalUpdateInput, withdrawalUncheckedUpdateInput>
  }

  /**
   * withdrawal delete
   */
  export type withdrawalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
    /**
     * Filter which withdrawal to delete.
     */
    where: withdrawalWhereUniqueInput
  }

  /**
   * withdrawal deleteMany
   */
  export type withdrawalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which withdrawals to delete
     */
    where?: withdrawalWhereInput
    /**
     * Limit how many withdrawals to delete.
     */
    limit?: number
  }

  /**
   * withdrawal without action
   */
  export type withdrawalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the withdrawal
     */
    select?: withdrawalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the withdrawal
     */
    omit?: withdrawalOmit<ExtArgs> | null
  }


  /**
   * Model sqlx_migrations
   */

  export type AggregateSqlx_migrations = {
    _count: Sqlx_migrationsCountAggregateOutputType | null
    _avg: Sqlx_migrationsAvgAggregateOutputType | null
    _sum: Sqlx_migrationsSumAggregateOutputType | null
    _min: Sqlx_migrationsMinAggregateOutputType | null
    _max: Sqlx_migrationsMaxAggregateOutputType | null
  }

  export type Sqlx_migrationsAvgAggregateOutputType = {
    version: number | null
    execution_time: number | null
  }

  export type Sqlx_migrationsSumAggregateOutputType = {
    version: bigint | null
    execution_time: bigint | null
  }

  export type Sqlx_migrationsMinAggregateOutputType = {
    version: bigint | null
    description: string | null
    installed_on: Date | null
    success: boolean | null
    checksum: Uint8Array | null
    execution_time: bigint | null
  }

  export type Sqlx_migrationsMaxAggregateOutputType = {
    version: bigint | null
    description: string | null
    installed_on: Date | null
    success: boolean | null
    checksum: Uint8Array | null
    execution_time: bigint | null
  }

  export type Sqlx_migrationsCountAggregateOutputType = {
    version: number
    description: number
    installed_on: number
    success: number
    checksum: number
    execution_time: number
    _all: number
  }


  export type Sqlx_migrationsAvgAggregateInputType = {
    version?: true
    execution_time?: true
  }

  export type Sqlx_migrationsSumAggregateInputType = {
    version?: true
    execution_time?: true
  }

  export type Sqlx_migrationsMinAggregateInputType = {
    version?: true
    description?: true
    installed_on?: true
    success?: true
    checksum?: true
    execution_time?: true
  }

  export type Sqlx_migrationsMaxAggregateInputType = {
    version?: true
    description?: true
    installed_on?: true
    success?: true
    checksum?: true
    execution_time?: true
  }

  export type Sqlx_migrationsCountAggregateInputType = {
    version?: true
    description?: true
    installed_on?: true
    success?: true
    checksum?: true
    execution_time?: true
    _all?: true
  }

  export type Sqlx_migrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sqlx_migrations to aggregate.
     */
    where?: sqlx_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sqlx_migrations to fetch.
     */
    orderBy?: sqlx_migrationsOrderByWithRelationInput | sqlx_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sqlx_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sqlx_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sqlx_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sqlx_migrations
    **/
    _count?: true | Sqlx_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sqlx_migrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sqlx_migrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sqlx_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sqlx_migrationsMaxAggregateInputType
  }

  export type GetSqlx_migrationsAggregateType<T extends Sqlx_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSqlx_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSqlx_migrations[P]>
      : GetScalarType<T[P], AggregateSqlx_migrations[P]>
  }




  export type sqlx_migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sqlx_migrationsWhereInput
    orderBy?: sqlx_migrationsOrderByWithAggregationInput | sqlx_migrationsOrderByWithAggregationInput[]
    by: Sqlx_migrationsScalarFieldEnum[] | Sqlx_migrationsScalarFieldEnum
    having?: sqlx_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sqlx_migrationsCountAggregateInputType | true
    _avg?: Sqlx_migrationsAvgAggregateInputType
    _sum?: Sqlx_migrationsSumAggregateInputType
    _min?: Sqlx_migrationsMinAggregateInputType
    _max?: Sqlx_migrationsMaxAggregateInputType
  }

  export type Sqlx_migrationsGroupByOutputType = {
    version: bigint
    description: string
    installed_on: Date
    success: boolean
    checksum: Uint8Array
    execution_time: bigint
    _count: Sqlx_migrationsCountAggregateOutputType | null
    _avg: Sqlx_migrationsAvgAggregateOutputType | null
    _sum: Sqlx_migrationsSumAggregateOutputType | null
    _min: Sqlx_migrationsMinAggregateOutputType | null
    _max: Sqlx_migrationsMaxAggregateOutputType | null
  }

  type GetSqlx_migrationsGroupByPayload<T extends sqlx_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sqlx_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sqlx_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sqlx_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Sqlx_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type sqlx_migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    description?: boolean
    installed_on?: boolean
    success?: boolean
    checksum?: boolean
    execution_time?: boolean
  }, ExtArgs["result"]["sqlx_migrations"]>

  export type sqlx_migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    description?: boolean
    installed_on?: boolean
    success?: boolean
    checksum?: boolean
    execution_time?: boolean
  }, ExtArgs["result"]["sqlx_migrations"]>

  export type sqlx_migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
    description?: boolean
    installed_on?: boolean
    success?: boolean
    checksum?: boolean
    execution_time?: boolean
  }, ExtArgs["result"]["sqlx_migrations"]>

  export type sqlx_migrationsSelectScalar = {
    version?: boolean
    description?: boolean
    installed_on?: boolean
    success?: boolean
    checksum?: boolean
    execution_time?: boolean
  }

  export type sqlx_migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"version" | "description" | "installed_on" | "success" | "checksum" | "execution_time", ExtArgs["result"]["sqlx_migrations"]>

  export type $sqlx_migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sqlx_migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: bigint
      description: string
      installed_on: Date
      success: boolean
      checksum: Uint8Array
      execution_time: bigint
    }, ExtArgs["result"]["sqlx_migrations"]>
    composites: {}
  }

  type sqlx_migrationsGetPayload<S extends boolean | null | undefined | sqlx_migrationsDefaultArgs> = $Result.GetResult<Prisma.$sqlx_migrationsPayload, S>

  type sqlx_migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sqlx_migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sqlx_migrationsCountAggregateInputType | true
    }

  export interface sqlx_migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sqlx_migrations'], meta: { name: 'sqlx_migrations' } }
    /**
     * Find zero or one Sqlx_migrations that matches the filter.
     * @param {sqlx_migrationsFindUniqueArgs} args - Arguments to find a Sqlx_migrations
     * @example
     * // Get one Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sqlx_migrationsFindUniqueArgs>(args: SelectSubset<T, sqlx_migrationsFindUniqueArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sqlx_migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sqlx_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Sqlx_migrations
     * @example
     * // Get one Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sqlx_migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, sqlx_migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sqlx_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsFindFirstArgs} args - Arguments to find a Sqlx_migrations
     * @example
     * // Get one Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sqlx_migrationsFindFirstArgs>(args?: SelectSubset<T, sqlx_migrationsFindFirstArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sqlx_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsFindFirstOrThrowArgs} args - Arguments to find a Sqlx_migrations
     * @example
     * // Get one Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sqlx_migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, sqlx_migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sqlx_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findMany()
     * 
     * // Get first 10 Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const sqlx_migrationsWithVersionOnly = await prisma.sqlx_migrations.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends sqlx_migrationsFindManyArgs>(args?: SelectSubset<T, sqlx_migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sqlx_migrations.
     * @param {sqlx_migrationsCreateArgs} args - Arguments to create a Sqlx_migrations.
     * @example
     * // Create one Sqlx_migrations
     * const Sqlx_migrations = await prisma.sqlx_migrations.create({
     *   data: {
     *     // ... data to create a Sqlx_migrations
     *   }
     * })
     * 
     */
    create<T extends sqlx_migrationsCreateArgs>(args: SelectSubset<T, sqlx_migrationsCreateArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sqlx_migrations.
     * @param {sqlx_migrationsCreateManyArgs} args - Arguments to create many Sqlx_migrations.
     * @example
     * // Create many Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sqlx_migrationsCreateManyArgs>(args?: SelectSubset<T, sqlx_migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sqlx_migrations and returns the data saved in the database.
     * @param {sqlx_migrationsCreateManyAndReturnArgs} args - Arguments to create many Sqlx_migrations.
     * @example
     * // Create many Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sqlx_migrations and only return the `version`
     * const sqlx_migrationsWithVersionOnly = await prisma.sqlx_migrations.createManyAndReturn({
     *   select: { version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sqlx_migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, sqlx_migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Sqlx_migrations.
     * @param {sqlx_migrationsDeleteArgs} args - Arguments to delete one Sqlx_migrations.
     * @example
     * // Delete one Sqlx_migrations
     * const Sqlx_migrations = await prisma.sqlx_migrations.delete({
     *   where: {
     *     // ... filter to delete one Sqlx_migrations
     *   }
     * })
     * 
     */
    delete<T extends sqlx_migrationsDeleteArgs>(args: SelectSubset<T, sqlx_migrationsDeleteArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sqlx_migrations.
     * @param {sqlx_migrationsUpdateArgs} args - Arguments to update one Sqlx_migrations.
     * @example
     * // Update one Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sqlx_migrationsUpdateArgs>(args: SelectSubset<T, sqlx_migrationsUpdateArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sqlx_migrations.
     * @param {sqlx_migrationsDeleteManyArgs} args - Arguments to filter Sqlx_migrations to delete.
     * @example
     * // Delete a few Sqlx_migrations
     * const { count } = await prisma.sqlx_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sqlx_migrationsDeleteManyArgs>(args?: SelectSubset<T, sqlx_migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sqlx_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sqlx_migrationsUpdateManyArgs>(args: SelectSubset<T, sqlx_migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sqlx_migrations and returns the data updated in the database.
     * @param {sqlx_migrationsUpdateManyAndReturnArgs} args - Arguments to update many Sqlx_migrations.
     * @example
     * // Update many Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sqlx_migrations and only return the `version`
     * const sqlx_migrationsWithVersionOnly = await prisma.sqlx_migrations.updateManyAndReturn({
     *   select: { version: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sqlx_migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, sqlx_migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Sqlx_migrations.
     * @param {sqlx_migrationsUpsertArgs} args - Arguments to update or create a Sqlx_migrations.
     * @example
     * // Update or create a Sqlx_migrations
     * const sqlx_migrations = await prisma.sqlx_migrations.upsert({
     *   create: {
     *     // ... data to create a Sqlx_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sqlx_migrations we want to update
     *   }
     * })
     */
    upsert<T extends sqlx_migrationsUpsertArgs>(args: SelectSubset<T, sqlx_migrationsUpsertArgs<ExtArgs>>): Prisma__sqlx_migrationsClient<$Result.GetResult<Prisma.$sqlx_migrationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sqlx_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsCountArgs} args - Arguments to filter Sqlx_migrations to count.
     * @example
     * // Count the number of Sqlx_migrations
     * const count = await prisma.sqlx_migrations.count({
     *   where: {
     *     // ... the filter for the Sqlx_migrations we want to count
     *   }
     * })
    **/
    count<T extends sqlx_migrationsCountArgs>(
      args?: Subset<T, sqlx_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sqlx_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sqlx_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sqlx_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sqlx_migrationsAggregateArgs>(args: Subset<T, Sqlx_migrationsAggregateArgs>): Prisma.PrismaPromise<GetSqlx_migrationsAggregateType<T>>

    /**
     * Group by Sqlx_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sqlx_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sqlx_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sqlx_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: sqlx_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sqlx_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSqlx_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sqlx_migrations model
   */
  readonly fields: sqlx_migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sqlx_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sqlx_migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sqlx_migrations model
   */ 
  interface sqlx_migrationsFieldRefs {
    readonly version: FieldRef<"sqlx_migrations", 'BigInt'>
    readonly description: FieldRef<"sqlx_migrations", 'String'>
    readonly installed_on: FieldRef<"sqlx_migrations", 'DateTime'>
    readonly success: FieldRef<"sqlx_migrations", 'Boolean'>
    readonly checksum: FieldRef<"sqlx_migrations", 'Bytes'>
    readonly execution_time: FieldRef<"sqlx_migrations", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * sqlx_migrations findUnique
   */
  export type sqlx_migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which sqlx_migrations to fetch.
     */
    where: sqlx_migrationsWhereUniqueInput
  }

  /**
   * sqlx_migrations findUniqueOrThrow
   */
  export type sqlx_migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which sqlx_migrations to fetch.
     */
    where: sqlx_migrationsWhereUniqueInput
  }

  /**
   * sqlx_migrations findFirst
   */
  export type sqlx_migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which sqlx_migrations to fetch.
     */
    where?: sqlx_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sqlx_migrations to fetch.
     */
    orderBy?: sqlx_migrationsOrderByWithRelationInput | sqlx_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sqlx_migrations.
     */
    cursor?: sqlx_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sqlx_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sqlx_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sqlx_migrations.
     */
    distinct?: Sqlx_migrationsScalarFieldEnum | Sqlx_migrationsScalarFieldEnum[]
  }

  /**
   * sqlx_migrations findFirstOrThrow
   */
  export type sqlx_migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which sqlx_migrations to fetch.
     */
    where?: sqlx_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sqlx_migrations to fetch.
     */
    orderBy?: sqlx_migrationsOrderByWithRelationInput | sqlx_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sqlx_migrations.
     */
    cursor?: sqlx_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sqlx_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sqlx_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sqlx_migrations.
     */
    distinct?: Sqlx_migrationsScalarFieldEnum | Sqlx_migrationsScalarFieldEnum[]
  }

  /**
   * sqlx_migrations findMany
   */
  export type sqlx_migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which sqlx_migrations to fetch.
     */
    where?: sqlx_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sqlx_migrations to fetch.
     */
    orderBy?: sqlx_migrationsOrderByWithRelationInput | sqlx_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sqlx_migrations.
     */
    cursor?: sqlx_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sqlx_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sqlx_migrations.
     */
    skip?: number
    distinct?: Sqlx_migrationsScalarFieldEnum | Sqlx_migrationsScalarFieldEnum[]
  }

  /**
   * sqlx_migrations create
   */
  export type sqlx_migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a sqlx_migrations.
     */
    data: XOR<sqlx_migrationsCreateInput, sqlx_migrationsUncheckedCreateInput>
  }

  /**
   * sqlx_migrations createMany
   */
  export type sqlx_migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sqlx_migrations.
     */
    data: sqlx_migrationsCreateManyInput | sqlx_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sqlx_migrations createManyAndReturn
   */
  export type sqlx_migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many sqlx_migrations.
     */
    data: sqlx_migrationsCreateManyInput | sqlx_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sqlx_migrations update
   */
  export type sqlx_migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a sqlx_migrations.
     */
    data: XOR<sqlx_migrationsUpdateInput, sqlx_migrationsUncheckedUpdateInput>
    /**
     * Choose, which sqlx_migrations to update.
     */
    where: sqlx_migrationsWhereUniqueInput
  }

  /**
   * sqlx_migrations updateMany
   */
  export type sqlx_migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sqlx_migrations.
     */
    data: XOR<sqlx_migrationsUpdateManyMutationInput, sqlx_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which sqlx_migrations to update
     */
    where?: sqlx_migrationsWhereInput
    /**
     * Limit how many sqlx_migrations to update.
     */
    limit?: number
  }

  /**
   * sqlx_migrations updateManyAndReturn
   */
  export type sqlx_migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * The data used to update sqlx_migrations.
     */
    data: XOR<sqlx_migrationsUpdateManyMutationInput, sqlx_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which sqlx_migrations to update
     */
    where?: sqlx_migrationsWhereInput
    /**
     * Limit how many sqlx_migrations to update.
     */
    limit?: number
  }

  /**
   * sqlx_migrations upsert
   */
  export type sqlx_migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the sqlx_migrations to update in case it exists.
     */
    where: sqlx_migrationsWhereUniqueInput
    /**
     * In case the sqlx_migrations found by the `where` argument doesn't exist, create a new sqlx_migrations with this data.
     */
    create: XOR<sqlx_migrationsCreateInput, sqlx_migrationsUncheckedCreateInput>
    /**
     * In case the sqlx_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sqlx_migrationsUpdateInput, sqlx_migrationsUncheckedUpdateInput>
  }

  /**
   * sqlx_migrations delete
   */
  export type sqlx_migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
    /**
     * Filter which sqlx_migrations to delete.
     */
    where: sqlx_migrationsWhereUniqueInput
  }

  /**
   * sqlx_migrations deleteMany
   */
  export type sqlx_migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sqlx_migrations to delete
     */
    where?: sqlx_migrationsWhereInput
    /**
     * Limit how many sqlx_migrations to delete.
     */
    limit?: number
  }

  /**
   * sqlx_migrations without action
   */
  export type sqlx_migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sqlx_migrations
     */
    select?: sqlx_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sqlx_migrations
     */
    omit?: sqlx_migrationsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Ada_potsScalarFieldEnum: {
    id: 'id',
    slot_no: 'slot_no',
    epoch_no: 'epoch_no',
    treasury: 'treasury',
    reserves: 'reserves',
    rewards: 'rewards',
    utxo: 'utxo',
    deposits_stake: 'deposits_stake',
    fees: 'fees',
    block_id: 'block_id',
    deposits_drep: 'deposits_drep',
    deposits_proposal: 'deposits_proposal'
  };

  export type Ada_potsScalarFieldEnum = (typeof Ada_potsScalarFieldEnum)[keyof typeof Ada_potsScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    epoch_no: 'epoch_no',
    slot_no: 'slot_no',
    epoch_slot_no: 'epoch_slot_no',
    block_no: 'block_no',
    previous_id: 'previous_id',
    slot_leader_id: 'slot_leader_id',
    size: 'size',
    time: 'time',
    tx_count: 'tx_count',
    proto_major: 'proto_major',
    proto_minor: 'proto_minor',
    vrf_key: 'vrf_key',
    op_cert: 'op_cert',
    op_cert_counter: 'op_cert_counter'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const Collateral_tx_inScalarFieldEnum: {
    id: 'id',
    tx_in_id: 'tx_in_id',
    tx_out_id: 'tx_out_id',
    tx_out_index: 'tx_out_index'
  };

  export type Collateral_tx_inScalarFieldEnum = (typeof Collateral_tx_inScalarFieldEnum)[keyof typeof Collateral_tx_inScalarFieldEnum]


  export const Collateral_tx_outScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    index: 'index',
    address: 'address',
    address_has_script: 'address_has_script',
    payment_cred: 'payment_cred',
    stake_address_id: 'stake_address_id',
    value: 'value',
    data_hash: 'data_hash',
    multi_assets_descr: 'multi_assets_descr',
    inline_datum_id: 'inline_datum_id',
    reference_script_id: 'reference_script_id'
  };

  export type Collateral_tx_outScalarFieldEnum = (typeof Collateral_tx_outScalarFieldEnum)[keyof typeof Collateral_tx_outScalarFieldEnum]


  export const CommitteeScalarFieldEnum: {
    id: 'id',
    gov_action_proposal_id: 'gov_action_proposal_id',
    quorum_numerator: 'quorum_numerator',
    quorum_denominator: 'quorum_denominator'
  };

  export type CommitteeScalarFieldEnum = (typeof CommitteeScalarFieldEnum)[keyof typeof CommitteeScalarFieldEnum]


  export const Committee_de_registrationScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    cert_index: 'cert_index',
    voting_anchor_id: 'voting_anchor_id',
    cold_key_id: 'cold_key_id'
  };

  export type Committee_de_registrationScalarFieldEnum = (typeof Committee_de_registrationScalarFieldEnum)[keyof typeof Committee_de_registrationScalarFieldEnum]


  export const Committee_hashScalarFieldEnum: {
    id: 'id',
    raw: 'raw',
    has_script: 'has_script'
  };

  export type Committee_hashScalarFieldEnum = (typeof Committee_hashScalarFieldEnum)[keyof typeof Committee_hashScalarFieldEnum]


  export const Committee_memberScalarFieldEnum: {
    id: 'id',
    committee_id: 'committee_id',
    committee_hash_id: 'committee_hash_id',
    expiration_epoch: 'expiration_epoch'
  };

  export type Committee_memberScalarFieldEnum = (typeof Committee_memberScalarFieldEnum)[keyof typeof Committee_memberScalarFieldEnum]


  export const Committee_registrationScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    cert_index: 'cert_index',
    cold_key_id: 'cold_key_id',
    hot_key_id: 'hot_key_id'
  };

  export type Committee_registrationScalarFieldEnum = (typeof Committee_registrationScalarFieldEnum)[keyof typeof Committee_registrationScalarFieldEnum]


  export const ConstitutionScalarFieldEnum: {
    id: 'id',
    gov_action_proposal_id: 'gov_action_proposal_id',
    voting_anchor_id: 'voting_anchor_id',
    script_hash: 'script_hash'
  };

  export type ConstitutionScalarFieldEnum = (typeof ConstitutionScalarFieldEnum)[keyof typeof ConstitutionScalarFieldEnum]


  export const Cost_modelScalarFieldEnum: {
    id: 'id',
    costs: 'costs',
    hash: 'hash'
  };

  export type Cost_modelScalarFieldEnum = (typeof Cost_modelScalarFieldEnum)[keyof typeof Cost_modelScalarFieldEnum]


  export const DatumScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    tx_id: 'tx_id',
    value: 'value',
    bytes: 'bytes'
  };

  export type DatumScalarFieldEnum = (typeof DatumScalarFieldEnum)[keyof typeof DatumScalarFieldEnum]


  export const DelegationScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    pool_hash_id: 'pool_hash_id',
    active_epoch_no: 'active_epoch_no',
    tx_id: 'tx_id',
    slot_no: 'slot_no',
    redeemer_id: 'redeemer_id'
  };

  export type DelegationScalarFieldEnum = (typeof DelegationScalarFieldEnum)[keyof typeof DelegationScalarFieldEnum]


  export const Delegation_voteScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    drep_hash_id: 'drep_hash_id',
    tx_id: 'tx_id',
    redeemer_id: 'redeemer_id'
  };

  export type Delegation_voteScalarFieldEnum = (typeof Delegation_voteScalarFieldEnum)[keyof typeof Delegation_voteScalarFieldEnum]


  export const Delisted_poolScalarFieldEnum: {
    id: 'id',
    hash_raw: 'hash_raw'
  };

  export type Delisted_poolScalarFieldEnum = (typeof Delisted_poolScalarFieldEnum)[keyof typeof Delisted_poolScalarFieldEnum]


  export const Drep_distrScalarFieldEnum: {
    id: 'id',
    hash_id: 'hash_id',
    amount: 'amount',
    epoch_no: 'epoch_no',
    active_until: 'active_until'
  };

  export type Drep_distrScalarFieldEnum = (typeof Drep_distrScalarFieldEnum)[keyof typeof Drep_distrScalarFieldEnum]


  export const Drep_hashScalarFieldEnum: {
    id: 'id',
    raw: 'raw',
    view: 'view',
    has_script: 'has_script'
  };

  export type Drep_hashScalarFieldEnum = (typeof Drep_hashScalarFieldEnum)[keyof typeof Drep_hashScalarFieldEnum]


  export const Drep_registrationScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    cert_index: 'cert_index',
    deposit: 'deposit',
    drep_hash_id: 'drep_hash_id',
    voting_anchor_id: 'voting_anchor_id'
  };

  export type Drep_registrationScalarFieldEnum = (typeof Drep_registrationScalarFieldEnum)[keyof typeof Drep_registrationScalarFieldEnum]


  export const EpochScalarFieldEnum: {
    id: 'id',
    out_sum: 'out_sum',
    fees: 'fees',
    tx_count: 'tx_count',
    blk_count: 'blk_count',
    no: 'no',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type EpochScalarFieldEnum = (typeof EpochScalarFieldEnum)[keyof typeof EpochScalarFieldEnum]


  export const Epoch_paramScalarFieldEnum: {
    id: 'id',
    epoch_no: 'epoch_no',
    min_fee_a: 'min_fee_a',
    min_fee_b: 'min_fee_b',
    max_block_size: 'max_block_size',
    max_tx_size: 'max_tx_size',
    max_bh_size: 'max_bh_size',
    key_deposit: 'key_deposit',
    pool_deposit: 'pool_deposit',
    max_epoch: 'max_epoch',
    optimal_pool_count: 'optimal_pool_count',
    influence: 'influence',
    monetary_expand_rate: 'monetary_expand_rate',
    treasury_growth_rate: 'treasury_growth_rate',
    decentralisation: 'decentralisation',
    protocol_major: 'protocol_major',
    protocol_minor: 'protocol_minor',
    min_utxo_value: 'min_utxo_value',
    min_pool_cost: 'min_pool_cost',
    nonce: 'nonce',
    cost_model_id: 'cost_model_id',
    price_mem: 'price_mem',
    price_step: 'price_step',
    max_tx_ex_mem: 'max_tx_ex_mem',
    max_tx_ex_steps: 'max_tx_ex_steps',
    max_block_ex_mem: 'max_block_ex_mem',
    max_block_ex_steps: 'max_block_ex_steps',
    max_val_size: 'max_val_size',
    collateral_percent: 'collateral_percent',
    max_collateral_inputs: 'max_collateral_inputs',
    block_id: 'block_id',
    extra_entropy: 'extra_entropy',
    coins_per_utxo_size: 'coins_per_utxo_size',
    pvt_motion_no_confidence: 'pvt_motion_no_confidence',
    pvt_committee_normal: 'pvt_committee_normal',
    pvt_committee_no_confidence: 'pvt_committee_no_confidence',
    pvt_hard_fork_initiation: 'pvt_hard_fork_initiation',
    dvt_motion_no_confidence: 'dvt_motion_no_confidence',
    dvt_committee_normal: 'dvt_committee_normal',
    dvt_committee_no_confidence: 'dvt_committee_no_confidence',
    dvt_update_to_constitution: 'dvt_update_to_constitution',
    dvt_hard_fork_initiation: 'dvt_hard_fork_initiation',
    dvt_p_p_network_group: 'dvt_p_p_network_group',
    dvt_p_p_economic_group: 'dvt_p_p_economic_group',
    dvt_p_p_technical_group: 'dvt_p_p_technical_group',
    dvt_p_p_gov_group: 'dvt_p_p_gov_group',
    dvt_treasury_withdrawal: 'dvt_treasury_withdrawal',
    committee_min_size: 'committee_min_size',
    committee_max_term_length: 'committee_max_term_length',
    gov_action_lifetime: 'gov_action_lifetime',
    gov_action_deposit: 'gov_action_deposit',
    drep_deposit: 'drep_deposit',
    drep_activity: 'drep_activity',
    pvtpp_security_group: 'pvtpp_security_group',
    min_fee_ref_script_cost_per_byte: 'min_fee_ref_script_cost_per_byte'
  };

  export type Epoch_paramScalarFieldEnum = (typeof Epoch_paramScalarFieldEnum)[keyof typeof Epoch_paramScalarFieldEnum]


  export const Epoch_stakeScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    pool_id: 'pool_id',
    amount: 'amount',
    epoch_no: 'epoch_no'
  };

  export type Epoch_stakeScalarFieldEnum = (typeof Epoch_stakeScalarFieldEnum)[keyof typeof Epoch_stakeScalarFieldEnum]


  export const Epoch_stake_progressScalarFieldEnum: {
    id: 'id',
    epoch_no: 'epoch_no',
    completed: 'completed'
  };

  export type Epoch_stake_progressScalarFieldEnum = (typeof Epoch_stake_progressScalarFieldEnum)[keyof typeof Epoch_stake_progressScalarFieldEnum]


  export const Epoch_stateScalarFieldEnum: {
    id: 'id',
    committee_id: 'committee_id',
    no_confidence_id: 'no_confidence_id',
    constitution_id: 'constitution_id',
    epoch_no: 'epoch_no'
  };

  export type Epoch_stateScalarFieldEnum = (typeof Epoch_stateScalarFieldEnum)[keyof typeof Epoch_stateScalarFieldEnum]


  export const Epoch_sync_timeScalarFieldEnum: {
    id: 'id',
    no: 'no',
    seconds: 'seconds',
    state: 'state'
  };

  export type Epoch_sync_timeScalarFieldEnum = (typeof Epoch_sync_timeScalarFieldEnum)[keyof typeof Epoch_sync_timeScalarFieldEnum]


  export const Event_infoScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    epoch: 'epoch',
    type: 'type',
    explanation: 'explanation'
  };

  export type Event_infoScalarFieldEnum = (typeof Event_infoScalarFieldEnum)[keyof typeof Event_infoScalarFieldEnum]


  export const Extra_key_witnessScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    tx_id: 'tx_id'
  };

  export type Extra_key_witnessScalarFieldEnum = (typeof Extra_key_witnessScalarFieldEnum)[keyof typeof Extra_key_witnessScalarFieldEnum]


  export const Extra_migrationsScalarFieldEnum: {
    id: 'id',
    token: 'token',
    description: 'description'
  };

  export type Extra_migrationsScalarFieldEnum = (typeof Extra_migrationsScalarFieldEnum)[keyof typeof Extra_migrationsScalarFieldEnum]


  export const Gov_action_proposalScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    index: 'index',
    prev_gov_action_proposal: 'prev_gov_action_proposal',
    deposit: 'deposit',
    return_address: 'return_address',
    expiration: 'expiration',
    voting_anchor_id: 'voting_anchor_id',
    type: 'type',
    description: 'description',
    param_proposal: 'param_proposal',
    ratified_epoch: 'ratified_epoch',
    enacted_epoch: 'enacted_epoch',
    dropped_epoch: 'dropped_epoch',
    expired_epoch: 'expired_epoch'
  };

  export type Gov_action_proposalScalarFieldEnum = (typeof Gov_action_proposalScalarFieldEnum)[keyof typeof Gov_action_proposalScalarFieldEnum]


  export const Ma_tx_mintScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    tx_id: 'tx_id',
    ident: 'ident'
  };

  export type Ma_tx_mintScalarFieldEnum = (typeof Ma_tx_mintScalarFieldEnum)[keyof typeof Ma_tx_mintScalarFieldEnum]


  export const Ma_tx_outScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    tx_out_id: 'tx_out_id',
    ident: 'ident'
  };

  export type Ma_tx_outScalarFieldEnum = (typeof Ma_tx_outScalarFieldEnum)[keyof typeof Ma_tx_outScalarFieldEnum]


  export const MetaScalarFieldEnum: {
    id: 'id',
    start_time: 'start_time',
    network_name: 'network_name',
    version: 'version'
  };

  export type MetaScalarFieldEnum = (typeof MetaScalarFieldEnum)[keyof typeof MetaScalarFieldEnum]


  export const Multi_assetScalarFieldEnum: {
    id: 'id',
    policy: 'policy',
    name: 'name',
    fingerprint: 'fingerprint'
  };

  export type Multi_assetScalarFieldEnum = (typeof Multi_assetScalarFieldEnum)[keyof typeof Multi_assetScalarFieldEnum]


  export const New_committeeScalarFieldEnum: {
    id: 'id',
    gov_action_proposal_id: 'gov_action_proposal_id',
    deleted_members: 'deleted_members',
    added_members: 'added_members',
    quorum_numerator: 'quorum_numerator',
    quorum_denominator: 'quorum_denominator'
  };

  export type New_committeeScalarFieldEnum = (typeof New_committeeScalarFieldEnum)[keyof typeof New_committeeScalarFieldEnum]


  export const Off_chain_pool_dataScalarFieldEnum: {
    id: 'id',
    pool_id: 'pool_id',
    ticker_name: 'ticker_name',
    hash: 'hash',
    json: 'json',
    bytes: 'bytes',
    pmr_id: 'pmr_id'
  };

  export type Off_chain_pool_dataScalarFieldEnum = (typeof Off_chain_pool_dataScalarFieldEnum)[keyof typeof Off_chain_pool_dataScalarFieldEnum]


  export const Off_chain_pool_fetch_errorScalarFieldEnum: {
    id: 'id',
    pool_id: 'pool_id',
    fetch_time: 'fetch_time',
    pmr_id: 'pmr_id',
    fetch_error: 'fetch_error',
    retry_count: 'retry_count'
  };

  export type Off_chain_pool_fetch_errorScalarFieldEnum = (typeof Off_chain_pool_fetch_errorScalarFieldEnum)[keyof typeof Off_chain_pool_fetch_errorScalarFieldEnum]


  export const Off_chain_vote_authorScalarFieldEnum: {
    id: 'id',
    off_chain_vote_data_id: 'off_chain_vote_data_id',
    name: 'name',
    witness_algorithm: 'witness_algorithm',
    public_key: 'public_key',
    signature: 'signature',
    warning: 'warning'
  };

  export type Off_chain_vote_authorScalarFieldEnum = (typeof Off_chain_vote_authorScalarFieldEnum)[keyof typeof Off_chain_vote_authorScalarFieldEnum]


  export const Off_chain_vote_dataScalarFieldEnum: {
    id: 'id',
    voting_anchor_id: 'voting_anchor_id',
    hash: 'hash',
    json: 'json',
    bytes: 'bytes',
    warning: 'warning',
    language: 'language',
    comment: 'comment',
    is_valid: 'is_valid'
  };

  export type Off_chain_vote_dataScalarFieldEnum = (typeof Off_chain_vote_dataScalarFieldEnum)[keyof typeof Off_chain_vote_dataScalarFieldEnum]


  export const Off_chain_vote_drep_dataScalarFieldEnum: {
    id: 'id',
    off_chain_vote_data_id: 'off_chain_vote_data_id',
    payment_address: 'payment_address',
    given_name: 'given_name',
    objectives: 'objectives',
    motivations: 'motivations',
    qualifications: 'qualifications',
    image_url: 'image_url',
    image_hash: 'image_hash'
  };

  export type Off_chain_vote_drep_dataScalarFieldEnum = (typeof Off_chain_vote_drep_dataScalarFieldEnum)[keyof typeof Off_chain_vote_drep_dataScalarFieldEnum]


  export const Off_chain_vote_external_updateScalarFieldEnum: {
    id: 'id',
    off_chain_vote_data_id: 'off_chain_vote_data_id',
    title: 'title',
    uri: 'uri'
  };

  export type Off_chain_vote_external_updateScalarFieldEnum = (typeof Off_chain_vote_external_updateScalarFieldEnum)[keyof typeof Off_chain_vote_external_updateScalarFieldEnum]


  export const Off_chain_vote_fetch_errorScalarFieldEnum: {
    id: 'id',
    voting_anchor_id: 'voting_anchor_id',
    fetch_error: 'fetch_error',
    fetch_time: 'fetch_time',
    retry_count: 'retry_count'
  };

  export type Off_chain_vote_fetch_errorScalarFieldEnum = (typeof Off_chain_vote_fetch_errorScalarFieldEnum)[keyof typeof Off_chain_vote_fetch_errorScalarFieldEnum]


  export const Off_chain_vote_gov_action_dataScalarFieldEnum: {
    id: 'id',
    off_chain_vote_data_id: 'off_chain_vote_data_id',
    title: 'title',
    abstract: 'abstract',
    motivation: 'motivation',
    rationale: 'rationale'
  };

  export type Off_chain_vote_gov_action_dataScalarFieldEnum = (typeof Off_chain_vote_gov_action_dataScalarFieldEnum)[keyof typeof Off_chain_vote_gov_action_dataScalarFieldEnum]


  export const Off_chain_vote_referenceScalarFieldEnum: {
    id: 'id',
    off_chain_vote_data_id: 'off_chain_vote_data_id',
    label: 'label',
    uri: 'uri',
    hash_digest: 'hash_digest',
    hash_algorithm: 'hash_algorithm'
  };

  export type Off_chain_vote_referenceScalarFieldEnum = (typeof Off_chain_vote_referenceScalarFieldEnum)[keyof typeof Off_chain_vote_referenceScalarFieldEnum]


  export const Param_proposalScalarFieldEnum: {
    id: 'id',
    epoch_no: 'epoch_no',
    key: 'key',
    min_fee_a: 'min_fee_a',
    min_fee_b: 'min_fee_b',
    max_block_size: 'max_block_size',
    max_tx_size: 'max_tx_size',
    max_bh_size: 'max_bh_size',
    key_deposit: 'key_deposit',
    pool_deposit: 'pool_deposit',
    max_epoch: 'max_epoch',
    optimal_pool_count: 'optimal_pool_count',
    influence: 'influence',
    monetary_expand_rate: 'monetary_expand_rate',
    treasury_growth_rate: 'treasury_growth_rate',
    decentralisation: 'decentralisation',
    entropy: 'entropy',
    protocol_major: 'protocol_major',
    protocol_minor: 'protocol_minor',
    min_utxo_value: 'min_utxo_value',
    min_pool_cost: 'min_pool_cost',
    cost_model_id: 'cost_model_id',
    price_mem: 'price_mem',
    price_step: 'price_step',
    max_tx_ex_mem: 'max_tx_ex_mem',
    max_tx_ex_steps: 'max_tx_ex_steps',
    max_block_ex_mem: 'max_block_ex_mem',
    max_block_ex_steps: 'max_block_ex_steps',
    max_val_size: 'max_val_size',
    collateral_percent: 'collateral_percent',
    max_collateral_inputs: 'max_collateral_inputs',
    registered_tx_id: 'registered_tx_id',
    coins_per_utxo_size: 'coins_per_utxo_size',
    pvt_motion_no_confidence: 'pvt_motion_no_confidence',
    pvt_committee_normal: 'pvt_committee_normal',
    pvt_committee_no_confidence: 'pvt_committee_no_confidence',
    pvt_hard_fork_initiation: 'pvt_hard_fork_initiation',
    dvt_motion_no_confidence: 'dvt_motion_no_confidence',
    dvt_committee_normal: 'dvt_committee_normal',
    dvt_committee_no_confidence: 'dvt_committee_no_confidence',
    dvt_update_to_constitution: 'dvt_update_to_constitution',
    dvt_hard_fork_initiation: 'dvt_hard_fork_initiation',
    dvt_p_p_network_group: 'dvt_p_p_network_group',
    dvt_p_p_economic_group: 'dvt_p_p_economic_group',
    dvt_p_p_technical_group: 'dvt_p_p_technical_group',
    dvt_p_p_gov_group: 'dvt_p_p_gov_group',
    dvt_treasury_withdrawal: 'dvt_treasury_withdrawal',
    committee_min_size: 'committee_min_size',
    committee_max_term_length: 'committee_max_term_length',
    gov_action_lifetime: 'gov_action_lifetime',
    gov_action_deposit: 'gov_action_deposit',
    drep_deposit: 'drep_deposit',
    drep_activity: 'drep_activity',
    pvtpp_security_group: 'pvtpp_security_group',
    min_fee_ref_script_cost_per_byte: 'min_fee_ref_script_cost_per_byte'
  };

  export type Param_proposalScalarFieldEnum = (typeof Param_proposalScalarFieldEnum)[keyof typeof Param_proposalScalarFieldEnum]


  export const Pool_hashScalarFieldEnum: {
    id: 'id',
    hash_raw: 'hash_raw',
    view: 'view'
  };

  export type Pool_hashScalarFieldEnum = (typeof Pool_hashScalarFieldEnum)[keyof typeof Pool_hashScalarFieldEnum]


  export const Pool_metadata_refScalarFieldEnum: {
    id: 'id',
    pool_id: 'pool_id',
    url: 'url',
    hash: 'hash',
    registered_tx_id: 'registered_tx_id'
  };

  export type Pool_metadata_refScalarFieldEnum = (typeof Pool_metadata_refScalarFieldEnum)[keyof typeof Pool_metadata_refScalarFieldEnum]


  export const Pool_ownerScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    pool_update_id: 'pool_update_id'
  };

  export type Pool_ownerScalarFieldEnum = (typeof Pool_ownerScalarFieldEnum)[keyof typeof Pool_ownerScalarFieldEnum]


  export const Pool_relayScalarFieldEnum: {
    id: 'id',
    update_id: 'update_id',
    ipv4: 'ipv4',
    ipv6: 'ipv6',
    dns_name: 'dns_name',
    dns_srv_name: 'dns_srv_name',
    port: 'port'
  };

  export type Pool_relayScalarFieldEnum = (typeof Pool_relayScalarFieldEnum)[keyof typeof Pool_relayScalarFieldEnum]


  export const Pool_retireScalarFieldEnum: {
    id: 'id',
    hash_id: 'hash_id',
    cert_index: 'cert_index',
    announced_tx_id: 'announced_tx_id',
    retiring_epoch: 'retiring_epoch'
  };

  export type Pool_retireScalarFieldEnum = (typeof Pool_retireScalarFieldEnum)[keyof typeof Pool_retireScalarFieldEnum]


  export const Pool_statScalarFieldEnum: {
    id: 'id',
    pool_hash_id: 'pool_hash_id',
    epoch_no: 'epoch_no',
    number_of_blocks: 'number_of_blocks',
    number_of_delegators: 'number_of_delegators',
    stake: 'stake',
    voting_power: 'voting_power'
  };

  export type Pool_statScalarFieldEnum = (typeof Pool_statScalarFieldEnum)[keyof typeof Pool_statScalarFieldEnum]


  export const Pool_updateScalarFieldEnum: {
    id: 'id',
    hash_id: 'hash_id',
    cert_index: 'cert_index',
    vrf_key_hash: 'vrf_key_hash',
    pledge: 'pledge',
    active_epoch_no: 'active_epoch_no',
    meta_id: 'meta_id',
    margin: 'margin',
    fixed_cost: 'fixed_cost',
    registered_tx_id: 'registered_tx_id',
    reward_addr_id: 'reward_addr_id',
    deposit: 'deposit'
  };

  export type Pool_updateScalarFieldEnum = (typeof Pool_updateScalarFieldEnum)[keyof typeof Pool_updateScalarFieldEnum]


  export const Pot_transferScalarFieldEnum: {
    id: 'id',
    cert_index: 'cert_index',
    treasury: 'treasury',
    reserves: 'reserves',
    tx_id: 'tx_id'
  };

  export type Pot_transferScalarFieldEnum = (typeof Pot_transferScalarFieldEnum)[keyof typeof Pot_transferScalarFieldEnum]


  export const RedeemerScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    unit_mem: 'unit_mem',
    unit_steps: 'unit_steps',
    fee: 'fee',
    purpose: 'purpose',
    index: 'index',
    script_hash: 'script_hash',
    redeemer_data_id: 'redeemer_data_id'
  };

  export type RedeemerScalarFieldEnum = (typeof RedeemerScalarFieldEnum)[keyof typeof RedeemerScalarFieldEnum]


  export const Redeemer_dataScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    tx_id: 'tx_id',
    value: 'value',
    bytes: 'bytes'
  };

  export type Redeemer_dataScalarFieldEnum = (typeof Redeemer_dataScalarFieldEnum)[keyof typeof Redeemer_dataScalarFieldEnum]


  export const Reference_tx_inScalarFieldEnum: {
    id: 'id',
    tx_in_id: 'tx_in_id',
    tx_out_id: 'tx_out_id',
    tx_out_index: 'tx_out_index'
  };

  export type Reference_tx_inScalarFieldEnum = (typeof Reference_tx_inScalarFieldEnum)[keyof typeof Reference_tx_inScalarFieldEnum]


  export const ReserveScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    amount: 'amount',
    tx_id: 'tx_id'
  };

  export type ReserveScalarFieldEnum = (typeof ReserveScalarFieldEnum)[keyof typeof ReserveScalarFieldEnum]


  export const Reserved_pool_tickerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pool_hash: 'pool_hash'
  };

  export type Reserved_pool_tickerScalarFieldEnum = (typeof Reserved_pool_tickerScalarFieldEnum)[keyof typeof Reserved_pool_tickerScalarFieldEnum]


  export const Reverse_indexScalarFieldEnum: {
    id: 'id',
    block_id: 'block_id',
    min_ids: 'min_ids'
  };

  export type Reverse_indexScalarFieldEnum = (typeof Reverse_indexScalarFieldEnum)[keyof typeof Reverse_indexScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    addr_id: 'addr_id',
    type: 'type',
    amount: 'amount',
    spendable_epoch: 'spendable_epoch',
    pool_id: 'pool_id',
    earned_epoch: 'earned_epoch'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const Schema_versionScalarFieldEnum: {
    id: 'id',
    stage_one: 'stage_one',
    stage_two: 'stage_two',
    stage_three: 'stage_three'
  };

  export type Schema_versionScalarFieldEnum = (typeof Schema_versionScalarFieldEnum)[keyof typeof Schema_versionScalarFieldEnum]


  export const ScriptScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    hash: 'hash',
    type: 'type',
    json: 'json',
    bytes: 'bytes',
    serialised_size: 'serialised_size'
  };

  export type ScriptScalarFieldEnum = (typeof ScriptScalarFieldEnum)[keyof typeof ScriptScalarFieldEnum]


  export const Slot_leaderScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    pool_hash_id: 'pool_hash_id',
    description: 'description'
  };

  export type Slot_leaderScalarFieldEnum = (typeof Slot_leaderScalarFieldEnum)[keyof typeof Slot_leaderScalarFieldEnum]


  export const Stake_addressScalarFieldEnum: {
    id: 'id',
    hash_raw: 'hash_raw',
    view: 'view',
    script_hash: 'script_hash'
  };

  export type Stake_addressScalarFieldEnum = (typeof Stake_addressScalarFieldEnum)[keyof typeof Stake_addressScalarFieldEnum]


  export const Stake_deregistrationScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    epoch_no: 'epoch_no',
    tx_id: 'tx_id',
    redeemer_id: 'redeemer_id'
  };

  export type Stake_deregistrationScalarFieldEnum = (typeof Stake_deregistrationScalarFieldEnum)[keyof typeof Stake_deregistrationScalarFieldEnum]


  export const Stake_registrationScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    epoch_no: 'epoch_no',
    tx_id: 'tx_id',
    deposit: 'deposit'
  };

  export type Stake_registrationScalarFieldEnum = (typeof Stake_registrationScalarFieldEnum)[keyof typeof Stake_registrationScalarFieldEnum]


  export const TreasuryScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    cert_index: 'cert_index',
    amount: 'amount',
    tx_id: 'tx_id'
  };

  export type TreasuryScalarFieldEnum = (typeof TreasuryScalarFieldEnum)[keyof typeof TreasuryScalarFieldEnum]


  export const Treasury_withdrawalScalarFieldEnum: {
    id: 'id',
    gov_action_proposal_id: 'gov_action_proposal_id',
    stake_address_id: 'stake_address_id',
    amount: 'amount'
  };

  export type Treasury_withdrawalScalarFieldEnum = (typeof Treasury_withdrawalScalarFieldEnum)[keyof typeof Treasury_withdrawalScalarFieldEnum]


  export const TxScalarFieldEnum: {
    id: 'id',
    hash: 'hash',
    block_id: 'block_id',
    block_index: 'block_index',
    out_sum: 'out_sum',
    fee: 'fee',
    deposit: 'deposit',
    size: 'size',
    invalid_before: 'invalid_before',
    invalid_hereafter: 'invalid_hereafter',
    valid_contract: 'valid_contract',
    script_size: 'script_size',
    treasury_donation: 'treasury_donation'
  };

  export type TxScalarFieldEnum = (typeof TxScalarFieldEnum)[keyof typeof TxScalarFieldEnum]


  export const Tx_cborScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    bytes: 'bytes'
  };

  export type Tx_cborScalarFieldEnum = (typeof Tx_cborScalarFieldEnum)[keyof typeof Tx_cborScalarFieldEnum]


  export const Tx_inScalarFieldEnum: {
    id: 'id',
    tx_in_id: 'tx_in_id',
    tx_out_id: 'tx_out_id',
    tx_out_index: 'tx_out_index',
    redeemer_id: 'redeemer_id'
  };

  export type Tx_inScalarFieldEnum = (typeof Tx_inScalarFieldEnum)[keyof typeof Tx_inScalarFieldEnum]


  export const Tx_metadataScalarFieldEnum: {
    id: 'id',
    key: 'key',
    json: 'json',
    bytes: 'bytes',
    tx_id: 'tx_id'
  };

  export type Tx_metadataScalarFieldEnum = (typeof Tx_metadataScalarFieldEnum)[keyof typeof Tx_metadataScalarFieldEnum]


  export const Tx_outScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    index: 'index',
    address: 'address',
    address_has_script: 'address_has_script',
    payment_cred: 'payment_cred',
    stake_address_id: 'stake_address_id',
    value: 'value',
    data_hash: 'data_hash',
    inline_datum_id: 'inline_datum_id',
    reference_script_id: 'reference_script_id',
    consumed_by_tx_id: 'consumed_by_tx_id'
  };

  export type Tx_outScalarFieldEnum = (typeof Tx_outScalarFieldEnum)[keyof typeof Tx_outScalarFieldEnum]


  export const Voting_anchorScalarFieldEnum: {
    id: 'id',
    url: 'url',
    data_hash: 'data_hash',
    type: 'type',
    block_id: 'block_id'
  };

  export type Voting_anchorScalarFieldEnum = (typeof Voting_anchorScalarFieldEnum)[keyof typeof Voting_anchorScalarFieldEnum]


  export const Voting_procedureScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    index: 'index',
    gov_action_proposal_id: 'gov_action_proposal_id',
    voter_role: 'voter_role',
    drep_voter: 'drep_voter',
    pool_voter: 'pool_voter',
    vote: 'vote',
    voting_anchor_id: 'voting_anchor_id',
    committee_voter: 'committee_voter',
    invalid: 'invalid'
  };

  export type Voting_procedureScalarFieldEnum = (typeof Voting_procedureScalarFieldEnum)[keyof typeof Voting_procedureScalarFieldEnum]


  export const WithdrawalScalarFieldEnum: {
    id: 'id',
    addr_id: 'addr_id',
    amount: 'amount',
    redeemer_id: 'redeemer_id',
    tx_id: 'tx_id'
  };

  export type WithdrawalScalarFieldEnum = (typeof WithdrawalScalarFieldEnum)[keyof typeof WithdrawalScalarFieldEnum]


  export const Sqlx_migrationsScalarFieldEnum: {
    version: 'version',
    description: 'description',
    installed_on: 'installed_on',
    success: 'success',
    checksum: 'checksum',
    execution_time: 'execution_time'
  };

  export type Sqlx_migrationsScalarFieldEnum = (typeof Sqlx_migrationsScalarFieldEnum)[keyof typeof Sqlx_migrationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'syncstatetype'
   */
  export type EnumsyncstatetypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'syncstatetype'>
    


  /**
   * Reference to a field of type 'syncstatetype[]'
   */
  export type ListEnumsyncstatetypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'syncstatetype[]'>
    


  /**
   * Reference to a field of type 'govactiontype'
   */
  export type EnumgovactiontypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'govactiontype'>
    


  /**
   * Reference to a field of type 'govactiontype[]'
   */
  export type ListEnumgovactiontypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'govactiontype[]'>
    


  /**
   * Reference to a field of type 'scriptpurposetype'
   */
  export type EnumscriptpurposetypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scriptpurposetype'>
    


  /**
   * Reference to a field of type 'scriptpurposetype[]'
   */
  export type ListEnumscriptpurposetypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scriptpurposetype[]'>
    


  /**
   * Reference to a field of type 'rewardtype'
   */
  export type EnumrewardtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rewardtype'>
    


  /**
   * Reference to a field of type 'rewardtype[]'
   */
  export type ListEnumrewardtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rewardtype[]'>
    


  /**
   * Reference to a field of type 'scripttype'
   */
  export type EnumscripttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scripttype'>
    


  /**
   * Reference to a field of type 'scripttype[]'
   */
  export type ListEnumscripttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'scripttype[]'>
    


  /**
   * Reference to a field of type 'anchortype'
   */
  export type EnumanchortypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'anchortype'>
    


  /**
   * Reference to a field of type 'anchortype[]'
   */
  export type ListEnumanchortypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'anchortype[]'>
    


  /**
   * Reference to a field of type 'voterrole'
   */
  export type EnumvoterroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'voterrole'>
    


  /**
   * Reference to a field of type 'voterrole[]'
   */
  export type ListEnumvoterroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'voterrole[]'>
    


  /**
   * Reference to a field of type 'vote'
   */
  export type EnumvoteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'vote'>
    


  /**
   * Reference to a field of type 'vote[]'
   */
  export type ListEnumvoteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'vote[]'>
    
  /**
   * Deep Input Types
   */


  export type ada_potsWhereInput = {
    AND?: ada_potsWhereInput | ada_potsWhereInput[]
    OR?: ada_potsWhereInput[]
    NOT?: ada_potsWhereInput | ada_potsWhereInput[]
    id?: BigIntFilter<"ada_pots"> | bigint | number
    slot_no?: BigIntFilter<"ada_pots"> | bigint | number
    epoch_no?: IntFilter<"ada_pots"> | number
    treasury?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFilter<"ada_pots"> | bigint | number
    deposits_drep?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
  }

  export type ada_potsOrderByWithRelationInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type ada_potsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ada_potsWhereInput | ada_potsWhereInput[]
    OR?: ada_potsWhereInput[]
    NOT?: ada_potsWhereInput | ada_potsWhereInput[]
    slot_no?: BigIntFilter<"ada_pots"> | bigint | number
    epoch_no?: IntFilter<"ada_pots"> | number
    treasury?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFilter<"ada_pots"> | bigint | number
    deposits_drep?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type ada_potsOrderByWithAggregationInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
    _count?: ada_potsCountOrderByAggregateInput
    _avg?: ada_potsAvgOrderByAggregateInput
    _max?: ada_potsMaxOrderByAggregateInput
    _min?: ada_potsMinOrderByAggregateInput
    _sum?: ada_potsSumOrderByAggregateInput
  }

  export type ada_potsScalarWhereWithAggregatesInput = {
    AND?: ada_potsScalarWhereWithAggregatesInput | ada_potsScalarWhereWithAggregatesInput[]
    OR?: ada_potsScalarWhereWithAggregatesInput[]
    NOT?: ada_potsScalarWhereWithAggregatesInput | ada_potsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ada_pots"> | bigint | number
    slot_no?: BigIntWithAggregatesFilter<"ada_pots"> | bigint | number
    epoch_no?: IntWithAggregatesFilter<"ada_pots"> | number
    treasury?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    rewards?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    utxo?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    block_id?: BigIntWithAggregatesFilter<"ada_pots"> | bigint | number
    deposits_drep?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalWithAggregatesFilter<"ada_pots"> | Decimal | DecimalJsLike | number | string
  }

  export type blockWhereInput = {
    AND?: blockWhereInput | blockWhereInput[]
    OR?: blockWhereInput[]
    NOT?: blockWhereInput | blockWhereInput[]
    id?: BigIntFilter<"block"> | bigint | number
    hash?: BytesFilter<"block"> | Uint8Array
    epoch_no?: IntNullableFilter<"block"> | number | null
    slot_no?: BigIntNullableFilter<"block"> | bigint | number | null
    epoch_slot_no?: IntNullableFilter<"block"> | number | null
    block_no?: IntNullableFilter<"block"> | number | null
    previous_id?: BigIntNullableFilter<"block"> | bigint | number | null
    slot_leader_id?: BigIntFilter<"block"> | bigint | number
    size?: IntFilter<"block"> | number
    time?: DateTimeFilter<"block"> | Date | string
    tx_count?: BigIntFilter<"block"> | bigint | number
    proto_major?: IntFilter<"block"> | number
    proto_minor?: IntFilter<"block"> | number
    vrf_key?: StringNullableFilter<"block"> | string | null
    op_cert?: BytesNullableFilter<"block"> | Uint8Array | null
    op_cert_counter?: BigIntNullableFilter<"block"> | bigint | number | null
  }

  export type blockOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    epoch_no?: SortOrderInput | SortOrder
    slot_no?: SortOrderInput | SortOrder
    epoch_slot_no?: SortOrderInput | SortOrder
    block_no?: SortOrderInput | SortOrder
    previous_id?: SortOrderInput | SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    time?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    vrf_key?: SortOrderInput | SortOrder
    op_cert?: SortOrderInput | SortOrder
    op_cert_counter?: SortOrderInput | SortOrder
  }

  export type blockWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: blockWhereInput | blockWhereInput[]
    OR?: blockWhereInput[]
    NOT?: blockWhereInput | blockWhereInput[]
    epoch_no?: IntNullableFilter<"block"> | number | null
    slot_no?: BigIntNullableFilter<"block"> | bigint | number | null
    epoch_slot_no?: IntNullableFilter<"block"> | number | null
    block_no?: IntNullableFilter<"block"> | number | null
    previous_id?: BigIntNullableFilter<"block"> | bigint | number | null
    slot_leader_id?: BigIntFilter<"block"> | bigint | number
    size?: IntFilter<"block"> | number
    time?: DateTimeFilter<"block"> | Date | string
    tx_count?: BigIntFilter<"block"> | bigint | number
    proto_major?: IntFilter<"block"> | number
    proto_minor?: IntFilter<"block"> | number
    vrf_key?: StringNullableFilter<"block"> | string | null
    op_cert?: BytesNullableFilter<"block"> | Uint8Array | null
    op_cert_counter?: BigIntNullableFilter<"block"> | bigint | number | null
  }, "id" | "hash">

  export type blockOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    epoch_no?: SortOrderInput | SortOrder
    slot_no?: SortOrderInput | SortOrder
    epoch_slot_no?: SortOrderInput | SortOrder
    block_no?: SortOrderInput | SortOrder
    previous_id?: SortOrderInput | SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    time?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    vrf_key?: SortOrderInput | SortOrder
    op_cert?: SortOrderInput | SortOrder
    op_cert_counter?: SortOrderInput | SortOrder
    _count?: blockCountOrderByAggregateInput
    _avg?: blockAvgOrderByAggregateInput
    _max?: blockMaxOrderByAggregateInput
    _min?: blockMinOrderByAggregateInput
    _sum?: blockSumOrderByAggregateInput
  }

  export type blockScalarWhereWithAggregatesInput = {
    AND?: blockScalarWhereWithAggregatesInput | blockScalarWhereWithAggregatesInput[]
    OR?: blockScalarWhereWithAggregatesInput[]
    NOT?: blockScalarWhereWithAggregatesInput | blockScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"block"> | bigint | number
    hash?: BytesWithAggregatesFilter<"block"> | Uint8Array
    epoch_no?: IntNullableWithAggregatesFilter<"block"> | number | null
    slot_no?: BigIntNullableWithAggregatesFilter<"block"> | bigint | number | null
    epoch_slot_no?: IntNullableWithAggregatesFilter<"block"> | number | null
    block_no?: IntNullableWithAggregatesFilter<"block"> | number | null
    previous_id?: BigIntNullableWithAggregatesFilter<"block"> | bigint | number | null
    slot_leader_id?: BigIntWithAggregatesFilter<"block"> | bigint | number
    size?: IntWithAggregatesFilter<"block"> | number
    time?: DateTimeWithAggregatesFilter<"block"> | Date | string
    tx_count?: BigIntWithAggregatesFilter<"block"> | bigint | number
    proto_major?: IntWithAggregatesFilter<"block"> | number
    proto_minor?: IntWithAggregatesFilter<"block"> | number
    vrf_key?: StringNullableWithAggregatesFilter<"block"> | string | null
    op_cert?: BytesNullableWithAggregatesFilter<"block"> | Uint8Array | null
    op_cert_counter?: BigIntNullableWithAggregatesFilter<"block"> | bigint | number | null
  }

  export type collateral_tx_inWhereInput = {
    AND?: collateral_tx_inWhereInput | collateral_tx_inWhereInput[]
    OR?: collateral_tx_inWhereInput[]
    NOT?: collateral_tx_inWhereInput | collateral_tx_inWhereInput[]
    id?: BigIntFilter<"collateral_tx_in"> | bigint | number
    tx_in_id?: BigIntFilter<"collateral_tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"collateral_tx_in"> | bigint | number
    tx_out_index?: IntFilter<"collateral_tx_in"> | number
  }

  export type collateral_tx_inOrderByWithRelationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type collateral_tx_inWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: collateral_tx_inWhereInput | collateral_tx_inWhereInput[]
    OR?: collateral_tx_inWhereInput[]
    NOT?: collateral_tx_inWhereInput | collateral_tx_inWhereInput[]
    tx_in_id?: BigIntFilter<"collateral_tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"collateral_tx_in"> | bigint | number
    tx_out_index?: IntFilter<"collateral_tx_in"> | number
  }, "id">

  export type collateral_tx_inOrderByWithAggregationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    _count?: collateral_tx_inCountOrderByAggregateInput
    _avg?: collateral_tx_inAvgOrderByAggregateInput
    _max?: collateral_tx_inMaxOrderByAggregateInput
    _min?: collateral_tx_inMinOrderByAggregateInput
    _sum?: collateral_tx_inSumOrderByAggregateInput
  }

  export type collateral_tx_inScalarWhereWithAggregatesInput = {
    AND?: collateral_tx_inScalarWhereWithAggregatesInput | collateral_tx_inScalarWhereWithAggregatesInput[]
    OR?: collateral_tx_inScalarWhereWithAggregatesInput[]
    NOT?: collateral_tx_inScalarWhereWithAggregatesInput | collateral_tx_inScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collateral_tx_in"> | bigint | number
    tx_in_id?: BigIntWithAggregatesFilter<"collateral_tx_in"> | bigint | number
    tx_out_id?: BigIntWithAggregatesFilter<"collateral_tx_in"> | bigint | number
    tx_out_index?: IntWithAggregatesFilter<"collateral_tx_in"> | number
  }

  export type collateral_tx_outWhereInput = {
    AND?: collateral_tx_outWhereInput | collateral_tx_outWhereInput[]
    OR?: collateral_tx_outWhereInput[]
    NOT?: collateral_tx_outWhereInput | collateral_tx_outWhereInput[]
    id?: BigIntFilter<"collateral_tx_out"> | bigint | number
    tx_id?: BigIntFilter<"collateral_tx_out"> | bigint | number
    index?: IntFilter<"collateral_tx_out"> | number
    address?: StringFilter<"collateral_tx_out"> | string
    address_has_script?: BoolFilter<"collateral_tx_out"> | boolean
    payment_cred?: BytesNullableFilter<"collateral_tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
    value?: DecimalFilter<"collateral_tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableFilter<"collateral_tx_out"> | Uint8Array | null
    multi_assets_descr?: StringFilter<"collateral_tx_out"> | string
    inline_datum_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
  }

  export type collateral_tx_outOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrderInput | SortOrder
    stake_address_id?: SortOrderInput | SortOrder
    value?: SortOrder
    data_hash?: SortOrderInput | SortOrder
    multi_assets_descr?: SortOrder
    inline_datum_id?: SortOrderInput | SortOrder
    reference_script_id?: SortOrderInput | SortOrder
  }

  export type collateral_tx_outWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: collateral_tx_outWhereInput | collateral_tx_outWhereInput[]
    OR?: collateral_tx_outWhereInput[]
    NOT?: collateral_tx_outWhereInput | collateral_tx_outWhereInput[]
    tx_id?: BigIntFilter<"collateral_tx_out"> | bigint | number
    index?: IntFilter<"collateral_tx_out"> | number
    address?: StringFilter<"collateral_tx_out"> | string
    address_has_script?: BoolFilter<"collateral_tx_out"> | boolean
    payment_cred?: BytesNullableFilter<"collateral_tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
    value?: DecimalFilter<"collateral_tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableFilter<"collateral_tx_out"> | Uint8Array | null
    multi_assets_descr?: StringFilter<"collateral_tx_out"> | string
    inline_datum_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableFilter<"collateral_tx_out"> | bigint | number | null
  }, "id">

  export type collateral_tx_outOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrderInput | SortOrder
    stake_address_id?: SortOrderInput | SortOrder
    value?: SortOrder
    data_hash?: SortOrderInput | SortOrder
    multi_assets_descr?: SortOrder
    inline_datum_id?: SortOrderInput | SortOrder
    reference_script_id?: SortOrderInput | SortOrder
    _count?: collateral_tx_outCountOrderByAggregateInput
    _avg?: collateral_tx_outAvgOrderByAggregateInput
    _max?: collateral_tx_outMaxOrderByAggregateInput
    _min?: collateral_tx_outMinOrderByAggregateInput
    _sum?: collateral_tx_outSumOrderByAggregateInput
  }

  export type collateral_tx_outScalarWhereWithAggregatesInput = {
    AND?: collateral_tx_outScalarWhereWithAggregatesInput | collateral_tx_outScalarWhereWithAggregatesInput[]
    OR?: collateral_tx_outScalarWhereWithAggregatesInput[]
    NOT?: collateral_tx_outScalarWhereWithAggregatesInput | collateral_tx_outScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"collateral_tx_out"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"collateral_tx_out"> | bigint | number
    index?: IntWithAggregatesFilter<"collateral_tx_out"> | number
    address?: StringWithAggregatesFilter<"collateral_tx_out"> | string
    address_has_script?: BoolWithAggregatesFilter<"collateral_tx_out"> | boolean
    payment_cred?: BytesNullableWithAggregatesFilter<"collateral_tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableWithAggregatesFilter<"collateral_tx_out"> | bigint | number | null
    value?: DecimalWithAggregatesFilter<"collateral_tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableWithAggregatesFilter<"collateral_tx_out"> | Uint8Array | null
    multi_assets_descr?: StringWithAggregatesFilter<"collateral_tx_out"> | string
    inline_datum_id?: BigIntNullableWithAggregatesFilter<"collateral_tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableWithAggregatesFilter<"collateral_tx_out"> | bigint | number | null
  }

  export type committeeWhereInput = {
    AND?: committeeWhereInput | committeeWhereInput[]
    OR?: committeeWhereInput[]
    NOT?: committeeWhereInput | committeeWhereInput[]
    id?: BigIntFilter<"committee"> | bigint | number
    gov_action_proposal_id?: BigIntNullableFilter<"committee"> | bigint | number | null
    quorum_numerator?: BigIntFilter<"committee"> | bigint | number
    quorum_denominator?: BigIntFilter<"committee"> | bigint | number
    committee_member?: Committee_memberListRelationFilter
  }

  export type committeeOrderByWithRelationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrderInput | SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
    committee_member?: committee_memberOrderByRelationAggregateInput
  }

  export type committeeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: committeeWhereInput | committeeWhereInput[]
    OR?: committeeWhereInput[]
    NOT?: committeeWhereInput | committeeWhereInput[]
    gov_action_proposal_id?: BigIntNullableFilter<"committee"> | bigint | number | null
    quorum_numerator?: BigIntFilter<"committee"> | bigint | number
    quorum_denominator?: BigIntFilter<"committee"> | bigint | number
    committee_member?: Committee_memberListRelationFilter
  }, "id">

  export type committeeOrderByWithAggregationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrderInput | SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
    _count?: committeeCountOrderByAggregateInput
    _avg?: committeeAvgOrderByAggregateInput
    _max?: committeeMaxOrderByAggregateInput
    _min?: committeeMinOrderByAggregateInput
    _sum?: committeeSumOrderByAggregateInput
  }

  export type committeeScalarWhereWithAggregatesInput = {
    AND?: committeeScalarWhereWithAggregatesInput | committeeScalarWhereWithAggregatesInput[]
    OR?: committeeScalarWhereWithAggregatesInput[]
    NOT?: committeeScalarWhereWithAggregatesInput | committeeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"committee"> | bigint | number
    gov_action_proposal_id?: BigIntNullableWithAggregatesFilter<"committee"> | bigint | number | null
    quorum_numerator?: BigIntWithAggregatesFilter<"committee"> | bigint | number
    quorum_denominator?: BigIntWithAggregatesFilter<"committee"> | bigint | number
  }

  export type committee_de_registrationWhereInput = {
    AND?: committee_de_registrationWhereInput | committee_de_registrationWhereInput[]
    OR?: committee_de_registrationWhereInput[]
    NOT?: committee_de_registrationWhereInput | committee_de_registrationWhereInput[]
    id?: BigIntFilter<"committee_de_registration"> | bigint | number
    tx_id?: BigIntFilter<"committee_de_registration"> | bigint | number
    cert_index?: IntFilter<"committee_de_registration"> | number
    voting_anchor_id?: BigIntNullableFilter<"committee_de_registration"> | bigint | number | null
    cold_key_id?: BigIntFilter<"committee_de_registration"> | bigint | number
  }

  export type committee_de_registrationOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_de_registrationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: committee_de_registrationWhereInput | committee_de_registrationWhereInput[]
    OR?: committee_de_registrationWhereInput[]
    NOT?: committee_de_registrationWhereInput | committee_de_registrationWhereInput[]
    tx_id?: BigIntFilter<"committee_de_registration"> | bigint | number
    cert_index?: IntFilter<"committee_de_registration"> | number
    voting_anchor_id?: BigIntNullableFilter<"committee_de_registration"> | bigint | number | null
    cold_key_id?: BigIntFilter<"committee_de_registration"> | bigint | number
  }, "id">

  export type committee_de_registrationOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    cold_key_id?: SortOrder
    _count?: committee_de_registrationCountOrderByAggregateInput
    _avg?: committee_de_registrationAvgOrderByAggregateInput
    _max?: committee_de_registrationMaxOrderByAggregateInput
    _min?: committee_de_registrationMinOrderByAggregateInput
    _sum?: committee_de_registrationSumOrderByAggregateInput
  }

  export type committee_de_registrationScalarWhereWithAggregatesInput = {
    AND?: committee_de_registrationScalarWhereWithAggregatesInput | committee_de_registrationScalarWhereWithAggregatesInput[]
    OR?: committee_de_registrationScalarWhereWithAggregatesInput[]
    NOT?: committee_de_registrationScalarWhereWithAggregatesInput | committee_de_registrationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"committee_de_registration"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"committee_de_registration"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"committee_de_registration"> | number
    voting_anchor_id?: BigIntNullableWithAggregatesFilter<"committee_de_registration"> | bigint | number | null
    cold_key_id?: BigIntWithAggregatesFilter<"committee_de_registration"> | bigint | number
  }

  export type committee_hashWhereInput = {
    AND?: committee_hashWhereInput | committee_hashWhereInput[]
    OR?: committee_hashWhereInput[]
    NOT?: committee_hashWhereInput | committee_hashWhereInput[]
    id?: BigIntFilter<"committee_hash"> | bigint | number
    raw?: BytesFilter<"committee_hash"> | Uint8Array
    has_script?: BoolFilter<"committee_hash"> | boolean
  }

  export type committee_hashOrderByWithRelationInput = {
    id?: SortOrder
    raw?: SortOrder
    has_script?: SortOrder
  }

  export type committee_hashWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    raw_has_script?: committee_hashRawHas_scriptCompoundUniqueInput
    AND?: committee_hashWhereInput | committee_hashWhereInput[]
    OR?: committee_hashWhereInput[]
    NOT?: committee_hashWhereInput | committee_hashWhereInput[]
    raw?: BytesFilter<"committee_hash"> | Uint8Array
    has_script?: BoolFilter<"committee_hash"> | boolean
  }, "id" | "raw_has_script">

  export type committee_hashOrderByWithAggregationInput = {
    id?: SortOrder
    raw?: SortOrder
    has_script?: SortOrder
    _count?: committee_hashCountOrderByAggregateInput
    _avg?: committee_hashAvgOrderByAggregateInput
    _max?: committee_hashMaxOrderByAggregateInput
    _min?: committee_hashMinOrderByAggregateInput
    _sum?: committee_hashSumOrderByAggregateInput
  }

  export type committee_hashScalarWhereWithAggregatesInput = {
    AND?: committee_hashScalarWhereWithAggregatesInput | committee_hashScalarWhereWithAggregatesInput[]
    OR?: committee_hashScalarWhereWithAggregatesInput[]
    NOT?: committee_hashScalarWhereWithAggregatesInput | committee_hashScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"committee_hash"> | bigint | number
    raw?: BytesWithAggregatesFilter<"committee_hash"> | Uint8Array
    has_script?: BoolWithAggregatesFilter<"committee_hash"> | boolean
  }

  export type committee_memberWhereInput = {
    AND?: committee_memberWhereInput | committee_memberWhereInput[]
    OR?: committee_memberWhereInput[]
    NOT?: committee_memberWhereInput | committee_memberWhereInput[]
    id?: BigIntFilter<"committee_member"> | bigint | number
    committee_id?: BigIntFilter<"committee_member"> | bigint | number
    committee_hash_id?: BigIntFilter<"committee_member"> | bigint | number
    expiration_epoch?: IntFilter<"committee_member"> | number
    committee?: XOR<CommitteeScalarRelationFilter, committeeWhereInput>
  }

  export type committee_memberOrderByWithRelationInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
    committee?: committeeOrderByWithRelationInput
  }

  export type committee_memberWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: committee_memberWhereInput | committee_memberWhereInput[]
    OR?: committee_memberWhereInput[]
    NOT?: committee_memberWhereInput | committee_memberWhereInput[]
    committee_id?: BigIntFilter<"committee_member"> | bigint | number
    committee_hash_id?: BigIntFilter<"committee_member"> | bigint | number
    expiration_epoch?: IntFilter<"committee_member"> | number
    committee?: XOR<CommitteeScalarRelationFilter, committeeWhereInput>
  }, "id">

  export type committee_memberOrderByWithAggregationInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
    _count?: committee_memberCountOrderByAggregateInput
    _avg?: committee_memberAvgOrderByAggregateInput
    _max?: committee_memberMaxOrderByAggregateInput
    _min?: committee_memberMinOrderByAggregateInput
    _sum?: committee_memberSumOrderByAggregateInput
  }

  export type committee_memberScalarWhereWithAggregatesInput = {
    AND?: committee_memberScalarWhereWithAggregatesInput | committee_memberScalarWhereWithAggregatesInput[]
    OR?: committee_memberScalarWhereWithAggregatesInput[]
    NOT?: committee_memberScalarWhereWithAggregatesInput | committee_memberScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"committee_member"> | bigint | number
    committee_id?: BigIntWithAggregatesFilter<"committee_member"> | bigint | number
    committee_hash_id?: BigIntWithAggregatesFilter<"committee_member"> | bigint | number
    expiration_epoch?: IntWithAggregatesFilter<"committee_member"> | number
  }

  export type committee_registrationWhereInput = {
    AND?: committee_registrationWhereInput | committee_registrationWhereInput[]
    OR?: committee_registrationWhereInput[]
    NOT?: committee_registrationWhereInput | committee_registrationWhereInput[]
    id?: BigIntFilter<"committee_registration"> | bigint | number
    tx_id?: BigIntFilter<"committee_registration"> | bigint | number
    cert_index?: IntFilter<"committee_registration"> | number
    cold_key_id?: BigIntFilter<"committee_registration"> | bigint | number
    hot_key_id?: BigIntFilter<"committee_registration"> | bigint | number
  }

  export type committee_registrationOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type committee_registrationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: committee_registrationWhereInput | committee_registrationWhereInput[]
    OR?: committee_registrationWhereInput[]
    NOT?: committee_registrationWhereInput | committee_registrationWhereInput[]
    tx_id?: BigIntFilter<"committee_registration"> | bigint | number
    cert_index?: IntFilter<"committee_registration"> | number
    cold_key_id?: BigIntFilter<"committee_registration"> | bigint | number
    hot_key_id?: BigIntFilter<"committee_registration"> | bigint | number
  }, "id">

  export type committee_registrationOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
    _count?: committee_registrationCountOrderByAggregateInput
    _avg?: committee_registrationAvgOrderByAggregateInput
    _max?: committee_registrationMaxOrderByAggregateInput
    _min?: committee_registrationMinOrderByAggregateInput
    _sum?: committee_registrationSumOrderByAggregateInput
  }

  export type committee_registrationScalarWhereWithAggregatesInput = {
    AND?: committee_registrationScalarWhereWithAggregatesInput | committee_registrationScalarWhereWithAggregatesInput[]
    OR?: committee_registrationScalarWhereWithAggregatesInput[]
    NOT?: committee_registrationScalarWhereWithAggregatesInput | committee_registrationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"committee_registration"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"committee_registration"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"committee_registration"> | number
    cold_key_id?: BigIntWithAggregatesFilter<"committee_registration"> | bigint | number
    hot_key_id?: BigIntWithAggregatesFilter<"committee_registration"> | bigint | number
  }

  export type constitutionWhereInput = {
    AND?: constitutionWhereInput | constitutionWhereInput[]
    OR?: constitutionWhereInput[]
    NOT?: constitutionWhereInput | constitutionWhereInput[]
    id?: BigIntFilter<"constitution"> | bigint | number
    gov_action_proposal_id?: BigIntNullableFilter<"constitution"> | bigint | number | null
    voting_anchor_id?: BigIntFilter<"constitution"> | bigint | number
    script_hash?: BytesNullableFilter<"constitution"> | Uint8Array | null
  }

  export type constitutionOrderByWithRelationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrderInput | SortOrder
    voting_anchor_id?: SortOrder
    script_hash?: SortOrderInput | SortOrder
  }

  export type constitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: constitutionWhereInput | constitutionWhereInput[]
    OR?: constitutionWhereInput[]
    NOT?: constitutionWhereInput | constitutionWhereInput[]
    gov_action_proposal_id?: BigIntNullableFilter<"constitution"> | bigint | number | null
    voting_anchor_id?: BigIntFilter<"constitution"> | bigint | number
    script_hash?: BytesNullableFilter<"constitution"> | Uint8Array | null
  }, "id">

  export type constitutionOrderByWithAggregationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrderInput | SortOrder
    voting_anchor_id?: SortOrder
    script_hash?: SortOrderInput | SortOrder
    _count?: constitutionCountOrderByAggregateInput
    _avg?: constitutionAvgOrderByAggregateInput
    _max?: constitutionMaxOrderByAggregateInput
    _min?: constitutionMinOrderByAggregateInput
    _sum?: constitutionSumOrderByAggregateInput
  }

  export type constitutionScalarWhereWithAggregatesInput = {
    AND?: constitutionScalarWhereWithAggregatesInput | constitutionScalarWhereWithAggregatesInput[]
    OR?: constitutionScalarWhereWithAggregatesInput[]
    NOT?: constitutionScalarWhereWithAggregatesInput | constitutionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"constitution"> | bigint | number
    gov_action_proposal_id?: BigIntNullableWithAggregatesFilter<"constitution"> | bigint | number | null
    voting_anchor_id?: BigIntWithAggregatesFilter<"constitution"> | bigint | number
    script_hash?: BytesNullableWithAggregatesFilter<"constitution"> | Uint8Array | null
  }

  export type cost_modelWhereInput = {
    AND?: cost_modelWhereInput | cost_modelWhereInput[]
    OR?: cost_modelWhereInput[]
    NOT?: cost_modelWhereInput | cost_modelWhereInput[]
    id?: BigIntFilter<"cost_model"> | bigint | number
    costs?: JsonFilter<"cost_model">
    hash?: BytesFilter<"cost_model"> | Uint8Array
  }

  export type cost_modelOrderByWithRelationInput = {
    id?: SortOrder
    costs?: SortOrder
    hash?: SortOrder
  }

  export type cost_modelWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: cost_modelWhereInput | cost_modelWhereInput[]
    OR?: cost_modelWhereInput[]
    NOT?: cost_modelWhereInput | cost_modelWhereInput[]
    costs?: JsonFilter<"cost_model">
  }, "id" | "hash">

  export type cost_modelOrderByWithAggregationInput = {
    id?: SortOrder
    costs?: SortOrder
    hash?: SortOrder
    _count?: cost_modelCountOrderByAggregateInput
    _avg?: cost_modelAvgOrderByAggregateInput
    _max?: cost_modelMaxOrderByAggregateInput
    _min?: cost_modelMinOrderByAggregateInput
    _sum?: cost_modelSumOrderByAggregateInput
  }

  export type cost_modelScalarWhereWithAggregatesInput = {
    AND?: cost_modelScalarWhereWithAggregatesInput | cost_modelScalarWhereWithAggregatesInput[]
    OR?: cost_modelScalarWhereWithAggregatesInput[]
    NOT?: cost_modelScalarWhereWithAggregatesInput | cost_modelScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"cost_model"> | bigint | number
    costs?: JsonWithAggregatesFilter<"cost_model">
    hash?: BytesWithAggregatesFilter<"cost_model"> | Uint8Array
  }

  export type datumWhereInput = {
    AND?: datumWhereInput | datumWhereInput[]
    OR?: datumWhereInput[]
    NOT?: datumWhereInput | datumWhereInput[]
    id?: BigIntFilter<"datum"> | bigint | number
    hash?: BytesFilter<"datum"> | Uint8Array
    tx_id?: BigIntFilter<"datum"> | bigint | number
    value?: JsonNullableFilter<"datum">
    bytes?: BytesFilter<"datum"> | Uint8Array
  }

  export type datumOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrderInput | SortOrder
    bytes?: SortOrder
  }

  export type datumWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: datumWhereInput | datumWhereInput[]
    OR?: datumWhereInput[]
    NOT?: datumWhereInput | datumWhereInput[]
    tx_id?: BigIntFilter<"datum"> | bigint | number
    value?: JsonNullableFilter<"datum">
    bytes?: BytesFilter<"datum"> | Uint8Array
  }, "id" | "hash">

  export type datumOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrderInput | SortOrder
    bytes?: SortOrder
    _count?: datumCountOrderByAggregateInput
    _avg?: datumAvgOrderByAggregateInput
    _max?: datumMaxOrderByAggregateInput
    _min?: datumMinOrderByAggregateInput
    _sum?: datumSumOrderByAggregateInput
  }

  export type datumScalarWhereWithAggregatesInput = {
    AND?: datumScalarWhereWithAggregatesInput | datumScalarWhereWithAggregatesInput[]
    OR?: datumScalarWhereWithAggregatesInput[]
    NOT?: datumScalarWhereWithAggregatesInput | datumScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"datum"> | bigint | number
    hash?: BytesWithAggregatesFilter<"datum"> | Uint8Array
    tx_id?: BigIntWithAggregatesFilter<"datum"> | bigint | number
    value?: JsonNullableWithAggregatesFilter<"datum">
    bytes?: BytesWithAggregatesFilter<"datum"> | Uint8Array
  }

  export type delegationWhereInput = {
    AND?: delegationWhereInput | delegationWhereInput[]
    OR?: delegationWhereInput[]
    NOT?: delegationWhereInput | delegationWhereInput[]
    id?: BigIntFilter<"delegation"> | bigint | number
    addr_id?: BigIntFilter<"delegation"> | bigint | number
    cert_index?: IntFilter<"delegation"> | number
    pool_hash_id?: BigIntFilter<"delegation"> | bigint | number
    active_epoch_no?: BigIntFilter<"delegation"> | bigint | number
    tx_id?: BigIntFilter<"delegation"> | bigint | number
    slot_no?: BigIntFilter<"delegation"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"delegation"> | bigint | number | null
  }

  export type delegationOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
  }

  export type delegationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: delegationWhereInput | delegationWhereInput[]
    OR?: delegationWhereInput[]
    NOT?: delegationWhereInput | delegationWhereInput[]
    addr_id?: BigIntFilter<"delegation"> | bigint | number
    cert_index?: IntFilter<"delegation"> | number
    pool_hash_id?: BigIntFilter<"delegation"> | bigint | number
    active_epoch_no?: BigIntFilter<"delegation"> | bigint | number
    tx_id?: BigIntFilter<"delegation"> | bigint | number
    slot_no?: BigIntFilter<"delegation"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"delegation"> | bigint | number | null
  }, "id">

  export type delegationOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    _count?: delegationCountOrderByAggregateInput
    _avg?: delegationAvgOrderByAggregateInput
    _max?: delegationMaxOrderByAggregateInput
    _min?: delegationMinOrderByAggregateInput
    _sum?: delegationSumOrderByAggregateInput
  }

  export type delegationScalarWhereWithAggregatesInput = {
    AND?: delegationScalarWhereWithAggregatesInput | delegationScalarWhereWithAggregatesInput[]
    OR?: delegationScalarWhereWithAggregatesInput[]
    NOT?: delegationScalarWhereWithAggregatesInput | delegationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"delegation"> | number
    pool_hash_id?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    active_epoch_no?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    slot_no?: BigIntWithAggregatesFilter<"delegation"> | bigint | number
    redeemer_id?: BigIntNullableWithAggregatesFilter<"delegation"> | bigint | number | null
  }

  export type delegation_voteWhereInput = {
    AND?: delegation_voteWhereInput | delegation_voteWhereInput[]
    OR?: delegation_voteWhereInput[]
    NOT?: delegation_voteWhereInput | delegation_voteWhereInput[]
    id?: BigIntFilter<"delegation_vote"> | bigint | number
    addr_id?: BigIntFilter<"delegation_vote"> | bigint | number
    cert_index?: IntFilter<"delegation_vote"> | number
    drep_hash_id?: BigIntFilter<"delegation_vote"> | bigint | number
    tx_id?: BigIntFilter<"delegation_vote"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"delegation_vote"> | bigint | number | null
  }

  export type delegation_voteOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
  }

  export type delegation_voteWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: delegation_voteWhereInput | delegation_voteWhereInput[]
    OR?: delegation_voteWhereInput[]
    NOT?: delegation_voteWhereInput | delegation_voteWhereInput[]
    addr_id?: BigIntFilter<"delegation_vote"> | bigint | number
    cert_index?: IntFilter<"delegation_vote"> | number
    drep_hash_id?: BigIntFilter<"delegation_vote"> | bigint | number
    tx_id?: BigIntFilter<"delegation_vote"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"delegation_vote"> | bigint | number | null
  }, "id">

  export type delegation_voteOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    _count?: delegation_voteCountOrderByAggregateInput
    _avg?: delegation_voteAvgOrderByAggregateInput
    _max?: delegation_voteMaxOrderByAggregateInput
    _min?: delegation_voteMinOrderByAggregateInput
    _sum?: delegation_voteSumOrderByAggregateInput
  }

  export type delegation_voteScalarWhereWithAggregatesInput = {
    AND?: delegation_voteScalarWhereWithAggregatesInput | delegation_voteScalarWhereWithAggregatesInput[]
    OR?: delegation_voteScalarWhereWithAggregatesInput[]
    NOT?: delegation_voteScalarWhereWithAggregatesInput | delegation_voteScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"delegation_vote"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"delegation_vote"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"delegation_vote"> | number
    drep_hash_id?: BigIntWithAggregatesFilter<"delegation_vote"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"delegation_vote"> | bigint | number
    redeemer_id?: BigIntNullableWithAggregatesFilter<"delegation_vote"> | bigint | number | null
  }

  export type delisted_poolWhereInput = {
    AND?: delisted_poolWhereInput | delisted_poolWhereInput[]
    OR?: delisted_poolWhereInput[]
    NOT?: delisted_poolWhereInput | delisted_poolWhereInput[]
    id?: BigIntFilter<"delisted_pool"> | bigint | number
    hash_raw?: BytesFilter<"delisted_pool"> | Uint8Array
  }

  export type delisted_poolOrderByWithRelationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
  }

  export type delisted_poolWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash_raw?: Uint8Array
    AND?: delisted_poolWhereInput | delisted_poolWhereInput[]
    OR?: delisted_poolWhereInput[]
    NOT?: delisted_poolWhereInput | delisted_poolWhereInput[]
  }, "id" | "hash_raw">

  export type delisted_poolOrderByWithAggregationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    _count?: delisted_poolCountOrderByAggregateInput
    _avg?: delisted_poolAvgOrderByAggregateInput
    _max?: delisted_poolMaxOrderByAggregateInput
    _min?: delisted_poolMinOrderByAggregateInput
    _sum?: delisted_poolSumOrderByAggregateInput
  }

  export type delisted_poolScalarWhereWithAggregatesInput = {
    AND?: delisted_poolScalarWhereWithAggregatesInput | delisted_poolScalarWhereWithAggregatesInput[]
    OR?: delisted_poolScalarWhereWithAggregatesInput[]
    NOT?: delisted_poolScalarWhereWithAggregatesInput | delisted_poolScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"delisted_pool"> | bigint | number
    hash_raw?: BytesWithAggregatesFilter<"delisted_pool"> | Uint8Array
  }

  export type drep_distrWhereInput = {
    AND?: drep_distrWhereInput | drep_distrWhereInput[]
    OR?: drep_distrWhereInput[]
    NOT?: drep_distrWhereInput | drep_distrWhereInput[]
    id?: BigIntFilter<"drep_distr"> | bigint | number
    hash_id?: BigIntFilter<"drep_distr"> | bigint | number
    amount?: BigIntFilter<"drep_distr"> | bigint | number
    epoch_no?: IntFilter<"drep_distr"> | number
    active_until?: IntNullableFilter<"drep_distr"> | number | null
  }

  export type drep_distrOrderByWithRelationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrderInput | SortOrder
  }

  export type drep_distrWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash_id_epoch_no?: drep_distrHash_idEpoch_noCompoundUniqueInput
    AND?: drep_distrWhereInput | drep_distrWhereInput[]
    OR?: drep_distrWhereInput[]
    NOT?: drep_distrWhereInput | drep_distrWhereInput[]
    hash_id?: BigIntFilter<"drep_distr"> | bigint | number
    amount?: BigIntFilter<"drep_distr"> | bigint | number
    epoch_no?: IntFilter<"drep_distr"> | number
    active_until?: IntNullableFilter<"drep_distr"> | number | null
  }, "id" | "hash_id_epoch_no">

  export type drep_distrOrderByWithAggregationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrderInput | SortOrder
    _count?: drep_distrCountOrderByAggregateInput
    _avg?: drep_distrAvgOrderByAggregateInput
    _max?: drep_distrMaxOrderByAggregateInput
    _min?: drep_distrMinOrderByAggregateInput
    _sum?: drep_distrSumOrderByAggregateInput
  }

  export type drep_distrScalarWhereWithAggregatesInput = {
    AND?: drep_distrScalarWhereWithAggregatesInput | drep_distrScalarWhereWithAggregatesInput[]
    OR?: drep_distrScalarWhereWithAggregatesInput[]
    NOT?: drep_distrScalarWhereWithAggregatesInput | drep_distrScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"drep_distr"> | bigint | number
    hash_id?: BigIntWithAggregatesFilter<"drep_distr"> | bigint | number
    amount?: BigIntWithAggregatesFilter<"drep_distr"> | bigint | number
    epoch_no?: IntWithAggregatesFilter<"drep_distr"> | number
    active_until?: IntNullableWithAggregatesFilter<"drep_distr"> | number | null
  }

  export type drep_hashWhereInput = {
    AND?: drep_hashWhereInput | drep_hashWhereInput[]
    OR?: drep_hashWhereInput[]
    NOT?: drep_hashWhereInput | drep_hashWhereInput[]
    id?: BigIntFilter<"drep_hash"> | bigint | number
    raw?: BytesNullableFilter<"drep_hash"> | Uint8Array | null
    view?: StringFilter<"drep_hash"> | string
    has_script?: BoolFilter<"drep_hash"> | boolean
  }

  export type drep_hashOrderByWithRelationInput = {
    id?: SortOrder
    raw?: SortOrderInput | SortOrder
    view?: SortOrder
    has_script?: SortOrder
  }

  export type drep_hashWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    raw_has_script?: drep_hashRawHas_scriptCompoundUniqueInput
    AND?: drep_hashWhereInput | drep_hashWhereInput[]
    OR?: drep_hashWhereInput[]
    NOT?: drep_hashWhereInput | drep_hashWhereInput[]
    raw?: BytesNullableFilter<"drep_hash"> | Uint8Array | null
    view?: StringFilter<"drep_hash"> | string
    has_script?: BoolFilter<"drep_hash"> | boolean
  }, "id" | "raw_has_script">

  export type drep_hashOrderByWithAggregationInput = {
    id?: SortOrder
    raw?: SortOrderInput | SortOrder
    view?: SortOrder
    has_script?: SortOrder
    _count?: drep_hashCountOrderByAggregateInput
    _avg?: drep_hashAvgOrderByAggregateInput
    _max?: drep_hashMaxOrderByAggregateInput
    _min?: drep_hashMinOrderByAggregateInput
    _sum?: drep_hashSumOrderByAggregateInput
  }

  export type drep_hashScalarWhereWithAggregatesInput = {
    AND?: drep_hashScalarWhereWithAggregatesInput | drep_hashScalarWhereWithAggregatesInput[]
    OR?: drep_hashScalarWhereWithAggregatesInput[]
    NOT?: drep_hashScalarWhereWithAggregatesInput | drep_hashScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"drep_hash"> | bigint | number
    raw?: BytesNullableWithAggregatesFilter<"drep_hash"> | Uint8Array | null
    view?: StringWithAggregatesFilter<"drep_hash"> | string
    has_script?: BoolWithAggregatesFilter<"drep_hash"> | boolean
  }

  export type drep_registrationWhereInput = {
    AND?: drep_registrationWhereInput | drep_registrationWhereInput[]
    OR?: drep_registrationWhereInput[]
    NOT?: drep_registrationWhereInput | drep_registrationWhereInput[]
    id?: BigIntFilter<"drep_registration"> | bigint | number
    tx_id?: BigIntFilter<"drep_registration"> | bigint | number
    cert_index?: IntFilter<"drep_registration"> | number
    deposit?: BigIntNullableFilter<"drep_registration"> | bigint | number | null
    drep_hash_id?: BigIntFilter<"drep_registration"> | bigint | number
    voting_anchor_id?: BigIntNullableFilter<"drep_registration"> | bigint | number | null
  }

  export type drep_registrationOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrderInput | SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
  }

  export type drep_registrationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: drep_registrationWhereInput | drep_registrationWhereInput[]
    OR?: drep_registrationWhereInput[]
    NOT?: drep_registrationWhereInput | drep_registrationWhereInput[]
    tx_id?: BigIntFilter<"drep_registration"> | bigint | number
    cert_index?: IntFilter<"drep_registration"> | number
    deposit?: BigIntNullableFilter<"drep_registration"> | bigint | number | null
    drep_hash_id?: BigIntFilter<"drep_registration"> | bigint | number
    voting_anchor_id?: BigIntNullableFilter<"drep_registration"> | bigint | number | null
  }, "id">

  export type drep_registrationOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrderInput | SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    _count?: drep_registrationCountOrderByAggregateInput
    _avg?: drep_registrationAvgOrderByAggregateInput
    _max?: drep_registrationMaxOrderByAggregateInput
    _min?: drep_registrationMinOrderByAggregateInput
    _sum?: drep_registrationSumOrderByAggregateInput
  }

  export type drep_registrationScalarWhereWithAggregatesInput = {
    AND?: drep_registrationScalarWhereWithAggregatesInput | drep_registrationScalarWhereWithAggregatesInput[]
    OR?: drep_registrationScalarWhereWithAggregatesInput[]
    NOT?: drep_registrationScalarWhereWithAggregatesInput | drep_registrationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"drep_registration"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"drep_registration"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"drep_registration"> | number
    deposit?: BigIntNullableWithAggregatesFilter<"drep_registration"> | bigint | number | null
    drep_hash_id?: BigIntWithAggregatesFilter<"drep_registration"> | bigint | number
    voting_anchor_id?: BigIntNullableWithAggregatesFilter<"drep_registration"> | bigint | number | null
  }

  export type epochWhereInput = {
    AND?: epochWhereInput | epochWhereInput[]
    OR?: epochWhereInput[]
    NOT?: epochWhereInput | epochWhereInput[]
    id?: BigIntFilter<"epoch"> | bigint | number
    out_sum?: DecimalFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    tx_count?: IntFilter<"epoch"> | number
    blk_count?: IntFilter<"epoch"> | number
    no?: IntFilter<"epoch"> | number
    start_time?: DateTimeFilter<"epoch"> | Date | string
    end_time?: DateTimeFilter<"epoch"> | Date | string
  }

  export type epochOrderByWithRelationInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type epochWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    no?: number
    AND?: epochWhereInput | epochWhereInput[]
    OR?: epochWhereInput[]
    NOT?: epochWhereInput | epochWhereInput[]
    out_sum?: DecimalFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    tx_count?: IntFilter<"epoch"> | number
    blk_count?: IntFilter<"epoch"> | number
    start_time?: DateTimeFilter<"epoch"> | Date | string
    end_time?: DateTimeFilter<"epoch"> | Date | string
  }, "id" | "no">

  export type epochOrderByWithAggregationInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: epochCountOrderByAggregateInput
    _avg?: epochAvgOrderByAggregateInput
    _max?: epochMaxOrderByAggregateInput
    _min?: epochMinOrderByAggregateInput
    _sum?: epochSumOrderByAggregateInput
  }

  export type epochScalarWhereWithAggregatesInput = {
    AND?: epochScalarWhereWithAggregatesInput | epochScalarWhereWithAggregatesInput[]
    OR?: epochScalarWhereWithAggregatesInput[]
    NOT?: epochScalarWhereWithAggregatesInput | epochScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch"> | bigint | number
    out_sum?: DecimalWithAggregatesFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalWithAggregatesFilter<"epoch"> | Decimal | DecimalJsLike | number | string
    tx_count?: IntWithAggregatesFilter<"epoch"> | number
    blk_count?: IntWithAggregatesFilter<"epoch"> | number
    no?: IntWithAggregatesFilter<"epoch"> | number
    start_time?: DateTimeWithAggregatesFilter<"epoch"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"epoch"> | Date | string
  }

  export type epoch_paramWhereInput = {
    AND?: epoch_paramWhereInput | epoch_paramWhereInput[]
    OR?: epoch_paramWhereInput[]
    NOT?: epoch_paramWhereInput | epoch_paramWhereInput[]
    id?: BigIntFilter<"epoch_param"> | bigint | number
    epoch_no?: IntFilter<"epoch_param"> | number
    min_fee_a?: IntFilter<"epoch_param"> | number
    min_fee_b?: IntFilter<"epoch_param"> | number
    max_block_size?: IntFilter<"epoch_param"> | number
    max_tx_size?: IntFilter<"epoch_param"> | number
    max_bh_size?: IntFilter<"epoch_param"> | number
    key_deposit?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFilter<"epoch_param"> | number
    optimal_pool_count?: IntFilter<"epoch_param"> | number
    influence?: FloatFilter<"epoch_param"> | number
    monetary_expand_rate?: FloatFilter<"epoch_param"> | number
    treasury_growth_rate?: FloatFilter<"epoch_param"> | number
    decentralisation?: FloatFilter<"epoch_param"> | number
    protocol_major?: IntFilter<"epoch_param"> | number
    protocol_minor?: IntFilter<"epoch_param"> | number
    min_utxo_value?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    nonce?: BytesNullableFilter<"epoch_param"> | Uint8Array | null
    cost_model_id?: BigIntNullableFilter<"epoch_param"> | bigint | number | null
    price_mem?: FloatNullableFilter<"epoch_param"> | number | null
    price_step?: FloatNullableFilter<"epoch_param"> | number | null
    max_tx_ex_mem?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableFilter<"epoch_param"> | number | null
    max_collateral_inputs?: IntNullableFilter<"epoch_param"> | number | null
    block_id?: BigIntFilter<"epoch_param"> | bigint | number
    extra_entropy?: BytesNullableFilter<"epoch_param"> | Uint8Array | null
    coins_per_utxo_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_committee_normal?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_committee_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_hard_fork_initiation?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_motion_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_committee_normal?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_committee_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_update_to_constitution?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_hard_fork_initiation?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_network_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_economic_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_technical_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_gov_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_treasury_withdrawal?: FloatNullableFilter<"epoch_param"> | number | null
    committee_min_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableFilter<"epoch_param"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableFilter<"epoch_param"> | number | null
  }

  export type epoch_paramOrderByWithRelationInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    nonce?: SortOrderInput | SortOrder
    cost_model_id?: SortOrderInput | SortOrder
    price_mem?: SortOrderInput | SortOrder
    price_step?: SortOrderInput | SortOrder
    max_tx_ex_mem?: SortOrderInput | SortOrder
    max_tx_ex_steps?: SortOrderInput | SortOrder
    max_block_ex_mem?: SortOrderInput | SortOrder
    max_block_ex_steps?: SortOrderInput | SortOrder
    max_val_size?: SortOrderInput | SortOrder
    collateral_percent?: SortOrderInput | SortOrder
    max_collateral_inputs?: SortOrderInput | SortOrder
    block_id?: SortOrder
    extra_entropy?: SortOrderInput | SortOrder
    coins_per_utxo_size?: SortOrderInput | SortOrder
    pvt_motion_no_confidence?: SortOrderInput | SortOrder
    pvt_committee_normal?: SortOrderInput | SortOrder
    pvt_committee_no_confidence?: SortOrderInput | SortOrder
    pvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_motion_no_confidence?: SortOrderInput | SortOrder
    dvt_committee_normal?: SortOrderInput | SortOrder
    dvt_committee_no_confidence?: SortOrderInput | SortOrder
    dvt_update_to_constitution?: SortOrderInput | SortOrder
    dvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_p_p_network_group?: SortOrderInput | SortOrder
    dvt_p_p_economic_group?: SortOrderInput | SortOrder
    dvt_p_p_technical_group?: SortOrderInput | SortOrder
    dvt_p_p_gov_group?: SortOrderInput | SortOrder
    dvt_treasury_withdrawal?: SortOrderInput | SortOrder
    committee_min_size?: SortOrderInput | SortOrder
    committee_max_term_length?: SortOrderInput | SortOrder
    gov_action_lifetime?: SortOrderInput | SortOrder
    gov_action_deposit?: SortOrderInput | SortOrder
    drep_deposit?: SortOrderInput | SortOrder
    drep_activity?: SortOrderInput | SortOrder
    pvtpp_security_group?: SortOrderInput | SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrderInput | SortOrder
  }

  export type epoch_paramWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: epoch_paramWhereInput | epoch_paramWhereInput[]
    OR?: epoch_paramWhereInput[]
    NOT?: epoch_paramWhereInput | epoch_paramWhereInput[]
    epoch_no?: IntFilter<"epoch_param"> | number
    min_fee_a?: IntFilter<"epoch_param"> | number
    min_fee_b?: IntFilter<"epoch_param"> | number
    max_block_size?: IntFilter<"epoch_param"> | number
    max_tx_size?: IntFilter<"epoch_param"> | number
    max_bh_size?: IntFilter<"epoch_param"> | number
    key_deposit?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFilter<"epoch_param"> | number
    optimal_pool_count?: IntFilter<"epoch_param"> | number
    influence?: FloatFilter<"epoch_param"> | number
    monetary_expand_rate?: FloatFilter<"epoch_param"> | number
    treasury_growth_rate?: FloatFilter<"epoch_param"> | number
    decentralisation?: FloatFilter<"epoch_param"> | number
    protocol_major?: IntFilter<"epoch_param"> | number
    protocol_minor?: IntFilter<"epoch_param"> | number
    min_utxo_value?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    nonce?: BytesNullableFilter<"epoch_param"> | Uint8Array | null
    cost_model_id?: BigIntNullableFilter<"epoch_param"> | bigint | number | null
    price_mem?: FloatNullableFilter<"epoch_param"> | number | null
    price_step?: FloatNullableFilter<"epoch_param"> | number | null
    max_tx_ex_mem?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableFilter<"epoch_param"> | number | null
    max_collateral_inputs?: IntNullableFilter<"epoch_param"> | number | null
    block_id?: BigIntFilter<"epoch_param"> | bigint | number
    extra_entropy?: BytesNullableFilter<"epoch_param"> | Uint8Array | null
    coins_per_utxo_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_committee_normal?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_committee_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    pvt_hard_fork_initiation?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_motion_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_committee_normal?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_committee_no_confidence?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_update_to_constitution?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_hard_fork_initiation?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_network_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_economic_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_technical_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_p_p_gov_group?: FloatNullableFilter<"epoch_param"> | number | null
    dvt_treasury_withdrawal?: FloatNullableFilter<"epoch_param"> | number | null
    committee_min_size?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableFilter<"epoch_param"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableFilter<"epoch_param"> | number | null
  }, "id">

  export type epoch_paramOrderByWithAggregationInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    nonce?: SortOrderInput | SortOrder
    cost_model_id?: SortOrderInput | SortOrder
    price_mem?: SortOrderInput | SortOrder
    price_step?: SortOrderInput | SortOrder
    max_tx_ex_mem?: SortOrderInput | SortOrder
    max_tx_ex_steps?: SortOrderInput | SortOrder
    max_block_ex_mem?: SortOrderInput | SortOrder
    max_block_ex_steps?: SortOrderInput | SortOrder
    max_val_size?: SortOrderInput | SortOrder
    collateral_percent?: SortOrderInput | SortOrder
    max_collateral_inputs?: SortOrderInput | SortOrder
    block_id?: SortOrder
    extra_entropy?: SortOrderInput | SortOrder
    coins_per_utxo_size?: SortOrderInput | SortOrder
    pvt_motion_no_confidence?: SortOrderInput | SortOrder
    pvt_committee_normal?: SortOrderInput | SortOrder
    pvt_committee_no_confidence?: SortOrderInput | SortOrder
    pvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_motion_no_confidence?: SortOrderInput | SortOrder
    dvt_committee_normal?: SortOrderInput | SortOrder
    dvt_committee_no_confidence?: SortOrderInput | SortOrder
    dvt_update_to_constitution?: SortOrderInput | SortOrder
    dvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_p_p_network_group?: SortOrderInput | SortOrder
    dvt_p_p_economic_group?: SortOrderInput | SortOrder
    dvt_p_p_technical_group?: SortOrderInput | SortOrder
    dvt_p_p_gov_group?: SortOrderInput | SortOrder
    dvt_treasury_withdrawal?: SortOrderInput | SortOrder
    committee_min_size?: SortOrderInput | SortOrder
    committee_max_term_length?: SortOrderInput | SortOrder
    gov_action_lifetime?: SortOrderInput | SortOrder
    gov_action_deposit?: SortOrderInput | SortOrder
    drep_deposit?: SortOrderInput | SortOrder
    drep_activity?: SortOrderInput | SortOrder
    pvtpp_security_group?: SortOrderInput | SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrderInput | SortOrder
    _count?: epoch_paramCountOrderByAggregateInput
    _avg?: epoch_paramAvgOrderByAggregateInput
    _max?: epoch_paramMaxOrderByAggregateInput
    _min?: epoch_paramMinOrderByAggregateInput
    _sum?: epoch_paramSumOrderByAggregateInput
  }

  export type epoch_paramScalarWhereWithAggregatesInput = {
    AND?: epoch_paramScalarWhereWithAggregatesInput | epoch_paramScalarWhereWithAggregatesInput[]
    OR?: epoch_paramScalarWhereWithAggregatesInput[]
    NOT?: epoch_paramScalarWhereWithAggregatesInput | epoch_paramScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch_param"> | bigint | number
    epoch_no?: IntWithAggregatesFilter<"epoch_param"> | number
    min_fee_a?: IntWithAggregatesFilter<"epoch_param"> | number
    min_fee_b?: IntWithAggregatesFilter<"epoch_param"> | number
    max_block_size?: IntWithAggregatesFilter<"epoch_param"> | number
    max_tx_size?: IntWithAggregatesFilter<"epoch_param"> | number
    max_bh_size?: IntWithAggregatesFilter<"epoch_param"> | number
    key_deposit?: DecimalWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    max_epoch?: IntWithAggregatesFilter<"epoch_param"> | number
    optimal_pool_count?: IntWithAggregatesFilter<"epoch_param"> | number
    influence?: FloatWithAggregatesFilter<"epoch_param"> | number
    monetary_expand_rate?: FloatWithAggregatesFilter<"epoch_param"> | number
    treasury_growth_rate?: FloatWithAggregatesFilter<"epoch_param"> | number
    decentralisation?: FloatWithAggregatesFilter<"epoch_param"> | number
    protocol_major?: IntWithAggregatesFilter<"epoch_param"> | number
    protocol_minor?: IntWithAggregatesFilter<"epoch_param"> | number
    min_utxo_value?: DecimalWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string
    nonce?: BytesNullableWithAggregatesFilter<"epoch_param"> | Uint8Array | null
    cost_model_id?: BigIntNullableWithAggregatesFilter<"epoch_param"> | bigint | number | null
    price_mem?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    price_step?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    max_tx_ex_mem?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableWithAggregatesFilter<"epoch_param"> | number | null
    max_collateral_inputs?: IntNullableWithAggregatesFilter<"epoch_param"> | number | null
    block_id?: BigIntWithAggregatesFilter<"epoch_param"> | bigint | number
    extra_entropy?: BytesNullableWithAggregatesFilter<"epoch_param"> | Uint8Array | null
    coins_per_utxo_size?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    pvt_committee_normal?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    pvt_committee_no_confidence?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    pvt_hard_fork_initiation?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_motion_no_confidence?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_committee_normal?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_committee_no_confidence?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_update_to_constitution?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_hard_fork_initiation?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_p_p_network_group?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_p_p_economic_group?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_p_p_technical_group?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_p_p_gov_group?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    dvt_treasury_withdrawal?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    committee_min_size?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableWithAggregatesFilter<"epoch_param"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableWithAggregatesFilter<"epoch_param"> | number | null
  }

  export type epoch_stakeWhereInput = {
    AND?: epoch_stakeWhereInput | epoch_stakeWhereInput[]
    OR?: epoch_stakeWhereInput[]
    NOT?: epoch_stakeWhereInput | epoch_stakeWhereInput[]
    id?: BigIntFilter<"epoch_stake"> | bigint | number
    addr_id?: BigIntFilter<"epoch_stake"> | bigint | number
    pool_id?: BigIntFilter<"epoch_stake"> | bigint | number
    amount?: DecimalFilter<"epoch_stake"> | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFilter<"epoch_stake"> | number
  }

  export type epoch_stakeOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stakeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    epoch_no_id?: epoch_stakeEpoch_noIdCompoundUniqueInput
    epoch_no_addr_id_pool_id?: epoch_stakeEpoch_noAddr_idPool_idCompoundUniqueInput
    AND?: epoch_stakeWhereInput | epoch_stakeWhereInput[]
    OR?: epoch_stakeWhereInput[]
    NOT?: epoch_stakeWhereInput | epoch_stakeWhereInput[]
    addr_id?: BigIntFilter<"epoch_stake"> | bigint | number
    pool_id?: BigIntFilter<"epoch_stake"> | bigint | number
    amount?: DecimalFilter<"epoch_stake"> | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFilter<"epoch_stake"> | number
  }, "id" | "epoch_no_id" | "epoch_no_addr_id_pool_id">

  export type epoch_stakeOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    _count?: epoch_stakeCountOrderByAggregateInput
    _avg?: epoch_stakeAvgOrderByAggregateInput
    _max?: epoch_stakeMaxOrderByAggregateInput
    _min?: epoch_stakeMinOrderByAggregateInput
    _sum?: epoch_stakeSumOrderByAggregateInput
  }

  export type epoch_stakeScalarWhereWithAggregatesInput = {
    AND?: epoch_stakeScalarWhereWithAggregatesInput | epoch_stakeScalarWhereWithAggregatesInput[]
    OR?: epoch_stakeScalarWhereWithAggregatesInput[]
    NOT?: epoch_stakeScalarWhereWithAggregatesInput | epoch_stakeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch_stake"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"epoch_stake"> | bigint | number
    pool_id?: BigIntWithAggregatesFilter<"epoch_stake"> | bigint | number
    amount?: DecimalWithAggregatesFilter<"epoch_stake"> | Decimal | DecimalJsLike | number | string
    epoch_no?: IntWithAggregatesFilter<"epoch_stake"> | number
  }

  export type epoch_stake_progressWhereInput = {
    AND?: epoch_stake_progressWhereInput | epoch_stake_progressWhereInput[]
    OR?: epoch_stake_progressWhereInput[]
    NOT?: epoch_stake_progressWhereInput | epoch_stake_progressWhereInput[]
    id?: BigIntFilter<"epoch_stake_progress"> | bigint | number
    epoch_no?: IntFilter<"epoch_stake_progress"> | number
    completed?: BoolFilter<"epoch_stake_progress"> | boolean
  }

  export type epoch_stake_progressOrderByWithRelationInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    completed?: SortOrder
  }

  export type epoch_stake_progressWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    epoch_no?: number
    AND?: epoch_stake_progressWhereInput | epoch_stake_progressWhereInput[]
    OR?: epoch_stake_progressWhereInput[]
    NOT?: epoch_stake_progressWhereInput | epoch_stake_progressWhereInput[]
    completed?: BoolFilter<"epoch_stake_progress"> | boolean
  }, "id" | "epoch_no">

  export type epoch_stake_progressOrderByWithAggregationInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    completed?: SortOrder
    _count?: epoch_stake_progressCountOrderByAggregateInput
    _avg?: epoch_stake_progressAvgOrderByAggregateInput
    _max?: epoch_stake_progressMaxOrderByAggregateInput
    _min?: epoch_stake_progressMinOrderByAggregateInput
    _sum?: epoch_stake_progressSumOrderByAggregateInput
  }

  export type epoch_stake_progressScalarWhereWithAggregatesInput = {
    AND?: epoch_stake_progressScalarWhereWithAggregatesInput | epoch_stake_progressScalarWhereWithAggregatesInput[]
    OR?: epoch_stake_progressScalarWhereWithAggregatesInput[]
    NOT?: epoch_stake_progressScalarWhereWithAggregatesInput | epoch_stake_progressScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch_stake_progress"> | bigint | number
    epoch_no?: IntWithAggregatesFilter<"epoch_stake_progress"> | number
    completed?: BoolWithAggregatesFilter<"epoch_stake_progress"> | boolean
  }

  export type epoch_stateWhereInput = {
    AND?: epoch_stateWhereInput | epoch_stateWhereInput[]
    OR?: epoch_stateWhereInput[]
    NOT?: epoch_stateWhereInput | epoch_stateWhereInput[]
    id?: BigIntFilter<"epoch_state"> | bigint | number
    committee_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    no_confidence_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    constitution_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    epoch_no?: IntFilter<"epoch_state"> | number
  }

  export type epoch_stateOrderByWithRelationInput = {
    id?: SortOrder
    committee_id?: SortOrderInput | SortOrder
    no_confidence_id?: SortOrderInput | SortOrder
    constitution_id?: SortOrderInput | SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: epoch_stateWhereInput | epoch_stateWhereInput[]
    OR?: epoch_stateWhereInput[]
    NOT?: epoch_stateWhereInput | epoch_stateWhereInput[]
    committee_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    no_confidence_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    constitution_id?: BigIntNullableFilter<"epoch_state"> | bigint | number | null
    epoch_no?: IntFilter<"epoch_state"> | number
  }, "id">

  export type epoch_stateOrderByWithAggregationInput = {
    id?: SortOrder
    committee_id?: SortOrderInput | SortOrder
    no_confidence_id?: SortOrderInput | SortOrder
    constitution_id?: SortOrderInput | SortOrder
    epoch_no?: SortOrder
    _count?: epoch_stateCountOrderByAggregateInput
    _avg?: epoch_stateAvgOrderByAggregateInput
    _max?: epoch_stateMaxOrderByAggregateInput
    _min?: epoch_stateMinOrderByAggregateInput
    _sum?: epoch_stateSumOrderByAggregateInput
  }

  export type epoch_stateScalarWhereWithAggregatesInput = {
    AND?: epoch_stateScalarWhereWithAggregatesInput | epoch_stateScalarWhereWithAggregatesInput[]
    OR?: epoch_stateScalarWhereWithAggregatesInput[]
    NOT?: epoch_stateScalarWhereWithAggregatesInput | epoch_stateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch_state"> | bigint | number
    committee_id?: BigIntNullableWithAggregatesFilter<"epoch_state"> | bigint | number | null
    no_confidence_id?: BigIntNullableWithAggregatesFilter<"epoch_state"> | bigint | number | null
    constitution_id?: BigIntNullableWithAggregatesFilter<"epoch_state"> | bigint | number | null
    epoch_no?: IntWithAggregatesFilter<"epoch_state"> | number
  }

  export type epoch_sync_timeWhereInput = {
    AND?: epoch_sync_timeWhereInput | epoch_sync_timeWhereInput[]
    OR?: epoch_sync_timeWhereInput[]
    NOT?: epoch_sync_timeWhereInput | epoch_sync_timeWhereInput[]
    id?: BigIntFilter<"epoch_sync_time"> | bigint | number
    no?: BigIntFilter<"epoch_sync_time"> | bigint | number
    seconds?: BigIntFilter<"epoch_sync_time"> | bigint | number
    state?: EnumsyncstatetypeFilter<"epoch_sync_time"> | $Enums.syncstatetype
  }

  export type epoch_sync_timeOrderByWithRelationInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
    state?: SortOrder
  }

  export type epoch_sync_timeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    no?: bigint | number
    AND?: epoch_sync_timeWhereInput | epoch_sync_timeWhereInput[]
    OR?: epoch_sync_timeWhereInput[]
    NOT?: epoch_sync_timeWhereInput | epoch_sync_timeWhereInput[]
    seconds?: BigIntFilter<"epoch_sync_time"> | bigint | number
    state?: EnumsyncstatetypeFilter<"epoch_sync_time"> | $Enums.syncstatetype
  }, "id" | "no">

  export type epoch_sync_timeOrderByWithAggregationInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
    state?: SortOrder
    _count?: epoch_sync_timeCountOrderByAggregateInput
    _avg?: epoch_sync_timeAvgOrderByAggregateInput
    _max?: epoch_sync_timeMaxOrderByAggregateInput
    _min?: epoch_sync_timeMinOrderByAggregateInput
    _sum?: epoch_sync_timeSumOrderByAggregateInput
  }

  export type epoch_sync_timeScalarWhereWithAggregatesInput = {
    AND?: epoch_sync_timeScalarWhereWithAggregatesInput | epoch_sync_timeScalarWhereWithAggregatesInput[]
    OR?: epoch_sync_timeScalarWhereWithAggregatesInput[]
    NOT?: epoch_sync_timeScalarWhereWithAggregatesInput | epoch_sync_timeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"epoch_sync_time"> | bigint | number
    no?: BigIntWithAggregatesFilter<"epoch_sync_time"> | bigint | number
    seconds?: BigIntWithAggregatesFilter<"epoch_sync_time"> | bigint | number
    state?: EnumsyncstatetypeWithAggregatesFilter<"epoch_sync_time"> | $Enums.syncstatetype
  }

  export type event_infoWhereInput = {
    AND?: event_infoWhereInput | event_infoWhereInput[]
    OR?: event_infoWhereInput[]
    NOT?: event_infoWhereInput | event_infoWhereInput[]
    id?: BigIntFilter<"event_info"> | bigint | number
    tx_id?: BigIntNullableFilter<"event_info"> | bigint | number | null
    epoch?: IntFilter<"event_info"> | number
    type?: StringFilter<"event_info"> | string
    explanation?: StringNullableFilter<"event_info"> | string | null
  }

  export type event_infoOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrderInput | SortOrder
    epoch?: SortOrder
    type?: SortOrder
    explanation?: SortOrderInput | SortOrder
  }

  export type event_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: event_infoWhereInput | event_infoWhereInput[]
    OR?: event_infoWhereInput[]
    NOT?: event_infoWhereInput | event_infoWhereInput[]
    tx_id?: BigIntNullableFilter<"event_info"> | bigint | number | null
    epoch?: IntFilter<"event_info"> | number
    type?: StringFilter<"event_info"> | string
    explanation?: StringNullableFilter<"event_info"> | string | null
  }, "id">

  export type event_infoOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrderInput | SortOrder
    epoch?: SortOrder
    type?: SortOrder
    explanation?: SortOrderInput | SortOrder
    _count?: event_infoCountOrderByAggregateInput
    _avg?: event_infoAvgOrderByAggregateInput
    _max?: event_infoMaxOrderByAggregateInput
    _min?: event_infoMinOrderByAggregateInput
    _sum?: event_infoSumOrderByAggregateInput
  }

  export type event_infoScalarWhereWithAggregatesInput = {
    AND?: event_infoScalarWhereWithAggregatesInput | event_infoScalarWhereWithAggregatesInput[]
    OR?: event_infoScalarWhereWithAggregatesInput[]
    NOT?: event_infoScalarWhereWithAggregatesInput | event_infoScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"event_info"> | bigint | number
    tx_id?: BigIntNullableWithAggregatesFilter<"event_info"> | bigint | number | null
    epoch?: IntWithAggregatesFilter<"event_info"> | number
    type?: StringWithAggregatesFilter<"event_info"> | string
    explanation?: StringNullableWithAggregatesFilter<"event_info"> | string | null
  }

  export type extra_key_witnessWhereInput = {
    AND?: extra_key_witnessWhereInput | extra_key_witnessWhereInput[]
    OR?: extra_key_witnessWhereInput[]
    NOT?: extra_key_witnessWhereInput | extra_key_witnessWhereInput[]
    id?: BigIntFilter<"extra_key_witness"> | bigint | number
    hash?: BytesFilter<"extra_key_witness"> | Uint8Array
    tx_id?: BigIntFilter<"extra_key_witness"> | bigint | number
  }

  export type extra_key_witnessOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_key_witnessWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: extra_key_witnessWhereInput | extra_key_witnessWhereInput[]
    OR?: extra_key_witnessWhereInput[]
    NOT?: extra_key_witnessWhereInput | extra_key_witnessWhereInput[]
    hash?: BytesFilter<"extra_key_witness"> | Uint8Array
    tx_id?: BigIntFilter<"extra_key_witness"> | bigint | number
  }, "id">

  export type extra_key_witnessOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    _count?: extra_key_witnessCountOrderByAggregateInput
    _avg?: extra_key_witnessAvgOrderByAggregateInput
    _max?: extra_key_witnessMaxOrderByAggregateInput
    _min?: extra_key_witnessMinOrderByAggregateInput
    _sum?: extra_key_witnessSumOrderByAggregateInput
  }

  export type extra_key_witnessScalarWhereWithAggregatesInput = {
    AND?: extra_key_witnessScalarWhereWithAggregatesInput | extra_key_witnessScalarWhereWithAggregatesInput[]
    OR?: extra_key_witnessScalarWhereWithAggregatesInput[]
    NOT?: extra_key_witnessScalarWhereWithAggregatesInput | extra_key_witnessScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"extra_key_witness"> | bigint | number
    hash?: BytesWithAggregatesFilter<"extra_key_witness"> | Uint8Array
    tx_id?: BigIntWithAggregatesFilter<"extra_key_witness"> | bigint | number
  }

  export type extra_migrationsWhereInput = {
    AND?: extra_migrationsWhereInput | extra_migrationsWhereInput[]
    OR?: extra_migrationsWhereInput[]
    NOT?: extra_migrationsWhereInput | extra_migrationsWhereInput[]
    id?: BigIntFilter<"extra_migrations"> | bigint | number
    token?: StringFilter<"extra_migrations"> | string
    description?: StringNullableFilter<"extra_migrations"> | string | null
  }

  export type extra_migrationsOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type extra_migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: extra_migrationsWhereInput | extra_migrationsWhereInput[]
    OR?: extra_migrationsWhereInput[]
    NOT?: extra_migrationsWhereInput | extra_migrationsWhereInput[]
    token?: StringFilter<"extra_migrations"> | string
    description?: StringNullableFilter<"extra_migrations"> | string | null
  }, "id">

  export type extra_migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: extra_migrationsCountOrderByAggregateInput
    _avg?: extra_migrationsAvgOrderByAggregateInput
    _max?: extra_migrationsMaxOrderByAggregateInput
    _min?: extra_migrationsMinOrderByAggregateInput
    _sum?: extra_migrationsSumOrderByAggregateInput
  }

  export type extra_migrationsScalarWhereWithAggregatesInput = {
    AND?: extra_migrationsScalarWhereWithAggregatesInput | extra_migrationsScalarWhereWithAggregatesInput[]
    OR?: extra_migrationsScalarWhereWithAggregatesInput[]
    NOT?: extra_migrationsScalarWhereWithAggregatesInput | extra_migrationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"extra_migrations"> | bigint | number
    token?: StringWithAggregatesFilter<"extra_migrations"> | string
    description?: StringNullableWithAggregatesFilter<"extra_migrations"> | string | null
  }

  export type gov_action_proposalWhereInput = {
    AND?: gov_action_proposalWhereInput | gov_action_proposalWhereInput[]
    OR?: gov_action_proposalWhereInput[]
    NOT?: gov_action_proposalWhereInput | gov_action_proposalWhereInput[]
    id?: BigIntFilter<"gov_action_proposal"> | bigint | number
    tx_id?: BigIntFilter<"gov_action_proposal"> | bigint | number
    index?: BigIntFilter<"gov_action_proposal"> | bigint | number
    prev_gov_action_proposal?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    deposit?: DecimalFilter<"gov_action_proposal"> | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFilter<"gov_action_proposal"> | bigint | number
    expiration?: IntNullableFilter<"gov_action_proposal"> | number | null
    voting_anchor_id?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    type?: EnumgovactiontypeFilter<"gov_action_proposal"> | $Enums.govactiontype
    description?: JsonFilter<"gov_action_proposal">
    param_proposal?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    ratified_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    enacted_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    dropped_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    expired_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
  }

  export type gov_action_proposalOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrderInput | SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrderInput | SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    param_proposal?: SortOrderInput | SortOrder
    ratified_epoch?: SortOrderInput | SortOrder
    enacted_epoch?: SortOrderInput | SortOrder
    dropped_epoch?: SortOrderInput | SortOrder
    expired_epoch?: SortOrderInput | SortOrder
  }

  export type gov_action_proposalWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: gov_action_proposalWhereInput | gov_action_proposalWhereInput[]
    OR?: gov_action_proposalWhereInput[]
    NOT?: gov_action_proposalWhereInput | gov_action_proposalWhereInput[]
    tx_id?: BigIntFilter<"gov_action_proposal"> | bigint | number
    index?: BigIntFilter<"gov_action_proposal"> | bigint | number
    prev_gov_action_proposal?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    deposit?: DecimalFilter<"gov_action_proposal"> | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFilter<"gov_action_proposal"> | bigint | number
    expiration?: IntNullableFilter<"gov_action_proposal"> | number | null
    voting_anchor_id?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    type?: EnumgovactiontypeFilter<"gov_action_proposal"> | $Enums.govactiontype
    description?: JsonFilter<"gov_action_proposal">
    param_proposal?: BigIntNullableFilter<"gov_action_proposal"> | bigint | number | null
    ratified_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    enacted_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    dropped_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
    expired_epoch?: IntNullableFilter<"gov_action_proposal"> | number | null
  }, "id">

  export type gov_action_proposalOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrderInput | SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrderInput | SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    param_proposal?: SortOrderInput | SortOrder
    ratified_epoch?: SortOrderInput | SortOrder
    enacted_epoch?: SortOrderInput | SortOrder
    dropped_epoch?: SortOrderInput | SortOrder
    expired_epoch?: SortOrderInput | SortOrder
    _count?: gov_action_proposalCountOrderByAggregateInput
    _avg?: gov_action_proposalAvgOrderByAggregateInput
    _max?: gov_action_proposalMaxOrderByAggregateInput
    _min?: gov_action_proposalMinOrderByAggregateInput
    _sum?: gov_action_proposalSumOrderByAggregateInput
  }

  export type gov_action_proposalScalarWhereWithAggregatesInput = {
    AND?: gov_action_proposalScalarWhereWithAggregatesInput | gov_action_proposalScalarWhereWithAggregatesInput[]
    OR?: gov_action_proposalScalarWhereWithAggregatesInput[]
    NOT?: gov_action_proposalScalarWhereWithAggregatesInput | gov_action_proposalScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"gov_action_proposal"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"gov_action_proposal"> | bigint | number
    index?: BigIntWithAggregatesFilter<"gov_action_proposal"> | bigint | number
    prev_gov_action_proposal?: BigIntNullableWithAggregatesFilter<"gov_action_proposal"> | bigint | number | null
    deposit?: DecimalWithAggregatesFilter<"gov_action_proposal"> | Decimal | DecimalJsLike | number | string
    return_address?: BigIntWithAggregatesFilter<"gov_action_proposal"> | bigint | number
    expiration?: IntNullableWithAggregatesFilter<"gov_action_proposal"> | number | null
    voting_anchor_id?: BigIntNullableWithAggregatesFilter<"gov_action_proposal"> | bigint | number | null
    type?: EnumgovactiontypeWithAggregatesFilter<"gov_action_proposal"> | $Enums.govactiontype
    description?: JsonWithAggregatesFilter<"gov_action_proposal">
    param_proposal?: BigIntNullableWithAggregatesFilter<"gov_action_proposal"> | bigint | number | null
    ratified_epoch?: IntNullableWithAggregatesFilter<"gov_action_proposal"> | number | null
    enacted_epoch?: IntNullableWithAggregatesFilter<"gov_action_proposal"> | number | null
    dropped_epoch?: IntNullableWithAggregatesFilter<"gov_action_proposal"> | number | null
    expired_epoch?: IntNullableWithAggregatesFilter<"gov_action_proposal"> | number | null
  }

  export type ma_tx_mintWhereInput = {
    AND?: ma_tx_mintWhereInput | ma_tx_mintWhereInput[]
    OR?: ma_tx_mintWhereInput[]
    NOT?: ma_tx_mintWhereInput | ma_tx_mintWhereInput[]
    id?: BigIntFilter<"ma_tx_mint"> | bigint | number
    quantity?: DecimalFilter<"ma_tx_mint"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"ma_tx_mint"> | bigint | number
    ident?: BigIntFilter<"ma_tx_mint"> | bigint | number
  }

  export type ma_tx_mintOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_mintWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ma_tx_mintWhereInput | ma_tx_mintWhereInput[]
    OR?: ma_tx_mintWhereInput[]
    NOT?: ma_tx_mintWhereInput | ma_tx_mintWhereInput[]
    quantity?: DecimalFilter<"ma_tx_mint"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"ma_tx_mint"> | bigint | number
    ident?: BigIntFilter<"ma_tx_mint"> | bigint | number
  }, "id">

  export type ma_tx_mintOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
    _count?: ma_tx_mintCountOrderByAggregateInput
    _avg?: ma_tx_mintAvgOrderByAggregateInput
    _max?: ma_tx_mintMaxOrderByAggregateInput
    _min?: ma_tx_mintMinOrderByAggregateInput
    _sum?: ma_tx_mintSumOrderByAggregateInput
  }

  export type ma_tx_mintScalarWhereWithAggregatesInput = {
    AND?: ma_tx_mintScalarWhereWithAggregatesInput | ma_tx_mintScalarWhereWithAggregatesInput[]
    OR?: ma_tx_mintScalarWhereWithAggregatesInput[]
    NOT?: ma_tx_mintScalarWhereWithAggregatesInput | ma_tx_mintScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ma_tx_mint"> | bigint | number
    quantity?: DecimalWithAggregatesFilter<"ma_tx_mint"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntWithAggregatesFilter<"ma_tx_mint"> | bigint | number
    ident?: BigIntWithAggregatesFilter<"ma_tx_mint"> | bigint | number
  }

  export type ma_tx_outWhereInput = {
    AND?: ma_tx_outWhereInput | ma_tx_outWhereInput[]
    OR?: ma_tx_outWhereInput[]
    NOT?: ma_tx_outWhereInput | ma_tx_outWhereInput[]
    id?: BigIntFilter<"ma_tx_out"> | bigint | number
    quantity?: DecimalFilter<"ma_tx_out"> | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFilter<"ma_tx_out"> | bigint | number
    ident?: BigIntFilter<"ma_tx_out"> | bigint | number
  }

  export type ma_tx_outOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ma_tx_outWhereInput | ma_tx_outWhereInput[]
    OR?: ma_tx_outWhereInput[]
    NOT?: ma_tx_outWhereInput | ma_tx_outWhereInput[]
    quantity?: DecimalFilter<"ma_tx_out"> | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFilter<"ma_tx_out"> | bigint | number
    ident?: BigIntFilter<"ma_tx_out"> | bigint | number
  }, "id">

  export type ma_tx_outOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
    _count?: ma_tx_outCountOrderByAggregateInput
    _avg?: ma_tx_outAvgOrderByAggregateInput
    _max?: ma_tx_outMaxOrderByAggregateInput
    _min?: ma_tx_outMinOrderByAggregateInput
    _sum?: ma_tx_outSumOrderByAggregateInput
  }

  export type ma_tx_outScalarWhereWithAggregatesInput = {
    AND?: ma_tx_outScalarWhereWithAggregatesInput | ma_tx_outScalarWhereWithAggregatesInput[]
    OR?: ma_tx_outScalarWhereWithAggregatesInput[]
    NOT?: ma_tx_outScalarWhereWithAggregatesInput | ma_tx_outScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ma_tx_out"> | bigint | number
    quantity?: DecimalWithAggregatesFilter<"ma_tx_out"> | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntWithAggregatesFilter<"ma_tx_out"> | bigint | number
    ident?: BigIntWithAggregatesFilter<"ma_tx_out"> | bigint | number
  }

  export type metaWhereInput = {
    AND?: metaWhereInput | metaWhereInput[]
    OR?: metaWhereInput[]
    NOT?: metaWhereInput | metaWhereInput[]
    id?: BigIntFilter<"meta"> | bigint | number
    start_time?: DateTimeFilter<"meta"> | Date | string
    network_name?: StringFilter<"meta"> | string
    version?: StringFilter<"meta"> | string
  }

  export type metaOrderByWithRelationInput = {
    id?: SortOrder
    start_time?: SortOrder
    network_name?: SortOrder
    version?: SortOrder
  }

  export type metaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    start_time?: Date | string
    AND?: metaWhereInput | metaWhereInput[]
    OR?: metaWhereInput[]
    NOT?: metaWhereInput | metaWhereInput[]
    network_name?: StringFilter<"meta"> | string
    version?: StringFilter<"meta"> | string
  }, "id" | "start_time">

  export type metaOrderByWithAggregationInput = {
    id?: SortOrder
    start_time?: SortOrder
    network_name?: SortOrder
    version?: SortOrder
    _count?: metaCountOrderByAggregateInput
    _avg?: metaAvgOrderByAggregateInput
    _max?: metaMaxOrderByAggregateInput
    _min?: metaMinOrderByAggregateInput
    _sum?: metaSumOrderByAggregateInput
  }

  export type metaScalarWhereWithAggregatesInput = {
    AND?: metaScalarWhereWithAggregatesInput | metaScalarWhereWithAggregatesInput[]
    OR?: metaScalarWhereWithAggregatesInput[]
    NOT?: metaScalarWhereWithAggregatesInput | metaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"meta"> | bigint | number
    start_time?: DateTimeWithAggregatesFilter<"meta"> | Date | string
    network_name?: StringWithAggregatesFilter<"meta"> | string
    version?: StringWithAggregatesFilter<"meta"> | string
  }

  export type multi_assetWhereInput = {
    AND?: multi_assetWhereInput | multi_assetWhereInput[]
    OR?: multi_assetWhereInput[]
    NOT?: multi_assetWhereInput | multi_assetWhereInput[]
    id?: BigIntFilter<"multi_asset"> | bigint | number
    policy?: BytesFilter<"multi_asset"> | Uint8Array
    name?: BytesFilter<"multi_asset"> | Uint8Array
    fingerprint?: StringFilter<"multi_asset"> | string
  }

  export type multi_assetOrderByWithRelationInput = {
    id?: SortOrder
    policy?: SortOrder
    name?: SortOrder
    fingerprint?: SortOrder
  }

  export type multi_assetWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    policy_name?: multi_assetPolicyNameCompoundUniqueInput
    AND?: multi_assetWhereInput | multi_assetWhereInput[]
    OR?: multi_assetWhereInput[]
    NOT?: multi_assetWhereInput | multi_assetWhereInput[]
    policy?: BytesFilter<"multi_asset"> | Uint8Array
    name?: BytesFilter<"multi_asset"> | Uint8Array
    fingerprint?: StringFilter<"multi_asset"> | string
  }, "id" | "policy_name">

  export type multi_assetOrderByWithAggregationInput = {
    id?: SortOrder
    policy?: SortOrder
    name?: SortOrder
    fingerprint?: SortOrder
    _count?: multi_assetCountOrderByAggregateInput
    _avg?: multi_assetAvgOrderByAggregateInput
    _max?: multi_assetMaxOrderByAggregateInput
    _min?: multi_assetMinOrderByAggregateInput
    _sum?: multi_assetSumOrderByAggregateInput
  }

  export type multi_assetScalarWhereWithAggregatesInput = {
    AND?: multi_assetScalarWhereWithAggregatesInput | multi_assetScalarWhereWithAggregatesInput[]
    OR?: multi_assetScalarWhereWithAggregatesInput[]
    NOT?: multi_assetScalarWhereWithAggregatesInput | multi_assetScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"multi_asset"> | bigint | number
    policy?: BytesWithAggregatesFilter<"multi_asset"> | Uint8Array
    name?: BytesWithAggregatesFilter<"multi_asset"> | Uint8Array
    fingerprint?: StringWithAggregatesFilter<"multi_asset"> | string
  }

  export type new_committeeWhereInput = {
    AND?: new_committeeWhereInput | new_committeeWhereInput[]
    OR?: new_committeeWhereInput[]
    NOT?: new_committeeWhereInput | new_committeeWhereInput[]
    id?: BigIntFilter<"new_committee"> | bigint | number
    gov_action_proposal_id?: BigIntFilter<"new_committee"> | bigint | number
    deleted_members?: StringFilter<"new_committee"> | string
    added_members?: StringFilter<"new_committee"> | string
    quorum_numerator?: BigIntFilter<"new_committee"> | bigint | number
    quorum_denominator?: BigIntFilter<"new_committee"> | bigint | number
  }

  export type new_committeeOrderByWithRelationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    deleted_members?: SortOrder
    added_members?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type new_committeeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: new_committeeWhereInput | new_committeeWhereInput[]
    OR?: new_committeeWhereInput[]
    NOT?: new_committeeWhereInput | new_committeeWhereInput[]
    gov_action_proposal_id?: BigIntFilter<"new_committee"> | bigint | number
    deleted_members?: StringFilter<"new_committee"> | string
    added_members?: StringFilter<"new_committee"> | string
    quorum_numerator?: BigIntFilter<"new_committee"> | bigint | number
    quorum_denominator?: BigIntFilter<"new_committee"> | bigint | number
  }, "id">

  export type new_committeeOrderByWithAggregationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    deleted_members?: SortOrder
    added_members?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
    _count?: new_committeeCountOrderByAggregateInput
    _avg?: new_committeeAvgOrderByAggregateInput
    _max?: new_committeeMaxOrderByAggregateInput
    _min?: new_committeeMinOrderByAggregateInput
    _sum?: new_committeeSumOrderByAggregateInput
  }

  export type new_committeeScalarWhereWithAggregatesInput = {
    AND?: new_committeeScalarWhereWithAggregatesInput | new_committeeScalarWhereWithAggregatesInput[]
    OR?: new_committeeScalarWhereWithAggregatesInput[]
    NOT?: new_committeeScalarWhereWithAggregatesInput | new_committeeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"new_committee"> | bigint | number
    gov_action_proposal_id?: BigIntWithAggregatesFilter<"new_committee"> | bigint | number
    deleted_members?: StringWithAggregatesFilter<"new_committee"> | string
    added_members?: StringWithAggregatesFilter<"new_committee"> | string
    quorum_numerator?: BigIntWithAggregatesFilter<"new_committee"> | bigint | number
    quorum_denominator?: BigIntWithAggregatesFilter<"new_committee"> | bigint | number
  }

  export type off_chain_pool_dataWhereInput = {
    AND?: off_chain_pool_dataWhereInput | off_chain_pool_dataWhereInput[]
    OR?: off_chain_pool_dataWhereInput[]
    NOT?: off_chain_pool_dataWhereInput | off_chain_pool_dataWhereInput[]
    id?: BigIntFilter<"off_chain_pool_data"> | bigint | number
    pool_id?: BigIntFilter<"off_chain_pool_data"> | bigint | number
    ticker_name?: StringFilter<"off_chain_pool_data"> | string
    hash?: BytesFilter<"off_chain_pool_data"> | Uint8Array
    json?: JsonFilter<"off_chain_pool_data">
    bytes?: BytesFilter<"off_chain_pool_data"> | Uint8Array
    pmr_id?: BigIntFilter<"off_chain_pool_data"> | bigint | number
  }

  export type off_chain_pool_dataOrderByWithRelationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    ticker_name?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    pool_id_pmr_id?: off_chain_pool_dataPool_idPmr_idCompoundUniqueInput
    AND?: off_chain_pool_dataWhereInput | off_chain_pool_dataWhereInput[]
    OR?: off_chain_pool_dataWhereInput[]
    NOT?: off_chain_pool_dataWhereInput | off_chain_pool_dataWhereInput[]
    pool_id?: BigIntFilter<"off_chain_pool_data"> | bigint | number
    ticker_name?: StringFilter<"off_chain_pool_data"> | string
    hash?: BytesFilter<"off_chain_pool_data"> | Uint8Array
    json?: JsonFilter<"off_chain_pool_data">
    bytes?: BytesFilter<"off_chain_pool_data"> | Uint8Array
    pmr_id?: BigIntFilter<"off_chain_pool_data"> | bigint | number
  }, "id" | "pool_id_pmr_id">

  export type off_chain_pool_dataOrderByWithAggregationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    ticker_name?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    pmr_id?: SortOrder
    _count?: off_chain_pool_dataCountOrderByAggregateInput
    _avg?: off_chain_pool_dataAvgOrderByAggregateInput
    _max?: off_chain_pool_dataMaxOrderByAggregateInput
    _min?: off_chain_pool_dataMinOrderByAggregateInput
    _sum?: off_chain_pool_dataSumOrderByAggregateInput
  }

  export type off_chain_pool_dataScalarWhereWithAggregatesInput = {
    AND?: off_chain_pool_dataScalarWhereWithAggregatesInput | off_chain_pool_dataScalarWhereWithAggregatesInput[]
    OR?: off_chain_pool_dataScalarWhereWithAggregatesInput[]
    NOT?: off_chain_pool_dataScalarWhereWithAggregatesInput | off_chain_pool_dataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_pool_data"> | bigint | number
    pool_id?: BigIntWithAggregatesFilter<"off_chain_pool_data"> | bigint | number
    ticker_name?: StringWithAggregatesFilter<"off_chain_pool_data"> | string
    hash?: BytesWithAggregatesFilter<"off_chain_pool_data"> | Uint8Array
    json?: JsonWithAggregatesFilter<"off_chain_pool_data">
    bytes?: BytesWithAggregatesFilter<"off_chain_pool_data"> | Uint8Array
    pmr_id?: BigIntWithAggregatesFilter<"off_chain_pool_data"> | bigint | number
  }

  export type off_chain_pool_fetch_errorWhereInput = {
    AND?: off_chain_pool_fetch_errorWhereInput | off_chain_pool_fetch_errorWhereInput[]
    OR?: off_chain_pool_fetch_errorWhereInput[]
    NOT?: off_chain_pool_fetch_errorWhereInput | off_chain_pool_fetch_errorWhereInput[]
    id?: BigIntFilter<"off_chain_pool_fetch_error"> | bigint | number
    pool_id?: BigIntFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_time?: DateTimeFilter<"off_chain_pool_fetch_error"> | Date | string
    pmr_id?: BigIntFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_error?: StringFilter<"off_chain_pool_fetch_error"> | string
    retry_count?: IntFilter<"off_chain_pool_fetch_error"> | number
  }

  export type off_chain_pool_fetch_errorOrderByWithRelationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    fetch_time?: SortOrder
    pmr_id?: SortOrder
    fetch_error?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_pool_fetch_errorWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    pool_id_fetch_time_retry_count?: off_chain_pool_fetch_errorPool_idFetch_timeRetry_countCompoundUniqueInput
    AND?: off_chain_pool_fetch_errorWhereInput | off_chain_pool_fetch_errorWhereInput[]
    OR?: off_chain_pool_fetch_errorWhereInput[]
    NOT?: off_chain_pool_fetch_errorWhereInput | off_chain_pool_fetch_errorWhereInput[]
    pool_id?: BigIntFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_time?: DateTimeFilter<"off_chain_pool_fetch_error"> | Date | string
    pmr_id?: BigIntFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_error?: StringFilter<"off_chain_pool_fetch_error"> | string
    retry_count?: IntFilter<"off_chain_pool_fetch_error"> | number
  }, "id" | "pool_id_fetch_time_retry_count">

  export type off_chain_pool_fetch_errorOrderByWithAggregationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    fetch_time?: SortOrder
    pmr_id?: SortOrder
    fetch_error?: SortOrder
    retry_count?: SortOrder
    _count?: off_chain_pool_fetch_errorCountOrderByAggregateInput
    _avg?: off_chain_pool_fetch_errorAvgOrderByAggregateInput
    _max?: off_chain_pool_fetch_errorMaxOrderByAggregateInput
    _min?: off_chain_pool_fetch_errorMinOrderByAggregateInput
    _sum?: off_chain_pool_fetch_errorSumOrderByAggregateInput
  }

  export type off_chain_pool_fetch_errorScalarWhereWithAggregatesInput = {
    AND?: off_chain_pool_fetch_errorScalarWhereWithAggregatesInput | off_chain_pool_fetch_errorScalarWhereWithAggregatesInput[]
    OR?: off_chain_pool_fetch_errorScalarWhereWithAggregatesInput[]
    NOT?: off_chain_pool_fetch_errorScalarWhereWithAggregatesInput | off_chain_pool_fetch_errorScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_pool_fetch_error"> | bigint | number
    pool_id?: BigIntWithAggregatesFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_time?: DateTimeWithAggregatesFilter<"off_chain_pool_fetch_error"> | Date | string
    pmr_id?: BigIntWithAggregatesFilter<"off_chain_pool_fetch_error"> | bigint | number
    fetch_error?: StringWithAggregatesFilter<"off_chain_pool_fetch_error"> | string
    retry_count?: IntWithAggregatesFilter<"off_chain_pool_fetch_error"> | number
  }

  export type off_chain_vote_authorWhereInput = {
    AND?: off_chain_vote_authorWhereInput | off_chain_vote_authorWhereInput[]
    OR?: off_chain_vote_authorWhereInput[]
    NOT?: off_chain_vote_authorWhereInput | off_chain_vote_authorWhereInput[]
    id?: BigIntFilter<"off_chain_vote_author"> | bigint | number
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_author"> | bigint | number
    name?: StringNullableFilter<"off_chain_vote_author"> | string | null
    witness_algorithm?: StringFilter<"off_chain_vote_author"> | string
    public_key?: StringFilter<"off_chain_vote_author"> | string
    signature?: StringFilter<"off_chain_vote_author"> | string
    warning?: StringNullableFilter<"off_chain_vote_author"> | string | null
  }

  export type off_chain_vote_authorOrderByWithRelationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    name?: SortOrderInput | SortOrder
    witness_algorithm?: SortOrder
    public_key?: SortOrder
    signature?: SortOrder
    warning?: SortOrderInput | SortOrder
  }

  export type off_chain_vote_authorWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: off_chain_vote_authorWhereInput | off_chain_vote_authorWhereInput[]
    OR?: off_chain_vote_authorWhereInput[]
    NOT?: off_chain_vote_authorWhereInput | off_chain_vote_authorWhereInput[]
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_author"> | bigint | number
    name?: StringNullableFilter<"off_chain_vote_author"> | string | null
    witness_algorithm?: StringFilter<"off_chain_vote_author"> | string
    public_key?: StringFilter<"off_chain_vote_author"> | string
    signature?: StringFilter<"off_chain_vote_author"> | string
    warning?: StringNullableFilter<"off_chain_vote_author"> | string | null
  }, "id">

  export type off_chain_vote_authorOrderByWithAggregationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    name?: SortOrderInput | SortOrder
    witness_algorithm?: SortOrder
    public_key?: SortOrder
    signature?: SortOrder
    warning?: SortOrderInput | SortOrder
    _count?: off_chain_vote_authorCountOrderByAggregateInput
    _avg?: off_chain_vote_authorAvgOrderByAggregateInput
    _max?: off_chain_vote_authorMaxOrderByAggregateInput
    _min?: off_chain_vote_authorMinOrderByAggregateInput
    _sum?: off_chain_vote_authorSumOrderByAggregateInput
  }

  export type off_chain_vote_authorScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_authorScalarWhereWithAggregatesInput | off_chain_vote_authorScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_authorScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_authorScalarWhereWithAggregatesInput | off_chain_vote_authorScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_author"> | bigint | number
    off_chain_vote_data_id?: BigIntWithAggregatesFilter<"off_chain_vote_author"> | bigint | number
    name?: StringNullableWithAggregatesFilter<"off_chain_vote_author"> | string | null
    witness_algorithm?: StringWithAggregatesFilter<"off_chain_vote_author"> | string
    public_key?: StringWithAggregatesFilter<"off_chain_vote_author"> | string
    signature?: StringWithAggregatesFilter<"off_chain_vote_author"> | string
    warning?: StringNullableWithAggregatesFilter<"off_chain_vote_author"> | string | null
  }

  export type off_chain_vote_dataWhereInput = {
    AND?: off_chain_vote_dataWhereInput | off_chain_vote_dataWhereInput[]
    OR?: off_chain_vote_dataWhereInput[]
    NOT?: off_chain_vote_dataWhereInput | off_chain_vote_dataWhereInput[]
    id?: BigIntFilter<"off_chain_vote_data"> | bigint | number
    voting_anchor_id?: BigIntFilter<"off_chain_vote_data"> | bigint | number
    hash?: BytesFilter<"off_chain_vote_data"> | Uint8Array
    json?: JsonFilter<"off_chain_vote_data">
    bytes?: BytesFilter<"off_chain_vote_data"> | Uint8Array
    warning?: StringNullableFilter<"off_chain_vote_data"> | string | null
    language?: StringFilter<"off_chain_vote_data"> | string
    comment?: StringNullableFilter<"off_chain_vote_data"> | string | null
    is_valid?: BoolNullableFilter<"off_chain_vote_data"> | boolean | null
  }

  export type off_chain_vote_dataOrderByWithRelationInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    warning?: SortOrderInput | SortOrder
    language?: SortOrder
    comment?: SortOrderInput | SortOrder
    is_valid?: SortOrderInput | SortOrder
  }

  export type off_chain_vote_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    voting_anchor_id_hash?: off_chain_vote_dataVoting_anchor_idHashCompoundUniqueInput
    AND?: off_chain_vote_dataWhereInput | off_chain_vote_dataWhereInput[]
    OR?: off_chain_vote_dataWhereInput[]
    NOT?: off_chain_vote_dataWhereInput | off_chain_vote_dataWhereInput[]
    voting_anchor_id?: BigIntFilter<"off_chain_vote_data"> | bigint | number
    hash?: BytesFilter<"off_chain_vote_data"> | Uint8Array
    json?: JsonFilter<"off_chain_vote_data">
    bytes?: BytesFilter<"off_chain_vote_data"> | Uint8Array
    warning?: StringNullableFilter<"off_chain_vote_data"> | string | null
    language?: StringFilter<"off_chain_vote_data"> | string
    comment?: StringNullableFilter<"off_chain_vote_data"> | string | null
    is_valid?: BoolNullableFilter<"off_chain_vote_data"> | boolean | null
  }, "id" | "voting_anchor_id_hash">

  export type off_chain_vote_dataOrderByWithAggregationInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    warning?: SortOrderInput | SortOrder
    language?: SortOrder
    comment?: SortOrderInput | SortOrder
    is_valid?: SortOrderInput | SortOrder
    _count?: off_chain_vote_dataCountOrderByAggregateInput
    _avg?: off_chain_vote_dataAvgOrderByAggregateInput
    _max?: off_chain_vote_dataMaxOrderByAggregateInput
    _min?: off_chain_vote_dataMinOrderByAggregateInput
    _sum?: off_chain_vote_dataSumOrderByAggregateInput
  }

  export type off_chain_vote_dataScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_dataScalarWhereWithAggregatesInput | off_chain_vote_dataScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_dataScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_dataScalarWhereWithAggregatesInput | off_chain_vote_dataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_data"> | bigint | number
    voting_anchor_id?: BigIntWithAggregatesFilter<"off_chain_vote_data"> | bigint | number
    hash?: BytesWithAggregatesFilter<"off_chain_vote_data"> | Uint8Array
    json?: JsonWithAggregatesFilter<"off_chain_vote_data">
    bytes?: BytesWithAggregatesFilter<"off_chain_vote_data"> | Uint8Array
    warning?: StringNullableWithAggregatesFilter<"off_chain_vote_data"> | string | null
    language?: StringWithAggregatesFilter<"off_chain_vote_data"> | string
    comment?: StringNullableWithAggregatesFilter<"off_chain_vote_data"> | string | null
    is_valid?: BoolNullableWithAggregatesFilter<"off_chain_vote_data"> | boolean | null
  }

  export type off_chain_vote_drep_dataWhereInput = {
    AND?: off_chain_vote_drep_dataWhereInput | off_chain_vote_drep_dataWhereInput[]
    OR?: off_chain_vote_drep_dataWhereInput[]
    NOT?: off_chain_vote_drep_dataWhereInput | off_chain_vote_drep_dataWhereInput[]
    id?: BigIntFilter<"off_chain_vote_drep_data"> | bigint | number
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_drep_data"> | bigint | number
    payment_address?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    given_name?: StringFilter<"off_chain_vote_drep_data"> | string
    objectives?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    motivations?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    qualifications?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    image_url?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    image_hash?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
  }

  export type off_chain_vote_drep_dataOrderByWithRelationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    payment_address?: SortOrderInput | SortOrder
    given_name?: SortOrder
    objectives?: SortOrderInput | SortOrder
    motivations?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_hash?: SortOrderInput | SortOrder
  }

  export type off_chain_vote_drep_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: off_chain_vote_drep_dataWhereInput | off_chain_vote_drep_dataWhereInput[]
    OR?: off_chain_vote_drep_dataWhereInput[]
    NOT?: off_chain_vote_drep_dataWhereInput | off_chain_vote_drep_dataWhereInput[]
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_drep_data"> | bigint | number
    payment_address?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    given_name?: StringFilter<"off_chain_vote_drep_data"> | string
    objectives?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    motivations?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    qualifications?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    image_url?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
    image_hash?: StringNullableFilter<"off_chain_vote_drep_data"> | string | null
  }, "id">

  export type off_chain_vote_drep_dataOrderByWithAggregationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    payment_address?: SortOrderInput | SortOrder
    given_name?: SortOrder
    objectives?: SortOrderInput | SortOrder
    motivations?: SortOrderInput | SortOrder
    qualifications?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    image_hash?: SortOrderInput | SortOrder
    _count?: off_chain_vote_drep_dataCountOrderByAggregateInput
    _avg?: off_chain_vote_drep_dataAvgOrderByAggregateInput
    _max?: off_chain_vote_drep_dataMaxOrderByAggregateInput
    _min?: off_chain_vote_drep_dataMinOrderByAggregateInput
    _sum?: off_chain_vote_drep_dataSumOrderByAggregateInput
  }

  export type off_chain_vote_drep_dataScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_drep_dataScalarWhereWithAggregatesInput | off_chain_vote_drep_dataScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_drep_dataScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_drep_dataScalarWhereWithAggregatesInput | off_chain_vote_drep_dataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_drep_data"> | bigint | number
    off_chain_vote_data_id?: BigIntWithAggregatesFilter<"off_chain_vote_drep_data"> | bigint | number
    payment_address?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
    given_name?: StringWithAggregatesFilter<"off_chain_vote_drep_data"> | string
    objectives?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
    motivations?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
    qualifications?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
    image_hash?: StringNullableWithAggregatesFilter<"off_chain_vote_drep_data"> | string | null
  }

  export type off_chain_vote_external_updateWhereInput = {
    AND?: off_chain_vote_external_updateWhereInput | off_chain_vote_external_updateWhereInput[]
    OR?: off_chain_vote_external_updateWhereInput[]
    NOT?: off_chain_vote_external_updateWhereInput | off_chain_vote_external_updateWhereInput[]
    id?: BigIntFilter<"off_chain_vote_external_update"> | bigint | number
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_external_update"> | bigint | number
    title?: StringFilter<"off_chain_vote_external_update"> | string
    uri?: StringFilter<"off_chain_vote_external_update"> | string
  }

  export type off_chain_vote_external_updateOrderByWithRelationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    uri?: SortOrder
  }

  export type off_chain_vote_external_updateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: off_chain_vote_external_updateWhereInput | off_chain_vote_external_updateWhereInput[]
    OR?: off_chain_vote_external_updateWhereInput[]
    NOT?: off_chain_vote_external_updateWhereInput | off_chain_vote_external_updateWhereInput[]
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_external_update"> | bigint | number
    title?: StringFilter<"off_chain_vote_external_update"> | string
    uri?: StringFilter<"off_chain_vote_external_update"> | string
  }, "id">

  export type off_chain_vote_external_updateOrderByWithAggregationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    uri?: SortOrder
    _count?: off_chain_vote_external_updateCountOrderByAggregateInput
    _avg?: off_chain_vote_external_updateAvgOrderByAggregateInput
    _max?: off_chain_vote_external_updateMaxOrderByAggregateInput
    _min?: off_chain_vote_external_updateMinOrderByAggregateInput
    _sum?: off_chain_vote_external_updateSumOrderByAggregateInput
  }

  export type off_chain_vote_external_updateScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_external_updateScalarWhereWithAggregatesInput | off_chain_vote_external_updateScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_external_updateScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_external_updateScalarWhereWithAggregatesInput | off_chain_vote_external_updateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_external_update"> | bigint | number
    off_chain_vote_data_id?: BigIntWithAggregatesFilter<"off_chain_vote_external_update"> | bigint | number
    title?: StringWithAggregatesFilter<"off_chain_vote_external_update"> | string
    uri?: StringWithAggregatesFilter<"off_chain_vote_external_update"> | string
  }

  export type off_chain_vote_fetch_errorWhereInput = {
    AND?: off_chain_vote_fetch_errorWhereInput | off_chain_vote_fetch_errorWhereInput[]
    OR?: off_chain_vote_fetch_errorWhereInput[]
    NOT?: off_chain_vote_fetch_errorWhereInput | off_chain_vote_fetch_errorWhereInput[]
    id?: BigIntFilter<"off_chain_vote_fetch_error"> | bigint | number
    voting_anchor_id?: BigIntFilter<"off_chain_vote_fetch_error"> | bigint | number
    fetch_error?: StringFilter<"off_chain_vote_fetch_error"> | string
    fetch_time?: DateTimeFilter<"off_chain_vote_fetch_error"> | Date | string
    retry_count?: IntFilter<"off_chain_vote_fetch_error"> | number
  }

  export type off_chain_vote_fetch_errorOrderByWithRelationInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    fetch_error?: SortOrder
    fetch_time?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_fetch_errorWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    voting_anchor_id_retry_count?: off_chain_vote_fetch_errorVoting_anchor_idRetry_countCompoundUniqueInput
    AND?: off_chain_vote_fetch_errorWhereInput | off_chain_vote_fetch_errorWhereInput[]
    OR?: off_chain_vote_fetch_errorWhereInput[]
    NOT?: off_chain_vote_fetch_errorWhereInput | off_chain_vote_fetch_errorWhereInput[]
    voting_anchor_id?: BigIntFilter<"off_chain_vote_fetch_error"> | bigint | number
    fetch_error?: StringFilter<"off_chain_vote_fetch_error"> | string
    fetch_time?: DateTimeFilter<"off_chain_vote_fetch_error"> | Date | string
    retry_count?: IntFilter<"off_chain_vote_fetch_error"> | number
  }, "id" | "voting_anchor_id_retry_count">

  export type off_chain_vote_fetch_errorOrderByWithAggregationInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    fetch_error?: SortOrder
    fetch_time?: SortOrder
    retry_count?: SortOrder
    _count?: off_chain_vote_fetch_errorCountOrderByAggregateInput
    _avg?: off_chain_vote_fetch_errorAvgOrderByAggregateInput
    _max?: off_chain_vote_fetch_errorMaxOrderByAggregateInput
    _min?: off_chain_vote_fetch_errorMinOrderByAggregateInput
    _sum?: off_chain_vote_fetch_errorSumOrderByAggregateInput
  }

  export type off_chain_vote_fetch_errorScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_fetch_errorScalarWhereWithAggregatesInput | off_chain_vote_fetch_errorScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_fetch_errorScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_fetch_errorScalarWhereWithAggregatesInput | off_chain_vote_fetch_errorScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_fetch_error"> | bigint | number
    voting_anchor_id?: BigIntWithAggregatesFilter<"off_chain_vote_fetch_error"> | bigint | number
    fetch_error?: StringWithAggregatesFilter<"off_chain_vote_fetch_error"> | string
    fetch_time?: DateTimeWithAggregatesFilter<"off_chain_vote_fetch_error"> | Date | string
    retry_count?: IntWithAggregatesFilter<"off_chain_vote_fetch_error"> | number
  }

  export type off_chain_vote_gov_action_dataWhereInput = {
    AND?: off_chain_vote_gov_action_dataWhereInput | off_chain_vote_gov_action_dataWhereInput[]
    OR?: off_chain_vote_gov_action_dataWhereInput[]
    NOT?: off_chain_vote_gov_action_dataWhereInput | off_chain_vote_gov_action_dataWhereInput[]
    id?: BigIntFilter<"off_chain_vote_gov_action_data"> | bigint | number
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_gov_action_data"> | bigint | number
    title?: StringFilter<"off_chain_vote_gov_action_data"> | string
    abstract?: StringFilter<"off_chain_vote_gov_action_data"> | string
    motivation?: StringFilter<"off_chain_vote_gov_action_data"> | string
    rationale?: StringFilter<"off_chain_vote_gov_action_data"> | string
  }

  export type off_chain_vote_gov_action_dataOrderByWithRelationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    motivation?: SortOrder
    rationale?: SortOrder
  }

  export type off_chain_vote_gov_action_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: off_chain_vote_gov_action_dataWhereInput | off_chain_vote_gov_action_dataWhereInput[]
    OR?: off_chain_vote_gov_action_dataWhereInput[]
    NOT?: off_chain_vote_gov_action_dataWhereInput | off_chain_vote_gov_action_dataWhereInput[]
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_gov_action_data"> | bigint | number
    title?: StringFilter<"off_chain_vote_gov_action_data"> | string
    abstract?: StringFilter<"off_chain_vote_gov_action_data"> | string
    motivation?: StringFilter<"off_chain_vote_gov_action_data"> | string
    rationale?: StringFilter<"off_chain_vote_gov_action_data"> | string
  }, "id">

  export type off_chain_vote_gov_action_dataOrderByWithAggregationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    motivation?: SortOrder
    rationale?: SortOrder
    _count?: off_chain_vote_gov_action_dataCountOrderByAggregateInput
    _avg?: off_chain_vote_gov_action_dataAvgOrderByAggregateInput
    _max?: off_chain_vote_gov_action_dataMaxOrderByAggregateInput
    _min?: off_chain_vote_gov_action_dataMinOrderByAggregateInput
    _sum?: off_chain_vote_gov_action_dataSumOrderByAggregateInput
  }

  export type off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput | off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput | off_chain_vote_gov_action_dataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_gov_action_data"> | bigint | number
    off_chain_vote_data_id?: BigIntWithAggregatesFilter<"off_chain_vote_gov_action_data"> | bigint | number
    title?: StringWithAggregatesFilter<"off_chain_vote_gov_action_data"> | string
    abstract?: StringWithAggregatesFilter<"off_chain_vote_gov_action_data"> | string
    motivation?: StringWithAggregatesFilter<"off_chain_vote_gov_action_data"> | string
    rationale?: StringWithAggregatesFilter<"off_chain_vote_gov_action_data"> | string
  }

  export type off_chain_vote_referenceWhereInput = {
    AND?: off_chain_vote_referenceWhereInput | off_chain_vote_referenceWhereInput[]
    OR?: off_chain_vote_referenceWhereInput[]
    NOT?: off_chain_vote_referenceWhereInput | off_chain_vote_referenceWhereInput[]
    id?: BigIntFilter<"off_chain_vote_reference"> | bigint | number
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_reference"> | bigint | number
    label?: StringFilter<"off_chain_vote_reference"> | string
    uri?: StringFilter<"off_chain_vote_reference"> | string
    hash_digest?: StringNullableFilter<"off_chain_vote_reference"> | string | null
    hash_algorithm?: StringNullableFilter<"off_chain_vote_reference"> | string | null
  }

  export type off_chain_vote_referenceOrderByWithRelationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    label?: SortOrder
    uri?: SortOrder
    hash_digest?: SortOrderInput | SortOrder
    hash_algorithm?: SortOrderInput | SortOrder
  }

  export type off_chain_vote_referenceWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: off_chain_vote_referenceWhereInput | off_chain_vote_referenceWhereInput[]
    OR?: off_chain_vote_referenceWhereInput[]
    NOT?: off_chain_vote_referenceWhereInput | off_chain_vote_referenceWhereInput[]
    off_chain_vote_data_id?: BigIntFilter<"off_chain_vote_reference"> | bigint | number
    label?: StringFilter<"off_chain_vote_reference"> | string
    uri?: StringFilter<"off_chain_vote_reference"> | string
    hash_digest?: StringNullableFilter<"off_chain_vote_reference"> | string | null
    hash_algorithm?: StringNullableFilter<"off_chain_vote_reference"> | string | null
  }, "id">

  export type off_chain_vote_referenceOrderByWithAggregationInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    label?: SortOrder
    uri?: SortOrder
    hash_digest?: SortOrderInput | SortOrder
    hash_algorithm?: SortOrderInput | SortOrder
    _count?: off_chain_vote_referenceCountOrderByAggregateInput
    _avg?: off_chain_vote_referenceAvgOrderByAggregateInput
    _max?: off_chain_vote_referenceMaxOrderByAggregateInput
    _min?: off_chain_vote_referenceMinOrderByAggregateInput
    _sum?: off_chain_vote_referenceSumOrderByAggregateInput
  }

  export type off_chain_vote_referenceScalarWhereWithAggregatesInput = {
    AND?: off_chain_vote_referenceScalarWhereWithAggregatesInput | off_chain_vote_referenceScalarWhereWithAggregatesInput[]
    OR?: off_chain_vote_referenceScalarWhereWithAggregatesInput[]
    NOT?: off_chain_vote_referenceScalarWhereWithAggregatesInput | off_chain_vote_referenceScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"off_chain_vote_reference"> | bigint | number
    off_chain_vote_data_id?: BigIntWithAggregatesFilter<"off_chain_vote_reference"> | bigint | number
    label?: StringWithAggregatesFilter<"off_chain_vote_reference"> | string
    uri?: StringWithAggregatesFilter<"off_chain_vote_reference"> | string
    hash_digest?: StringNullableWithAggregatesFilter<"off_chain_vote_reference"> | string | null
    hash_algorithm?: StringNullableWithAggregatesFilter<"off_chain_vote_reference"> | string | null
  }

  export type param_proposalWhereInput = {
    AND?: param_proposalWhereInput | param_proposalWhereInput[]
    OR?: param_proposalWhereInput[]
    NOT?: param_proposalWhereInput | param_proposalWhereInput[]
    id?: BigIntFilter<"param_proposal"> | bigint | number
    epoch_no?: IntNullableFilter<"param_proposal"> | number | null
    key?: BytesNullableFilter<"param_proposal"> | Uint8Array | null
    min_fee_a?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    key_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_epoch?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    influence?: FloatNullableFilter<"param_proposal"> | number | null
    monetary_expand_rate?: FloatNullableFilter<"param_proposal"> | number | null
    treasury_growth_rate?: FloatNullableFilter<"param_proposal"> | number | null
    decentralisation?: FloatNullableFilter<"param_proposal"> | number | null
    entropy?: BytesNullableFilter<"param_proposal"> | Uint8Array | null
    protocol_major?: IntNullableFilter<"param_proposal"> | number | null
    protocol_minor?: IntNullableFilter<"param_proposal"> | number | null
    min_utxo_value?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: BigIntNullableFilter<"param_proposal"> | bigint | number | null
    price_mem?: FloatNullableFilter<"param_proposal"> | number | null
    price_step?: FloatNullableFilter<"param_proposal"> | number | null
    max_tx_ex_mem?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableFilter<"param_proposal"> | number | null
    max_collateral_inputs?: IntNullableFilter<"param_proposal"> | number | null
    registered_tx_id?: BigIntFilter<"param_proposal"> | bigint | number
    coins_per_utxo_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_committee_normal?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_committee_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_hard_fork_initiation?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_motion_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_committee_normal?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_committee_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_update_to_constitution?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_hard_fork_initiation?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_network_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_economic_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_technical_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_gov_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_treasury_withdrawal?: FloatNullableFilter<"param_proposal"> | number | null
    committee_min_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableFilter<"param_proposal"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableFilter<"param_proposal"> | number | null
  }

  export type param_proposalOrderByWithRelationInput = {
    id?: SortOrder
    epoch_no?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    min_fee_a?: SortOrderInput | SortOrder
    min_fee_b?: SortOrderInput | SortOrder
    max_block_size?: SortOrderInput | SortOrder
    max_tx_size?: SortOrderInput | SortOrder
    max_bh_size?: SortOrderInput | SortOrder
    key_deposit?: SortOrderInput | SortOrder
    pool_deposit?: SortOrderInput | SortOrder
    max_epoch?: SortOrderInput | SortOrder
    optimal_pool_count?: SortOrderInput | SortOrder
    influence?: SortOrderInput | SortOrder
    monetary_expand_rate?: SortOrderInput | SortOrder
    treasury_growth_rate?: SortOrderInput | SortOrder
    decentralisation?: SortOrderInput | SortOrder
    entropy?: SortOrderInput | SortOrder
    protocol_major?: SortOrderInput | SortOrder
    protocol_minor?: SortOrderInput | SortOrder
    min_utxo_value?: SortOrderInput | SortOrder
    min_pool_cost?: SortOrderInput | SortOrder
    cost_model_id?: SortOrderInput | SortOrder
    price_mem?: SortOrderInput | SortOrder
    price_step?: SortOrderInput | SortOrder
    max_tx_ex_mem?: SortOrderInput | SortOrder
    max_tx_ex_steps?: SortOrderInput | SortOrder
    max_block_ex_mem?: SortOrderInput | SortOrder
    max_block_ex_steps?: SortOrderInput | SortOrder
    max_val_size?: SortOrderInput | SortOrder
    collateral_percent?: SortOrderInput | SortOrder
    max_collateral_inputs?: SortOrderInput | SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrderInput | SortOrder
    pvt_motion_no_confidence?: SortOrderInput | SortOrder
    pvt_committee_normal?: SortOrderInput | SortOrder
    pvt_committee_no_confidence?: SortOrderInput | SortOrder
    pvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_motion_no_confidence?: SortOrderInput | SortOrder
    dvt_committee_normal?: SortOrderInput | SortOrder
    dvt_committee_no_confidence?: SortOrderInput | SortOrder
    dvt_update_to_constitution?: SortOrderInput | SortOrder
    dvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_p_p_network_group?: SortOrderInput | SortOrder
    dvt_p_p_economic_group?: SortOrderInput | SortOrder
    dvt_p_p_technical_group?: SortOrderInput | SortOrder
    dvt_p_p_gov_group?: SortOrderInput | SortOrder
    dvt_treasury_withdrawal?: SortOrderInput | SortOrder
    committee_min_size?: SortOrderInput | SortOrder
    committee_max_term_length?: SortOrderInput | SortOrder
    gov_action_lifetime?: SortOrderInput | SortOrder
    gov_action_deposit?: SortOrderInput | SortOrder
    drep_deposit?: SortOrderInput | SortOrder
    drep_activity?: SortOrderInput | SortOrder
    pvtpp_security_group?: SortOrderInput | SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrderInput | SortOrder
  }

  export type param_proposalWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: param_proposalWhereInput | param_proposalWhereInput[]
    OR?: param_proposalWhereInput[]
    NOT?: param_proposalWhereInput | param_proposalWhereInput[]
    epoch_no?: IntNullableFilter<"param_proposal"> | number | null
    key?: BytesNullableFilter<"param_proposal"> | Uint8Array | null
    min_fee_a?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    key_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_epoch?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    influence?: FloatNullableFilter<"param_proposal"> | number | null
    monetary_expand_rate?: FloatNullableFilter<"param_proposal"> | number | null
    treasury_growth_rate?: FloatNullableFilter<"param_proposal"> | number | null
    decentralisation?: FloatNullableFilter<"param_proposal"> | number | null
    entropy?: BytesNullableFilter<"param_proposal"> | Uint8Array | null
    protocol_major?: IntNullableFilter<"param_proposal"> | number | null
    protocol_minor?: IntNullableFilter<"param_proposal"> | number | null
    min_utxo_value?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: BigIntNullableFilter<"param_proposal"> | bigint | number | null
    price_mem?: FloatNullableFilter<"param_proposal"> | number | null
    price_step?: FloatNullableFilter<"param_proposal"> | number | null
    max_tx_ex_mem?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableFilter<"param_proposal"> | number | null
    max_collateral_inputs?: IntNullableFilter<"param_proposal"> | number | null
    registered_tx_id?: BigIntFilter<"param_proposal"> | bigint | number
    coins_per_utxo_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_committee_normal?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_committee_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    pvt_hard_fork_initiation?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_motion_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_committee_normal?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_committee_no_confidence?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_update_to_constitution?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_hard_fork_initiation?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_network_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_economic_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_technical_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_p_p_gov_group?: FloatNullableFilter<"param_proposal"> | number | null
    dvt_treasury_withdrawal?: FloatNullableFilter<"param_proposal"> | number | null
    committee_min_size?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableFilter<"param_proposal"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableFilter<"param_proposal"> | number | null
  }, "id">

  export type param_proposalOrderByWithAggregationInput = {
    id?: SortOrder
    epoch_no?: SortOrderInput | SortOrder
    key?: SortOrderInput | SortOrder
    min_fee_a?: SortOrderInput | SortOrder
    min_fee_b?: SortOrderInput | SortOrder
    max_block_size?: SortOrderInput | SortOrder
    max_tx_size?: SortOrderInput | SortOrder
    max_bh_size?: SortOrderInput | SortOrder
    key_deposit?: SortOrderInput | SortOrder
    pool_deposit?: SortOrderInput | SortOrder
    max_epoch?: SortOrderInput | SortOrder
    optimal_pool_count?: SortOrderInput | SortOrder
    influence?: SortOrderInput | SortOrder
    monetary_expand_rate?: SortOrderInput | SortOrder
    treasury_growth_rate?: SortOrderInput | SortOrder
    decentralisation?: SortOrderInput | SortOrder
    entropy?: SortOrderInput | SortOrder
    protocol_major?: SortOrderInput | SortOrder
    protocol_minor?: SortOrderInput | SortOrder
    min_utxo_value?: SortOrderInput | SortOrder
    min_pool_cost?: SortOrderInput | SortOrder
    cost_model_id?: SortOrderInput | SortOrder
    price_mem?: SortOrderInput | SortOrder
    price_step?: SortOrderInput | SortOrder
    max_tx_ex_mem?: SortOrderInput | SortOrder
    max_tx_ex_steps?: SortOrderInput | SortOrder
    max_block_ex_mem?: SortOrderInput | SortOrder
    max_block_ex_steps?: SortOrderInput | SortOrder
    max_val_size?: SortOrderInput | SortOrder
    collateral_percent?: SortOrderInput | SortOrder
    max_collateral_inputs?: SortOrderInput | SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrderInput | SortOrder
    pvt_motion_no_confidence?: SortOrderInput | SortOrder
    pvt_committee_normal?: SortOrderInput | SortOrder
    pvt_committee_no_confidence?: SortOrderInput | SortOrder
    pvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_motion_no_confidence?: SortOrderInput | SortOrder
    dvt_committee_normal?: SortOrderInput | SortOrder
    dvt_committee_no_confidence?: SortOrderInput | SortOrder
    dvt_update_to_constitution?: SortOrderInput | SortOrder
    dvt_hard_fork_initiation?: SortOrderInput | SortOrder
    dvt_p_p_network_group?: SortOrderInput | SortOrder
    dvt_p_p_economic_group?: SortOrderInput | SortOrder
    dvt_p_p_technical_group?: SortOrderInput | SortOrder
    dvt_p_p_gov_group?: SortOrderInput | SortOrder
    dvt_treasury_withdrawal?: SortOrderInput | SortOrder
    committee_min_size?: SortOrderInput | SortOrder
    committee_max_term_length?: SortOrderInput | SortOrder
    gov_action_lifetime?: SortOrderInput | SortOrder
    gov_action_deposit?: SortOrderInput | SortOrder
    drep_deposit?: SortOrderInput | SortOrder
    drep_activity?: SortOrderInput | SortOrder
    pvtpp_security_group?: SortOrderInput | SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrderInput | SortOrder
    _count?: param_proposalCountOrderByAggregateInput
    _avg?: param_proposalAvgOrderByAggregateInput
    _max?: param_proposalMaxOrderByAggregateInput
    _min?: param_proposalMinOrderByAggregateInput
    _sum?: param_proposalSumOrderByAggregateInput
  }

  export type param_proposalScalarWhereWithAggregatesInput = {
    AND?: param_proposalScalarWhereWithAggregatesInput | param_proposalScalarWhereWithAggregatesInput[]
    OR?: param_proposalScalarWhereWithAggregatesInput[]
    NOT?: param_proposalScalarWhereWithAggregatesInput | param_proposalScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"param_proposal"> | bigint | number
    epoch_no?: IntNullableWithAggregatesFilter<"param_proposal"> | number | null
    key?: BytesNullableWithAggregatesFilter<"param_proposal"> | Uint8Array | null
    min_fee_a?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    key_deposit?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_epoch?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    influence?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    monetary_expand_rate?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    treasury_growth_rate?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    decentralisation?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    entropy?: BytesNullableWithAggregatesFilter<"param_proposal"> | Uint8Array | null
    protocol_major?: IntNullableWithAggregatesFilter<"param_proposal"> | number | null
    protocol_minor?: IntNullableWithAggregatesFilter<"param_proposal"> | number | null
    min_utxo_value?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: BigIntNullableWithAggregatesFilter<"param_proposal"> | bigint | number | null
    price_mem?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    price_step?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    max_tx_ex_mem?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    max_val_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: IntNullableWithAggregatesFilter<"param_proposal"> | number | null
    max_collateral_inputs?: IntNullableWithAggregatesFilter<"param_proposal"> | number | null
    registered_tx_id?: BigIntWithAggregatesFilter<"param_proposal"> | bigint | number
    coins_per_utxo_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    pvt_committee_normal?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    pvt_committee_no_confidence?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    pvt_hard_fork_initiation?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_motion_no_confidence?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_committee_normal?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_committee_no_confidence?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_update_to_constitution?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_hard_fork_initiation?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_p_p_network_group?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_p_p_economic_group?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_p_p_technical_group?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_p_p_gov_group?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    dvt_treasury_withdrawal?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    committee_min_size?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    drep_activity?: DecimalNullableWithAggregatesFilter<"param_proposal"> | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
    min_fee_ref_script_cost_per_byte?: FloatNullableWithAggregatesFilter<"param_proposal"> | number | null
  }

  export type pool_hashWhereInput = {
    AND?: pool_hashWhereInput | pool_hashWhereInput[]
    OR?: pool_hashWhereInput[]
    NOT?: pool_hashWhereInput | pool_hashWhereInput[]
    id?: BigIntFilter<"pool_hash"> | bigint | number
    hash_raw?: BytesFilter<"pool_hash"> | Uint8Array
    view?: StringFilter<"pool_hash"> | string
  }

  export type pool_hashOrderByWithRelationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
  }

  export type pool_hashWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash_raw?: Uint8Array
    AND?: pool_hashWhereInput | pool_hashWhereInput[]
    OR?: pool_hashWhereInput[]
    NOT?: pool_hashWhereInput | pool_hashWhereInput[]
    view?: StringFilter<"pool_hash"> | string
  }, "id" | "hash_raw">

  export type pool_hashOrderByWithAggregationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    _count?: pool_hashCountOrderByAggregateInput
    _avg?: pool_hashAvgOrderByAggregateInput
    _max?: pool_hashMaxOrderByAggregateInput
    _min?: pool_hashMinOrderByAggregateInput
    _sum?: pool_hashSumOrderByAggregateInput
  }

  export type pool_hashScalarWhereWithAggregatesInput = {
    AND?: pool_hashScalarWhereWithAggregatesInput | pool_hashScalarWhereWithAggregatesInput[]
    OR?: pool_hashScalarWhereWithAggregatesInput[]
    NOT?: pool_hashScalarWhereWithAggregatesInput | pool_hashScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_hash"> | bigint | number
    hash_raw?: BytesWithAggregatesFilter<"pool_hash"> | Uint8Array
    view?: StringWithAggregatesFilter<"pool_hash"> | string
  }

  export type pool_metadata_refWhereInput = {
    AND?: pool_metadata_refWhereInput | pool_metadata_refWhereInput[]
    OR?: pool_metadata_refWhereInput[]
    NOT?: pool_metadata_refWhereInput | pool_metadata_refWhereInput[]
    id?: BigIntFilter<"pool_metadata_ref"> | bigint | number
    pool_id?: BigIntFilter<"pool_metadata_ref"> | bigint | number
    url?: StringFilter<"pool_metadata_ref"> | string
    hash?: BytesFilter<"pool_metadata_ref"> | Uint8Array
    registered_tx_id?: BigIntFilter<"pool_metadata_ref"> | bigint | number
  }

  export type pool_metadata_refOrderByWithRelationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    url?: SortOrder
    hash?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_metadata_refWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_metadata_refWhereInput | pool_metadata_refWhereInput[]
    OR?: pool_metadata_refWhereInput[]
    NOT?: pool_metadata_refWhereInput | pool_metadata_refWhereInput[]
    pool_id?: BigIntFilter<"pool_metadata_ref"> | bigint | number
    url?: StringFilter<"pool_metadata_ref"> | string
    hash?: BytesFilter<"pool_metadata_ref"> | Uint8Array
    registered_tx_id?: BigIntFilter<"pool_metadata_ref"> | bigint | number
  }, "id">

  export type pool_metadata_refOrderByWithAggregationInput = {
    id?: SortOrder
    pool_id?: SortOrder
    url?: SortOrder
    hash?: SortOrder
    registered_tx_id?: SortOrder
    _count?: pool_metadata_refCountOrderByAggregateInput
    _avg?: pool_metadata_refAvgOrderByAggregateInput
    _max?: pool_metadata_refMaxOrderByAggregateInput
    _min?: pool_metadata_refMinOrderByAggregateInput
    _sum?: pool_metadata_refSumOrderByAggregateInput
  }

  export type pool_metadata_refScalarWhereWithAggregatesInput = {
    AND?: pool_metadata_refScalarWhereWithAggregatesInput | pool_metadata_refScalarWhereWithAggregatesInput[]
    OR?: pool_metadata_refScalarWhereWithAggregatesInput[]
    NOT?: pool_metadata_refScalarWhereWithAggregatesInput | pool_metadata_refScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_metadata_ref"> | bigint | number
    pool_id?: BigIntWithAggregatesFilter<"pool_metadata_ref"> | bigint | number
    url?: StringWithAggregatesFilter<"pool_metadata_ref"> | string
    hash?: BytesWithAggregatesFilter<"pool_metadata_ref"> | Uint8Array
    registered_tx_id?: BigIntWithAggregatesFilter<"pool_metadata_ref"> | bigint | number
  }

  export type pool_ownerWhereInput = {
    AND?: pool_ownerWhereInput | pool_ownerWhereInput[]
    OR?: pool_ownerWhereInput[]
    NOT?: pool_ownerWhereInput | pool_ownerWhereInput[]
    id?: BigIntFilter<"pool_owner"> | bigint | number
    addr_id?: BigIntFilter<"pool_owner"> | bigint | number
    pool_update_id?: BigIntFilter<"pool_owner"> | bigint | number
  }

  export type pool_ownerOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_ownerWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_ownerWhereInput | pool_ownerWhereInput[]
    OR?: pool_ownerWhereInput[]
    NOT?: pool_ownerWhereInput | pool_ownerWhereInput[]
    addr_id?: BigIntFilter<"pool_owner"> | bigint | number
    pool_update_id?: BigIntFilter<"pool_owner"> | bigint | number
  }, "id">

  export type pool_ownerOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
    _count?: pool_ownerCountOrderByAggregateInput
    _avg?: pool_ownerAvgOrderByAggregateInput
    _max?: pool_ownerMaxOrderByAggregateInput
    _min?: pool_ownerMinOrderByAggregateInput
    _sum?: pool_ownerSumOrderByAggregateInput
  }

  export type pool_ownerScalarWhereWithAggregatesInput = {
    AND?: pool_ownerScalarWhereWithAggregatesInput | pool_ownerScalarWhereWithAggregatesInput[]
    OR?: pool_ownerScalarWhereWithAggregatesInput[]
    NOT?: pool_ownerScalarWhereWithAggregatesInput | pool_ownerScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_owner"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"pool_owner"> | bigint | number
    pool_update_id?: BigIntWithAggregatesFilter<"pool_owner"> | bigint | number
  }

  export type pool_relayWhereInput = {
    AND?: pool_relayWhereInput | pool_relayWhereInput[]
    OR?: pool_relayWhereInput[]
    NOT?: pool_relayWhereInput | pool_relayWhereInput[]
    id?: BigIntFilter<"pool_relay"> | bigint | number
    update_id?: BigIntFilter<"pool_relay"> | bigint | number
    ipv4?: StringNullableFilter<"pool_relay"> | string | null
    ipv6?: StringNullableFilter<"pool_relay"> | string | null
    dns_name?: StringNullableFilter<"pool_relay"> | string | null
    dns_srv_name?: StringNullableFilter<"pool_relay"> | string | null
    port?: IntNullableFilter<"pool_relay"> | number | null
  }

  export type pool_relayOrderByWithRelationInput = {
    id?: SortOrder
    update_id?: SortOrder
    ipv4?: SortOrderInput | SortOrder
    ipv6?: SortOrderInput | SortOrder
    dns_name?: SortOrderInput | SortOrder
    dns_srv_name?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
  }

  export type pool_relayWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_relayWhereInput | pool_relayWhereInput[]
    OR?: pool_relayWhereInput[]
    NOT?: pool_relayWhereInput | pool_relayWhereInput[]
    update_id?: BigIntFilter<"pool_relay"> | bigint | number
    ipv4?: StringNullableFilter<"pool_relay"> | string | null
    ipv6?: StringNullableFilter<"pool_relay"> | string | null
    dns_name?: StringNullableFilter<"pool_relay"> | string | null
    dns_srv_name?: StringNullableFilter<"pool_relay"> | string | null
    port?: IntNullableFilter<"pool_relay"> | number | null
  }, "id">

  export type pool_relayOrderByWithAggregationInput = {
    id?: SortOrder
    update_id?: SortOrder
    ipv4?: SortOrderInput | SortOrder
    ipv6?: SortOrderInput | SortOrder
    dns_name?: SortOrderInput | SortOrder
    dns_srv_name?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    _count?: pool_relayCountOrderByAggregateInput
    _avg?: pool_relayAvgOrderByAggregateInput
    _max?: pool_relayMaxOrderByAggregateInput
    _min?: pool_relayMinOrderByAggregateInput
    _sum?: pool_relaySumOrderByAggregateInput
  }

  export type pool_relayScalarWhereWithAggregatesInput = {
    AND?: pool_relayScalarWhereWithAggregatesInput | pool_relayScalarWhereWithAggregatesInput[]
    OR?: pool_relayScalarWhereWithAggregatesInput[]
    NOT?: pool_relayScalarWhereWithAggregatesInput | pool_relayScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_relay"> | bigint | number
    update_id?: BigIntWithAggregatesFilter<"pool_relay"> | bigint | number
    ipv4?: StringNullableWithAggregatesFilter<"pool_relay"> | string | null
    ipv6?: StringNullableWithAggregatesFilter<"pool_relay"> | string | null
    dns_name?: StringNullableWithAggregatesFilter<"pool_relay"> | string | null
    dns_srv_name?: StringNullableWithAggregatesFilter<"pool_relay"> | string | null
    port?: IntNullableWithAggregatesFilter<"pool_relay"> | number | null
  }

  export type pool_retireWhereInput = {
    AND?: pool_retireWhereInput | pool_retireWhereInput[]
    OR?: pool_retireWhereInput[]
    NOT?: pool_retireWhereInput | pool_retireWhereInput[]
    id?: BigIntFilter<"pool_retire"> | bigint | number
    hash_id?: BigIntFilter<"pool_retire"> | bigint | number
    cert_index?: IntFilter<"pool_retire"> | number
    announced_tx_id?: BigIntFilter<"pool_retire"> | bigint | number
    retiring_epoch?: IntFilter<"pool_retire"> | number
  }

  export type pool_retireOrderByWithRelationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_retireWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_retireWhereInput | pool_retireWhereInput[]
    OR?: pool_retireWhereInput[]
    NOT?: pool_retireWhereInput | pool_retireWhereInput[]
    hash_id?: BigIntFilter<"pool_retire"> | bigint | number
    cert_index?: IntFilter<"pool_retire"> | number
    announced_tx_id?: BigIntFilter<"pool_retire"> | bigint | number
    retiring_epoch?: IntFilter<"pool_retire"> | number
  }, "id">

  export type pool_retireOrderByWithAggregationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
    _count?: pool_retireCountOrderByAggregateInput
    _avg?: pool_retireAvgOrderByAggregateInput
    _max?: pool_retireMaxOrderByAggregateInput
    _min?: pool_retireMinOrderByAggregateInput
    _sum?: pool_retireSumOrderByAggregateInput
  }

  export type pool_retireScalarWhereWithAggregatesInput = {
    AND?: pool_retireScalarWhereWithAggregatesInput | pool_retireScalarWhereWithAggregatesInput[]
    OR?: pool_retireScalarWhereWithAggregatesInput[]
    NOT?: pool_retireScalarWhereWithAggregatesInput | pool_retireScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_retire"> | bigint | number
    hash_id?: BigIntWithAggregatesFilter<"pool_retire"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"pool_retire"> | number
    announced_tx_id?: BigIntWithAggregatesFilter<"pool_retire"> | bigint | number
    retiring_epoch?: IntWithAggregatesFilter<"pool_retire"> | number
  }

  export type pool_statWhereInput = {
    AND?: pool_statWhereInput | pool_statWhereInput[]
    OR?: pool_statWhereInput[]
    NOT?: pool_statWhereInput | pool_statWhereInput[]
    id?: BigIntFilter<"pool_stat"> | bigint | number
    pool_hash_id?: BigIntFilter<"pool_stat"> | bigint | number
    epoch_no?: IntFilter<"pool_stat"> | number
    number_of_blocks?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    stake?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    voting_power?: DecimalNullableFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statOrderByWithRelationInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrderInput | SortOrder
  }

  export type pool_statWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_statWhereInput | pool_statWhereInput[]
    OR?: pool_statWhereInput[]
    NOT?: pool_statWhereInput | pool_statWhereInput[]
    pool_hash_id?: BigIntFilter<"pool_stat"> | bigint | number
    epoch_no?: IntFilter<"pool_stat"> | number
    number_of_blocks?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    stake?: DecimalFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    voting_power?: DecimalNullableFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type pool_statOrderByWithAggregationInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrderInput | SortOrder
    _count?: pool_statCountOrderByAggregateInput
    _avg?: pool_statAvgOrderByAggregateInput
    _max?: pool_statMaxOrderByAggregateInput
    _min?: pool_statMinOrderByAggregateInput
    _sum?: pool_statSumOrderByAggregateInput
  }

  export type pool_statScalarWhereWithAggregatesInput = {
    AND?: pool_statScalarWhereWithAggregatesInput | pool_statScalarWhereWithAggregatesInput[]
    OR?: pool_statScalarWhereWithAggregatesInput[]
    NOT?: pool_statScalarWhereWithAggregatesInput | pool_statScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_stat"> | bigint | number
    pool_hash_id?: BigIntWithAggregatesFilter<"pool_stat"> | bigint | number
    epoch_no?: IntWithAggregatesFilter<"pool_stat"> | number
    number_of_blocks?: DecimalWithAggregatesFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalWithAggregatesFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    stake?: DecimalWithAggregatesFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string
    voting_power?: DecimalNullableWithAggregatesFilter<"pool_stat"> | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateWhereInput = {
    AND?: pool_updateWhereInput | pool_updateWhereInput[]
    OR?: pool_updateWhereInput[]
    NOT?: pool_updateWhereInput | pool_updateWhereInput[]
    id?: BigIntFilter<"pool_update"> | bigint | number
    hash_id?: BigIntFilter<"pool_update"> | bigint | number
    cert_index?: IntFilter<"pool_update"> | number
    vrf_key_hash?: BytesFilter<"pool_update"> | Uint8Array
    pledge?: DecimalFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFilter<"pool_update"> | bigint | number
    meta_id?: BigIntNullableFilter<"pool_update"> | bigint | number | null
    margin?: FloatFilter<"pool_update"> | number
    fixed_cost?: DecimalFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFilter<"pool_update"> | bigint | number
    reward_addr_id?: BigIntFilter<"pool_update"> | bigint | number
    deposit?: DecimalNullableFilter<"pool_update"> | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateOrderByWithRelationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    vrf_key_hash?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrderInput | SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrderInput | SortOrder
  }

  export type pool_updateWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pool_updateWhereInput | pool_updateWhereInput[]
    OR?: pool_updateWhereInput[]
    NOT?: pool_updateWhereInput | pool_updateWhereInput[]
    hash_id?: BigIntFilter<"pool_update"> | bigint | number
    cert_index?: IntFilter<"pool_update"> | number
    vrf_key_hash?: BytesFilter<"pool_update"> | Uint8Array
    pledge?: DecimalFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFilter<"pool_update"> | bigint | number
    meta_id?: BigIntNullableFilter<"pool_update"> | bigint | number | null
    margin?: FloatFilter<"pool_update"> | number
    fixed_cost?: DecimalFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFilter<"pool_update"> | bigint | number
    reward_addr_id?: BigIntFilter<"pool_update"> | bigint | number
    deposit?: DecimalNullableFilter<"pool_update"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type pool_updateOrderByWithAggregationInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    vrf_key_hash?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrderInput | SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrderInput | SortOrder
    _count?: pool_updateCountOrderByAggregateInput
    _avg?: pool_updateAvgOrderByAggregateInput
    _max?: pool_updateMaxOrderByAggregateInput
    _min?: pool_updateMinOrderByAggregateInput
    _sum?: pool_updateSumOrderByAggregateInput
  }

  export type pool_updateScalarWhereWithAggregatesInput = {
    AND?: pool_updateScalarWhereWithAggregatesInput | pool_updateScalarWhereWithAggregatesInput[]
    OR?: pool_updateScalarWhereWithAggregatesInput[]
    NOT?: pool_updateScalarWhereWithAggregatesInput | pool_updateScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pool_update"> | bigint | number
    hash_id?: BigIntWithAggregatesFilter<"pool_update"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"pool_update"> | number
    vrf_key_hash?: BytesWithAggregatesFilter<"pool_update"> | Uint8Array
    pledge?: DecimalWithAggregatesFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntWithAggregatesFilter<"pool_update"> | bigint | number
    meta_id?: BigIntNullableWithAggregatesFilter<"pool_update"> | bigint | number | null
    margin?: FloatWithAggregatesFilter<"pool_update"> | number
    fixed_cost?: DecimalWithAggregatesFilter<"pool_update"> | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntWithAggregatesFilter<"pool_update"> | bigint | number
    reward_addr_id?: BigIntWithAggregatesFilter<"pool_update"> | bigint | number
    deposit?: DecimalNullableWithAggregatesFilter<"pool_update"> | Decimal | DecimalJsLike | number | string | null
  }

  export type pot_transferWhereInput = {
    AND?: pot_transferWhereInput | pot_transferWhereInput[]
    OR?: pot_transferWhereInput[]
    NOT?: pot_transferWhereInput | pot_transferWhereInput[]
    id?: BigIntFilter<"pot_transfer"> | bigint | number
    cert_index?: IntFilter<"pot_transfer"> | number
    treasury?: DecimalFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"pot_transfer"> | bigint | number
  }

  export type pot_transferOrderByWithRelationInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type pot_transferWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: pot_transferWhereInput | pot_transferWhereInput[]
    OR?: pot_transferWhereInput[]
    NOT?: pot_transferWhereInput | pot_transferWhereInput[]
    cert_index?: IntFilter<"pot_transfer"> | number
    treasury?: DecimalFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"pot_transfer"> | bigint | number
  }, "id">

  export type pot_transferOrderByWithAggregationInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
    _count?: pot_transferCountOrderByAggregateInput
    _avg?: pot_transferAvgOrderByAggregateInput
    _max?: pot_transferMaxOrderByAggregateInput
    _min?: pot_transferMinOrderByAggregateInput
    _sum?: pot_transferSumOrderByAggregateInput
  }

  export type pot_transferScalarWhereWithAggregatesInput = {
    AND?: pot_transferScalarWhereWithAggregatesInput | pot_transferScalarWhereWithAggregatesInput[]
    OR?: pot_transferScalarWhereWithAggregatesInput[]
    NOT?: pot_transferScalarWhereWithAggregatesInput | pot_transferScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"pot_transfer"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"pot_transfer"> | number
    treasury?: DecimalWithAggregatesFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    reserves?: DecimalWithAggregatesFilter<"pot_transfer"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntWithAggregatesFilter<"pot_transfer"> | bigint | number
  }

  export type redeemerWhereInput = {
    AND?: redeemerWhereInput | redeemerWhereInput[]
    OR?: redeemerWhereInput[]
    NOT?: redeemerWhereInput | redeemerWhereInput[]
    id?: BigIntFilter<"redeemer"> | bigint | number
    tx_id?: BigIntFilter<"redeemer"> | bigint | number
    unit_mem?: BigIntFilter<"redeemer"> | bigint | number
    unit_steps?: BigIntFilter<"redeemer"> | bigint | number
    fee?: DecimalNullableFilter<"redeemer"> | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFilter<"redeemer"> | $Enums.scriptpurposetype
    index?: IntFilter<"redeemer"> | number
    script_hash?: BytesNullableFilter<"redeemer"> | Uint8Array | null
    redeemer_data_id?: BigIntFilter<"redeemer"> | bigint | number
  }

  export type redeemerOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrderInput | SortOrder
    purpose?: SortOrder
    index?: SortOrder
    script_hash?: SortOrderInput | SortOrder
    redeemer_data_id?: SortOrder
  }

  export type redeemerWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: redeemerWhereInput | redeemerWhereInput[]
    OR?: redeemerWhereInput[]
    NOT?: redeemerWhereInput | redeemerWhereInput[]
    tx_id?: BigIntFilter<"redeemer"> | bigint | number
    unit_mem?: BigIntFilter<"redeemer"> | bigint | number
    unit_steps?: BigIntFilter<"redeemer"> | bigint | number
    fee?: DecimalNullableFilter<"redeemer"> | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFilter<"redeemer"> | $Enums.scriptpurposetype
    index?: IntFilter<"redeemer"> | number
    script_hash?: BytesNullableFilter<"redeemer"> | Uint8Array | null
    redeemer_data_id?: BigIntFilter<"redeemer"> | bigint | number
  }, "id">

  export type redeemerOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrderInput | SortOrder
    purpose?: SortOrder
    index?: SortOrder
    script_hash?: SortOrderInput | SortOrder
    redeemer_data_id?: SortOrder
    _count?: redeemerCountOrderByAggregateInput
    _avg?: redeemerAvgOrderByAggregateInput
    _max?: redeemerMaxOrderByAggregateInput
    _min?: redeemerMinOrderByAggregateInput
    _sum?: redeemerSumOrderByAggregateInput
  }

  export type redeemerScalarWhereWithAggregatesInput = {
    AND?: redeemerScalarWhereWithAggregatesInput | redeemerScalarWhereWithAggregatesInput[]
    OR?: redeemerScalarWhereWithAggregatesInput[]
    NOT?: redeemerScalarWhereWithAggregatesInput | redeemerScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"redeemer"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"redeemer"> | bigint | number
    unit_mem?: BigIntWithAggregatesFilter<"redeemer"> | bigint | number
    unit_steps?: BigIntWithAggregatesFilter<"redeemer"> | bigint | number
    fee?: DecimalNullableWithAggregatesFilter<"redeemer"> | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeWithAggregatesFilter<"redeemer"> | $Enums.scriptpurposetype
    index?: IntWithAggregatesFilter<"redeemer"> | number
    script_hash?: BytesNullableWithAggregatesFilter<"redeemer"> | Uint8Array | null
    redeemer_data_id?: BigIntWithAggregatesFilter<"redeemer"> | bigint | number
  }

  export type redeemer_dataWhereInput = {
    AND?: redeemer_dataWhereInput | redeemer_dataWhereInput[]
    OR?: redeemer_dataWhereInput[]
    NOT?: redeemer_dataWhereInput | redeemer_dataWhereInput[]
    id?: BigIntFilter<"redeemer_data"> | bigint | number
    hash?: BytesFilter<"redeemer_data"> | Uint8Array
    tx_id?: BigIntFilter<"redeemer_data"> | bigint | number
    value?: JsonNullableFilter<"redeemer_data">
    bytes?: BytesFilter<"redeemer_data"> | Uint8Array
  }

  export type redeemer_dataOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrderInput | SortOrder
    bytes?: SortOrder
  }

  export type redeemer_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: redeemer_dataWhereInput | redeemer_dataWhereInput[]
    OR?: redeemer_dataWhereInput[]
    NOT?: redeemer_dataWhereInput | redeemer_dataWhereInput[]
    tx_id?: BigIntFilter<"redeemer_data"> | bigint | number
    value?: JsonNullableFilter<"redeemer_data">
    bytes?: BytesFilter<"redeemer_data"> | Uint8Array
  }, "id" | "hash">

  export type redeemer_dataOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrderInput | SortOrder
    bytes?: SortOrder
    _count?: redeemer_dataCountOrderByAggregateInput
    _avg?: redeemer_dataAvgOrderByAggregateInput
    _max?: redeemer_dataMaxOrderByAggregateInput
    _min?: redeemer_dataMinOrderByAggregateInput
    _sum?: redeemer_dataSumOrderByAggregateInput
  }

  export type redeemer_dataScalarWhereWithAggregatesInput = {
    AND?: redeemer_dataScalarWhereWithAggregatesInput | redeemer_dataScalarWhereWithAggregatesInput[]
    OR?: redeemer_dataScalarWhereWithAggregatesInput[]
    NOT?: redeemer_dataScalarWhereWithAggregatesInput | redeemer_dataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"redeemer_data"> | bigint | number
    hash?: BytesWithAggregatesFilter<"redeemer_data"> | Uint8Array
    tx_id?: BigIntWithAggregatesFilter<"redeemer_data"> | bigint | number
    value?: JsonNullableWithAggregatesFilter<"redeemer_data">
    bytes?: BytesWithAggregatesFilter<"redeemer_data"> | Uint8Array
  }

  export type reference_tx_inWhereInput = {
    AND?: reference_tx_inWhereInput | reference_tx_inWhereInput[]
    OR?: reference_tx_inWhereInput[]
    NOT?: reference_tx_inWhereInput | reference_tx_inWhereInput[]
    id?: BigIntFilter<"reference_tx_in"> | bigint | number
    tx_in_id?: BigIntFilter<"reference_tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"reference_tx_in"> | bigint | number
    tx_out_index?: IntFilter<"reference_tx_in"> | number
  }

  export type reference_tx_inOrderByWithRelationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reference_tx_inWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: reference_tx_inWhereInput | reference_tx_inWhereInput[]
    OR?: reference_tx_inWhereInput[]
    NOT?: reference_tx_inWhereInput | reference_tx_inWhereInput[]
    tx_in_id?: BigIntFilter<"reference_tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"reference_tx_in"> | bigint | number
    tx_out_index?: IntFilter<"reference_tx_in"> | number
  }, "id">

  export type reference_tx_inOrderByWithAggregationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    _count?: reference_tx_inCountOrderByAggregateInput
    _avg?: reference_tx_inAvgOrderByAggregateInput
    _max?: reference_tx_inMaxOrderByAggregateInput
    _min?: reference_tx_inMinOrderByAggregateInput
    _sum?: reference_tx_inSumOrderByAggregateInput
  }

  export type reference_tx_inScalarWhereWithAggregatesInput = {
    AND?: reference_tx_inScalarWhereWithAggregatesInput | reference_tx_inScalarWhereWithAggregatesInput[]
    OR?: reference_tx_inScalarWhereWithAggregatesInput[]
    NOT?: reference_tx_inScalarWhereWithAggregatesInput | reference_tx_inScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"reference_tx_in"> | bigint | number
    tx_in_id?: BigIntWithAggregatesFilter<"reference_tx_in"> | bigint | number
    tx_out_id?: BigIntWithAggregatesFilter<"reference_tx_in"> | bigint | number
    tx_out_index?: IntWithAggregatesFilter<"reference_tx_in"> | number
  }

  export type reserveWhereInput = {
    AND?: reserveWhereInput | reserveWhereInput[]
    OR?: reserveWhereInput[]
    NOT?: reserveWhereInput | reserveWhereInput[]
    id?: BigIntFilter<"reserve"> | bigint | number
    addr_id?: BigIntFilter<"reserve"> | bigint | number
    cert_index?: IntFilter<"reserve"> | number
    amount?: DecimalFilter<"reserve"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"reserve"> | bigint | number
  }

  export type reserveOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserveWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: reserveWhereInput | reserveWhereInput[]
    OR?: reserveWhereInput[]
    NOT?: reserveWhereInput | reserveWhereInput[]
    addr_id?: BigIntFilter<"reserve"> | bigint | number
    cert_index?: IntFilter<"reserve"> | number
    amount?: DecimalFilter<"reserve"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"reserve"> | bigint | number
  }, "id">

  export type reserveOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
    _count?: reserveCountOrderByAggregateInput
    _avg?: reserveAvgOrderByAggregateInput
    _max?: reserveMaxOrderByAggregateInput
    _min?: reserveMinOrderByAggregateInput
    _sum?: reserveSumOrderByAggregateInput
  }

  export type reserveScalarWhereWithAggregatesInput = {
    AND?: reserveScalarWhereWithAggregatesInput | reserveScalarWhereWithAggregatesInput[]
    OR?: reserveScalarWhereWithAggregatesInput[]
    NOT?: reserveScalarWhereWithAggregatesInput | reserveScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"reserve"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"reserve"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"reserve"> | number
    amount?: DecimalWithAggregatesFilter<"reserve"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntWithAggregatesFilter<"reserve"> | bigint | number
  }

  export type reserved_pool_tickerWhereInput = {
    AND?: reserved_pool_tickerWhereInput | reserved_pool_tickerWhereInput[]
    OR?: reserved_pool_tickerWhereInput[]
    NOT?: reserved_pool_tickerWhereInput | reserved_pool_tickerWhereInput[]
    id?: BigIntFilter<"reserved_pool_ticker"> | bigint | number
    name?: StringFilter<"reserved_pool_ticker"> | string
    pool_hash?: BytesFilter<"reserved_pool_ticker"> | Uint8Array
  }

  export type reserved_pool_tickerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pool_hash?: SortOrder
  }

  export type reserved_pool_tickerWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: reserved_pool_tickerWhereInput | reserved_pool_tickerWhereInput[]
    OR?: reserved_pool_tickerWhereInput[]
    NOT?: reserved_pool_tickerWhereInput | reserved_pool_tickerWhereInput[]
    pool_hash?: BytesFilter<"reserved_pool_ticker"> | Uint8Array
  }, "id" | "name">

  export type reserved_pool_tickerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pool_hash?: SortOrder
    _count?: reserved_pool_tickerCountOrderByAggregateInput
    _avg?: reserved_pool_tickerAvgOrderByAggregateInput
    _max?: reserved_pool_tickerMaxOrderByAggregateInput
    _min?: reserved_pool_tickerMinOrderByAggregateInput
    _sum?: reserved_pool_tickerSumOrderByAggregateInput
  }

  export type reserved_pool_tickerScalarWhereWithAggregatesInput = {
    AND?: reserved_pool_tickerScalarWhereWithAggregatesInput | reserved_pool_tickerScalarWhereWithAggregatesInput[]
    OR?: reserved_pool_tickerScalarWhereWithAggregatesInput[]
    NOT?: reserved_pool_tickerScalarWhereWithAggregatesInput | reserved_pool_tickerScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"reserved_pool_ticker"> | bigint | number
    name?: StringWithAggregatesFilter<"reserved_pool_ticker"> | string
    pool_hash?: BytesWithAggregatesFilter<"reserved_pool_ticker"> | Uint8Array
  }

  export type reverse_indexWhereInput = {
    AND?: reverse_indexWhereInput | reverse_indexWhereInput[]
    OR?: reverse_indexWhereInput[]
    NOT?: reverse_indexWhereInput | reverse_indexWhereInput[]
    id?: BigIntFilter<"reverse_index"> | bigint | number
    block_id?: BigIntFilter<"reverse_index"> | bigint | number
    min_ids?: StringFilter<"reverse_index"> | string
  }

  export type reverse_indexOrderByWithRelationInput = {
    id?: SortOrder
    block_id?: SortOrder
    min_ids?: SortOrder
  }

  export type reverse_indexWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: reverse_indexWhereInput | reverse_indexWhereInput[]
    OR?: reverse_indexWhereInput[]
    NOT?: reverse_indexWhereInput | reverse_indexWhereInput[]
    block_id?: BigIntFilter<"reverse_index"> | bigint | number
    min_ids?: StringFilter<"reverse_index"> | string
  }, "id">

  export type reverse_indexOrderByWithAggregationInput = {
    id?: SortOrder
    block_id?: SortOrder
    min_ids?: SortOrder
    _count?: reverse_indexCountOrderByAggregateInput
    _avg?: reverse_indexAvgOrderByAggregateInput
    _max?: reverse_indexMaxOrderByAggregateInput
    _min?: reverse_indexMinOrderByAggregateInput
    _sum?: reverse_indexSumOrderByAggregateInput
  }

  export type reverse_indexScalarWhereWithAggregatesInput = {
    AND?: reverse_indexScalarWhereWithAggregatesInput | reverse_indexScalarWhereWithAggregatesInput[]
    OR?: reverse_indexScalarWhereWithAggregatesInput[]
    NOT?: reverse_indexScalarWhereWithAggregatesInput | reverse_indexScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"reverse_index"> | bigint | number
    block_id?: BigIntWithAggregatesFilter<"reverse_index"> | bigint | number
    min_ids?: StringWithAggregatesFilter<"reverse_index"> | string
  }

  export type rewardWhereInput = {
    AND?: rewardWhereInput | rewardWhereInput[]
    OR?: rewardWhereInput[]
    NOT?: rewardWhereInput | rewardWhereInput[]
    addr_id?: BigIntFilter<"reward"> | bigint | number
    type?: EnumrewardtypeFilter<"reward"> | $Enums.rewardtype
    amount?: DecimalFilter<"reward"> | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFilter<"reward"> | bigint | number
    pool_id?: BigIntFilter<"reward"> | bigint | number
    earned_epoch?: BigIntFilter<"reward"> | bigint | number
  }

  export type rewardOrderByWithRelationInput = {
    addr_id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type rewardWhereUniqueInput = Prisma.AtLeast<{
    addr_id_type_earned_epoch_pool_id?: rewardAddr_idTypeEarned_epochPool_idCompoundUniqueInput
    AND?: rewardWhereInput | rewardWhereInput[]
    OR?: rewardWhereInput[]
    NOT?: rewardWhereInput | rewardWhereInput[]
    addr_id?: BigIntFilter<"reward"> | bigint | number
    type?: EnumrewardtypeFilter<"reward"> | $Enums.rewardtype
    amount?: DecimalFilter<"reward"> | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFilter<"reward"> | bigint | number
    pool_id?: BigIntFilter<"reward"> | bigint | number
    earned_epoch?: BigIntFilter<"reward"> | bigint | number
  }, "addr_id_type_earned_epoch_pool_id">

  export type rewardOrderByWithAggregationInput = {
    addr_id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
    _count?: rewardCountOrderByAggregateInput
    _avg?: rewardAvgOrderByAggregateInput
    _max?: rewardMaxOrderByAggregateInput
    _min?: rewardMinOrderByAggregateInput
    _sum?: rewardSumOrderByAggregateInput
  }

  export type rewardScalarWhereWithAggregatesInput = {
    AND?: rewardScalarWhereWithAggregatesInput | rewardScalarWhereWithAggregatesInput[]
    OR?: rewardScalarWhereWithAggregatesInput[]
    NOT?: rewardScalarWhereWithAggregatesInput | rewardScalarWhereWithAggregatesInput[]
    addr_id?: BigIntWithAggregatesFilter<"reward"> | bigint | number
    type?: EnumrewardtypeWithAggregatesFilter<"reward"> | $Enums.rewardtype
    amount?: DecimalWithAggregatesFilter<"reward"> | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntWithAggregatesFilter<"reward"> | bigint | number
    pool_id?: BigIntWithAggregatesFilter<"reward"> | bigint | number
    earned_epoch?: BigIntWithAggregatesFilter<"reward"> | bigint | number
  }

  export type schema_versionWhereInput = {
    AND?: schema_versionWhereInput | schema_versionWhereInput[]
    OR?: schema_versionWhereInput[]
    NOT?: schema_versionWhereInput | schema_versionWhereInput[]
    id?: BigIntFilter<"schema_version"> | bigint | number
    stage_one?: BigIntFilter<"schema_version"> | bigint | number
    stage_two?: BigIntFilter<"schema_version"> | bigint | number
    stage_three?: BigIntFilter<"schema_version"> | bigint | number
  }

  export type schema_versionOrderByWithRelationInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type schema_versionWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: schema_versionWhereInput | schema_versionWhereInput[]
    OR?: schema_versionWhereInput[]
    NOT?: schema_versionWhereInput | schema_versionWhereInput[]
    stage_one?: BigIntFilter<"schema_version"> | bigint | number
    stage_two?: BigIntFilter<"schema_version"> | bigint | number
    stage_three?: BigIntFilter<"schema_version"> | bigint | number
  }, "id">

  export type schema_versionOrderByWithAggregationInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
    _count?: schema_versionCountOrderByAggregateInput
    _avg?: schema_versionAvgOrderByAggregateInput
    _max?: schema_versionMaxOrderByAggregateInput
    _min?: schema_versionMinOrderByAggregateInput
    _sum?: schema_versionSumOrderByAggregateInput
  }

  export type schema_versionScalarWhereWithAggregatesInput = {
    AND?: schema_versionScalarWhereWithAggregatesInput | schema_versionScalarWhereWithAggregatesInput[]
    OR?: schema_versionScalarWhereWithAggregatesInput[]
    NOT?: schema_versionScalarWhereWithAggregatesInput | schema_versionScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"schema_version"> | bigint | number
    stage_one?: BigIntWithAggregatesFilter<"schema_version"> | bigint | number
    stage_two?: BigIntWithAggregatesFilter<"schema_version"> | bigint | number
    stage_three?: BigIntWithAggregatesFilter<"schema_version"> | bigint | number
  }

  export type scriptWhereInput = {
    AND?: scriptWhereInput | scriptWhereInput[]
    OR?: scriptWhereInput[]
    NOT?: scriptWhereInput | scriptWhereInput[]
    id?: BigIntFilter<"script"> | bigint | number
    tx_id?: BigIntFilter<"script"> | bigint | number
    hash?: BytesFilter<"script"> | Uint8Array
    type?: EnumscripttypeFilter<"script"> | $Enums.scripttype
    json?: JsonNullableFilter<"script">
    bytes?: BytesNullableFilter<"script"> | Uint8Array | null
    serialised_size?: IntNullableFilter<"script"> | number | null
  }

  export type scriptOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    hash?: SortOrder
    type?: SortOrder
    json?: SortOrderInput | SortOrder
    bytes?: SortOrderInput | SortOrder
    serialised_size?: SortOrderInput | SortOrder
  }

  export type scriptWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: scriptWhereInput | scriptWhereInput[]
    OR?: scriptWhereInput[]
    NOT?: scriptWhereInput | scriptWhereInput[]
    tx_id?: BigIntFilter<"script"> | bigint | number
    type?: EnumscripttypeFilter<"script"> | $Enums.scripttype
    json?: JsonNullableFilter<"script">
    bytes?: BytesNullableFilter<"script"> | Uint8Array | null
    serialised_size?: IntNullableFilter<"script"> | number | null
  }, "id" | "hash">

  export type scriptOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    hash?: SortOrder
    type?: SortOrder
    json?: SortOrderInput | SortOrder
    bytes?: SortOrderInput | SortOrder
    serialised_size?: SortOrderInput | SortOrder
    _count?: scriptCountOrderByAggregateInput
    _avg?: scriptAvgOrderByAggregateInput
    _max?: scriptMaxOrderByAggregateInput
    _min?: scriptMinOrderByAggregateInput
    _sum?: scriptSumOrderByAggregateInput
  }

  export type scriptScalarWhereWithAggregatesInput = {
    AND?: scriptScalarWhereWithAggregatesInput | scriptScalarWhereWithAggregatesInput[]
    OR?: scriptScalarWhereWithAggregatesInput[]
    NOT?: scriptScalarWhereWithAggregatesInput | scriptScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"script"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"script"> | bigint | number
    hash?: BytesWithAggregatesFilter<"script"> | Uint8Array
    type?: EnumscripttypeWithAggregatesFilter<"script"> | $Enums.scripttype
    json?: JsonNullableWithAggregatesFilter<"script">
    bytes?: BytesNullableWithAggregatesFilter<"script"> | Uint8Array | null
    serialised_size?: IntNullableWithAggregatesFilter<"script"> | number | null
  }

  export type slot_leaderWhereInput = {
    AND?: slot_leaderWhereInput | slot_leaderWhereInput[]
    OR?: slot_leaderWhereInput[]
    NOT?: slot_leaderWhereInput | slot_leaderWhereInput[]
    id?: BigIntFilter<"slot_leader"> | bigint | number
    hash?: BytesFilter<"slot_leader"> | Uint8Array
    pool_hash_id?: BigIntNullableFilter<"slot_leader"> | bigint | number | null
    description?: StringFilter<"slot_leader"> | string
  }

  export type slot_leaderOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    pool_hash_id?: SortOrderInput | SortOrder
    description?: SortOrder
  }

  export type slot_leaderWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: slot_leaderWhereInput | slot_leaderWhereInput[]
    OR?: slot_leaderWhereInput[]
    NOT?: slot_leaderWhereInput | slot_leaderWhereInput[]
    pool_hash_id?: BigIntNullableFilter<"slot_leader"> | bigint | number | null
    description?: StringFilter<"slot_leader"> | string
  }, "id" | "hash">

  export type slot_leaderOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    pool_hash_id?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: slot_leaderCountOrderByAggregateInput
    _avg?: slot_leaderAvgOrderByAggregateInput
    _max?: slot_leaderMaxOrderByAggregateInput
    _min?: slot_leaderMinOrderByAggregateInput
    _sum?: slot_leaderSumOrderByAggregateInput
  }

  export type slot_leaderScalarWhereWithAggregatesInput = {
    AND?: slot_leaderScalarWhereWithAggregatesInput | slot_leaderScalarWhereWithAggregatesInput[]
    OR?: slot_leaderScalarWhereWithAggregatesInput[]
    NOT?: slot_leaderScalarWhereWithAggregatesInput | slot_leaderScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"slot_leader"> | bigint | number
    hash?: BytesWithAggregatesFilter<"slot_leader"> | Uint8Array
    pool_hash_id?: BigIntNullableWithAggregatesFilter<"slot_leader"> | bigint | number | null
    description?: StringWithAggregatesFilter<"slot_leader"> | string
  }

  export type stake_addressWhereInput = {
    AND?: stake_addressWhereInput | stake_addressWhereInput[]
    OR?: stake_addressWhereInput[]
    NOT?: stake_addressWhereInput | stake_addressWhereInput[]
    id?: BigIntFilter<"stake_address"> | bigint | number
    hash_raw?: BytesFilter<"stake_address"> | Uint8Array
    view?: StringFilter<"stake_address"> | string
    script_hash?: BytesNullableFilter<"stake_address"> | Uint8Array | null
  }

  export type stake_addressOrderByWithRelationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    script_hash?: SortOrderInput | SortOrder
  }

  export type stake_addressWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash_raw?: Uint8Array
    AND?: stake_addressWhereInput | stake_addressWhereInput[]
    OR?: stake_addressWhereInput[]
    NOT?: stake_addressWhereInput | stake_addressWhereInput[]
    view?: StringFilter<"stake_address"> | string
    script_hash?: BytesNullableFilter<"stake_address"> | Uint8Array | null
  }, "id" | "hash_raw">

  export type stake_addressOrderByWithAggregationInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    script_hash?: SortOrderInput | SortOrder
    _count?: stake_addressCountOrderByAggregateInput
    _avg?: stake_addressAvgOrderByAggregateInput
    _max?: stake_addressMaxOrderByAggregateInput
    _min?: stake_addressMinOrderByAggregateInput
    _sum?: stake_addressSumOrderByAggregateInput
  }

  export type stake_addressScalarWhereWithAggregatesInput = {
    AND?: stake_addressScalarWhereWithAggregatesInput | stake_addressScalarWhereWithAggregatesInput[]
    OR?: stake_addressScalarWhereWithAggregatesInput[]
    NOT?: stake_addressScalarWhereWithAggregatesInput | stake_addressScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"stake_address"> | bigint | number
    hash_raw?: BytesWithAggregatesFilter<"stake_address"> | Uint8Array
    view?: StringWithAggregatesFilter<"stake_address"> | string
    script_hash?: BytesNullableWithAggregatesFilter<"stake_address"> | Uint8Array | null
  }

  export type stake_deregistrationWhereInput = {
    AND?: stake_deregistrationWhereInput | stake_deregistrationWhereInput[]
    OR?: stake_deregistrationWhereInput[]
    NOT?: stake_deregistrationWhereInput | stake_deregistrationWhereInput[]
    id?: BigIntFilter<"stake_deregistration"> | bigint | number
    addr_id?: BigIntFilter<"stake_deregistration"> | bigint | number
    cert_index?: IntFilter<"stake_deregistration"> | number
    epoch_no?: IntFilter<"stake_deregistration"> | number
    tx_id?: BigIntFilter<"stake_deregistration"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"stake_deregistration"> | bigint | number | null
  }

  export type stake_deregistrationOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
  }

  export type stake_deregistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: stake_deregistrationWhereInput | stake_deregistrationWhereInput[]
    OR?: stake_deregistrationWhereInput[]
    NOT?: stake_deregistrationWhereInput | stake_deregistrationWhereInput[]
    addr_id?: BigIntFilter<"stake_deregistration"> | bigint | number
    cert_index?: IntFilter<"stake_deregistration"> | number
    epoch_no?: IntFilter<"stake_deregistration"> | number
    tx_id?: BigIntFilter<"stake_deregistration"> | bigint | number
    redeemer_id?: BigIntNullableFilter<"stake_deregistration"> | bigint | number | null
  }, "id">

  export type stake_deregistrationOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    _count?: stake_deregistrationCountOrderByAggregateInput
    _avg?: stake_deregistrationAvgOrderByAggregateInput
    _max?: stake_deregistrationMaxOrderByAggregateInput
    _min?: stake_deregistrationMinOrderByAggregateInput
    _sum?: stake_deregistrationSumOrderByAggregateInput
  }

  export type stake_deregistrationScalarWhereWithAggregatesInput = {
    AND?: stake_deregistrationScalarWhereWithAggregatesInput | stake_deregistrationScalarWhereWithAggregatesInput[]
    OR?: stake_deregistrationScalarWhereWithAggregatesInput[]
    NOT?: stake_deregistrationScalarWhereWithAggregatesInput | stake_deregistrationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"stake_deregistration"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"stake_deregistration"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"stake_deregistration"> | number
    epoch_no?: IntWithAggregatesFilter<"stake_deregistration"> | number
    tx_id?: BigIntWithAggregatesFilter<"stake_deregistration"> | bigint | number
    redeemer_id?: BigIntNullableWithAggregatesFilter<"stake_deregistration"> | bigint | number | null
  }

  export type stake_registrationWhereInput = {
    AND?: stake_registrationWhereInput | stake_registrationWhereInput[]
    OR?: stake_registrationWhereInput[]
    NOT?: stake_registrationWhereInput | stake_registrationWhereInput[]
    id?: BigIntFilter<"stake_registration"> | bigint | number
    addr_id?: BigIntFilter<"stake_registration"> | bigint | number
    cert_index?: IntFilter<"stake_registration"> | number
    epoch_no?: IntFilter<"stake_registration"> | number
    tx_id?: BigIntFilter<"stake_registration"> | bigint | number
    deposit?: DecimalNullableFilter<"stake_registration"> | Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrderInput | SortOrder
  }

  export type stake_registrationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: stake_registrationWhereInput | stake_registrationWhereInput[]
    OR?: stake_registrationWhereInput[]
    NOT?: stake_registrationWhereInput | stake_registrationWhereInput[]
    addr_id?: BigIntFilter<"stake_registration"> | bigint | number
    cert_index?: IntFilter<"stake_registration"> | number
    epoch_no?: IntFilter<"stake_registration"> | number
    tx_id?: BigIntFilter<"stake_registration"> | bigint | number
    deposit?: DecimalNullableFilter<"stake_registration"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type stake_registrationOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrderInput | SortOrder
    _count?: stake_registrationCountOrderByAggregateInput
    _avg?: stake_registrationAvgOrderByAggregateInput
    _max?: stake_registrationMaxOrderByAggregateInput
    _min?: stake_registrationMinOrderByAggregateInput
    _sum?: stake_registrationSumOrderByAggregateInput
  }

  export type stake_registrationScalarWhereWithAggregatesInput = {
    AND?: stake_registrationScalarWhereWithAggregatesInput | stake_registrationScalarWhereWithAggregatesInput[]
    OR?: stake_registrationScalarWhereWithAggregatesInput[]
    NOT?: stake_registrationScalarWhereWithAggregatesInput | stake_registrationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"stake_registration"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"stake_registration"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"stake_registration"> | number
    epoch_no?: IntWithAggregatesFilter<"stake_registration"> | number
    tx_id?: BigIntWithAggregatesFilter<"stake_registration"> | bigint | number
    deposit?: DecimalNullableWithAggregatesFilter<"stake_registration"> | Decimal | DecimalJsLike | number | string | null
  }

  export type treasuryWhereInput = {
    AND?: treasuryWhereInput | treasuryWhereInput[]
    OR?: treasuryWhereInput[]
    NOT?: treasuryWhereInput | treasuryWhereInput[]
    id?: BigIntFilter<"treasury"> | bigint | number
    addr_id?: BigIntFilter<"treasury"> | bigint | number
    cert_index?: IntFilter<"treasury"> | number
    amount?: DecimalFilter<"treasury"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"treasury"> | bigint | number
  }

  export type treasuryOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasuryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: treasuryWhereInput | treasuryWhereInput[]
    OR?: treasuryWhereInput[]
    NOT?: treasuryWhereInput | treasuryWhereInput[]
    addr_id?: BigIntFilter<"treasury"> | bigint | number
    cert_index?: IntFilter<"treasury"> | number
    amount?: DecimalFilter<"treasury"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFilter<"treasury"> | bigint | number
  }, "id">

  export type treasuryOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
    _count?: treasuryCountOrderByAggregateInput
    _avg?: treasuryAvgOrderByAggregateInput
    _max?: treasuryMaxOrderByAggregateInput
    _min?: treasuryMinOrderByAggregateInput
    _sum?: treasurySumOrderByAggregateInput
  }

  export type treasuryScalarWhereWithAggregatesInput = {
    AND?: treasuryScalarWhereWithAggregatesInput | treasuryScalarWhereWithAggregatesInput[]
    OR?: treasuryScalarWhereWithAggregatesInput[]
    NOT?: treasuryScalarWhereWithAggregatesInput | treasuryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"treasury"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"treasury"> | bigint | number
    cert_index?: IntWithAggregatesFilter<"treasury"> | number
    amount?: DecimalWithAggregatesFilter<"treasury"> | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntWithAggregatesFilter<"treasury"> | bigint | number
  }

  export type treasury_withdrawalWhereInput = {
    AND?: treasury_withdrawalWhereInput | treasury_withdrawalWhereInput[]
    OR?: treasury_withdrawalWhereInput[]
    NOT?: treasury_withdrawalWhereInput | treasury_withdrawalWhereInput[]
    id?: BigIntFilter<"treasury_withdrawal"> | bigint | number
    gov_action_proposal_id?: BigIntFilter<"treasury_withdrawal"> | bigint | number
    stake_address_id?: BigIntFilter<"treasury_withdrawal"> | bigint | number
    amount?: DecimalFilter<"treasury_withdrawal"> | Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalOrderByWithRelationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type treasury_withdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: treasury_withdrawalWhereInput | treasury_withdrawalWhereInput[]
    OR?: treasury_withdrawalWhereInput[]
    NOT?: treasury_withdrawalWhereInput | treasury_withdrawalWhereInput[]
    gov_action_proposal_id?: BigIntFilter<"treasury_withdrawal"> | bigint | number
    stake_address_id?: BigIntFilter<"treasury_withdrawal"> | bigint | number
    amount?: DecimalFilter<"treasury_withdrawal"> | Decimal | DecimalJsLike | number | string
  }, "id">

  export type treasury_withdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
    _count?: treasury_withdrawalCountOrderByAggregateInput
    _avg?: treasury_withdrawalAvgOrderByAggregateInput
    _max?: treasury_withdrawalMaxOrderByAggregateInput
    _min?: treasury_withdrawalMinOrderByAggregateInput
    _sum?: treasury_withdrawalSumOrderByAggregateInput
  }

  export type treasury_withdrawalScalarWhereWithAggregatesInput = {
    AND?: treasury_withdrawalScalarWhereWithAggregatesInput | treasury_withdrawalScalarWhereWithAggregatesInput[]
    OR?: treasury_withdrawalScalarWhereWithAggregatesInput[]
    NOT?: treasury_withdrawalScalarWhereWithAggregatesInput | treasury_withdrawalScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"treasury_withdrawal"> | bigint | number
    gov_action_proposal_id?: BigIntWithAggregatesFilter<"treasury_withdrawal"> | bigint | number
    stake_address_id?: BigIntWithAggregatesFilter<"treasury_withdrawal"> | bigint | number
    amount?: DecimalWithAggregatesFilter<"treasury_withdrawal"> | Decimal | DecimalJsLike | number | string
  }

  export type txWhereInput = {
    AND?: txWhereInput | txWhereInput[]
    OR?: txWhereInput[]
    NOT?: txWhereInput | txWhereInput[]
    id?: BigIntFilter<"tx"> | bigint | number
    hash?: BytesFilter<"tx"> | Uint8Array
    block_id?: BigIntFilter<"tx"> | bigint | number
    block_index?: IntFilter<"tx"> | number
    out_sum?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
    deposit?: BigIntNullableFilter<"tx"> | bigint | number | null
    size?: IntFilter<"tx"> | number
    invalid_before?: DecimalNullableFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: DecimalNullableFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFilter<"tx"> | boolean
    script_size?: IntFilter<"tx"> | number
    treasury_donation?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
  }

  export type txOrderByWithRelationInput = {
    id?: SortOrder
    hash?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrderInput | SortOrder
    size?: SortOrder
    invalid_before?: SortOrderInput | SortOrder
    invalid_hereafter?: SortOrderInput | SortOrder
    valid_contract?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type txWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    hash?: Uint8Array
    AND?: txWhereInput | txWhereInput[]
    OR?: txWhereInput[]
    NOT?: txWhereInput | txWhereInput[]
    block_id?: BigIntFilter<"tx"> | bigint | number
    block_index?: IntFilter<"tx"> | number
    out_sum?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
    deposit?: BigIntNullableFilter<"tx"> | bigint | number | null
    size?: IntFilter<"tx"> | number
    invalid_before?: DecimalNullableFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: DecimalNullableFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFilter<"tx"> | boolean
    script_size?: IntFilter<"tx"> | number
    treasury_donation?: DecimalFilter<"tx"> | Decimal | DecimalJsLike | number | string
  }, "id" | "hash">

  export type txOrderByWithAggregationInput = {
    id?: SortOrder
    hash?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrderInput | SortOrder
    size?: SortOrder
    invalid_before?: SortOrderInput | SortOrder
    invalid_hereafter?: SortOrderInput | SortOrder
    valid_contract?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
    _count?: txCountOrderByAggregateInput
    _avg?: txAvgOrderByAggregateInput
    _max?: txMaxOrderByAggregateInput
    _min?: txMinOrderByAggregateInput
    _sum?: txSumOrderByAggregateInput
  }

  export type txScalarWhereWithAggregatesInput = {
    AND?: txScalarWhereWithAggregatesInput | txScalarWhereWithAggregatesInput[]
    OR?: txScalarWhereWithAggregatesInput[]
    NOT?: txScalarWhereWithAggregatesInput | txScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tx"> | bigint | number
    hash?: BytesWithAggregatesFilter<"tx"> | Uint8Array
    block_id?: BigIntWithAggregatesFilter<"tx"> | bigint | number
    block_index?: IntWithAggregatesFilter<"tx"> | number
    out_sum?: DecimalWithAggregatesFilter<"tx"> | Decimal | DecimalJsLike | number | string
    fee?: DecimalWithAggregatesFilter<"tx"> | Decimal | DecimalJsLike | number | string
    deposit?: BigIntNullableWithAggregatesFilter<"tx"> | bigint | number | null
    size?: IntWithAggregatesFilter<"tx"> | number
    invalid_before?: DecimalNullableWithAggregatesFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: DecimalNullableWithAggregatesFilter<"tx"> | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolWithAggregatesFilter<"tx"> | boolean
    script_size?: IntWithAggregatesFilter<"tx"> | number
    treasury_donation?: DecimalWithAggregatesFilter<"tx"> | Decimal | DecimalJsLike | number | string
  }

  export type tx_cborWhereInput = {
    AND?: tx_cborWhereInput | tx_cborWhereInput[]
    OR?: tx_cborWhereInput[]
    NOT?: tx_cborWhereInput | tx_cborWhereInput[]
    id?: BigIntFilter<"tx_cbor"> | bigint | number
    tx_id?: BigIntFilter<"tx_cbor"> | bigint | number
    bytes?: BytesFilter<"tx_cbor"> | Uint8Array
  }

  export type tx_cborOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type tx_cborWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: tx_cborWhereInput | tx_cborWhereInput[]
    OR?: tx_cborWhereInput[]
    NOT?: tx_cborWhereInput | tx_cborWhereInput[]
    tx_id?: BigIntFilter<"tx_cbor"> | bigint | number
    bytes?: BytesFilter<"tx_cbor"> | Uint8Array
  }, "id">

  export type tx_cborOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
    _count?: tx_cborCountOrderByAggregateInput
    _avg?: tx_cborAvgOrderByAggregateInput
    _max?: tx_cborMaxOrderByAggregateInput
    _min?: tx_cborMinOrderByAggregateInput
    _sum?: tx_cborSumOrderByAggregateInput
  }

  export type tx_cborScalarWhereWithAggregatesInput = {
    AND?: tx_cborScalarWhereWithAggregatesInput | tx_cborScalarWhereWithAggregatesInput[]
    OR?: tx_cborScalarWhereWithAggregatesInput[]
    NOT?: tx_cborScalarWhereWithAggregatesInput | tx_cborScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tx_cbor"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"tx_cbor"> | bigint | number
    bytes?: BytesWithAggregatesFilter<"tx_cbor"> | Uint8Array
  }

  export type tx_inWhereInput = {
    AND?: tx_inWhereInput | tx_inWhereInput[]
    OR?: tx_inWhereInput[]
    NOT?: tx_inWhereInput | tx_inWhereInput[]
    id?: BigIntFilter<"tx_in"> | bigint | number
    tx_in_id?: BigIntFilter<"tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"tx_in"> | bigint | number
    tx_out_index?: IntFilter<"tx_in"> | number
    redeemer_id?: BigIntNullableFilter<"tx_in"> | bigint | number | null
  }

  export type tx_inOrderByWithRelationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
  }

  export type tx_inWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: tx_inWhereInput | tx_inWhereInput[]
    OR?: tx_inWhereInput[]
    NOT?: tx_inWhereInput | tx_inWhereInput[]
    tx_in_id?: BigIntFilter<"tx_in"> | bigint | number
    tx_out_id?: BigIntFilter<"tx_in"> | bigint | number
    tx_out_index?: IntFilter<"tx_in"> | number
    redeemer_id?: BigIntNullableFilter<"tx_in"> | bigint | number | null
  }, "id">

  export type tx_inOrderByWithAggregationInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    _count?: tx_inCountOrderByAggregateInput
    _avg?: tx_inAvgOrderByAggregateInput
    _max?: tx_inMaxOrderByAggregateInput
    _min?: tx_inMinOrderByAggregateInput
    _sum?: tx_inSumOrderByAggregateInput
  }

  export type tx_inScalarWhereWithAggregatesInput = {
    AND?: tx_inScalarWhereWithAggregatesInput | tx_inScalarWhereWithAggregatesInput[]
    OR?: tx_inScalarWhereWithAggregatesInput[]
    NOT?: tx_inScalarWhereWithAggregatesInput | tx_inScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tx_in"> | bigint | number
    tx_in_id?: BigIntWithAggregatesFilter<"tx_in"> | bigint | number
    tx_out_id?: BigIntWithAggregatesFilter<"tx_in"> | bigint | number
    tx_out_index?: IntWithAggregatesFilter<"tx_in"> | number
    redeemer_id?: BigIntNullableWithAggregatesFilter<"tx_in"> | bigint | number | null
  }

  export type tx_metadataWhereInput = {
    AND?: tx_metadataWhereInput | tx_metadataWhereInput[]
    OR?: tx_metadataWhereInput[]
    NOT?: tx_metadataWhereInput | tx_metadataWhereInput[]
    id?: BigIntFilter<"tx_metadata"> | bigint | number
    key?: DecimalFilter<"tx_metadata"> | Decimal | DecimalJsLike | number | string
    json?: JsonNullableFilter<"tx_metadata">
    bytes?: BytesFilter<"tx_metadata"> | Uint8Array
    tx_id?: BigIntFilter<"tx_metadata"> | bigint | number
  }

  export type tx_metadataOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    json?: SortOrderInput | SortOrder
    bytes?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_metadataWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: tx_metadataWhereInput | tx_metadataWhereInput[]
    OR?: tx_metadataWhereInput[]
    NOT?: tx_metadataWhereInput | tx_metadataWhereInput[]
    key?: DecimalFilter<"tx_metadata"> | Decimal | DecimalJsLike | number | string
    json?: JsonNullableFilter<"tx_metadata">
    bytes?: BytesFilter<"tx_metadata"> | Uint8Array
    tx_id?: BigIntFilter<"tx_metadata"> | bigint | number
  }, "id">

  export type tx_metadataOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    json?: SortOrderInput | SortOrder
    bytes?: SortOrder
    tx_id?: SortOrder
    _count?: tx_metadataCountOrderByAggregateInput
    _avg?: tx_metadataAvgOrderByAggregateInput
    _max?: tx_metadataMaxOrderByAggregateInput
    _min?: tx_metadataMinOrderByAggregateInput
    _sum?: tx_metadataSumOrderByAggregateInput
  }

  export type tx_metadataScalarWhereWithAggregatesInput = {
    AND?: tx_metadataScalarWhereWithAggregatesInput | tx_metadataScalarWhereWithAggregatesInput[]
    OR?: tx_metadataScalarWhereWithAggregatesInput[]
    NOT?: tx_metadataScalarWhereWithAggregatesInput | tx_metadataScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tx_metadata"> | bigint | number
    key?: DecimalWithAggregatesFilter<"tx_metadata"> | Decimal | DecimalJsLike | number | string
    json?: JsonNullableWithAggregatesFilter<"tx_metadata">
    bytes?: BytesWithAggregatesFilter<"tx_metadata"> | Uint8Array
    tx_id?: BigIntWithAggregatesFilter<"tx_metadata"> | bigint | number
  }

  export type tx_outWhereInput = {
    AND?: tx_outWhereInput | tx_outWhereInput[]
    OR?: tx_outWhereInput[]
    NOT?: tx_outWhereInput | tx_outWhereInput[]
    id?: BigIntFilter<"tx_out"> | bigint | number
    tx_id?: BigIntFilter<"tx_out"> | bigint | number
    index?: IntFilter<"tx_out"> | number
    address?: StringFilter<"tx_out"> | string
    address_has_script?: BoolFilter<"tx_out"> | boolean
    payment_cred?: BytesNullableFilter<"tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    value?: DecimalFilter<"tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableFilter<"tx_out"> | Uint8Array | null
    inline_datum_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    consumed_by_tx_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
  }

  export type tx_outOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrderInput | SortOrder
    stake_address_id?: SortOrderInput | SortOrder
    value?: SortOrder
    data_hash?: SortOrderInput | SortOrder
    inline_datum_id?: SortOrderInput | SortOrder
    reference_script_id?: SortOrderInput | SortOrder
    consumed_by_tx_id?: SortOrderInput | SortOrder
  }

  export type tx_outWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    tx_id_index?: tx_outTx_idIndexCompoundUniqueInput
    AND?: tx_outWhereInput | tx_outWhereInput[]
    OR?: tx_outWhereInput[]
    NOT?: tx_outWhereInput | tx_outWhereInput[]
    tx_id?: BigIntFilter<"tx_out"> | bigint | number
    index?: IntFilter<"tx_out"> | number
    address?: StringFilter<"tx_out"> | string
    address_has_script?: BoolFilter<"tx_out"> | boolean
    payment_cred?: BytesNullableFilter<"tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    value?: DecimalFilter<"tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableFilter<"tx_out"> | Uint8Array | null
    inline_datum_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
    consumed_by_tx_id?: BigIntNullableFilter<"tx_out"> | bigint | number | null
  }, "id" | "tx_id_index">

  export type tx_outOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrderInput | SortOrder
    stake_address_id?: SortOrderInput | SortOrder
    value?: SortOrder
    data_hash?: SortOrderInput | SortOrder
    inline_datum_id?: SortOrderInput | SortOrder
    reference_script_id?: SortOrderInput | SortOrder
    consumed_by_tx_id?: SortOrderInput | SortOrder
    _count?: tx_outCountOrderByAggregateInput
    _avg?: tx_outAvgOrderByAggregateInput
    _max?: tx_outMaxOrderByAggregateInput
    _min?: tx_outMinOrderByAggregateInput
    _sum?: tx_outSumOrderByAggregateInput
  }

  export type tx_outScalarWhereWithAggregatesInput = {
    AND?: tx_outScalarWhereWithAggregatesInput | tx_outScalarWhereWithAggregatesInput[]
    OR?: tx_outScalarWhereWithAggregatesInput[]
    NOT?: tx_outScalarWhereWithAggregatesInput | tx_outScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tx_out"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"tx_out"> | bigint | number
    index?: IntWithAggregatesFilter<"tx_out"> | number
    address?: StringWithAggregatesFilter<"tx_out"> | string
    address_has_script?: BoolWithAggregatesFilter<"tx_out"> | boolean
    payment_cred?: BytesNullableWithAggregatesFilter<"tx_out"> | Uint8Array | null
    stake_address_id?: BigIntNullableWithAggregatesFilter<"tx_out"> | bigint | number | null
    value?: DecimalWithAggregatesFilter<"tx_out"> | Decimal | DecimalJsLike | number | string
    data_hash?: BytesNullableWithAggregatesFilter<"tx_out"> | Uint8Array | null
    inline_datum_id?: BigIntNullableWithAggregatesFilter<"tx_out"> | bigint | number | null
    reference_script_id?: BigIntNullableWithAggregatesFilter<"tx_out"> | bigint | number | null
    consumed_by_tx_id?: BigIntNullableWithAggregatesFilter<"tx_out"> | bigint | number | null
  }

  export type voting_anchorWhereInput = {
    AND?: voting_anchorWhereInput | voting_anchorWhereInput[]
    OR?: voting_anchorWhereInput[]
    NOT?: voting_anchorWhereInput | voting_anchorWhereInput[]
    id?: BigIntFilter<"voting_anchor"> | bigint | number
    url?: StringFilter<"voting_anchor"> | string
    data_hash?: BytesFilter<"voting_anchor"> | Uint8Array
    type?: EnumanchortypeFilter<"voting_anchor"> | $Enums.anchortype
    block_id?: BigIntFilter<"voting_anchor"> | bigint | number
  }

  export type voting_anchorOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    data_hash?: SortOrder
    type?: SortOrder
    block_id?: SortOrder
  }

  export type voting_anchorWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    data_hash_url_type?: voting_anchorData_hashUrlTypeCompoundUniqueInput
    AND?: voting_anchorWhereInput | voting_anchorWhereInput[]
    OR?: voting_anchorWhereInput[]
    NOT?: voting_anchorWhereInput | voting_anchorWhereInput[]
    url?: StringFilter<"voting_anchor"> | string
    data_hash?: BytesFilter<"voting_anchor"> | Uint8Array
    type?: EnumanchortypeFilter<"voting_anchor"> | $Enums.anchortype
    block_id?: BigIntFilter<"voting_anchor"> | bigint | number
  }, "id" | "data_hash_url_type">

  export type voting_anchorOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    data_hash?: SortOrder
    type?: SortOrder
    block_id?: SortOrder
    _count?: voting_anchorCountOrderByAggregateInput
    _avg?: voting_anchorAvgOrderByAggregateInput
    _max?: voting_anchorMaxOrderByAggregateInput
    _min?: voting_anchorMinOrderByAggregateInput
    _sum?: voting_anchorSumOrderByAggregateInput
  }

  export type voting_anchorScalarWhereWithAggregatesInput = {
    AND?: voting_anchorScalarWhereWithAggregatesInput | voting_anchorScalarWhereWithAggregatesInput[]
    OR?: voting_anchorScalarWhereWithAggregatesInput[]
    NOT?: voting_anchorScalarWhereWithAggregatesInput | voting_anchorScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"voting_anchor"> | bigint | number
    url?: StringWithAggregatesFilter<"voting_anchor"> | string
    data_hash?: BytesWithAggregatesFilter<"voting_anchor"> | Uint8Array
    type?: EnumanchortypeWithAggregatesFilter<"voting_anchor"> | $Enums.anchortype
    block_id?: BigIntWithAggregatesFilter<"voting_anchor"> | bigint | number
  }

  export type voting_procedureWhereInput = {
    AND?: voting_procedureWhereInput | voting_procedureWhereInput[]
    OR?: voting_procedureWhereInput[]
    NOT?: voting_procedureWhereInput | voting_procedureWhereInput[]
    id?: BigIntFilter<"voting_procedure"> | bigint | number
    tx_id?: BigIntFilter<"voting_procedure"> | bigint | number
    index?: IntFilter<"voting_procedure"> | number
    gov_action_proposal_id?: BigIntFilter<"voting_procedure"> | bigint | number
    voter_role?: EnumvoterroleFilter<"voting_procedure"> | $Enums.voterrole
    drep_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    pool_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    vote?: EnumvoteFilter<"voting_procedure"> | $Enums.vote
    voting_anchor_id?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    committee_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    invalid?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
  }

  export type voting_procedureOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    voter_role?: SortOrder
    drep_voter?: SortOrderInput | SortOrder
    pool_voter?: SortOrderInput | SortOrder
    vote?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    committee_voter?: SortOrderInput | SortOrder
    invalid?: SortOrderInput | SortOrder
  }

  export type voting_procedureWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: voting_procedureWhereInput | voting_procedureWhereInput[]
    OR?: voting_procedureWhereInput[]
    NOT?: voting_procedureWhereInput | voting_procedureWhereInput[]
    tx_id?: BigIntFilter<"voting_procedure"> | bigint | number
    index?: IntFilter<"voting_procedure"> | number
    gov_action_proposal_id?: BigIntFilter<"voting_procedure"> | bigint | number
    voter_role?: EnumvoterroleFilter<"voting_procedure"> | $Enums.voterrole
    drep_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    pool_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    vote?: EnumvoteFilter<"voting_procedure"> | $Enums.vote
    voting_anchor_id?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    committee_voter?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
    invalid?: BigIntNullableFilter<"voting_procedure"> | bigint | number | null
  }, "id">

  export type voting_procedureOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    voter_role?: SortOrder
    drep_voter?: SortOrderInput | SortOrder
    pool_voter?: SortOrderInput | SortOrder
    vote?: SortOrder
    voting_anchor_id?: SortOrderInput | SortOrder
    committee_voter?: SortOrderInput | SortOrder
    invalid?: SortOrderInput | SortOrder
    _count?: voting_procedureCountOrderByAggregateInput
    _avg?: voting_procedureAvgOrderByAggregateInput
    _max?: voting_procedureMaxOrderByAggregateInput
    _min?: voting_procedureMinOrderByAggregateInput
    _sum?: voting_procedureSumOrderByAggregateInput
  }

  export type voting_procedureScalarWhereWithAggregatesInput = {
    AND?: voting_procedureScalarWhereWithAggregatesInput | voting_procedureScalarWhereWithAggregatesInput[]
    OR?: voting_procedureScalarWhereWithAggregatesInput[]
    NOT?: voting_procedureScalarWhereWithAggregatesInput | voting_procedureScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"voting_procedure"> | bigint | number
    tx_id?: BigIntWithAggregatesFilter<"voting_procedure"> | bigint | number
    index?: IntWithAggregatesFilter<"voting_procedure"> | number
    gov_action_proposal_id?: BigIntWithAggregatesFilter<"voting_procedure"> | bigint | number
    voter_role?: EnumvoterroleWithAggregatesFilter<"voting_procedure"> | $Enums.voterrole
    drep_voter?: BigIntNullableWithAggregatesFilter<"voting_procedure"> | bigint | number | null
    pool_voter?: BigIntNullableWithAggregatesFilter<"voting_procedure"> | bigint | number | null
    vote?: EnumvoteWithAggregatesFilter<"voting_procedure"> | $Enums.vote
    voting_anchor_id?: BigIntNullableWithAggregatesFilter<"voting_procedure"> | bigint | number | null
    committee_voter?: BigIntNullableWithAggregatesFilter<"voting_procedure"> | bigint | number | null
    invalid?: BigIntNullableWithAggregatesFilter<"voting_procedure"> | bigint | number | null
  }

  export type withdrawalWhereInput = {
    AND?: withdrawalWhereInput | withdrawalWhereInput[]
    OR?: withdrawalWhereInput[]
    NOT?: withdrawalWhereInput | withdrawalWhereInput[]
    id?: BigIntFilter<"withdrawal"> | bigint | number
    addr_id?: BigIntFilter<"withdrawal"> | bigint | number
    amount?: DecimalFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    redeemer_id?: BigIntNullableFilter<"withdrawal"> | bigint | number | null
    tx_id?: BigIntFilter<"withdrawal"> | bigint | number
  }

  export type withdrawalOrderByWithRelationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    tx_id?: SortOrder
  }

  export type withdrawalWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: withdrawalWhereInput | withdrawalWhereInput[]
    OR?: withdrawalWhereInput[]
    NOT?: withdrawalWhereInput | withdrawalWhereInput[]
    addr_id?: BigIntFilter<"withdrawal"> | bigint | number
    amount?: DecimalFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    redeemer_id?: BigIntNullableFilter<"withdrawal"> | bigint | number | null
    tx_id?: BigIntFilter<"withdrawal"> | bigint | number
  }, "id">

  export type withdrawalOrderByWithAggregationInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrderInput | SortOrder
    tx_id?: SortOrder
    _count?: withdrawalCountOrderByAggregateInput
    _avg?: withdrawalAvgOrderByAggregateInput
    _max?: withdrawalMaxOrderByAggregateInput
    _min?: withdrawalMinOrderByAggregateInput
    _sum?: withdrawalSumOrderByAggregateInput
  }

  export type withdrawalScalarWhereWithAggregatesInput = {
    AND?: withdrawalScalarWhereWithAggregatesInput | withdrawalScalarWhereWithAggregatesInput[]
    OR?: withdrawalScalarWhereWithAggregatesInput[]
    NOT?: withdrawalScalarWhereWithAggregatesInput | withdrawalScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"withdrawal"> | bigint | number
    addr_id?: BigIntWithAggregatesFilter<"withdrawal"> | bigint | number
    amount?: DecimalWithAggregatesFilter<"withdrawal"> | Decimal | DecimalJsLike | number | string
    redeemer_id?: BigIntNullableWithAggregatesFilter<"withdrawal"> | bigint | number | null
    tx_id?: BigIntWithAggregatesFilter<"withdrawal"> | bigint | number
  }

  export type sqlx_migrationsWhereInput = {
    AND?: sqlx_migrationsWhereInput | sqlx_migrationsWhereInput[]
    OR?: sqlx_migrationsWhereInput[]
    NOT?: sqlx_migrationsWhereInput | sqlx_migrationsWhereInput[]
    version?: BigIntFilter<"sqlx_migrations"> | bigint | number
    description?: StringFilter<"sqlx_migrations"> | string
    installed_on?: DateTimeFilter<"sqlx_migrations"> | Date | string
    success?: BoolFilter<"sqlx_migrations"> | boolean
    checksum?: BytesFilter<"sqlx_migrations"> | Uint8Array
    execution_time?: BigIntFilter<"sqlx_migrations"> | bigint | number
  }

  export type sqlx_migrationsOrderByWithRelationInput = {
    version?: SortOrder
    description?: SortOrder
    installed_on?: SortOrder
    success?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type sqlx_migrationsWhereUniqueInput = Prisma.AtLeast<{
    version?: bigint | number
    AND?: sqlx_migrationsWhereInput | sqlx_migrationsWhereInput[]
    OR?: sqlx_migrationsWhereInput[]
    NOT?: sqlx_migrationsWhereInput | sqlx_migrationsWhereInput[]
    description?: StringFilter<"sqlx_migrations"> | string
    installed_on?: DateTimeFilter<"sqlx_migrations"> | Date | string
    success?: BoolFilter<"sqlx_migrations"> | boolean
    checksum?: BytesFilter<"sqlx_migrations"> | Uint8Array
    execution_time?: BigIntFilter<"sqlx_migrations"> | bigint | number
  }, "version">

  export type sqlx_migrationsOrderByWithAggregationInput = {
    version?: SortOrder
    description?: SortOrder
    installed_on?: SortOrder
    success?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
    _count?: sqlx_migrationsCountOrderByAggregateInput
    _avg?: sqlx_migrationsAvgOrderByAggregateInput
    _max?: sqlx_migrationsMaxOrderByAggregateInput
    _min?: sqlx_migrationsMinOrderByAggregateInput
    _sum?: sqlx_migrationsSumOrderByAggregateInput
  }

  export type sqlx_migrationsScalarWhereWithAggregatesInput = {
    AND?: sqlx_migrationsScalarWhereWithAggregatesInput | sqlx_migrationsScalarWhereWithAggregatesInput[]
    OR?: sqlx_migrationsScalarWhereWithAggregatesInput[]
    NOT?: sqlx_migrationsScalarWhereWithAggregatesInput | sqlx_migrationsScalarWhereWithAggregatesInput[]
    version?: BigIntWithAggregatesFilter<"sqlx_migrations"> | bigint | number
    description?: StringWithAggregatesFilter<"sqlx_migrations"> | string
    installed_on?: DateTimeWithAggregatesFilter<"sqlx_migrations"> | Date | string
    success?: BoolWithAggregatesFilter<"sqlx_migrations"> | boolean
    checksum?: BytesWithAggregatesFilter<"sqlx_migrations"> | Uint8Array
    execution_time?: BigIntWithAggregatesFilter<"sqlx_migrations"> | bigint | number
  }

  export type ada_potsCreateInput = {
    id?: bigint | number
    slot_no: bigint | number
    epoch_no: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    rewards: Decimal | DecimalJsLike | number | string
    utxo: Decimal | DecimalJsLike | number | string
    deposits_stake: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    block_id: bigint | number
    deposits_drep: Decimal | DecimalJsLike | number | string
    deposits_proposal: Decimal | DecimalJsLike | number | string
  }

  export type ada_potsUncheckedCreateInput = {
    id?: bigint | number
    slot_no: bigint | number
    epoch_no: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    rewards: Decimal | DecimalJsLike | number | string
    utxo: Decimal | DecimalJsLike | number | string
    deposits_stake: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    block_id: bigint | number
    deposits_drep: Decimal | DecimalJsLike | number | string
    deposits_proposal: Decimal | DecimalJsLike | number | string
  }

  export type ada_potsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposits_drep?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ada_potsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposits_drep?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ada_potsCreateManyInput = {
    id?: bigint | number
    slot_no: bigint | number
    epoch_no: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    rewards: Decimal | DecimalJsLike | number | string
    utxo: Decimal | DecimalJsLike | number | string
    deposits_stake: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    block_id: bigint | number
    deposits_drep: Decimal | DecimalJsLike | number | string
    deposits_proposal: Decimal | DecimalJsLike | number | string
  }

  export type ada_potsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposits_drep?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ada_potsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rewards?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utxo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposits_drep?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposits_proposal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type blockCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    epoch_no?: number | null
    slot_no?: bigint | number | null
    epoch_slot_no?: number | null
    block_no?: number | null
    previous_id?: bigint | number | null
    slot_leader_id: bigint | number
    size: number
    time: Date | string
    tx_count: bigint | number
    proto_major: number
    proto_minor: number
    vrf_key?: string | null
    op_cert?: Uint8Array | null
    op_cert_counter?: bigint | number | null
  }

  export type blockUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    epoch_no?: number | null
    slot_no?: bigint | number | null
    epoch_slot_no?: number | null
    block_no?: number | null
    previous_id?: bigint | number | null
    slot_leader_id: bigint | number
    size: number
    time: Date | string
    tx_count: bigint | number
    proto_major: number
    proto_minor: number
    vrf_key?: string | null
    op_cert?: Uint8Array | null
    op_cert_counter?: bigint | number | null
  }

  export type blockUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    slot_no?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_slot_no?: NullableIntFieldUpdateOperationsInput | number | null
    block_no?: NullableIntFieldUpdateOperationsInput | number | null
    previous_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    slot_leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    tx_count?: BigIntFieldUpdateOperationsInput | bigint | number
    proto_major?: IntFieldUpdateOperationsInput | number
    proto_minor?: IntFieldUpdateOperationsInput | number
    vrf_key?: NullableStringFieldUpdateOperationsInput | string | null
    op_cert?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    op_cert_counter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blockUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    slot_no?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_slot_no?: NullableIntFieldUpdateOperationsInput | number | null
    block_no?: NullableIntFieldUpdateOperationsInput | number | null
    previous_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    slot_leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    tx_count?: BigIntFieldUpdateOperationsInput | bigint | number
    proto_major?: IntFieldUpdateOperationsInput | number
    proto_minor?: IntFieldUpdateOperationsInput | number
    vrf_key?: NullableStringFieldUpdateOperationsInput | string | null
    op_cert?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    op_cert_counter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blockCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    epoch_no?: number | null
    slot_no?: bigint | number | null
    epoch_slot_no?: number | null
    block_no?: number | null
    previous_id?: bigint | number | null
    slot_leader_id: bigint | number
    size: number
    time: Date | string
    tx_count: bigint | number
    proto_major: number
    proto_minor: number
    vrf_key?: string | null
    op_cert?: Uint8Array | null
    op_cert_counter?: bigint | number | null
  }

  export type blockUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    slot_no?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_slot_no?: NullableIntFieldUpdateOperationsInput | number | null
    block_no?: NullableIntFieldUpdateOperationsInput | number | null
    previous_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    slot_leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    tx_count?: BigIntFieldUpdateOperationsInput | bigint | number
    proto_major?: IntFieldUpdateOperationsInput | number
    proto_minor?: IntFieldUpdateOperationsInput | number
    vrf_key?: NullableStringFieldUpdateOperationsInput | string | null
    op_cert?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    op_cert_counter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type blockUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    slot_no?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_slot_no?: NullableIntFieldUpdateOperationsInput | number | null
    block_no?: NullableIntFieldUpdateOperationsInput | number | null
    previous_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    slot_leader_id?: BigIntFieldUpdateOperationsInput | bigint | number
    size?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    tx_count?: BigIntFieldUpdateOperationsInput | bigint | number
    proto_major?: IntFieldUpdateOperationsInput | number
    proto_minor?: IntFieldUpdateOperationsInput | number
    vrf_key?: NullableStringFieldUpdateOperationsInput | string | null
    op_cert?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    op_cert_counter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collateral_tx_inCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type collateral_tx_inUncheckedCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type collateral_tx_inUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type collateral_tx_inUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type collateral_tx_inCreateManyInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type collateral_tx_inUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type collateral_tx_inUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type collateral_tx_outCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    multi_assets_descr: string
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
  }

  export type collateral_tx_outUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    multi_assets_descr: string
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
  }

  export type collateral_tx_outUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    multi_assets_descr?: StringFieldUpdateOperationsInput | string
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collateral_tx_outUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    multi_assets_descr?: StringFieldUpdateOperationsInput | string
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collateral_tx_outCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    multi_assets_descr: string
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
  }

  export type collateral_tx_outUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    multi_assets_descr?: StringFieldUpdateOperationsInput | string
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type collateral_tx_outUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    multi_assets_descr?: StringFieldUpdateOperationsInput | string
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type committeeCreateInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
    committee_member?: committee_memberCreateNestedManyWithoutCommitteeInput
  }

  export type committeeUncheckedCreateInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
    committee_member?: committee_memberUncheckedCreateNestedManyWithoutCommitteeInput
  }

  export type committeeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_member?: committee_memberUpdateManyWithoutCommitteeNestedInput
  }

  export type committeeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_member?: committee_memberUncheckedUpdateManyWithoutCommitteeNestedInput
  }

  export type committeeCreateManyInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type committeeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committeeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_de_registrationCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    voting_anchor_id?: bigint | number | null
    cold_key_id: bigint | number
  }

  export type committee_de_registrationUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    voting_anchor_id?: bigint | number | null
    cold_key_id: bigint | number
  }

  export type committee_de_registrationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_de_registrationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_de_registrationCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    voting_anchor_id?: bigint | number | null
    cold_key_id: bigint | number
  }

  export type committee_de_registrationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_de_registrationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_hashCreateInput = {
    id?: bigint | number
    raw: Uint8Array
    has_script: boolean
  }

  export type committee_hashUncheckedCreateInput = {
    id?: bigint | number
    raw: Uint8Array
    has_script: boolean
  }

  export type committee_hashUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: BytesFieldUpdateOperationsInput | Uint8Array
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type committee_hashUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: BytesFieldUpdateOperationsInput | Uint8Array
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type committee_hashCreateManyInput = {
    id?: bigint | number
    raw: Uint8Array
    has_script: boolean
  }

  export type committee_hashUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: BytesFieldUpdateOperationsInput | Uint8Array
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type committee_hashUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: BytesFieldUpdateOperationsInput | Uint8Array
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type committee_memberCreateInput = {
    id?: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
    committee: committeeCreateNestedOneWithoutCommittee_memberInput
  }

  export type committee_memberUncheckedCreateInput = {
    id?: bigint | number
    committee_id: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
  }

  export type committee_memberUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
    committee?: committeeUpdateOneRequiredWithoutCommittee_memberNestedInput
  }

  export type committee_memberUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type committee_memberCreateManyInput = {
    id?: bigint | number
    committee_id: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
  }

  export type committee_memberUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type committee_memberUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type committee_registrationCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    cold_key_id: bigint | number
    hot_key_id: bigint | number
  }

  export type committee_registrationUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    cold_key_id: bigint | number
    hot_key_id: bigint | number
  }

  export type committee_registrationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hot_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_registrationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hot_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_registrationCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    cold_key_id: bigint | number
    hot_key_id: bigint | number
  }

  export type committee_registrationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hot_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_registrationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    cold_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hot_key_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type constitutionCreateInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    voting_anchor_id: bigint | number
    script_hash?: Uint8Array | null
  }

  export type constitutionUncheckedCreateInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    voting_anchor_id: bigint | number
    script_hash?: Uint8Array | null
  }

  export type constitutionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type constitutionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type constitutionCreateManyInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    voting_anchor_id: bigint | number
    script_hash?: Uint8Array | null
  }

  export type constitutionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type constitutionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type cost_modelCreateInput = {
    id?: bigint | number
    costs: JsonNullValueInput | InputJsonValue
    hash: Uint8Array
  }

  export type cost_modelUncheckedCreateInput = {
    id?: bigint | number
    costs: JsonNullValueInput | InputJsonValue
    hash: Uint8Array
  }

  export type cost_modelUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    costs?: JsonNullValueInput | InputJsonValue
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type cost_modelUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    costs?: JsonNullValueInput | InputJsonValue
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type cost_modelCreateManyInput = {
    id?: bigint | number
    costs: JsonNullValueInput | InputJsonValue
    hash: Uint8Array
  }

  export type cost_modelUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    costs?: JsonNullValueInput | InputJsonValue
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type cost_modelUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    costs?: JsonNullValueInput | InputJsonValue
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type datumCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type datumUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type datumUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type datumUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type datumCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type datumUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type datumUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type delegationCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    pool_hash_id: bigint | number
    active_epoch_no: bigint | number
    tx_id: bigint | number
    slot_no: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegationUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    pool_hash_id: bigint | number
    active_epoch_no: bigint | number
    tx_id: bigint | number
    slot_no: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegationCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    pool_hash_id: bigint | number
    active_epoch_no: bigint | number
    tx_id: bigint | number
    slot_no: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    slot_no?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegation_voteCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    drep_hash_id: bigint | number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegation_voteUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    drep_hash_id: bigint | number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegation_voteUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegation_voteUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegation_voteCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    drep_hash_id: bigint | number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type delegation_voteUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delegation_voteUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type delisted_poolCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
  }

  export type delisted_poolUncheckedCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
  }

  export type delisted_poolUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type delisted_poolUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type delisted_poolCreateManyInput = {
    id?: bigint | number
    hash_raw: Uint8Array
  }

  export type delisted_poolUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type delisted_poolUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type drep_distrCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    amount: bigint | number
    epoch_no: number
    active_until?: number | null
  }

  export type drep_distrUncheckedCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    amount: bigint | number
    epoch_no: number
    active_until?: number | null
  }

  export type drep_distrUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    active_until?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drep_distrUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    active_until?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drep_distrCreateManyInput = {
    id?: bigint | number
    hash_id: bigint | number
    amount: bigint | number
    epoch_no: number
    active_until?: number | null
  }

  export type drep_distrUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    active_until?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drep_distrUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    active_until?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type drep_hashCreateInput = {
    id?: bigint | number
    raw?: Uint8Array | null
    view: string
    has_script: boolean
  }

  export type drep_hashUncheckedCreateInput = {
    id?: bigint | number
    raw?: Uint8Array | null
    view: string
    has_script: boolean
  }

  export type drep_hashUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    view?: StringFieldUpdateOperationsInput | string
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type drep_hashUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    view?: StringFieldUpdateOperationsInput | string
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type drep_hashCreateManyInput = {
    id?: bigint | number
    raw?: Uint8Array | null
    view: string
    has_script: boolean
  }

  export type drep_hashUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    view?: StringFieldUpdateOperationsInput | string
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type drep_hashUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    raw?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    view?: StringFieldUpdateOperationsInput | string
    has_script?: BoolFieldUpdateOperationsInput | boolean
  }

  export type drep_registrationCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    deposit?: bigint | number | null
    drep_hash_id: bigint | number
    voting_anchor_id?: bigint | number | null
  }

  export type drep_registrationUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    deposit?: bigint | number | null
    drep_hash_id: bigint | number
    voting_anchor_id?: bigint | number | null
  }

  export type drep_registrationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type drep_registrationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type drep_registrationCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    cert_index: number
    deposit?: bigint | number | null
    drep_hash_id: bigint | number
    voting_anchor_id?: bigint | number | null
  }

  export type drep_registrationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type drep_registrationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    drep_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type epochCreateInput = {
    id?: bigint | number
    out_sum: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    tx_count: number
    blk_count: number
    no: number
    start_time: Date | string
    end_time: Date | string
  }

  export type epochUncheckedCreateInput = {
    id?: bigint | number
    out_sum: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    tx_count: number
    blk_count: number
    no: number
    start_time: Date | string
    end_time: Date | string
  }

  export type epochUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_count?: IntFieldUpdateOperationsInput | number
    blk_count?: IntFieldUpdateOperationsInput | number
    no?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type epochUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_count?: IntFieldUpdateOperationsInput | number
    blk_count?: IntFieldUpdateOperationsInput | number
    no?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type epochCreateManyInput = {
    id?: bigint | number
    out_sum: Decimal | DecimalJsLike | number | string
    fees: Decimal | DecimalJsLike | number | string
    tx_count: number
    blk_count: number
    no: number
    start_time: Date | string
    end_time: Date | string
  }

  export type epochUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_count?: IntFieldUpdateOperationsInput | number
    blk_count?: IntFieldUpdateOperationsInput | number
    no?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type epochUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_count?: IntFieldUpdateOperationsInput | number
    blk_count?: IntFieldUpdateOperationsInput | number
    no?: IntFieldUpdateOperationsInput | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type epoch_paramCreateInput = {
    id?: bigint | number
    epoch_no: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: Decimal | DecimalJsLike | number | string
    pool_deposit: Decimal | DecimalJsLike | number | string
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: Decimal | DecimalJsLike | number | string
    min_pool_cost: Decimal | DecimalJsLike | number | string
    nonce?: Uint8Array | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    block_id: bigint | number
    extra_entropy?: Uint8Array | null
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type epoch_paramUncheckedCreateInput = {
    id?: bigint | number
    epoch_no: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: Decimal | DecimalJsLike | number | string
    pool_deposit: Decimal | DecimalJsLike | number | string
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: Decimal | DecimalJsLike | number | string
    min_pool_cost: Decimal | DecimalJsLike | number | string
    nonce?: Uint8Array | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    block_id: bigint | number
    extra_entropy?: Uint8Array | null
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type epoch_paramUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    min_fee_a?: IntFieldUpdateOperationsInput | number
    min_fee_b?: IntFieldUpdateOperationsInput | number
    max_block_size?: IntFieldUpdateOperationsInput | number
    max_tx_size?: IntFieldUpdateOperationsInput | number
    max_bh_size?: IntFieldUpdateOperationsInput | number
    key_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFieldUpdateOperationsInput | number
    optimal_pool_count?: IntFieldUpdateOperationsInput | number
    influence?: FloatFieldUpdateOperationsInput | number
    monetary_expand_rate?: FloatFieldUpdateOperationsInput | number
    treasury_growth_rate?: FloatFieldUpdateOperationsInput | number
    decentralisation?: FloatFieldUpdateOperationsInput | number
    protocol_major?: IntFieldUpdateOperationsInput | number
    protocol_minor?: IntFieldUpdateOperationsInput | number
    min_utxo_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonce?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extra_entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type epoch_paramUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    min_fee_a?: IntFieldUpdateOperationsInput | number
    min_fee_b?: IntFieldUpdateOperationsInput | number
    max_block_size?: IntFieldUpdateOperationsInput | number
    max_tx_size?: IntFieldUpdateOperationsInput | number
    max_bh_size?: IntFieldUpdateOperationsInput | number
    key_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFieldUpdateOperationsInput | number
    optimal_pool_count?: IntFieldUpdateOperationsInput | number
    influence?: FloatFieldUpdateOperationsInput | number
    monetary_expand_rate?: FloatFieldUpdateOperationsInput | number
    treasury_growth_rate?: FloatFieldUpdateOperationsInput | number
    decentralisation?: FloatFieldUpdateOperationsInput | number
    protocol_major?: IntFieldUpdateOperationsInput | number
    protocol_minor?: IntFieldUpdateOperationsInput | number
    min_utxo_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonce?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extra_entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type epoch_paramCreateManyInput = {
    id?: bigint | number
    epoch_no: number
    min_fee_a: number
    min_fee_b: number
    max_block_size: number
    max_tx_size: number
    max_bh_size: number
    key_deposit: Decimal | DecimalJsLike | number | string
    pool_deposit: Decimal | DecimalJsLike | number | string
    max_epoch: number
    optimal_pool_count: number
    influence: number
    monetary_expand_rate: number
    treasury_growth_rate: number
    decentralisation: number
    protocol_major: number
    protocol_minor: number
    min_utxo_value: Decimal | DecimalJsLike | number | string
    min_pool_cost: Decimal | DecimalJsLike | number | string
    nonce?: Uint8Array | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    block_id: bigint | number
    extra_entropy?: Uint8Array | null
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type epoch_paramUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    min_fee_a?: IntFieldUpdateOperationsInput | number
    min_fee_b?: IntFieldUpdateOperationsInput | number
    max_block_size?: IntFieldUpdateOperationsInput | number
    max_tx_size?: IntFieldUpdateOperationsInput | number
    max_bh_size?: IntFieldUpdateOperationsInput | number
    key_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFieldUpdateOperationsInput | number
    optimal_pool_count?: IntFieldUpdateOperationsInput | number
    influence?: FloatFieldUpdateOperationsInput | number
    monetary_expand_rate?: FloatFieldUpdateOperationsInput | number
    treasury_growth_rate?: FloatFieldUpdateOperationsInput | number
    decentralisation?: FloatFieldUpdateOperationsInput | number
    protocol_major?: IntFieldUpdateOperationsInput | number
    protocol_minor?: IntFieldUpdateOperationsInput | number
    min_utxo_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonce?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extra_entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type epoch_paramUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    min_fee_a?: IntFieldUpdateOperationsInput | number
    min_fee_b?: IntFieldUpdateOperationsInput | number
    max_block_size?: IntFieldUpdateOperationsInput | number
    max_tx_size?: IntFieldUpdateOperationsInput | number
    max_bh_size?: IntFieldUpdateOperationsInput | number
    key_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pool_deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    max_epoch?: IntFieldUpdateOperationsInput | number
    optimal_pool_count?: IntFieldUpdateOperationsInput | number
    influence?: FloatFieldUpdateOperationsInput | number
    monetary_expand_rate?: FloatFieldUpdateOperationsInput | number
    treasury_growth_rate?: FloatFieldUpdateOperationsInput | number
    decentralisation?: FloatFieldUpdateOperationsInput | number
    protocol_major?: IntFieldUpdateOperationsInput | number
    protocol_minor?: IntFieldUpdateOperationsInput | number
    min_utxo_value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    min_pool_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonce?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    extra_entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type epoch_stakeCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    epoch_no: number
  }

  export type epoch_stakeUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    epoch_no: number
  }

  export type epoch_stakeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stakeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stakeCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    epoch_no: number
  }

  export type epoch_stakeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stakeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stake_progressCreateInput = {
    id?: bigint | number
    epoch_no: number
    completed: boolean
  }

  export type epoch_stake_progressUncheckedCreateInput = {
    id?: bigint | number
    epoch_no: number
    completed: boolean
  }

  export type epoch_stake_progressUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type epoch_stake_progressUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type epoch_stake_progressCreateManyInput = {
    id?: bigint | number
    epoch_no: number
    completed: boolean
  }

  export type epoch_stake_progressUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type epoch_stake_progressUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type epoch_stateCreateInput = {
    id?: bigint | number
    committee_id?: bigint | number | null
    no_confidence_id?: bigint | number | null
    constitution_id?: bigint | number | null
    epoch_no: number
  }

  export type epoch_stateUncheckedCreateInput = {
    id?: bigint | number
    committee_id?: bigint | number | null
    no_confidence_id?: bigint | number | null
    constitution_id?: bigint | number | null
    epoch_no: number
  }

  export type epoch_stateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    no_confidence_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    constitution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    no_confidence_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    constitution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stateCreateManyInput = {
    id?: bigint | number
    committee_id?: bigint | number | null
    no_confidence_id?: bigint | number | null
    constitution_id?: bigint | number | null
    epoch_no: number
  }

  export type epoch_stateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    no_confidence_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    constitution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_stateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    no_confidence_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    constitution_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch_no?: IntFieldUpdateOperationsInput | number
  }

  export type epoch_sync_timeCreateInput = {
    id?: bigint | number
    no: bigint | number
    seconds: bigint | number
    state: $Enums.syncstatetype
  }

  export type epoch_sync_timeUncheckedCreateInput = {
    id?: bigint | number
    no: bigint | number
    seconds: bigint | number
    state: $Enums.syncstatetype
  }

  export type epoch_sync_timeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    no?: BigIntFieldUpdateOperationsInput | bigint | number
    seconds?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: EnumsyncstatetypeFieldUpdateOperationsInput | $Enums.syncstatetype
  }

  export type epoch_sync_timeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    no?: BigIntFieldUpdateOperationsInput | bigint | number
    seconds?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: EnumsyncstatetypeFieldUpdateOperationsInput | $Enums.syncstatetype
  }

  export type epoch_sync_timeCreateManyInput = {
    id?: bigint | number
    no: bigint | number
    seconds: bigint | number
    state: $Enums.syncstatetype
  }

  export type epoch_sync_timeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    no?: BigIntFieldUpdateOperationsInput | bigint | number
    seconds?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: EnumsyncstatetypeFieldUpdateOperationsInput | $Enums.syncstatetype
  }

  export type epoch_sync_timeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    no?: BigIntFieldUpdateOperationsInput | bigint | number
    seconds?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: EnumsyncstatetypeFieldUpdateOperationsInput | $Enums.syncstatetype
  }

  export type event_infoCreateInput = {
    id?: bigint | number
    tx_id?: bigint | number | null
    epoch: number
    type: string
    explanation?: string | null
  }

  export type event_infoUncheckedCreateInput = {
    id?: bigint | number
    tx_id?: bigint | number | null
    epoch: number
    type: string
    explanation?: string | null
  }

  export type event_infoUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type event_infoUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type event_infoCreateManyInput = {
    id?: bigint | number
    tx_id?: bigint | number | null
    epoch: number
    type: string
    explanation?: string | null
  }

  export type event_infoUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type event_infoUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    epoch?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type extra_key_witnessCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
  }

  export type extra_key_witnessUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
  }

  export type extra_key_witnessUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type extra_key_witnessUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type extra_key_witnessCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
  }

  export type extra_key_witnessUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type extra_key_witnessUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type extra_migrationsCreateInput = {
    id?: bigint | number
    token: string
    description?: string | null
  }

  export type extra_migrationsUncheckedCreateInput = {
    id?: bigint | number
    token: string
    description?: string | null
  }

  export type extra_migrationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type extra_migrationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type extra_migrationsCreateManyInput = {
    id?: bigint | number
    token: string
    description?: string | null
  }

  export type extra_migrationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type extra_migrationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    token?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gov_action_proposalCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: bigint | number
    prev_gov_action_proposal?: bigint | number | null
    deposit: Decimal | DecimalJsLike | number | string
    return_address: bigint | number
    expiration?: number | null
    voting_anchor_id?: bigint | number | null
    type: $Enums.govactiontype
    description: JsonNullValueInput | InputJsonValue
    param_proposal?: bigint | number | null
    ratified_epoch?: number | null
    enacted_epoch?: number | null
    dropped_epoch?: number | null
    expired_epoch?: number | null
  }

  export type gov_action_proposalUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: bigint | number
    prev_gov_action_proposal?: bigint | number | null
    deposit: Decimal | DecimalJsLike | number | string
    return_address: bigint | number
    expiration?: number | null
    voting_anchor_id?: bigint | number | null
    type: $Enums.govactiontype
    description: JsonNullValueInput | InputJsonValue
    param_proposal?: bigint | number | null
    ratified_epoch?: number | null
    enacted_epoch?: number | null
    dropped_epoch?: number | null
    expired_epoch?: number | null
  }

  export type gov_action_proposalUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: BigIntFieldUpdateOperationsInput | bigint | number
    prev_gov_action_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    type?: EnumgovactiontypeFieldUpdateOperationsInput | $Enums.govactiontype
    description?: JsonNullValueInput | InputJsonValue
    param_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ratified_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    enacted_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    dropped_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    expired_epoch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gov_action_proposalUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: BigIntFieldUpdateOperationsInput | bigint | number
    prev_gov_action_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    type?: EnumgovactiontypeFieldUpdateOperationsInput | $Enums.govactiontype
    description?: JsonNullValueInput | InputJsonValue
    param_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ratified_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    enacted_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    dropped_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    expired_epoch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gov_action_proposalCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: bigint | number
    prev_gov_action_proposal?: bigint | number | null
    deposit: Decimal | DecimalJsLike | number | string
    return_address: bigint | number
    expiration?: number | null
    voting_anchor_id?: bigint | number | null
    type: $Enums.govactiontype
    description: JsonNullValueInput | InputJsonValue
    param_proposal?: bigint | number | null
    ratified_epoch?: number | null
    enacted_epoch?: number | null
    dropped_epoch?: number | null
    expired_epoch?: number | null
  }

  export type gov_action_proposalUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: BigIntFieldUpdateOperationsInput | bigint | number
    prev_gov_action_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    type?: EnumgovactiontypeFieldUpdateOperationsInput | $Enums.govactiontype
    description?: JsonNullValueInput | InputJsonValue
    param_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ratified_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    enacted_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    dropped_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    expired_epoch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type gov_action_proposalUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: BigIntFieldUpdateOperationsInput | bigint | number
    prev_gov_action_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    deposit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_address?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    type?: EnumgovactiontypeFieldUpdateOperationsInput | $Enums.govactiontype
    description?: JsonNullValueInput | InputJsonValue
    param_proposal?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ratified_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    enacted_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    dropped_epoch?: NullableIntFieldUpdateOperationsInput | number | null
    expired_epoch?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ma_tx_mintCreateInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_mintUncheckedCreateInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_mintUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_mintUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_mintCreateManyInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_mintUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_mintUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_outCreateInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_out_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_outUncheckedCreateInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_out_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_outUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_outUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_outCreateManyInput = {
    id?: bigint | number
    quantity: Decimal | DecimalJsLike | number | string
    tx_out_id: bigint | number
    ident: bigint | number
  }

  export type ma_tx_outUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ma_tx_outUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    quantity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ident?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type metaCreateInput = {
    id?: bigint | number
    start_time: Date | string
    network_name: string
    version: string
  }

  export type metaUncheckedCreateInput = {
    id?: bigint | number
    start_time: Date | string
    network_name: string
    version: string
  }

  export type metaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    network_name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type metaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    network_name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type metaCreateManyInput = {
    id?: bigint | number
    start_time: Date | string
    network_name: string
    version: string
  }

  export type metaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    network_name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type metaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    network_name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type multi_assetCreateInput = {
    id?: bigint | number
    policy: Uint8Array
    name: Uint8Array
    fingerprint: string
  }

  export type multi_assetUncheckedCreateInput = {
    id?: bigint | number
    policy: Uint8Array
    name: Uint8Array
    fingerprint: string
  }

  export type multi_assetUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: BytesFieldUpdateOperationsInput | Uint8Array
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type multi_assetUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: BytesFieldUpdateOperationsInput | Uint8Array
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type multi_assetCreateManyInput = {
    id?: bigint | number
    policy: Uint8Array
    name: Uint8Array
    fingerprint: string
  }

  export type multi_assetUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: BytesFieldUpdateOperationsInput | Uint8Array
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type multi_assetUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    policy?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: BytesFieldUpdateOperationsInput | Uint8Array
    fingerprint?: StringFieldUpdateOperationsInput | string
  }

  export type new_committeeCreateInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    deleted_members: string
    added_members: string
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type new_committeeUncheckedCreateInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    deleted_members: string
    added_members: string
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type new_committeeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_members?: StringFieldUpdateOperationsInput | string
    added_members?: StringFieldUpdateOperationsInput | string
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type new_committeeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_members?: StringFieldUpdateOperationsInput | string
    added_members?: StringFieldUpdateOperationsInput | string
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type new_committeeCreateManyInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    deleted_members: string
    added_members: string
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type new_committeeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_members?: StringFieldUpdateOperationsInput | string
    added_members?: StringFieldUpdateOperationsInput | string
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type new_committeeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deleted_members?: StringFieldUpdateOperationsInput | string
    added_members?: StringFieldUpdateOperationsInput | string
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type off_chain_pool_dataCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    ticker_name: string
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    pmr_id: bigint | number
  }

  export type off_chain_pool_dataUncheckedCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    ticker_name: string
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    pmr_id: bigint | number
  }

  export type off_chain_pool_dataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ticker_name?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type off_chain_pool_dataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ticker_name?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type off_chain_pool_dataCreateManyInput = {
    id?: bigint | number
    pool_id: bigint | number
    ticker_name: string
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    pmr_id: bigint | number
  }

  export type off_chain_pool_dataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ticker_name?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type off_chain_pool_dataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ticker_name?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type off_chain_pool_fetch_errorCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    fetch_time: Date | string
    pmr_id: bigint | number
    fetch_error: string
    retry_count: number
  }

  export type off_chain_pool_fetch_errorUncheckedCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    fetch_time: Date | string
    pmr_id: bigint | number
    fetch_error: string
    retry_count: number
  }

  export type off_chain_pool_fetch_errorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_pool_fetch_errorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_pool_fetch_errorCreateManyInput = {
    id?: bigint | number
    pool_id: bigint | number
    fetch_time: Date | string
    pmr_id: bigint | number
    fetch_error: string
    retry_count: number
  }

  export type off_chain_pool_fetch_errorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_pool_fetch_errorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    pmr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_vote_authorCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    name?: string | null
    witness_algorithm: string
    public_key: string
    signature: string
    warning?: string | null
  }

  export type off_chain_vote_authorUncheckedCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    name?: string | null
    witness_algorithm: string
    public_key: string
    signature: string
    warning?: string | null
  }

  export type off_chain_vote_authorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    witness_algorithm?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    warning?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_authorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    witness_algorithm?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    warning?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_authorCreateManyInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    name?: string | null
    witness_algorithm: string
    public_key: string
    signature: string
    warning?: string | null
  }

  export type off_chain_vote_authorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    witness_algorithm?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    warning?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_authorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    witness_algorithm?: StringFieldUpdateOperationsInput | string
    public_key?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    warning?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_dataCreateInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    warning?: string | null
    language: string
    comment?: string | null
    is_valid?: boolean | null
  }

  export type off_chain_vote_dataUncheckedCreateInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    warning?: string | null
    language: string
    comment?: string | null
    is_valid?: boolean | null
  }

  export type off_chain_vote_dataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    warning?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    is_valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type off_chain_vote_dataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    warning?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    is_valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type off_chain_vote_dataCreateManyInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    hash: Uint8Array
    json: JsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    warning?: string | null
    language: string
    comment?: string | null
    is_valid?: boolean | null
  }

  export type off_chain_vote_dataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    warning?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    is_valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type off_chain_vote_dataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    json?: JsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    warning?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    is_valid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type off_chain_vote_drep_dataCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    payment_address?: string | null
    given_name: string
    objectives?: string | null
    motivations?: string | null
    qualifications?: string | null
    image_url?: string | null
    image_hash?: string | null
  }

  export type off_chain_vote_drep_dataUncheckedCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    payment_address?: string | null
    given_name: string
    objectives?: string | null
    motivations?: string | null
    qualifications?: string | null
    image_url?: string | null
    image_hash?: string | null
  }

  export type off_chain_vote_drep_dataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_address?: NullableStringFieldUpdateOperationsInput | string | null
    given_name?: StringFieldUpdateOperationsInput | string
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_drep_dataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_address?: NullableStringFieldUpdateOperationsInput | string | null
    given_name?: StringFieldUpdateOperationsInput | string
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_drep_dataCreateManyInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    payment_address?: string | null
    given_name: string
    objectives?: string | null
    motivations?: string | null
    qualifications?: string | null
    image_url?: string | null
    image_hash?: string | null
  }

  export type off_chain_vote_drep_dataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_address?: NullableStringFieldUpdateOperationsInput | string | null
    given_name?: StringFieldUpdateOperationsInput | string
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_drep_dataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_address?: NullableStringFieldUpdateOperationsInput | string | null
    given_name?: StringFieldUpdateOperationsInput | string
    objectives?: NullableStringFieldUpdateOperationsInput | string | null
    motivations?: NullableStringFieldUpdateOperationsInput | string | null
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_external_updateCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    uri: string
  }

  export type off_chain_vote_external_updateUncheckedCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    uri: string
  }

  export type off_chain_vote_external_updateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_external_updateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_external_updateCreateManyInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    uri: string
  }

  export type off_chain_vote_external_updateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_external_updateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_fetch_errorCreateInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    fetch_error: string
    fetch_time: Date | string
    retry_count: number
  }

  export type off_chain_vote_fetch_errorUncheckedCreateInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    fetch_error: string
    fetch_time: Date | string
    retry_count: number
  }

  export type off_chain_vote_fetch_errorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_vote_fetch_errorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_vote_fetch_errorCreateManyInput = {
    id?: bigint | number
    voting_anchor_id: bigint | number
    fetch_error: string
    fetch_time: Date | string
    retry_count: number
  }

  export type off_chain_vote_fetch_errorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_vote_fetch_errorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    voting_anchor_id?: BigIntFieldUpdateOperationsInput | bigint | number
    fetch_error?: StringFieldUpdateOperationsInput | string
    fetch_time?: DateTimeFieldUpdateOperationsInput | Date | string
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type off_chain_vote_gov_action_dataCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    abstract: string
    motivation: string
    rationale: string
  }

  export type off_chain_vote_gov_action_dataUncheckedCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    abstract: string
    motivation: string
    rationale: string
  }

  export type off_chain_vote_gov_action_dataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: StringFieldUpdateOperationsInput | string
    motivation?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_gov_action_dataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: StringFieldUpdateOperationsInput | string
    motivation?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_gov_action_dataCreateManyInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    title: string
    abstract: string
    motivation: string
    rationale: string
  }

  export type off_chain_vote_gov_action_dataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: StringFieldUpdateOperationsInput | string
    motivation?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_gov_action_dataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    abstract?: StringFieldUpdateOperationsInput | string
    motivation?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
  }

  export type off_chain_vote_referenceCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    label: string
    uri: string
    hash_digest?: string | null
    hash_algorithm?: string | null
  }

  export type off_chain_vote_referenceUncheckedCreateInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    label: string
    uri: string
    hash_digest?: string | null
    hash_algorithm?: string | null
  }

  export type off_chain_vote_referenceUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    hash_digest?: NullableStringFieldUpdateOperationsInput | string | null
    hash_algorithm?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_referenceUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    hash_digest?: NullableStringFieldUpdateOperationsInput | string | null
    hash_algorithm?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_referenceCreateManyInput = {
    id?: bigint | number
    off_chain_vote_data_id: bigint | number
    label: string
    uri: string
    hash_digest?: string | null
    hash_algorithm?: string | null
  }

  export type off_chain_vote_referenceUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    hash_digest?: NullableStringFieldUpdateOperationsInput | string | null
    hash_algorithm?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type off_chain_vote_referenceUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    off_chain_vote_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
    label?: StringFieldUpdateOperationsInput | string
    uri?: StringFieldUpdateOperationsInput | string
    hash_digest?: NullableStringFieldUpdateOperationsInput | string | null
    hash_algorithm?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type param_proposalCreateInput = {
    id?: bigint | number
    epoch_no?: number | null
    key?: Uint8Array | null
    min_fee_a?: Decimal | DecimalJsLike | number | string | null
    min_fee_b?: Decimal | DecimalJsLike | number | string | null
    max_block_size?: Decimal | DecimalJsLike | number | string | null
    max_tx_size?: Decimal | DecimalJsLike | number | string | null
    max_bh_size?: Decimal | DecimalJsLike | number | string | null
    key_deposit?: Decimal | DecimalJsLike | number | string | null
    pool_deposit?: Decimal | DecimalJsLike | number | string | null
    max_epoch?: Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: Decimal | DecimalJsLike | number | string | null
    influence?: number | null
    monetary_expand_rate?: number | null
    treasury_growth_rate?: number | null
    decentralisation?: number | null
    entropy?: Uint8Array | null
    protocol_major?: number | null
    protocol_minor?: number | null
    min_utxo_value?: Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: Decimal | DecimalJsLike | number | string | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    registered_tx_id: bigint | number
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type param_proposalUncheckedCreateInput = {
    id?: bigint | number
    epoch_no?: number | null
    key?: Uint8Array | null
    min_fee_a?: Decimal | DecimalJsLike | number | string | null
    min_fee_b?: Decimal | DecimalJsLike | number | string | null
    max_block_size?: Decimal | DecimalJsLike | number | string | null
    max_tx_size?: Decimal | DecimalJsLike | number | string | null
    max_bh_size?: Decimal | DecimalJsLike | number | string | null
    key_deposit?: Decimal | DecimalJsLike | number | string | null
    pool_deposit?: Decimal | DecimalJsLike | number | string | null
    max_epoch?: Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: Decimal | DecimalJsLike | number | string | null
    influence?: number | null
    monetary_expand_rate?: number | null
    treasury_growth_rate?: number | null
    decentralisation?: number | null
    entropy?: Uint8Array | null
    protocol_major?: number | null
    protocol_minor?: number | null
    min_utxo_value?: Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: Decimal | DecimalJsLike | number | string | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    registered_tx_id: bigint | number
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type param_proposalUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    min_fee_a?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    key_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_epoch?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    influence?: NullableFloatFieldUpdateOperationsInput | number | null
    monetary_expand_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    treasury_growth_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    decentralisation?: NullableFloatFieldUpdateOperationsInput | number | null
    entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    protocol_major?: NullableIntFieldUpdateOperationsInput | number | null
    protocol_minor?: NullableIntFieldUpdateOperationsInput | number | null
    min_utxo_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type param_proposalUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    min_fee_a?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    key_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_epoch?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    influence?: NullableFloatFieldUpdateOperationsInput | number | null
    monetary_expand_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    treasury_growth_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    decentralisation?: NullableFloatFieldUpdateOperationsInput | number | null
    entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    protocol_major?: NullableIntFieldUpdateOperationsInput | number | null
    protocol_minor?: NullableIntFieldUpdateOperationsInput | number | null
    min_utxo_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type param_proposalCreateManyInput = {
    id?: bigint | number
    epoch_no?: number | null
    key?: Uint8Array | null
    min_fee_a?: Decimal | DecimalJsLike | number | string | null
    min_fee_b?: Decimal | DecimalJsLike | number | string | null
    max_block_size?: Decimal | DecimalJsLike | number | string | null
    max_tx_size?: Decimal | DecimalJsLike | number | string | null
    max_bh_size?: Decimal | DecimalJsLike | number | string | null
    key_deposit?: Decimal | DecimalJsLike | number | string | null
    pool_deposit?: Decimal | DecimalJsLike | number | string | null
    max_epoch?: Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: Decimal | DecimalJsLike | number | string | null
    influence?: number | null
    monetary_expand_rate?: number | null
    treasury_growth_rate?: number | null
    decentralisation?: number | null
    entropy?: Uint8Array | null
    protocol_major?: number | null
    protocol_minor?: number | null
    min_utxo_value?: Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: Decimal | DecimalJsLike | number | string | null
    cost_model_id?: bigint | number | null
    price_mem?: number | null
    price_step?: number | null
    max_tx_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: Decimal | DecimalJsLike | number | string | null
    max_val_size?: Decimal | DecimalJsLike | number | string | null
    collateral_percent?: number | null
    max_collateral_inputs?: number | null
    registered_tx_id: bigint | number
    coins_per_utxo_size?: Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: number | null
    pvt_committee_normal?: number | null
    pvt_committee_no_confidence?: number | null
    pvt_hard_fork_initiation?: number | null
    dvt_motion_no_confidence?: number | null
    dvt_committee_normal?: number | null
    dvt_committee_no_confidence?: number | null
    dvt_update_to_constitution?: number | null
    dvt_hard_fork_initiation?: number | null
    dvt_p_p_network_group?: number | null
    dvt_p_p_economic_group?: number | null
    dvt_p_p_technical_group?: number | null
    dvt_p_p_gov_group?: number | null
    dvt_treasury_withdrawal?: number | null
    committee_min_size?: Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_deposit?: Decimal | DecimalJsLike | number | string | null
    drep_activity?: Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: number | null
    min_fee_ref_script_cost_per_byte?: number | null
  }

  export type param_proposalUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    min_fee_a?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    key_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_epoch?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    influence?: NullableFloatFieldUpdateOperationsInput | number | null
    monetary_expand_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    treasury_growth_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    decentralisation?: NullableFloatFieldUpdateOperationsInput | number | null
    entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    protocol_major?: NullableIntFieldUpdateOperationsInput | number | null
    protocol_minor?: NullableIntFieldUpdateOperationsInput | number | null
    min_utxo_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type param_proposalUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: NullableIntFieldUpdateOperationsInput | number | null
    key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    min_fee_a?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_fee_b?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_bh_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    key_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pool_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_epoch?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    optimal_pool_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    influence?: NullableFloatFieldUpdateOperationsInput | number | null
    monetary_expand_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    treasury_growth_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    decentralisation?: NullableFloatFieldUpdateOperationsInput | number | null
    entropy?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    protocol_major?: NullableIntFieldUpdateOperationsInput | number | null
    protocol_minor?: NullableIntFieldUpdateOperationsInput | number | null
    min_utxo_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    min_pool_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cost_model_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    price_mem?: NullableFloatFieldUpdateOperationsInput | number | null
    price_step?: NullableFloatFieldUpdateOperationsInput | number | null
    max_tx_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_tx_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_mem?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_block_ex_steps?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    max_val_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    collateral_percent?: NullableIntFieldUpdateOperationsInput | number | null
    max_collateral_inputs?: NullableIntFieldUpdateOperationsInput | number | null
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    coins_per_utxo_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_motion_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_normal?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_committee_no_confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_update_to_constitution?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_hard_fork_initiation?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_network_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_economic_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_technical_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_p_p_gov_group?: NullableFloatFieldUpdateOperationsInput | number | null
    dvt_treasury_withdrawal?: NullableFloatFieldUpdateOperationsInput | number | null
    committee_min_size?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    committee_max_term_length?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_lifetime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gov_action_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    drep_activity?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pvtpp_security_group?: NullableFloatFieldUpdateOperationsInput | number | null
    min_fee_ref_script_cost_per_byte?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type pool_hashCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
  }

  export type pool_hashUncheckedCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
  }

  export type pool_hashUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
  }

  export type pool_hashUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
  }

  export type pool_hashCreateManyInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
  }

  export type pool_hashUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
  }

  export type pool_hashUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
  }

  export type pool_metadata_refCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    url: string
    hash: Uint8Array
    registered_tx_id: bigint | number
  }

  export type pool_metadata_refUncheckedCreateInput = {
    id?: bigint | number
    pool_id: bigint | number
    url: string
    hash: Uint8Array
    registered_tx_id: bigint | number
  }

  export type pool_metadata_refUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_metadata_refUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_metadata_refCreateManyInput = {
    id?: bigint | number
    pool_id: bigint | number
    url: string
    hash: Uint8Array
    registered_tx_id: bigint | number
  }

  export type pool_metadata_refUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_metadata_refUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_ownerCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_update_id: bigint | number
  }

  export type pool_ownerUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_update_id: bigint | number
  }

  export type pool_ownerUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_update_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_ownerUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_update_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_ownerCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    pool_update_id: bigint | number
  }

  export type pool_ownerUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_update_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_ownerUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_update_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pool_relayCreateInput = {
    id?: bigint | number
    update_id: bigint | number
    ipv4?: string | null
    ipv6?: string | null
    dns_name?: string | null
    dns_srv_name?: string | null
    port?: number | null
  }

  export type pool_relayUncheckedCreateInput = {
    id?: bigint | number
    update_id: bigint | number
    ipv4?: string | null
    ipv6?: string | null
    dns_name?: string | null
    dns_srv_name?: string | null
    port?: number | null
  }

  export type pool_relayUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    update_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    ipv6?: NullableStringFieldUpdateOperationsInput | string | null
    dns_name?: NullableStringFieldUpdateOperationsInput | string | null
    dns_srv_name?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pool_relayUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    update_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    ipv6?: NullableStringFieldUpdateOperationsInput | string | null
    dns_name?: NullableStringFieldUpdateOperationsInput | string | null
    dns_srv_name?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pool_relayCreateManyInput = {
    id?: bigint | number
    update_id: bigint | number
    ipv4?: string | null
    ipv6?: string | null
    dns_name?: string | null
    dns_srv_name?: string | null
    port?: number | null
  }

  export type pool_relayUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    update_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    ipv6?: NullableStringFieldUpdateOperationsInput | string | null
    dns_name?: NullableStringFieldUpdateOperationsInput | string | null
    dns_srv_name?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pool_relayUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    update_id?: BigIntFieldUpdateOperationsInput | bigint | number
    ipv4?: NullableStringFieldUpdateOperationsInput | string | null
    ipv6?: NullableStringFieldUpdateOperationsInput | string | null
    dns_name?: NullableStringFieldUpdateOperationsInput | string | null
    dns_srv_name?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pool_retireCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    announced_tx_id: bigint | number
    retiring_epoch: number
  }

  export type pool_retireUncheckedCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    announced_tx_id: bigint | number
    retiring_epoch: number
  }

  export type pool_retireUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    announced_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    retiring_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type pool_retireUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    announced_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    retiring_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type pool_retireCreateManyInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    announced_tx_id: bigint | number
    retiring_epoch: number
  }

  export type pool_retireUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    announced_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    retiring_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type pool_retireUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    announced_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    retiring_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type pool_statCreateInput = {
    id?: bigint | number
    pool_hash_id: bigint | number
    epoch_no: number
    number_of_blocks: Decimal | DecimalJsLike | number | string
    number_of_delegators: Decimal | DecimalJsLike | number | string
    stake: Decimal | DecimalJsLike | number | string
    voting_power?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statUncheckedCreateInput = {
    id?: bigint | number
    pool_hash_id: bigint | number
    epoch_no: number
    number_of_blocks: Decimal | DecimalJsLike | number | string
    number_of_delegators: Decimal | DecimalJsLike | number | string
    stake: Decimal | DecimalJsLike | number | string
    voting_power?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    number_of_blocks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    voting_power?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    number_of_blocks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    voting_power?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statCreateManyInput = {
    id?: bigint | number
    pool_hash_id: bigint | number
    epoch_no: number
    number_of_blocks: Decimal | DecimalJsLike | number | string
    number_of_delegators: Decimal | DecimalJsLike | number | string
    stake: Decimal | DecimalJsLike | number | string
    voting_power?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    number_of_blocks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    voting_power?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_statUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    number_of_blocks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    number_of_delegators?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stake?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    voting_power?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    vrf_key_hash: Uint8Array
    pledge: Decimal | DecimalJsLike | number | string
    active_epoch_no: bigint | number
    meta_id?: bigint | number | null
    margin: number
    fixed_cost: Decimal | DecimalJsLike | number | string
    registered_tx_id: bigint | number
    reward_addr_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateUncheckedCreateInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    vrf_key_hash: Uint8Array
    pledge: Decimal | DecimalJsLike | number | string
    active_epoch_no: bigint | number
    meta_id?: bigint | number | null
    margin: number
    fixed_cost: Decimal | DecimalJsLike | number | string
    registered_tx_id: bigint | number
    reward_addr_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    vrf_key_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pledge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    fixed_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    vrf_key_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pledge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    fixed_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateCreateManyInput = {
    id?: bigint | number
    hash_id: bigint | number
    cert_index: number
    vrf_key_hash: Uint8Array
    pledge: Decimal | DecimalJsLike | number | string
    active_epoch_no: bigint | number
    meta_id?: bigint | number | null
    margin: number
    fixed_cost: Decimal | DecimalJsLike | number | string
    registered_tx_id: bigint | number
    reward_addr_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    vrf_key_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pledge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    fixed_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pool_updateUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    vrf_key_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pledge?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active_epoch_no?: BigIntFieldUpdateOperationsInput | bigint | number
    meta_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    margin?: FloatFieldUpdateOperationsInput | number
    fixed_cost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    registered_tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    reward_addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pot_transferCreateInput = {
    id?: bigint | number
    cert_index: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type pot_transferUncheckedCreateInput = {
    id?: bigint | number
    cert_index: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type pot_transferUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pot_transferUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pot_transferCreateManyInput = {
    id?: bigint | number
    cert_index: number
    treasury: Decimal | DecimalJsLike | number | string
    reserves: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type pot_transferUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type pot_transferUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    treasury?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reserves?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type redeemerCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    unit_mem: bigint | number
    unit_steps: bigint | number
    fee?: Decimal | DecimalJsLike | number | string | null
    purpose: $Enums.scriptpurposetype
    index: number
    script_hash?: Uint8Array | null
    redeemer_data_id: bigint | number
  }

  export type redeemerUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    unit_mem: bigint | number
    unit_steps: bigint | number
    fee?: Decimal | DecimalJsLike | number | string | null
    purpose: $Enums.scriptpurposetype
    index: number
    script_hash?: Uint8Array | null
    redeemer_data_id: bigint | number
  }

  export type redeemerUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_mem?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_steps?: BigIntFieldUpdateOperationsInput | bigint | number
    fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFieldUpdateOperationsInput | $Enums.scriptpurposetype
    index?: IntFieldUpdateOperationsInput | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    redeemer_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type redeemerUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_mem?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_steps?: BigIntFieldUpdateOperationsInput | bigint | number
    fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFieldUpdateOperationsInput | $Enums.scriptpurposetype
    index?: IntFieldUpdateOperationsInput | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    redeemer_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type redeemerCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    unit_mem: bigint | number
    unit_steps: bigint | number
    fee?: Decimal | DecimalJsLike | number | string | null
    purpose: $Enums.scriptpurposetype
    index: number
    script_hash?: Uint8Array | null
    redeemer_data_id: bigint | number
  }

  export type redeemerUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_mem?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_steps?: BigIntFieldUpdateOperationsInput | bigint | number
    fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFieldUpdateOperationsInput | $Enums.scriptpurposetype
    index?: IntFieldUpdateOperationsInput | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    redeemer_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type redeemerUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_mem?: BigIntFieldUpdateOperationsInput | bigint | number
    unit_steps?: BigIntFieldUpdateOperationsInput | bigint | number
    fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    purpose?: EnumscriptpurposetypeFieldUpdateOperationsInput | $Enums.scriptpurposetype
    index?: IntFieldUpdateOperationsInput | number
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    redeemer_data_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type redeemer_dataCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type redeemer_dataUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type redeemer_dataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type redeemer_dataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type redeemer_dataCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    tx_id: bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
  }

  export type redeemer_dataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type redeemer_dataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type reference_tx_inCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type reference_tx_inUncheckedCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type reference_tx_inUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type reference_tx_inUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type reference_tx_inCreateManyInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
  }

  export type reference_tx_inUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type reference_tx_inUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
  }

  export type reserveCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type reserveUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type reserveUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type reserveUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type reserveCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type reserveUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type reserveUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type reserved_pool_tickerCreateInput = {
    id?: bigint | number
    name: string
    pool_hash: Uint8Array
  }

  export type reserved_pool_tickerUncheckedCreateInput = {
    id?: bigint | number
    name: string
    pool_hash: Uint8Array
  }

  export type reserved_pool_tickerUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pool_hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type reserved_pool_tickerUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pool_hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type reserved_pool_tickerCreateManyInput = {
    id?: bigint | number
    name: string
    pool_hash: Uint8Array
  }

  export type reserved_pool_tickerUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pool_hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type reserved_pool_tickerUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pool_hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type reverse_indexCreateInput = {
    id?: bigint | number
    block_id: bigint | number
    min_ids: string
  }

  export type reverse_indexUncheckedCreateInput = {
    id?: bigint | number
    block_id: bigint | number
    min_ids: string
  }

  export type reverse_indexUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    min_ids?: StringFieldUpdateOperationsInput | string
  }

  export type reverse_indexUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    min_ids?: StringFieldUpdateOperationsInput | string
  }

  export type reverse_indexCreateManyInput = {
    id?: bigint | number
    block_id: bigint | number
    min_ids: string
  }

  export type reverse_indexUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    min_ids?: StringFieldUpdateOperationsInput | string
  }

  export type reverse_indexUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    min_ids?: StringFieldUpdateOperationsInput | string
  }

  export type rewardCreateInput = {
    addr_id: bigint | number
    type: $Enums.rewardtype
    amount: Decimal | DecimalJsLike | number | string
    spendable_epoch: bigint | number
    pool_id: bigint | number
    earned_epoch?: bigint | number
  }

  export type rewardUncheckedCreateInput = {
    addr_id: bigint | number
    type: $Enums.rewardtype
    amount: Decimal | DecimalJsLike | number | string
    spendable_epoch: bigint | number
    pool_id: bigint | number
    earned_epoch?: bigint | number
  }

  export type rewardUpdateInput = {
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumrewardtypeFieldUpdateOperationsInput | $Enums.rewardtype
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    earned_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type rewardUncheckedUpdateInput = {
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumrewardtypeFieldUpdateOperationsInput | $Enums.rewardtype
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    earned_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type rewardCreateManyInput = {
    addr_id: bigint | number
    type: $Enums.rewardtype
    amount: Decimal | DecimalJsLike | number | string
    spendable_epoch: bigint | number
    pool_id: bigint | number
    earned_epoch?: bigint | number
  }

  export type rewardUpdateManyMutationInput = {
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumrewardtypeFieldUpdateOperationsInput | $Enums.rewardtype
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    earned_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type rewardUncheckedUpdateManyInput = {
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type?: EnumrewardtypeFieldUpdateOperationsInput | $Enums.rewardtype
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    spendable_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
    pool_id?: BigIntFieldUpdateOperationsInput | bigint | number
    earned_epoch?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type schema_versionCreateInput = {
    id?: bigint | number
    stage_one: bigint | number
    stage_two: bigint | number
    stage_three: bigint | number
  }

  export type schema_versionUncheckedCreateInput = {
    id?: bigint | number
    stage_one: bigint | number
    stage_two: bigint | number
    stage_three: bigint | number
  }

  export type schema_versionUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_one?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_two?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_three?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type schema_versionUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_one?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_two?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_three?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type schema_versionCreateManyInput = {
    id?: bigint | number
    stage_one: bigint | number
    stage_two: bigint | number
    stage_three: bigint | number
  }

  export type schema_versionUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_one?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_two?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_three?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type schema_versionUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_one?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_two?: BigIntFieldUpdateOperationsInput | bigint | number
    stage_three?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type scriptCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    hash: Uint8Array
    type: $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: Uint8Array | null
    serialised_size?: number | null
  }

  export type scriptUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    hash: Uint8Array
    type: $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: Uint8Array | null
    serialised_size?: number | null
  }

  export type scriptUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumscripttypeFieldUpdateOperationsInput | $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    serialised_size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scriptUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumscripttypeFieldUpdateOperationsInput | $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    serialised_size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scriptCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    hash: Uint8Array
    type: $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: Uint8Array | null
    serialised_size?: number | null
  }

  export type scriptUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumscripttypeFieldUpdateOperationsInput | $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    serialised_size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type scriptUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumscripttypeFieldUpdateOperationsInput | $Enums.scripttype
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    serialised_size?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type slot_leaderCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    pool_hash_id?: bigint | number | null
    description: string
  }

  export type slot_leaderUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    pool_hash_id?: bigint | number | null
    description: string
  }

  export type slot_leaderUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pool_hash_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type slot_leaderUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pool_hash_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type slot_leaderCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    pool_hash_id?: bigint | number | null
    description: string
  }

  export type slot_leaderUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pool_hash_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type slot_leaderUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    pool_hash_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type stake_addressCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
    script_hash?: Uint8Array | null
  }

  export type stake_addressUncheckedCreateInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
    script_hash?: Uint8Array | null
  }

  export type stake_addressUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type stake_addressUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type stake_addressCreateManyInput = {
    id?: bigint | number
    hash_raw: Uint8Array
    view: string
    script_hash?: Uint8Array | null
  }

  export type stake_addressUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type stake_addressUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash_raw?: BytesFieldUpdateOperationsInput | Uint8Array
    view?: StringFieldUpdateOperationsInput | string
    script_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type stake_deregistrationCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type stake_deregistrationUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type stake_deregistrationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type stake_deregistrationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type stake_deregistrationCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    redeemer_id?: bigint | number | null
  }

  export type stake_deregistrationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type stake_deregistrationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type stake_registrationCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    epoch_no: number
    tx_id: bigint | number
    deposit?: Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type stake_registrationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    epoch_no?: IntFieldUpdateOperationsInput | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    deposit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type treasuryCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type treasuryUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type treasuryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type treasuryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type treasuryCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    cert_index: number
    amount: Decimal | DecimalJsLike | number | string
    tx_id: bigint | number
  }

  export type treasuryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type treasuryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    cert_index?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type treasury_withdrawalCreateInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    stake_address_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalUncheckedCreateInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    stake_address_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stake_address_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stake_address_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalCreateManyInput = {
    id?: bigint | number
    gov_action_proposal_id: bigint | number
    stake_address_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stake_address_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type treasury_withdrawalUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    stake_address_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type txCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    block_id: bigint | number
    block_index: number
    out_sum: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    deposit?: bigint | number | null
    size: number
    invalid_before?: Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: Decimal | DecimalJsLike | number | string | null
    valid_contract: boolean
    script_size: number
    treasury_donation?: Decimal | DecimalJsLike | number | string
  }

  export type txUncheckedCreateInput = {
    id?: bigint | number
    hash: Uint8Array
    block_id: bigint | number
    block_index: number
    out_sum: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    deposit?: bigint | number | null
    size: number
    invalid_before?: Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: Decimal | DecimalJsLike | number | string | null
    valid_contract: boolean
    script_size: number
    treasury_donation?: Decimal | DecimalJsLike | number | string
  }

  export type txUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_index?: IntFieldUpdateOperationsInput | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    size?: IntFieldUpdateOperationsInput | number
    invalid_before?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFieldUpdateOperationsInput | boolean
    script_size?: IntFieldUpdateOperationsInput | number
    treasury_donation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type txUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_index?: IntFieldUpdateOperationsInput | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    size?: IntFieldUpdateOperationsInput | number
    invalid_before?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFieldUpdateOperationsInput | boolean
    script_size?: IntFieldUpdateOperationsInput | number
    treasury_donation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type txCreateManyInput = {
    id?: bigint | number
    hash: Uint8Array
    block_id: bigint | number
    block_index: number
    out_sum: Decimal | DecimalJsLike | number | string
    fee: Decimal | DecimalJsLike | number | string
    deposit?: bigint | number | null
    size: number
    invalid_before?: Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: Decimal | DecimalJsLike | number | string | null
    valid_contract: boolean
    script_size: number
    treasury_donation?: Decimal | DecimalJsLike | number | string
  }

  export type txUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_index?: IntFieldUpdateOperationsInput | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    size?: IntFieldUpdateOperationsInput | number
    invalid_before?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFieldUpdateOperationsInput | boolean
    script_size?: IntFieldUpdateOperationsInput | number
    treasury_donation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type txUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
    block_index?: IntFieldUpdateOperationsInput | number
    out_sum?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deposit?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    size?: IntFieldUpdateOperationsInput | number
    invalid_before?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    invalid_hereafter?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    valid_contract?: BoolFieldUpdateOperationsInput | boolean
    script_size?: IntFieldUpdateOperationsInput | number
    treasury_donation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type tx_cborCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    bytes: Uint8Array
  }

  export type tx_cborUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    bytes: Uint8Array
  }

  export type tx_cborUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type tx_cborUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type tx_cborCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    bytes: Uint8Array
  }

  export type tx_cborUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type tx_cborUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type tx_inCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
    redeemer_id?: bigint | number | null
  }

  export type tx_inUncheckedCreateInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
    redeemer_id?: bigint | number | null
  }

  export type tx_inUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_inUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_inCreateManyInput = {
    id?: bigint | number
    tx_in_id: bigint | number
    tx_out_id: bigint | number
    tx_out_index: number
    redeemer_id?: bigint | number | null
  }

  export type tx_inUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_inUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_in_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_out_index?: IntFieldUpdateOperationsInput | number
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_metadataCreateInput = {
    id?: bigint | number
    key: Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    tx_id: bigint | number
  }

  export type tx_metadataUncheckedCreateInput = {
    id?: bigint | number
    key: Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    tx_id: bigint | number
  }

  export type tx_metadataUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type tx_metadataUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type tx_metadataCreateManyInput = {
    id?: bigint | number
    key: Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes: Uint8Array
    tx_id: bigint | number
  }

  export type tx_metadataUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type tx_metadataUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    key?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    json?: NullableJsonNullValueInput | InputJsonValue
    bytes?: BytesFieldUpdateOperationsInput | Uint8Array
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type tx_outCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
    consumed_by_tx_id?: bigint | number | null
  }

  export type tx_outUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
    consumed_by_tx_id?: bigint | number | null
  }

  export type tx_outUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    consumed_by_tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_outUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    consumed_by_tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_outCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    address: string
    address_has_script: boolean
    payment_cred?: Uint8Array | null
    stake_address_id?: bigint | number | null
    value: Decimal | DecimalJsLike | number | string
    data_hash?: Uint8Array | null
    inline_datum_id?: bigint | number | null
    reference_script_id?: bigint | number | null
    consumed_by_tx_id?: bigint | number | null
  }

  export type tx_outUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    consumed_by_tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type tx_outUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    address_has_script?: BoolFieldUpdateOperationsInput | boolean
    payment_cred?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    stake_address_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_hash?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    inline_datum_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    reference_script_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    consumed_by_tx_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type voting_anchorCreateInput = {
    id?: bigint | number
    url: string
    data_hash: Uint8Array
    type: $Enums.anchortype
    block_id: bigint | number
  }

  export type voting_anchorUncheckedCreateInput = {
    id?: bigint | number
    url: string
    data_hash: Uint8Array
    type: $Enums.anchortype
    block_id: bigint | number
  }

  export type voting_anchorUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    data_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumanchortypeFieldUpdateOperationsInput | $Enums.anchortype
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type voting_anchorUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    data_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumanchortypeFieldUpdateOperationsInput | $Enums.anchortype
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type voting_anchorCreateManyInput = {
    id?: bigint | number
    url: string
    data_hash: Uint8Array
    type: $Enums.anchortype
    block_id: bigint | number
  }

  export type voting_anchorUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    data_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumanchortypeFieldUpdateOperationsInput | $Enums.anchortype
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type voting_anchorUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    url?: StringFieldUpdateOperationsInput | string
    data_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumanchortypeFieldUpdateOperationsInput | $Enums.anchortype
    block_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type voting_procedureCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    gov_action_proposal_id: bigint | number
    voter_role: $Enums.voterrole
    drep_voter?: bigint | number | null
    pool_voter?: bigint | number | null
    vote: $Enums.vote
    voting_anchor_id?: bigint | number | null
    committee_voter?: bigint | number | null
    invalid?: bigint | number | null
  }

  export type voting_procedureUncheckedCreateInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    gov_action_proposal_id: bigint | number
    voter_role: $Enums.voterrole
    drep_voter?: bigint | number | null
    pool_voter?: bigint | number | null
    vote: $Enums.vote
    voting_anchor_id?: bigint | number | null
    committee_voter?: bigint | number | null
    invalid?: bigint | number | null
  }

  export type voting_procedureUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voter_role?: EnumvoterroleFieldUpdateOperationsInput | $Enums.voterrole
    drep_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pool_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vote?: EnumvoteFieldUpdateOperationsInput | $Enums.vote
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    committee_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invalid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type voting_procedureUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voter_role?: EnumvoterroleFieldUpdateOperationsInput | $Enums.voterrole
    drep_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pool_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vote?: EnumvoteFieldUpdateOperationsInput | $Enums.vote
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    committee_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invalid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type voting_procedureCreateManyInput = {
    id?: bigint | number
    tx_id: bigint | number
    index: number
    gov_action_proposal_id: bigint | number
    voter_role: $Enums.voterrole
    drep_voter?: bigint | number | null
    pool_voter?: bigint | number | null
    vote: $Enums.vote
    voting_anchor_id?: bigint | number | null
    committee_voter?: bigint | number | null
    invalid?: bigint | number | null
  }

  export type voting_procedureUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voter_role?: EnumvoterroleFieldUpdateOperationsInput | $Enums.voterrole
    drep_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pool_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vote?: EnumvoteFieldUpdateOperationsInput | $Enums.vote
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    committee_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invalid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type voting_procedureUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
    index?: IntFieldUpdateOperationsInput | number
    gov_action_proposal_id?: BigIntFieldUpdateOperationsInput | bigint | number
    voter_role?: EnumvoterroleFieldUpdateOperationsInput | $Enums.voterrole
    drep_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    pool_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    vote?: EnumvoteFieldUpdateOperationsInput | $Enums.vote
    voting_anchor_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    committee_voter?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    invalid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type withdrawalCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    redeemer_id?: bigint | number | null
    tx_id: bigint | number
  }

  export type withdrawalUncheckedCreateInput = {
    id?: bigint | number
    addr_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    redeemer_id?: bigint | number | null
    tx_id: bigint | number
  }

  export type withdrawalUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type withdrawalUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type withdrawalCreateManyInput = {
    id?: bigint | number
    addr_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    redeemer_id?: bigint | number | null
    tx_id: bigint | number
  }

  export type withdrawalUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type withdrawalUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    addr_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    redeemer_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    tx_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sqlx_migrationsCreateInput = {
    version: bigint | number
    description: string
    installed_on?: Date | string
    success: boolean
    checksum: Uint8Array
    execution_time: bigint | number
  }

  export type sqlx_migrationsUncheckedCreateInput = {
    version: bigint | number
    description: string
    installed_on?: Date | string
    success: boolean
    checksum: Uint8Array
    execution_time: bigint | number
  }

  export type sqlx_migrationsUpdateInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    checksum?: BytesFieldUpdateOperationsInput | Uint8Array
    execution_time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sqlx_migrationsUncheckedUpdateInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    checksum?: BytesFieldUpdateOperationsInput | Uint8Array
    execution_time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sqlx_migrationsCreateManyInput = {
    version: bigint | number
    description: string
    installed_on?: Date | string
    success: boolean
    checksum: Uint8Array
    execution_time: bigint | number
  }

  export type sqlx_migrationsUpdateManyMutationInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    checksum?: BytesFieldUpdateOperationsInput | Uint8Array
    execution_time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sqlx_migrationsUncheckedUpdateManyInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    description?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    checksum?: BytesFieldUpdateOperationsInput | Uint8Array
    execution_time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ada_potsCountOrderByAggregateInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type ada_potsAvgOrderByAggregateInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type ada_potsMaxOrderByAggregateInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type ada_potsMinOrderByAggregateInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type ada_potsSumOrderByAggregateInput = {
    id?: SortOrder
    slot_no?: SortOrder
    epoch_no?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    rewards?: SortOrder
    utxo?: SortOrder
    deposits_stake?: SortOrder
    fees?: SortOrder
    block_id?: SortOrder
    deposits_drep?: SortOrder
    deposits_proposal?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type blockCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    epoch_no?: SortOrder
    slot_no?: SortOrder
    epoch_slot_no?: SortOrder
    block_no?: SortOrder
    previous_id?: SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    time?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    vrf_key?: SortOrder
    op_cert?: SortOrder
    op_cert_counter?: SortOrder
  }

  export type blockAvgOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    slot_no?: SortOrder
    epoch_slot_no?: SortOrder
    block_no?: SortOrder
    previous_id?: SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    op_cert_counter?: SortOrder
  }

  export type blockMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    epoch_no?: SortOrder
    slot_no?: SortOrder
    epoch_slot_no?: SortOrder
    block_no?: SortOrder
    previous_id?: SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    time?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    vrf_key?: SortOrder
    op_cert?: SortOrder
    op_cert_counter?: SortOrder
  }

  export type blockMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    epoch_no?: SortOrder
    slot_no?: SortOrder
    epoch_slot_no?: SortOrder
    block_no?: SortOrder
    previous_id?: SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    time?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    vrf_key?: SortOrder
    op_cert?: SortOrder
    op_cert_counter?: SortOrder
  }

  export type blockSumOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    slot_no?: SortOrder
    epoch_slot_no?: SortOrder
    block_no?: SortOrder
    previous_id?: SortOrder
    slot_leader_id?: SortOrder
    size?: SortOrder
    tx_count?: SortOrder
    proto_major?: SortOrder
    proto_minor?: SortOrder
    op_cert_counter?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type collateral_tx_inCountOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type collateral_tx_inAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type collateral_tx_inMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type collateral_tx_inMinOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type collateral_tx_inSumOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type collateral_tx_outCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    multi_assets_descr?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
  }

  export type collateral_tx_outAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
  }

  export type collateral_tx_outMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    multi_assets_descr?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
  }

  export type collateral_tx_outMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    multi_assets_descr?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
  }

  export type collateral_tx_outSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Committee_memberListRelationFilter = {
    every?: committee_memberWhereInput
    some?: committee_memberWhereInput
    none?: committee_memberWhereInput
  }

  export type committee_memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type committeeCountOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type committeeAvgOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type committeeMaxOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type committeeMinOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type committeeSumOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type committee_de_registrationCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_de_registrationAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_de_registrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_de_registrationMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_de_registrationSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    voting_anchor_id?: SortOrder
    cold_key_id?: SortOrder
  }

  export type committee_hashRawHas_scriptCompoundUniqueInput = {
    raw: Uint8Array
    has_script: boolean
  }

  export type committee_hashCountOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    has_script?: SortOrder
  }

  export type committee_hashAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type committee_hashMaxOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    has_script?: SortOrder
  }

  export type committee_hashMinOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    has_script?: SortOrder
  }

  export type committee_hashSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommitteeScalarRelationFilter = {
    is?: committeeWhereInput
    isNot?: committeeWhereInput
  }

  export type committee_memberCountOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
  }

  export type committee_memberAvgOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
  }

  export type committee_memberMaxOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
  }

  export type committee_memberMinOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
  }

  export type committee_memberSumOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    committee_hash_id?: SortOrder
    expiration_epoch?: SortOrder
  }

  export type committee_registrationCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type committee_registrationAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type committee_registrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type committee_registrationMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type committee_registrationSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    cold_key_id?: SortOrder
    hot_key_id?: SortOrder
  }

  export type constitutionCountOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    voting_anchor_id?: SortOrder
    script_hash?: SortOrder
  }

  export type constitutionAvgOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type constitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    voting_anchor_id?: SortOrder
    script_hash?: SortOrder
  }

  export type constitutionMinOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    voting_anchor_id?: SortOrder
    script_hash?: SortOrder
  }

  export type constitutionSumOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    voting_anchor_id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type cost_modelCountOrderByAggregateInput = {
    id?: SortOrder
    costs?: SortOrder
    hash?: SortOrder
  }

  export type cost_modelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cost_modelMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
  }

  export type cost_modelMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
  }

  export type cost_modelSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type datumCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrder
    bytes?: SortOrder
  }

  export type datumAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type datumMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type datumMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type datumSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type delegationCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegationAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegationMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegationMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegationSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    pool_hash_id?: SortOrder
    active_epoch_no?: SortOrder
    tx_id?: SortOrder
    slot_no?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegation_voteCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegation_voteAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegation_voteMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegation_voteMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delegation_voteSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    drep_hash_id?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type delisted_poolCountOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
  }

  export type delisted_poolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type delisted_poolMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
  }

  export type delisted_poolMinOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
  }

  export type delisted_poolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type drep_distrHash_idEpoch_noCompoundUniqueInput = {
    hash_id: bigint | number
    epoch_no: number
  }

  export type drep_distrCountOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrder
  }

  export type drep_distrAvgOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrder
  }

  export type drep_distrMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrder
  }

  export type drep_distrMinOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrder
  }

  export type drep_distrSumOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
    active_until?: SortOrder
  }

  export type drep_hashRawHas_scriptCompoundUniqueInput = {
    raw: Uint8Array
    has_script: boolean
  }

  export type drep_hashCountOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    view?: SortOrder
    has_script?: SortOrder
  }

  export type drep_hashAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type drep_hashMaxOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    view?: SortOrder
    has_script?: SortOrder
  }

  export type drep_hashMinOrderByAggregateInput = {
    id?: SortOrder
    raw?: SortOrder
    view?: SortOrder
    has_script?: SortOrder
  }

  export type drep_hashSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type drep_registrationCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type drep_registrationAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type drep_registrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type drep_registrationMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type drep_registrationSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    cert_index?: SortOrder
    deposit?: SortOrder
    drep_hash_id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type epochCountOrderByAggregateInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type epochAvgOrderByAggregateInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
  }

  export type epochMaxOrderByAggregateInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type epochMinOrderByAggregateInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type epochSumOrderByAggregateInput = {
    id?: SortOrder
    out_sum?: SortOrder
    fees?: SortOrder
    tx_count?: SortOrder
    blk_count?: SortOrder
    no?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type epoch_paramCountOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    nonce?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    block_id?: SortOrder
    extra_entropy?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type epoch_paramAvgOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    block_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type epoch_paramMaxOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    nonce?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    block_id?: SortOrder
    extra_entropy?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type epoch_paramMinOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    nonce?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    block_id?: SortOrder
    extra_entropy?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type epoch_paramSumOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    block_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type epoch_stakeEpoch_noIdCompoundUniqueInput = {
    epoch_no: number
    id: bigint | number
  }

  export type epoch_stakeEpoch_noAddr_idPool_idCompoundUniqueInput = {
    epoch_no: number
    addr_id: bigint | number
    pool_id: bigint | number
  }

  export type epoch_stakeCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stakeAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stakeMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stakeMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stakeSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_id?: SortOrder
    amount?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stake_progressCountOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    completed?: SortOrder
  }

  export type epoch_stake_progressAvgOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stake_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    completed?: SortOrder
  }

  export type epoch_stake_progressMinOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    completed?: SortOrder
  }

  export type epoch_stake_progressSumOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateCountOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    no_confidence_id?: SortOrder
    constitution_id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateAvgOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    no_confidence_id?: SortOrder
    constitution_id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateMaxOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    no_confidence_id?: SortOrder
    constitution_id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateMinOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    no_confidence_id?: SortOrder
    constitution_id?: SortOrder
    epoch_no?: SortOrder
  }

  export type epoch_stateSumOrderByAggregateInput = {
    id?: SortOrder
    committee_id?: SortOrder
    no_confidence_id?: SortOrder
    constitution_id?: SortOrder
    epoch_no?: SortOrder
  }

  export type EnumsyncstatetypeFilter<$PrismaModel = never> = {
    equals?: $Enums.syncstatetype | EnumsyncstatetypeFieldRefInput<$PrismaModel>
    in?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumsyncstatetypeFilter<$PrismaModel> | $Enums.syncstatetype
  }

  export type epoch_sync_timeCountOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
    state?: SortOrder
  }

  export type epoch_sync_timeAvgOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
  }

  export type epoch_sync_timeMaxOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
    state?: SortOrder
  }

  export type epoch_sync_timeMinOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
    state?: SortOrder
  }

  export type epoch_sync_timeSumOrderByAggregateInput = {
    id?: SortOrder
    no?: SortOrder
    seconds?: SortOrder
  }

  export type EnumsyncstatetypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.syncstatetype | EnumsyncstatetypeFieldRefInput<$PrismaModel>
    in?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumsyncstatetypeWithAggregatesFilter<$PrismaModel> | $Enums.syncstatetype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsyncstatetypeFilter<$PrismaModel>
    _max?: NestedEnumsyncstatetypeFilter<$PrismaModel>
  }

  export type event_infoCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    epoch?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
  }

  export type event_infoAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    epoch?: SortOrder
  }

  export type event_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    epoch?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
  }

  export type event_infoMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    epoch?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
  }

  export type event_infoSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    epoch?: SortOrder
  }

  export type extra_key_witnessCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_key_witnessAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_key_witnessMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_key_witnessMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_key_witnessSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type extra_migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    description?: SortOrder
  }

  export type extra_migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type extra_migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    description?: SortOrder
  }

  export type extra_migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    description?: SortOrder
  }

  export type extra_migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumgovactiontypeFilter<$PrismaModel = never> = {
    equals?: $Enums.govactiontype | EnumgovactiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumgovactiontypeFilter<$PrismaModel> | $Enums.govactiontype
  }

  export type gov_action_proposalCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrder
    voting_anchor_id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    param_proposal?: SortOrder
    ratified_epoch?: SortOrder
    enacted_epoch?: SortOrder
    dropped_epoch?: SortOrder
    expired_epoch?: SortOrder
  }

  export type gov_action_proposalAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrder
    voting_anchor_id?: SortOrder
    param_proposal?: SortOrder
    ratified_epoch?: SortOrder
    enacted_epoch?: SortOrder
    dropped_epoch?: SortOrder
    expired_epoch?: SortOrder
  }

  export type gov_action_proposalMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrder
    voting_anchor_id?: SortOrder
    type?: SortOrder
    param_proposal?: SortOrder
    ratified_epoch?: SortOrder
    enacted_epoch?: SortOrder
    dropped_epoch?: SortOrder
    expired_epoch?: SortOrder
  }

  export type gov_action_proposalMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrder
    voting_anchor_id?: SortOrder
    type?: SortOrder
    param_proposal?: SortOrder
    ratified_epoch?: SortOrder
    enacted_epoch?: SortOrder
    dropped_epoch?: SortOrder
    expired_epoch?: SortOrder
  }

  export type gov_action_proposalSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    prev_gov_action_proposal?: SortOrder
    deposit?: SortOrder
    return_address?: SortOrder
    expiration?: SortOrder
    voting_anchor_id?: SortOrder
    param_proposal?: SortOrder
    ratified_epoch?: SortOrder
    enacted_epoch?: SortOrder
    dropped_epoch?: SortOrder
    expired_epoch?: SortOrder
  }

  export type EnumgovactiontypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.govactiontype | EnumgovactiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumgovactiontypeWithAggregatesFilter<$PrismaModel> | $Enums.govactiontype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgovactiontypeFilter<$PrismaModel>
    _max?: NestedEnumgovactiontypeFilter<$PrismaModel>
  }

  export type ma_tx_mintCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_mintAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_mintMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_mintMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_mintSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type ma_tx_outSumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    tx_out_id?: SortOrder
    ident?: SortOrder
  }

  export type metaCountOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    network_name?: SortOrder
    version?: SortOrder
  }

  export type metaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type metaMaxOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    network_name?: SortOrder
    version?: SortOrder
  }

  export type metaMinOrderByAggregateInput = {
    id?: SortOrder
    start_time?: SortOrder
    network_name?: SortOrder
    version?: SortOrder
  }

  export type metaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type multi_assetPolicyNameCompoundUniqueInput = {
    policy: Uint8Array
    name: Uint8Array
  }

  export type multi_assetCountOrderByAggregateInput = {
    id?: SortOrder
    policy?: SortOrder
    name?: SortOrder
    fingerprint?: SortOrder
  }

  export type multi_assetAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type multi_assetMaxOrderByAggregateInput = {
    id?: SortOrder
    policy?: SortOrder
    name?: SortOrder
    fingerprint?: SortOrder
  }

  export type multi_assetMinOrderByAggregateInput = {
    id?: SortOrder
    policy?: SortOrder
    name?: SortOrder
    fingerprint?: SortOrder
  }

  export type multi_assetSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type new_committeeCountOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    deleted_members?: SortOrder
    added_members?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type new_committeeAvgOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type new_committeeMaxOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    deleted_members?: SortOrder
    added_members?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type new_committeeMinOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    deleted_members?: SortOrder
    added_members?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type new_committeeSumOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    quorum_numerator?: SortOrder
    quorum_denominator?: SortOrder
  }

  export type off_chain_pool_dataPool_idPmr_idCompoundUniqueInput = {
    pool_id: bigint | number
    pmr_id: bigint | number
  }

  export type off_chain_pool_dataCountOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    ticker_name?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_dataAvgOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    ticker_name?: SortOrder
    hash?: SortOrder
    bytes?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_dataMinOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    ticker_name?: SortOrder
    hash?: SortOrder
    bytes?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_dataSumOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    pmr_id?: SortOrder
  }

  export type off_chain_pool_fetch_errorPool_idFetch_timeRetry_countCompoundUniqueInput = {
    pool_id: bigint | number
    fetch_time: Date | string
    retry_count: number
  }

  export type off_chain_pool_fetch_errorCountOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    fetch_time?: SortOrder
    pmr_id?: SortOrder
    fetch_error?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_pool_fetch_errorAvgOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    pmr_id?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_pool_fetch_errorMaxOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    fetch_time?: SortOrder
    pmr_id?: SortOrder
    fetch_error?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_pool_fetch_errorMinOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    fetch_time?: SortOrder
    pmr_id?: SortOrder
    fetch_error?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_pool_fetch_errorSumOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    pmr_id?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_authorCountOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    name?: SortOrder
    witness_algorithm?: SortOrder
    public_key?: SortOrder
    signature?: SortOrder
    warning?: SortOrder
  }

  export type off_chain_vote_authorAvgOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_authorMaxOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    name?: SortOrder
    witness_algorithm?: SortOrder
    public_key?: SortOrder
    signature?: SortOrder
    warning?: SortOrder
  }

  export type off_chain_vote_authorMinOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    name?: SortOrder
    witness_algorithm?: SortOrder
    public_key?: SortOrder
    signature?: SortOrder
    warning?: SortOrder
  }

  export type off_chain_vote_authorSumOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type off_chain_vote_dataVoting_anchor_idHashCompoundUniqueInput = {
    voting_anchor_id: bigint | number
    hash: Uint8Array
  }

  export type off_chain_vote_dataCountOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    hash?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    warning?: SortOrder
    language?: SortOrder
    comment?: SortOrder
    is_valid?: SortOrder
  }

  export type off_chain_vote_dataAvgOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type off_chain_vote_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    hash?: SortOrder
    bytes?: SortOrder
    warning?: SortOrder
    language?: SortOrder
    comment?: SortOrder
    is_valid?: SortOrder
  }

  export type off_chain_vote_dataMinOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    hash?: SortOrder
    bytes?: SortOrder
    warning?: SortOrder
    language?: SortOrder
    comment?: SortOrder
    is_valid?: SortOrder
  }

  export type off_chain_vote_dataSumOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type off_chain_vote_drep_dataCountOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    payment_address?: SortOrder
    given_name?: SortOrder
    objectives?: SortOrder
    motivations?: SortOrder
    qualifications?: SortOrder
    image_url?: SortOrder
    image_hash?: SortOrder
  }

  export type off_chain_vote_drep_dataAvgOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_drep_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    payment_address?: SortOrder
    given_name?: SortOrder
    objectives?: SortOrder
    motivations?: SortOrder
    qualifications?: SortOrder
    image_url?: SortOrder
    image_hash?: SortOrder
  }

  export type off_chain_vote_drep_dataMinOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    payment_address?: SortOrder
    given_name?: SortOrder
    objectives?: SortOrder
    motivations?: SortOrder
    qualifications?: SortOrder
    image_url?: SortOrder
    image_hash?: SortOrder
  }

  export type off_chain_vote_drep_dataSumOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_external_updateCountOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    uri?: SortOrder
  }

  export type off_chain_vote_external_updateAvgOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_external_updateMaxOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    uri?: SortOrder
  }

  export type off_chain_vote_external_updateMinOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    uri?: SortOrder
  }

  export type off_chain_vote_external_updateSumOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_fetch_errorVoting_anchor_idRetry_countCompoundUniqueInput = {
    voting_anchor_id: bigint | number
    retry_count: number
  }

  export type off_chain_vote_fetch_errorCountOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    fetch_error?: SortOrder
    fetch_time?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_fetch_errorAvgOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_fetch_errorMaxOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    fetch_error?: SortOrder
    fetch_time?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_fetch_errorMinOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    fetch_error?: SortOrder
    fetch_time?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_fetch_errorSumOrderByAggregateInput = {
    id?: SortOrder
    voting_anchor_id?: SortOrder
    retry_count?: SortOrder
  }

  export type off_chain_vote_gov_action_dataCountOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    motivation?: SortOrder
    rationale?: SortOrder
  }

  export type off_chain_vote_gov_action_dataAvgOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_gov_action_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    motivation?: SortOrder
    rationale?: SortOrder
  }

  export type off_chain_vote_gov_action_dataMinOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    motivation?: SortOrder
    rationale?: SortOrder
  }

  export type off_chain_vote_gov_action_dataSumOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_referenceCountOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    label?: SortOrder
    uri?: SortOrder
    hash_digest?: SortOrder
    hash_algorithm?: SortOrder
  }

  export type off_chain_vote_referenceAvgOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type off_chain_vote_referenceMaxOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    label?: SortOrder
    uri?: SortOrder
    hash_digest?: SortOrder
    hash_algorithm?: SortOrder
  }

  export type off_chain_vote_referenceMinOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
    label?: SortOrder
    uri?: SortOrder
    hash_digest?: SortOrder
    hash_algorithm?: SortOrder
  }

  export type off_chain_vote_referenceSumOrderByAggregateInput = {
    id?: SortOrder
    off_chain_vote_data_id?: SortOrder
  }

  export type param_proposalCountOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    key?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    entropy?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type param_proposalAvgOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type param_proposalMaxOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    key?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    entropy?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type param_proposalMinOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    key?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    entropy?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type param_proposalSumOrderByAggregateInput = {
    id?: SortOrder
    epoch_no?: SortOrder
    min_fee_a?: SortOrder
    min_fee_b?: SortOrder
    max_block_size?: SortOrder
    max_tx_size?: SortOrder
    max_bh_size?: SortOrder
    key_deposit?: SortOrder
    pool_deposit?: SortOrder
    max_epoch?: SortOrder
    optimal_pool_count?: SortOrder
    influence?: SortOrder
    monetary_expand_rate?: SortOrder
    treasury_growth_rate?: SortOrder
    decentralisation?: SortOrder
    protocol_major?: SortOrder
    protocol_minor?: SortOrder
    min_utxo_value?: SortOrder
    min_pool_cost?: SortOrder
    cost_model_id?: SortOrder
    price_mem?: SortOrder
    price_step?: SortOrder
    max_tx_ex_mem?: SortOrder
    max_tx_ex_steps?: SortOrder
    max_block_ex_mem?: SortOrder
    max_block_ex_steps?: SortOrder
    max_val_size?: SortOrder
    collateral_percent?: SortOrder
    max_collateral_inputs?: SortOrder
    registered_tx_id?: SortOrder
    coins_per_utxo_size?: SortOrder
    pvt_motion_no_confidence?: SortOrder
    pvt_committee_normal?: SortOrder
    pvt_committee_no_confidence?: SortOrder
    pvt_hard_fork_initiation?: SortOrder
    dvt_motion_no_confidence?: SortOrder
    dvt_committee_normal?: SortOrder
    dvt_committee_no_confidence?: SortOrder
    dvt_update_to_constitution?: SortOrder
    dvt_hard_fork_initiation?: SortOrder
    dvt_p_p_network_group?: SortOrder
    dvt_p_p_economic_group?: SortOrder
    dvt_p_p_technical_group?: SortOrder
    dvt_p_p_gov_group?: SortOrder
    dvt_treasury_withdrawal?: SortOrder
    committee_min_size?: SortOrder
    committee_max_term_length?: SortOrder
    gov_action_lifetime?: SortOrder
    gov_action_deposit?: SortOrder
    drep_deposit?: SortOrder
    drep_activity?: SortOrder
    pvtpp_security_group?: SortOrder
    min_fee_ref_script_cost_per_byte?: SortOrder
  }

  export type pool_hashCountOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
  }

  export type pool_hashAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pool_hashMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
  }

  export type pool_hashMinOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
  }

  export type pool_hashSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pool_metadata_refCountOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    url?: SortOrder
    hash?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_metadata_refAvgOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_metadata_refMaxOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    url?: SortOrder
    hash?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_metadata_refMinOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    url?: SortOrder
    hash?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_metadata_refSumOrderByAggregateInput = {
    id?: SortOrder
    pool_id?: SortOrder
    registered_tx_id?: SortOrder
  }

  export type pool_ownerCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_ownerAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_ownerMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_ownerMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_ownerSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    pool_update_id?: SortOrder
  }

  export type pool_relayCountOrderByAggregateInput = {
    id?: SortOrder
    update_id?: SortOrder
    ipv4?: SortOrder
    ipv6?: SortOrder
    dns_name?: SortOrder
    dns_srv_name?: SortOrder
    port?: SortOrder
  }

  export type pool_relayAvgOrderByAggregateInput = {
    id?: SortOrder
    update_id?: SortOrder
    port?: SortOrder
  }

  export type pool_relayMaxOrderByAggregateInput = {
    id?: SortOrder
    update_id?: SortOrder
    ipv4?: SortOrder
    ipv6?: SortOrder
    dns_name?: SortOrder
    dns_srv_name?: SortOrder
    port?: SortOrder
  }

  export type pool_relayMinOrderByAggregateInput = {
    id?: SortOrder
    update_id?: SortOrder
    ipv4?: SortOrder
    ipv6?: SortOrder
    dns_name?: SortOrder
    dns_srv_name?: SortOrder
    port?: SortOrder
  }

  export type pool_relaySumOrderByAggregateInput = {
    id?: SortOrder
    update_id?: SortOrder
    port?: SortOrder
  }

  export type pool_retireCountOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_retireAvgOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_retireMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_retireMinOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_retireSumOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    announced_tx_id?: SortOrder
    retiring_epoch?: SortOrder
  }

  export type pool_statCountOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrder
  }

  export type pool_statAvgOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrder
  }

  export type pool_statMaxOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrder
  }

  export type pool_statMinOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrder
  }

  export type pool_statSumOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
    epoch_no?: SortOrder
    number_of_blocks?: SortOrder
    number_of_delegators?: SortOrder
    stake?: SortOrder
    voting_power?: SortOrder
  }

  export type pool_updateCountOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    vrf_key_hash?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrder
  }

  export type pool_updateAvgOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrder
  }

  export type pool_updateMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    vrf_key_hash?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrder
  }

  export type pool_updateMinOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    vrf_key_hash?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrder
  }

  export type pool_updateSumOrderByAggregateInput = {
    id?: SortOrder
    hash_id?: SortOrder
    cert_index?: SortOrder
    pledge?: SortOrder
    active_epoch_no?: SortOrder
    meta_id?: SortOrder
    margin?: SortOrder
    fixed_cost?: SortOrder
    registered_tx_id?: SortOrder
    reward_addr_id?: SortOrder
    deposit?: SortOrder
  }

  export type pot_transferCountOrderByAggregateInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type pot_transferAvgOrderByAggregateInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type pot_transferMaxOrderByAggregateInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type pot_transferMinOrderByAggregateInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type pot_transferSumOrderByAggregateInput = {
    id?: SortOrder
    cert_index?: SortOrder
    treasury?: SortOrder
    reserves?: SortOrder
    tx_id?: SortOrder
  }

  export type EnumscriptpurposetypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scriptpurposetype | EnumscriptpurposetypeFieldRefInput<$PrismaModel>
    in?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscriptpurposetypeFilter<$PrismaModel> | $Enums.scriptpurposetype
  }

  export type redeemerCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrder
    purpose?: SortOrder
    index?: SortOrder
    script_hash?: SortOrder
    redeemer_data_id?: SortOrder
  }

  export type redeemerAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrder
    index?: SortOrder
    redeemer_data_id?: SortOrder
  }

  export type redeemerMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrder
    purpose?: SortOrder
    index?: SortOrder
    script_hash?: SortOrder
    redeemer_data_id?: SortOrder
  }

  export type redeemerMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrder
    purpose?: SortOrder
    index?: SortOrder
    script_hash?: SortOrder
    redeemer_data_id?: SortOrder
  }

  export type redeemerSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    unit_mem?: SortOrder
    unit_steps?: SortOrder
    fee?: SortOrder
    index?: SortOrder
    redeemer_data_id?: SortOrder
  }

  export type EnumscriptpurposetypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scriptpurposetype | EnumscriptpurposetypeFieldRefInput<$PrismaModel>
    in?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscriptpurposetypeWithAggregatesFilter<$PrismaModel> | $Enums.scriptpurposetype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscriptpurposetypeFilter<$PrismaModel>
    _max?: NestedEnumscriptpurposetypeFilter<$PrismaModel>
  }

  export type redeemer_dataCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    value?: SortOrder
    bytes?: SortOrder
  }

  export type redeemer_dataAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type redeemer_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type redeemer_dataMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type redeemer_dataSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type reference_tx_inCountOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reference_tx_inAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reference_tx_inMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reference_tx_inMinOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reference_tx_inSumOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
  }

  export type reserveCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserveAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserveMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserveMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserveSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type reserved_pool_tickerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pool_hash?: SortOrder
  }

  export type reserved_pool_tickerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type reserved_pool_tickerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pool_hash?: SortOrder
  }

  export type reserved_pool_tickerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pool_hash?: SortOrder
  }

  export type reserved_pool_tickerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type reverse_indexCountOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
    min_ids?: SortOrder
  }

  export type reverse_indexAvgOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
  }

  export type reverse_indexMaxOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
    min_ids?: SortOrder
  }

  export type reverse_indexMinOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
    min_ids?: SortOrder
  }

  export type reverse_indexSumOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
  }

  export type EnumrewardtypeFilter<$PrismaModel = never> = {
    equals?: $Enums.rewardtype | EnumrewardtypeFieldRefInput<$PrismaModel>
    in?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumrewardtypeFilter<$PrismaModel> | $Enums.rewardtype
  }

  export type rewardAddr_idTypeEarned_epochPool_idCompoundUniqueInput = {
    addr_id: bigint | number
    type: $Enums.rewardtype
    earned_epoch: bigint | number
    pool_id: bigint | number
  }

  export type rewardCountOrderByAggregateInput = {
    addr_id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type rewardAvgOrderByAggregateInput = {
    addr_id?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type rewardMaxOrderByAggregateInput = {
    addr_id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type rewardMinOrderByAggregateInput = {
    addr_id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type rewardSumOrderByAggregateInput = {
    addr_id?: SortOrder
    amount?: SortOrder
    spendable_epoch?: SortOrder
    pool_id?: SortOrder
    earned_epoch?: SortOrder
  }

  export type EnumrewardtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rewardtype | EnumrewardtypeFieldRefInput<$PrismaModel>
    in?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumrewardtypeWithAggregatesFilter<$PrismaModel> | $Enums.rewardtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrewardtypeFilter<$PrismaModel>
    _max?: NestedEnumrewardtypeFilter<$PrismaModel>
  }

  export type schema_versionCountOrderByAggregateInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type schema_versionAvgOrderByAggregateInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type schema_versionMaxOrderByAggregateInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type schema_versionMinOrderByAggregateInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type schema_versionSumOrderByAggregateInput = {
    id?: SortOrder
    stage_one?: SortOrder
    stage_two?: SortOrder
    stage_three?: SortOrder
  }

  export type EnumscripttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scripttype | EnumscripttypeFieldRefInput<$PrismaModel>
    in?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscripttypeFilter<$PrismaModel> | $Enums.scripttype
  }

  export type scriptCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    hash?: SortOrder
    type?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    serialised_size?: SortOrder
  }

  export type scriptAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    serialised_size?: SortOrder
  }

  export type scriptMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    hash?: SortOrder
    type?: SortOrder
    bytes?: SortOrder
    serialised_size?: SortOrder
  }

  export type scriptMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    hash?: SortOrder
    type?: SortOrder
    bytes?: SortOrder
    serialised_size?: SortOrder
  }

  export type scriptSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    serialised_size?: SortOrder
  }

  export type EnumscripttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scripttype | EnumscripttypeFieldRefInput<$PrismaModel>
    in?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscripttypeWithAggregatesFilter<$PrismaModel> | $Enums.scripttype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscripttypeFilter<$PrismaModel>
    _max?: NestedEnumscripttypeFilter<$PrismaModel>
  }

  export type slot_leaderCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    pool_hash_id?: SortOrder
    description?: SortOrder
  }

  export type slot_leaderAvgOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
  }

  export type slot_leaderMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    pool_hash_id?: SortOrder
    description?: SortOrder
  }

  export type slot_leaderMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    pool_hash_id?: SortOrder
    description?: SortOrder
  }

  export type slot_leaderSumOrderByAggregateInput = {
    id?: SortOrder
    pool_hash_id?: SortOrder
  }

  export type stake_addressCountOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    script_hash?: SortOrder
  }

  export type stake_addressAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type stake_addressMaxOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    script_hash?: SortOrder
  }

  export type stake_addressMinOrderByAggregateInput = {
    id?: SortOrder
    hash_raw?: SortOrder
    view?: SortOrder
    script_hash?: SortOrder
  }

  export type stake_addressSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type stake_deregistrationCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type stake_deregistrationAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type stake_deregistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type stake_deregistrationMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type stake_deregistrationSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    redeemer_id?: SortOrder
  }

  export type stake_registrationCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrder
  }

  export type stake_registrationAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrder
  }

  export type stake_registrationMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrder
  }

  export type stake_registrationMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrder
  }

  export type stake_registrationSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    epoch_no?: SortOrder
    tx_id?: SortOrder
    deposit?: SortOrder
  }

  export type treasuryCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasuryAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasuryMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasuryMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasurySumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    cert_index?: SortOrder
    amount?: SortOrder
    tx_id?: SortOrder
  }

  export type treasury_withdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type treasury_withdrawalAvgOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type treasury_withdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type treasury_withdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type treasury_withdrawalSumOrderByAggregateInput = {
    id?: SortOrder
    gov_action_proposal_id?: SortOrder
    stake_address_id?: SortOrder
    amount?: SortOrder
  }

  export type txCountOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrder
    size?: SortOrder
    invalid_before?: SortOrder
    invalid_hereafter?: SortOrder
    valid_contract?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type txAvgOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrder
    size?: SortOrder
    invalid_before?: SortOrder
    invalid_hereafter?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type txMaxOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrder
    size?: SortOrder
    invalid_before?: SortOrder
    invalid_hereafter?: SortOrder
    valid_contract?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type txMinOrderByAggregateInput = {
    id?: SortOrder
    hash?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrder
    size?: SortOrder
    invalid_before?: SortOrder
    invalid_hereafter?: SortOrder
    valid_contract?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type txSumOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
    block_index?: SortOrder
    out_sum?: SortOrder
    fee?: SortOrder
    deposit?: SortOrder
    size?: SortOrder
    invalid_before?: SortOrder
    invalid_hereafter?: SortOrder
    script_size?: SortOrder
    treasury_donation?: SortOrder
  }

  export type tx_cborCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type tx_cborAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_cborMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type tx_cborMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    bytes?: SortOrder
  }

  export type tx_cborSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_inCountOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrder
  }

  export type tx_inAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrder
  }

  export type tx_inMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrder
  }

  export type tx_inMinOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrder
  }

  export type tx_inSumOrderByAggregateInput = {
    id?: SortOrder
    tx_in_id?: SortOrder
    tx_out_id?: SortOrder
    tx_out_index?: SortOrder
    redeemer_id?: SortOrder
  }

  export type tx_metadataCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    json?: SortOrder
    bytes?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_metadataAvgOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_metadataMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    bytes?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_metadataMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    bytes?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_metadataSumOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    tx_id?: SortOrder
  }

  export type tx_outTx_idIndexCompoundUniqueInput = {
    tx_id: bigint | number
    index: number
  }

  export type tx_outCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
    consumed_by_tx_id?: SortOrder
  }

  export type tx_outAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
    consumed_by_tx_id?: SortOrder
  }

  export type tx_outMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
    consumed_by_tx_id?: SortOrder
  }

  export type tx_outMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    address?: SortOrder
    address_has_script?: SortOrder
    payment_cred?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    data_hash?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
    consumed_by_tx_id?: SortOrder
  }

  export type tx_outSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    stake_address_id?: SortOrder
    value?: SortOrder
    inline_datum_id?: SortOrder
    reference_script_id?: SortOrder
    consumed_by_tx_id?: SortOrder
  }

  export type EnumanchortypeFilter<$PrismaModel = never> = {
    equals?: $Enums.anchortype | EnumanchortypeFieldRefInput<$PrismaModel>
    in?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    not?: NestedEnumanchortypeFilter<$PrismaModel> | $Enums.anchortype
  }

  export type voting_anchorData_hashUrlTypeCompoundUniqueInput = {
    data_hash: Uint8Array
    url: string
    type: $Enums.anchortype
  }

  export type voting_anchorCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    data_hash?: SortOrder
    type?: SortOrder
    block_id?: SortOrder
  }

  export type voting_anchorAvgOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
  }

  export type voting_anchorMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    data_hash?: SortOrder
    type?: SortOrder
    block_id?: SortOrder
  }

  export type voting_anchorMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    data_hash?: SortOrder
    type?: SortOrder
    block_id?: SortOrder
  }

  export type voting_anchorSumOrderByAggregateInput = {
    id?: SortOrder
    block_id?: SortOrder
  }

  export type EnumanchortypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.anchortype | EnumanchortypeFieldRefInput<$PrismaModel>
    in?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    not?: NestedEnumanchortypeWithAggregatesFilter<$PrismaModel> | $Enums.anchortype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumanchortypeFilter<$PrismaModel>
    _max?: NestedEnumanchortypeFilter<$PrismaModel>
  }

  export type EnumvoterroleFilter<$PrismaModel = never> = {
    equals?: $Enums.voterrole | EnumvoterroleFieldRefInput<$PrismaModel>
    in?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    not?: NestedEnumvoterroleFilter<$PrismaModel> | $Enums.voterrole
  }

  export type EnumvoteFilter<$PrismaModel = never> = {
    equals?: $Enums.vote | EnumvoteFieldRefInput<$PrismaModel>
    in?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    notIn?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    not?: NestedEnumvoteFilter<$PrismaModel> | $Enums.vote
  }

  export type voting_procedureCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    voter_role?: SortOrder
    drep_voter?: SortOrder
    pool_voter?: SortOrder
    vote?: SortOrder
    voting_anchor_id?: SortOrder
    committee_voter?: SortOrder
    invalid?: SortOrder
  }

  export type voting_procedureAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    drep_voter?: SortOrder
    pool_voter?: SortOrder
    voting_anchor_id?: SortOrder
    committee_voter?: SortOrder
    invalid?: SortOrder
  }

  export type voting_procedureMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    voter_role?: SortOrder
    drep_voter?: SortOrder
    pool_voter?: SortOrder
    vote?: SortOrder
    voting_anchor_id?: SortOrder
    committee_voter?: SortOrder
    invalid?: SortOrder
  }

  export type voting_procedureMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    voter_role?: SortOrder
    drep_voter?: SortOrder
    pool_voter?: SortOrder
    vote?: SortOrder
    voting_anchor_id?: SortOrder
    committee_voter?: SortOrder
    invalid?: SortOrder
  }

  export type voting_procedureSumOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    index?: SortOrder
    gov_action_proposal_id?: SortOrder
    drep_voter?: SortOrder
    pool_voter?: SortOrder
    voting_anchor_id?: SortOrder
    committee_voter?: SortOrder
    invalid?: SortOrder
  }

  export type EnumvoterroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.voterrole | EnumvoterroleFieldRefInput<$PrismaModel>
    in?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    not?: NestedEnumvoterroleWithAggregatesFilter<$PrismaModel> | $Enums.voterrole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvoterroleFilter<$PrismaModel>
    _max?: NestedEnumvoterroleFilter<$PrismaModel>
  }

  export type EnumvoteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.vote | EnumvoteFieldRefInput<$PrismaModel>
    in?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    notIn?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    not?: NestedEnumvoteWithAggregatesFilter<$PrismaModel> | $Enums.vote
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvoteFilter<$PrismaModel>
    _max?: NestedEnumvoteFilter<$PrismaModel>
  }

  export type withdrawalCountOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrder
    tx_id?: SortOrder
  }

  export type withdrawalAvgOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrder
    tx_id?: SortOrder
  }

  export type withdrawalMaxOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrder
    tx_id?: SortOrder
  }

  export type withdrawalMinOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrder
    tx_id?: SortOrder
  }

  export type withdrawalSumOrderByAggregateInput = {
    id?: SortOrder
    addr_id?: SortOrder
    amount?: SortOrder
    redeemer_id?: SortOrder
    tx_id?: SortOrder
  }

  export type sqlx_migrationsCountOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    installed_on?: SortOrder
    success?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type sqlx_migrationsAvgOrderByAggregateInput = {
    version?: SortOrder
    execution_time?: SortOrder
  }

  export type sqlx_migrationsMaxOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    installed_on?: SortOrder
    success?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type sqlx_migrationsMinOrderByAggregateInput = {
    version?: SortOrder
    description?: SortOrder
    installed_on?: SortOrder
    success?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type sqlx_migrationsSumOrderByAggregateInput = {
    version?: SortOrder
    execution_time?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type committee_memberCreateNestedManyWithoutCommitteeInput = {
    create?: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput> | committee_memberCreateWithoutCommitteeInput[] | committee_memberUncheckedCreateWithoutCommitteeInput[]
    connectOrCreate?: committee_memberCreateOrConnectWithoutCommitteeInput | committee_memberCreateOrConnectWithoutCommitteeInput[]
    createMany?: committee_memberCreateManyCommitteeInputEnvelope
    connect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
  }

  export type committee_memberUncheckedCreateNestedManyWithoutCommitteeInput = {
    create?: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput> | committee_memberCreateWithoutCommitteeInput[] | committee_memberUncheckedCreateWithoutCommitteeInput[]
    connectOrCreate?: committee_memberCreateOrConnectWithoutCommitteeInput | committee_memberCreateOrConnectWithoutCommitteeInput[]
    createMany?: committee_memberCreateManyCommitteeInputEnvelope
    connect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
  }

  export type committee_memberUpdateManyWithoutCommitteeNestedInput = {
    create?: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput> | committee_memberCreateWithoutCommitteeInput[] | committee_memberUncheckedCreateWithoutCommitteeInput[]
    connectOrCreate?: committee_memberCreateOrConnectWithoutCommitteeInput | committee_memberCreateOrConnectWithoutCommitteeInput[]
    upsert?: committee_memberUpsertWithWhereUniqueWithoutCommitteeInput | committee_memberUpsertWithWhereUniqueWithoutCommitteeInput[]
    createMany?: committee_memberCreateManyCommitteeInputEnvelope
    set?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    disconnect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    delete?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    connect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    update?: committee_memberUpdateWithWhereUniqueWithoutCommitteeInput | committee_memberUpdateWithWhereUniqueWithoutCommitteeInput[]
    updateMany?: committee_memberUpdateManyWithWhereWithoutCommitteeInput | committee_memberUpdateManyWithWhereWithoutCommitteeInput[]
    deleteMany?: committee_memberScalarWhereInput | committee_memberScalarWhereInput[]
  }

  export type committee_memberUncheckedUpdateManyWithoutCommitteeNestedInput = {
    create?: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput> | committee_memberCreateWithoutCommitteeInput[] | committee_memberUncheckedCreateWithoutCommitteeInput[]
    connectOrCreate?: committee_memberCreateOrConnectWithoutCommitteeInput | committee_memberCreateOrConnectWithoutCommitteeInput[]
    upsert?: committee_memberUpsertWithWhereUniqueWithoutCommitteeInput | committee_memberUpsertWithWhereUniqueWithoutCommitteeInput[]
    createMany?: committee_memberCreateManyCommitteeInputEnvelope
    set?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    disconnect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    delete?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    connect?: committee_memberWhereUniqueInput | committee_memberWhereUniqueInput[]
    update?: committee_memberUpdateWithWhereUniqueWithoutCommitteeInput | committee_memberUpdateWithWhereUniqueWithoutCommitteeInput[]
    updateMany?: committee_memberUpdateManyWithWhereWithoutCommitteeInput | committee_memberUpdateManyWithWhereWithoutCommitteeInput[]
    deleteMany?: committee_memberScalarWhereInput | committee_memberScalarWhereInput[]
  }

  export type committeeCreateNestedOneWithoutCommittee_memberInput = {
    create?: XOR<committeeCreateWithoutCommittee_memberInput, committeeUncheckedCreateWithoutCommittee_memberInput>
    connectOrCreate?: committeeCreateOrConnectWithoutCommittee_memberInput
    connect?: committeeWhereUniqueInput
  }

  export type committeeUpdateOneRequiredWithoutCommittee_memberNestedInput = {
    create?: XOR<committeeCreateWithoutCommittee_memberInput, committeeUncheckedCreateWithoutCommittee_memberInput>
    connectOrCreate?: committeeCreateOrConnectWithoutCommittee_memberInput
    upsert?: committeeUpsertWithoutCommittee_memberInput
    connect?: committeeWhereUniqueInput
    update?: XOR<XOR<committeeUpdateToOneWithWhereWithoutCommittee_memberInput, committeeUpdateWithoutCommittee_memberInput>, committeeUncheckedUpdateWithoutCommittee_memberInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumsyncstatetypeFieldUpdateOperationsInput = {
    set?: $Enums.syncstatetype
  }

  export type EnumgovactiontypeFieldUpdateOperationsInput = {
    set?: $Enums.govactiontype
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumscriptpurposetypeFieldUpdateOperationsInput = {
    set?: $Enums.scriptpurposetype
  }

  export type EnumrewardtypeFieldUpdateOperationsInput = {
    set?: $Enums.rewardtype
  }

  export type EnumscripttypeFieldUpdateOperationsInput = {
    set?: $Enums.scripttype
  }

  export type EnumanchortypeFieldUpdateOperationsInput = {
    set?: $Enums.anchortype
  }

  export type EnumvoterroleFieldUpdateOperationsInput = {
    set?: $Enums.voterrole
  }

  export type EnumvoteFieldUpdateOperationsInput = {
    set?: $Enums.vote
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumsyncstatetypeFilter<$PrismaModel = never> = {
    equals?: $Enums.syncstatetype | EnumsyncstatetypeFieldRefInput<$PrismaModel>
    in?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumsyncstatetypeFilter<$PrismaModel> | $Enums.syncstatetype
  }

  export type NestedEnumsyncstatetypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.syncstatetype | EnumsyncstatetypeFieldRefInput<$PrismaModel>
    in?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.syncstatetype[] | ListEnumsyncstatetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumsyncstatetypeWithAggregatesFilter<$PrismaModel> | $Enums.syncstatetype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsyncstatetypeFilter<$PrismaModel>
    _max?: NestedEnumsyncstatetypeFilter<$PrismaModel>
  }

  export type NestedEnumgovactiontypeFilter<$PrismaModel = never> = {
    equals?: $Enums.govactiontype | EnumgovactiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumgovactiontypeFilter<$PrismaModel> | $Enums.govactiontype
  }

  export type NestedEnumgovactiontypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.govactiontype | EnumgovactiontypeFieldRefInput<$PrismaModel>
    in?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.govactiontype[] | ListEnumgovactiontypeFieldRefInput<$PrismaModel>
    not?: NestedEnumgovactiontypeWithAggregatesFilter<$PrismaModel> | $Enums.govactiontype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgovactiontypeFilter<$PrismaModel>
    _max?: NestedEnumgovactiontypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumscriptpurposetypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scriptpurposetype | EnumscriptpurposetypeFieldRefInput<$PrismaModel>
    in?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscriptpurposetypeFilter<$PrismaModel> | $Enums.scriptpurposetype
  }

  export type NestedEnumscriptpurposetypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scriptpurposetype | EnumscriptpurposetypeFieldRefInput<$PrismaModel>
    in?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scriptpurposetype[] | ListEnumscriptpurposetypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscriptpurposetypeWithAggregatesFilter<$PrismaModel> | $Enums.scriptpurposetype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscriptpurposetypeFilter<$PrismaModel>
    _max?: NestedEnumscriptpurposetypeFilter<$PrismaModel>
  }

  export type NestedEnumrewardtypeFilter<$PrismaModel = never> = {
    equals?: $Enums.rewardtype | EnumrewardtypeFieldRefInput<$PrismaModel>
    in?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumrewardtypeFilter<$PrismaModel> | $Enums.rewardtype
  }

  export type NestedEnumrewardtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rewardtype | EnumrewardtypeFieldRefInput<$PrismaModel>
    in?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.rewardtype[] | ListEnumrewardtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumrewardtypeWithAggregatesFilter<$PrismaModel> | $Enums.rewardtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrewardtypeFilter<$PrismaModel>
    _max?: NestedEnumrewardtypeFilter<$PrismaModel>
  }

  export type NestedEnumscripttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.scripttype | EnumscripttypeFieldRefInput<$PrismaModel>
    in?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscripttypeFilter<$PrismaModel> | $Enums.scripttype
  }

  export type NestedEnumscripttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.scripttype | EnumscripttypeFieldRefInput<$PrismaModel>
    in?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.scripttype[] | ListEnumscripttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumscripttypeWithAggregatesFilter<$PrismaModel> | $Enums.scripttype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumscripttypeFilter<$PrismaModel>
    _max?: NestedEnumscripttypeFilter<$PrismaModel>
  }

  export type NestedEnumanchortypeFilter<$PrismaModel = never> = {
    equals?: $Enums.anchortype | EnumanchortypeFieldRefInput<$PrismaModel>
    in?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    not?: NestedEnumanchortypeFilter<$PrismaModel> | $Enums.anchortype
  }

  export type NestedEnumanchortypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.anchortype | EnumanchortypeFieldRefInput<$PrismaModel>
    in?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.anchortype[] | ListEnumanchortypeFieldRefInput<$PrismaModel>
    not?: NestedEnumanchortypeWithAggregatesFilter<$PrismaModel> | $Enums.anchortype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumanchortypeFilter<$PrismaModel>
    _max?: NestedEnumanchortypeFilter<$PrismaModel>
  }

  export type NestedEnumvoterroleFilter<$PrismaModel = never> = {
    equals?: $Enums.voterrole | EnumvoterroleFieldRefInput<$PrismaModel>
    in?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    not?: NestedEnumvoterroleFilter<$PrismaModel> | $Enums.voterrole
  }

  export type NestedEnumvoteFilter<$PrismaModel = never> = {
    equals?: $Enums.vote | EnumvoteFieldRefInput<$PrismaModel>
    in?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    notIn?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    not?: NestedEnumvoteFilter<$PrismaModel> | $Enums.vote
  }

  export type NestedEnumvoterroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.voterrole | EnumvoterroleFieldRefInput<$PrismaModel>
    in?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.voterrole[] | ListEnumvoterroleFieldRefInput<$PrismaModel>
    not?: NestedEnumvoterroleWithAggregatesFilter<$PrismaModel> | $Enums.voterrole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvoterroleFilter<$PrismaModel>
    _max?: NestedEnumvoterroleFilter<$PrismaModel>
  }

  export type NestedEnumvoteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.vote | EnumvoteFieldRefInput<$PrismaModel>
    in?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    notIn?: $Enums.vote[] | ListEnumvoteFieldRefInput<$PrismaModel>
    not?: NestedEnumvoteWithAggregatesFilter<$PrismaModel> | $Enums.vote
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumvoteFilter<$PrismaModel>
    _max?: NestedEnumvoteFilter<$PrismaModel>
  }

  export type committee_memberCreateWithoutCommitteeInput = {
    id?: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
  }

  export type committee_memberUncheckedCreateWithoutCommitteeInput = {
    id?: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
  }

  export type committee_memberCreateOrConnectWithoutCommitteeInput = {
    where: committee_memberWhereUniqueInput
    create: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput>
  }

  export type committee_memberCreateManyCommitteeInputEnvelope = {
    data: committee_memberCreateManyCommitteeInput | committee_memberCreateManyCommitteeInput[]
    skipDuplicates?: boolean
  }

  export type committee_memberUpsertWithWhereUniqueWithoutCommitteeInput = {
    where: committee_memberWhereUniqueInput
    update: XOR<committee_memberUpdateWithoutCommitteeInput, committee_memberUncheckedUpdateWithoutCommitteeInput>
    create: XOR<committee_memberCreateWithoutCommitteeInput, committee_memberUncheckedCreateWithoutCommitteeInput>
  }

  export type committee_memberUpdateWithWhereUniqueWithoutCommitteeInput = {
    where: committee_memberWhereUniqueInput
    data: XOR<committee_memberUpdateWithoutCommitteeInput, committee_memberUncheckedUpdateWithoutCommitteeInput>
  }

  export type committee_memberUpdateManyWithWhereWithoutCommitteeInput = {
    where: committee_memberScalarWhereInput
    data: XOR<committee_memberUpdateManyMutationInput, committee_memberUncheckedUpdateManyWithoutCommitteeInput>
  }

  export type committee_memberScalarWhereInput = {
    AND?: committee_memberScalarWhereInput | committee_memberScalarWhereInput[]
    OR?: committee_memberScalarWhereInput[]
    NOT?: committee_memberScalarWhereInput | committee_memberScalarWhereInput[]
    id?: BigIntFilter<"committee_member"> | bigint | number
    committee_id?: BigIntFilter<"committee_member"> | bigint | number
    committee_hash_id?: BigIntFilter<"committee_member"> | bigint | number
    expiration_epoch?: IntFilter<"committee_member"> | number
  }

  export type committeeCreateWithoutCommittee_memberInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type committeeUncheckedCreateWithoutCommittee_memberInput = {
    id?: bigint | number
    gov_action_proposal_id?: bigint | number | null
    quorum_numerator: bigint | number
    quorum_denominator: bigint | number
  }

  export type committeeCreateOrConnectWithoutCommittee_memberInput = {
    where: committeeWhereUniqueInput
    create: XOR<committeeCreateWithoutCommittee_memberInput, committeeUncheckedCreateWithoutCommittee_memberInput>
  }

  export type committeeUpsertWithoutCommittee_memberInput = {
    update: XOR<committeeUpdateWithoutCommittee_memberInput, committeeUncheckedUpdateWithoutCommittee_memberInput>
    create: XOR<committeeCreateWithoutCommittee_memberInput, committeeUncheckedCreateWithoutCommittee_memberInput>
    where?: committeeWhereInput
  }

  export type committeeUpdateToOneWithWhereWithoutCommittee_memberInput = {
    where?: committeeWhereInput
    data: XOR<committeeUpdateWithoutCommittee_memberInput, committeeUncheckedUpdateWithoutCommittee_memberInput>
  }

  export type committeeUpdateWithoutCommittee_memberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committeeUncheckedUpdateWithoutCommittee_memberInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gov_action_proposal_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    quorum_numerator?: BigIntFieldUpdateOperationsInput | bigint | number
    quorum_denominator?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type committee_memberCreateManyCommitteeInput = {
    id?: bigint | number
    committee_hash_id: bigint | number
    expiration_epoch: number
  }

  export type committee_memberUpdateWithoutCommitteeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type committee_memberUncheckedUpdateWithoutCommitteeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }

  export type committee_memberUncheckedUpdateManyWithoutCommitteeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    committee_hash_id?: BigIntFieldUpdateOperationsInput | bigint | number
    expiration_epoch?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}