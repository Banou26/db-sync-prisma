import { makeTypedQueryFactory as $mkFactory } from "../runtime/edge.js"
export const blockByHashOrNumber = /*#__PURE__*/ $mkFactory("SELECT extract(\nepoch\nFROM b.time\n)::INTEGER AS \"time!\",\nb.block_no AS \"height!\",\nencode(b.hash, 'hex') AS \"hash!\",\nb.slot_no AS \"slot!\",\nb.epoch_no AS \"epoch!\",\nb.epoch_slot_no AS \"epoch_slot!\",\nCASE\nWHEN ph.view IS NULL THEN\nCASE\nWHEN sl.description LIKE '%Key-%' THEN\nREPLACE(sl.description, 'Key-', '-')\nELSE sl.description\nEND\nELSE ph.view\nEND AS \"slot_leader\",\nb.size AS \"size\",\nb.tx_count AS \"tx_count\",\nSUM(tx.out_sum)::TEXT AS \"output\", -- cast to TEXT to avoid number overflow\nSUM(tx.fee)::TEXT AS \"fees\", -- cast to TEXT to avoid number overflow\nb.vrf_key AS \"block_vrf\",\nencode(b.op_cert, 'hex') AS \"op_cert\",\nb.op_cert_counter::TEXT AS \"op_cert_counter\", -- cast to TEXT to avoid number overflow\n(\nSELECT encode(hash, 'hex')\nFROM block\nWHERE id = b.previous_id\n) AS \"previous_block\",\n(\nSELECT encode(hash, 'hex')\nFROM block\nWHERE id = (\nSELECT MIN(id)\nFROM (\nSELECT id\nFROM block\nWHERE id > b.id\n) AS \"void\"\n)\n) AS \"next_block\",\n(\nSELECT block_no AS \"height\"\nFROM block\nWHERE block_no IS NOT NULL\nORDER BY block_no DESC\nLIMIT 1\n) - CASE\nWHEN b.block_no IS NOT NULL THEN -- regular block\nb.block_no\nWHEN b.slot_leader_id = 2 THEN -- epoch boundary\nCASE\nWHEN b.previous_id = 1 THEN -- first epoch boundary\n0\nELSE -- all other epoch boundaries\n(\nSELECT block_no\nFROM block btemp\nWHERE btemp.id = b.previous_id\n)\nEND\nWHEN b.slot_leader_id = 1 THEN -- genesis\n0\nELSE -- this should never happen and should throw error in tests\nNULL\nEND AS \"confirmations\"\nFROM block b\nLEFT JOIN tx ON (tx.block_id = b.id)\nJOIN slot_leader sl ON (sl.id = b.slot_leader_id)\nLEFT JOIN pool_hash ph ON (ph.id = sl.pool_hash_id)\nWHERE CASE\nWHEN $1 ~ '^[0-9]+$' THEN b.block_no = $1::integer\nELSE encode(b.hash, 'hex') = $1\nEND\nGROUP BY b.id,\nsl.id,\nph.id;")
