"use strict"
const { makeTypedQueryFactory: $mkFactory } = require("@prisma/client/runtime/library")
exports.transactionsByHash = /*#__PURE__*/ $mkFactory("SELECT\nencode(tx.hash, 'hex') AS \"hash!\",\nencode(b.hash, 'hex') AS \"block!\",\nblock_no AS \"block_height!\",\nextract(\nepoch\nFROM b.time\n)::INTEGER AS \"block_time!\",\nb.slot_no AS \"slot!\",\ntx.block_index AS \"index!\",\n(\nSELECT array_agg(obj)\nFROM (\nSELECT json_build_object(\n'unit', 'lovelace',\n'quantity', tx.out_sum::TEXT\n)\nUNION ALL\nSELECT json_build_object(\n'unit', CONCAT(encode(ma.policy, 'hex'), encode(ma.name, 'hex')),\n'quantity', mto.quantity::TEXT\n)\nFROM ma_tx_out mto\nJOIN multi_asset ma ON (mto.ident = ma.id)\nJOIN tx_out txo ON (txo.tx_id = tx.id)\nWHERE mto.tx_out_id = txo.id\n) t(obj)\n) as \"output_amount!: Vec<Json<TransactionAmount>>\",\ntx.fee::TEXT AS \"fees!\", -- cast to TEXT to avoid number overflow\ntx.deposit::TEXT AS \"deposit\", -- cast to TEXT to avoid number overflow\ntx.size AS \"size!\",\ntx.invalid_before::TEXT AS \"invalid_before\", -- cast to TEXT to avoid number overflow\ntx.invalid_hereafter::TEXT AS \"invalid_hereafter\", -- cast to TEXT to avoid number overflow\ntx.valid_contract AS \"valid_contract!\",\n(\nSELECT (\nSELECT COUNT(*)\nFROM tx\nJOIN tx_in txi ON (txi.tx_in_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n) + (\nSELECT COUNT(*)\nFROM tx\nJOIN tx_out txo ON (txo.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n)\n) AS \"utxo_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN withdrawal w ON (w.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"withdrawal_count!\",\n(\nSELECT(\nCOALESCE(\n(\nSELECT COUNT(DISTINCT tx.id)\nFROM tx\nJOIN treasury t ON (t.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n),\n0\n) + COALESCE(\n(\nSELECT COUNT(DISTINCT tx.id)\nFROM tx\nJOIN reserve r ON (r.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n),\n0\n)\n)\n) AS \"mir_cert_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN delegation d ON (d.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"delegation_count!\",\n(\nSELECT (\n(\nSELECT COUNT(*)\nFROM tx\nJOIN stake_registration sr ON (sr.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n) + (\nSELECT COUNT(*)\nFROM tx\nJOIN stake_deregistration sd ON (sd.tx_id = tx.id)\nWHERE encode(tx.hash, 'hex') = $1\n)\n)\n) AS \"stake_cert_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN pool_update pu ON (tx.id = pu.registered_tx_id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"pool_update_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN pool_retire pr ON (tx.id = pr.announced_tx_id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"pool_retire_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN ma_tx_mint mtm ON (tx.id = mtm.tx_id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"asset_mint_or_burn_count!\",\n(\nSELECT COUNT(*)\nFROM tx\nJOIN redeemer r ON (tx.id = r.tx_id)\nWHERE encode(tx.hash, 'hex') = $1\n) AS \"redeemer_count!\"\nFROM tx\nJOIN block b ON (tx.block_id = b.id)\nWHERE encode(tx.hash, 'hex') = $1;")
